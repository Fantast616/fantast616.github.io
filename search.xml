<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode《剑指Offer》题目情况整理（持续更新）</title>
    <url>/2022/02/03/b62f2c89d90c/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="f71b80c18c346210f2fac8aa9357ced8018d796b64517d500c9771fe77d1edfa">0b64cd3abe5b0a0a039a37d86c66d75e6ec8e220ebc13f2625638343d94e3b658da8c40ea430452654890c623f4dcfb24f0642b20202d7d277d1f2eaf3401d7e8931cbb53388f684d3b93e2de9e153f12e895a94d070525ce2de906373fb4cbf94e92e031f207c298839595348f1501b4bf727abc1428dfc74b33b7500340198f1d3a287ba35df763ca88f190b4ec65f9d676337edc877b8c21ce07a08a995fd892898347b548004ec7204b456116e8b1081289da98b952774bba0123bae9a554ce991d3f4c089dc1beb9b187c241b72f075dc547471768b5fd797194b1c30b3eb864d8c75c7039f4aeb9dfacfadef6a221a5e56f6895ce4b6e22baf85cf0aa4bf137d21a4f7f90899e8f2ff6643be5717872df903679740e097a36d415f3f61ece25e16235a00b75e97dcb8cc1183f0447fec3391444e8166a92e8d3f371a46a92150509927d96271fa80f3b7e3895d98712a41b59210292ff7f02ace1b9407fe8d738971cc89b8d4cb18819381ee6cd4f85091586a007ce6ec3951393145270f3c28a74b822f168b3f7607fc8ba5065e3c51360a49a3559172433ecc2497ab3777dc2bb7b2c6a6b61ff02eff86c679de2cb9fef70cb668acf421373315ec2419f363fba02cc1eca437ac55cd71d8d8b7b958026bd36658115f4b14956087feb8c55144798d107957a74203da0b5d8e901729c9e86c7929ce736e631a35d91fbea4c29fc670ef43b8857ee49a699bcc73efcba64e1cc89c4cc1d4f90f694d34b342a24555726a7a48b2d2a97a68d840079783e2c771484e67420f210bb065e534e118de9942b7fea7d96090ed6e56a310b715a933c5703c644f82ad2d2077a836beabb24b73086cafb6ab57b378c17c54fadce0a473e0a3b14a7daeac6e2e10b5e25e40ffbb6e9f35491d23918719a6249733d661ed027c7ba236b50e7dffc26aade97266e6eb74aabdfc303cd30bb5f8ad111e5699d1937776c1bc711b7d20fb0d456c9e0d7e0b4efddf792ff0664d607c238e7ffb3d0226ab36407d8cfc6738e18fc52ed26fb4128b6b07fec6f2245770778a159bda581165bdcbb09e884218a8e18e374f5cfb99835947b8562bd797855c261bc79fe3e073cb221a1298ce56436aef4be23e3d31463b8842c4b831e98b799cea8e4aa0dad7b501a592b844a8ead93828a7c250d0841cd5a2d5b42026a540c4fd5e1be9284e13e8aaf794b1845cd5bb09fd481537513f28e511b6fa685bee5e8b9b15cb639cb35fc95c880369d8b275b21fce232ac9d236dfbd4d21e2b159ca2798c23740c93281a93899211d630d4ad4cbf0cefedadfbdd486c2ab58bb27d41ee7dbff0db28daac454d34bf48ceefd26c1413bbac1d7fc1a4f249d03f78a7e27dffab170bf996366d8b10f3b32a6ac33189bffcd816e39cdb40623322385c3f1ba816a604b3fc35bafae5b27b3320d18cb54a0ec3b45331625d52c74f1bf3d785db7f8d342437f32bcaa13544d97e278fb8d84fa9bc61a49c8b77f11afec3832e8423d54487534be065c271e15b052242f5ee28b69bb31cdac9c6871855d6ab7acc0fd6e17b7bd4533ca54e1081583bdbe5e635631b77debac45b11ebeee825f7695eb3b78d37a87a9b67424a934bfd6e9185d43b0c32d0fcac458d1d763bf16eda82823be3b1fa32fb44f1dea52378798fff35ec23f251337dcb1a8b4d836e7739966b827528a036bad305933e0ec623638a62183a10040f633cade78d07e3bafbb64c4ec62bbfa7b3677e85959e18557164106702839be7955986442359a21ae8aaadc3349b7cb1acd2f3d80fa4b9c3de03b57f8d4ec2d77e601d49273b80d47057a53726a9303b5dee063784182c2faef1adadf775bd5f24f50bc166b80a271a4d175f482f6bf4503a5f4de0bdf225f12c0a4eaed78287269eb597d39a23188b2d9e43ce11bea7be92b8bc10979692b406787222cc37816e3ca507d796414d446910d0589beb44f0b1710ab870933cf9653a62cf18fd135df236b6619909a87335a7656fe0f8e6896b189c3f7c8b38f9b9f6824f887074ec30e64b7b0bd291900be77b843020007d8706460d4414aa6b699a596399c04c23c2635bdd5f83c9d010dc3916861371598c8f9b4d4931b33bf28caedfa18e63dbe02b2be6c5c3451939e6eb34dfbea0ffcaf878a62f49a16a32c83b800c73470dbe66e2104ba7ebd855291d9930ca1c881be0bf9d0730f00362c2acbee48ab185317a9e3a1fb5b2096d016197c6d01d22bcb350da09bcb18798254d3734f1eec5a24e6dadca1e910a9ab107e495a6b4f49f385a153db47fc72f23e00414fa7f7f6773fc3f75de71479e90da0fa6de3f02b6bfe3b72aad50ab387934c749956951bc48de3ae783f80139592efc3f7788a81cad081b2ef0145f4226926b43af62a4b994ce022057184b3942244563be50f0f7c4ea829f01bdbc638a7fe340b029a38ede921e63e3560eea0921e5c22617b9db747a94eaac58207ef89c08a6c0a0e208c9d38fcf733b4854f58f22d3350cabba21669981aa93300d9ba54c495c44002a796ca16af5122916c81efe63abb3aa94dbbd0452419f951fb6406ab9eaeaacc99a6f5c708daadf225c9594835d96a7b6d379c32c0ba989bc173c476222818a73754a5f98e03ecddf25724cb4d742047ddb9a25d0bf41bda5c89c33058dcfdbd55cda6a2b6274dd42e0a84f7b792beb3c8c19404489e1660a594e244fe021708ea0515f1c411dca31aaacfeb0d461a468eef638422eb8cf3a8162243a63aca64e791232f1b30d82a28767297b91d914754f9bb05e7b8b2d7f2a6829f67ba00959bf106719e4390e82b08819c56c6561a520a8b7bbe957dbfd90a8750d809eeeab1bb783286bbee236b1c02cd3a6a1ebace416d7e9d9f0f09593baa309403383d20e984ff370848bb313a7b504fef0006c90a8a8875976528f3e4c0cd4aca3f39182602e9aae373d0094a90e6e4855df60e956222184e05f39cacfe86239a45f885ceed60680c4171173f4580efcd20ed84402c4f4e1bdd83f35241b346306cf0ae04fae3c706dd59b71a8651b9e27cc27c3a12296606671fed0969879075cf5f98af38797150411d697a61733d2f9589f0b37f6399f2cddd4ea618b35e75c36f7d2bcc13a4fa6ac51aa75e458f9325c7b0a6d644415363ccd56fdfa8bcffeb861a7b087c831fbb66d116d2062ed4de8b74d853cc712bbcc996ff0b1403dfb91217931b82c20ef7b619ef73a3922e9c109febc55f4be019e1427409d6ce8649c665f650c60f4ffbd5e9ee485c6c4d9917cf7345344811fcddc02aaa8f2cf479f137d5be04e85c3f00218704b0662a9e7adfe08373c42ab44ef9fa578c92f430bd1bd8e63f67936f5190ddb09b2f76799bda9b21e31eb749c30dd8a71b6a443458916207814255cde69d0614cc98c37165a20e0ad996fcd7802ce0c81d6260655af6995fee4984e4991102d2d7c265d9ab48a946a12542a7ee789410d676af706e05d47da482bdc8e20a171127fdb936a963d18cd2cf3a4b6191d71866b056fec3edf2a00023e6bee17ef1ef225fb16a4976cb19b3f6c597b66bfff1e4fea595e91459346b1d38d70e469228b709ad2bd530e2eb6f27bfc910721515d50b7581156bbfc9c2e346c5ac5fb9665c6448c74e7dc0ab7cd48047d5e80b226c10b14705e5f0a5bd024daca3ab965c47f08ab01e6702f9d04217f705add0b97cfa8b9a4594e570b8288be0fea50df66361f0d426a1e86f6e4595ca84b5b56c763c8f5b7c959ca39e52282b53ffc1cf104c84c19b9e6b864f16613beaad3cf798883c6c784ff146132e8cc8185d2a845d174476e45a7436c84183b6b69fbcb1cc6a843296077b43dd14eb7fbc9cc5c76a1bc8e97cda506ba75323aae0076bf3dfd430955f4c45a6c8bc3b944f109c22b20c25eae7be307221013005afe9f1ab1344da824bc8a4ad5f6683ccdd8b9d6a6eae14725e05c2948c316324d1e41b43e011e615a4773f2033edb75cc8322859a8168d49efc3064d0ef3a8b39c3e7e8132cab0c9a6f025c47e99b06f3f0e4e4b8971bc2d226876729f7d5f7206af939c10d003bbcac4d109f7572c85aaebdc085305d56420672dfb75a261a983b66521400a2a9161a0645adffed81cf70696b4d345e9df4dc5a76343bfadd2b5d7adea922b25694c0c84a519f9b30045eb1587a7e2ec195a113d5cbeba91629b18212d685fa45b2530d04665e7023b548729c4a3303e584144c23d5cf0597d4b1755bee4c69274ff873523bdec3ab23823039b289fa162a2a743926d4262d040805c8c85ab75c4005959d5ad452981645757ab92baef682c9d81b5e713e9ce2b43d34bd1a589419824d8a89db3c9fa1d9df137d85bed5df749233b10ab8bf14f1652f9339f0b0b0aeff33693d280647bb8b277397fccde02724e980377eb249939791c533810460cc9cb95525e5c77eda9ec90e05fad1380e1b964214a9f836927fe700e18bdc33dacf89ee7d0072a693d73a8bc84266b5aa9ba769fb62e40840a67f759081b7e06249fa0c8d8426a8687a819272856c488b51ba98e0759e4d19b545536c2e1cdcdf989ac851bf3d36fa75124aa0f33e854dc3631f5e756574b195f6596f788e37bfa259486c6d3378c264d6f9166808102d39d0c4337ec523f8a44f5c5d1af419c2d7f15b5eb12712c1e8fc5e8b4b1d63f3aba8698e7ad7a0bc8f42d7cd2fde1a62080624d97d389d653ef66bff0d2aac09308b3f1fc70fe75b03bd3cf8ab92a4e4391a26aca12800300a490d6564601a20a81a3fe3f400c7a38b86bfe4fcc84434264a3377b6eeecf8bc8691d9be06278dbad433f3b490bdf331f88d31bbd8cdef9ee3ee11b792d7c49f45ae16103455a801c57ea85e62a7f208012703faca5226a327e6497dce8c1d078c6a0754a0ecb86c753e1108a695336caba2b4e1bdeda5a6785ff0dfadd0d36a42754e153905bc80cc07c45173345744253177b1dca339043b475916da141827c6f16beed13b804023009f54fc73240bf36b7b7fc0d87eded80306ab7d997639301ef25f35e679a266edd8d19858ce0beb023f45ba53fcf47959b74ba83feed6810567707c188c6b621a4339bf7f8d4060a49f1da1f8dca64dc5c1a7f5f6615abe29159ea2433a60558252d88be1289285239bb512fd8a2d9a0b0a745f8b82644e63cf8bbc51e7ece01ea6be56687175260ef3a05e5c1e8fc9d4787ae421e559f8e89fe661d0224d1af5d9d7d72f059a32b5ce28a373a296dd94247d67b6f3822711bc620087a11ab0637a5eb2a389e1c209b7c3bfbfd2a590c4f9cd07baa5274efc70507e9f3208fbb5368deeed9c1849444d8cedce62519e2039518ee42185f2cb8a19cb9dffa3439e01baaa8581098194611daf693b97fc5f7c6d146168232b270797abd1389e00588c2c63a53e28d5076452e0d64bac896640a3e9e7f5a4ff614bdb1fb0cb1a1393169dcd4be9a403e1c57636990a5edbab1cb4fe122b117bce7c78e703d3b24b0589c1d6f46372b1b721b7252c564e5c528347479563d012b971df23e9a33e3f91cf643142e70b1295df5290ade155baadaa9052ca8a994ca745c3f0f9d66557f9ff45582d2a9b9e0c6acde364a316625991a3afb509d1093532daa3129fcacbf92e304a4cfe502827eec09e161ea91defe6015d67d2b9abf45fac3d10750a877a30bb2252e4485c776173d807d00146449c1a9d5b95ed7838017c2a946f0b4dcfcfd0dcc03821f7e1f5913742b2fc7f910702dabccf601ab41e8a84b6d75384acbff7bd7c28d119591f241e3abd424fee3813becbcc2b0f09ea52b942f4a9dd72dc034a824156f9e9f68da81ebf7433dbb70f0eb1770d4a4adabfdfe0ec06ee503897eaadfa14243423757bc5c2e7b18f1117bf280706e5a2367edb47fa336b2c4c7e12a18e5df039ac6101be1f8ff150718be9a728db6b38723f7e59a6883205e0bc9d9f42270ddddd31a538c04d72a675b70dd342f3fe516e218a4af5e59f4a9471c8795fa9d00bceb6a3ef7465ac8c69a72e235a72e66bf615c6e667fb53c1aeb6b950a4de76360d52b1b615f78ae87fd0fe21c36b6e2a1f6e8b92bd41a6da3f939a9827a264fc73d844de69cea9e5b214c8ff7b200053041f3688c7dc625c8faf50c39388093db171a4f15d27b4985ab6d62427b374ed8856ff58dee88ac3799c1f43613b049a2d19bb41fadddf927b3c300f6cbae27ea7ee0f767efef4eaa282f309a92e08384436f6092db9dc97b4651a10878dfdccdfac49a4ef3d0ff38b27ee66a1ebd07182fe140bfeaee472815dc0d385e61190dd3bff16b0029c9215e482eef8920173127481462bd99b5de4736eacbb75fc2575a45d95b868a7106255405e7d1ceec5cd450e7d0a6e6b720714b96b4a74a582a46d761cdc35a5f88830e73d0d87f18bf4adebec87a0319c63d61f52bb66bc399d147c3a5e219864acd49373b666a2b8262becfe7af5fbde9758079211ebf9de45032c932ae1e3594b805ee5d434122d139c88167a71d3d57b356e8da89030a4fde36ef348bc3ad76704fc67f163bfb100b340c42202cd18d90e1796150e84816dea70404b58dec2d34de9d867d495aede30bc1426fc726459ab981c95672d8e18c7fb0db825d28346c944468983d1ec0542d457d1b1c5291e04a63dad7e094a73902d864f380bb1414d89534de8c78336a14e7c9135e4a03d41eaeeb784a64b55d38bb7e807ce082036492feee181e04400ea60f247f23075f99facf4cf8e59faadb4d0853a6707396e1999a98e12048d7e20ed39bd5c374c15443925356927cb82332bd4f4ad90eac7c11ec943c580ec3b4cd7c6da71a8d08037d3630641404fd21de8607646994ca719aef30ee7b728ba948009dd9b290a515bff97612240bd586e8d8920794f4a2c808df64b44d66222289d2751198d7b909d28f0835a0dddc67f6af8da5625c2495bfa7dce7f64d13b043c22a0f8172897d87ad35c7b4f949c89b17d501d849aec99efbed1b033d9d08e5627dff121f098f49cbdac499ed69378ba08ab158db187d104abe0720e63eea8094329a83d30380f436a156e9a95276bb40292ca38668aeff87e6cc99146133945bc5bf926728df9ea0940fda6800d66d7997b1343595be346aeaabff30f2eb79549eb96364f971442f34d6ce9f6e676d8c16c0da591933bdb2214c1bb4ef2c8a52447bb5e15ceaea345e401a399a20ac8af1dd1d7a9006e32db9f75ad7cec2be3f6f5d6524219216c5d473849f537fcb41fa2084260ad6e7c7100e0dd921e94fe6bc2db9ffddfd4f919db72b7f4d1eb2a88d9cc6eb82d8e2276258e612430f5948e77f13944f6f99641a911eb1ba816e33b8ec774fd90b9cffeeca40aa1c61641164049a51bbfadf49c46b6923e11d12be024ecf0f4c67332036589791a99e5462833f4881617ce7e3fdc09aa9eb836408a61789c8b3eddc2c7e07fe334fbbb52f0d62a456b7576fe49270ee18fb78b34ed8722ec3640e278fdc7e0c41a839c6036435b1f0204ac52dc56017560841f2c3ed8c2a886151c0a050141170e07654469aedf168dca71fb560f2f94502d2f30620513d85a476e05d1997f1c2bb1c8e7918ded526af708020cca3a876faffdb257a0208069025d0229e1962b6f9e49d10c90b97e2b01d0623be677ceee4d6225fac294e0697b30958efc5a5b62aaf88a08c7d6cdb5ae457f800fc1f783f5d9e7eb1c3949a0d70dc48e0784b24a0aa700f9c507daa25c1191d3e27b457965e46f782d4d360a1b3aa0f65dee805669ea0ea79816dcfc37315e3390abeaf79aafcd680674326108a9d7b15af0a102c52d38caa87c65c88d12dd0c46a8c09e93ffc564b4e73154a073b4d041c416c89caec4f6ddcffbe42245dd4005f4eaf32f669738a822b4ba00709aaa34dd600a41c563d21310bc8e0ee462024f358e8c8b1b08e4da87545b122680cd22940b2935debf39c5670f09a1f0ee45efaa389e5e5327fb795234d76ec98e4dfc0a84a94ead1a33be1f95320d3702c42080186ae9dfb7a638cbd51656ab8976f655f315643bf304611584b65ef4fdd0b934810bf62a7eaea081e6b1de75051465c74c53a8bbc944cb57b561a97f342766b5c36f92a69a8b04ab125b6ad300f22cabe06083bcc070fe174e7a1832897f37d3078d87782d0c7b0b344bd01b38ad603b0eb2c2876aed6fc4a897d079cbddf635f6f81b9c4985a9442577bd5ffb972cdb8d55edb5474e27125865b4b93face0c4a02bbb862cc9cbd5dd77ee47afad1b53c7800c7ae3e8ab03db0de1bfaf0f02f098a1632cb2d1c1128849a788cd504a4c1a108e85d69a7ab7027e1c54f8c78f22b8389073c155f04a37a48a52894183655972c08e3b4450ae6d607aef471798cba9ec0c49876005b9a6dd0682d598ca521134d0bc6ae9afe4b2e1ea5f47ea671c403cf831b74b771e76640245be8dd34495388423f9379eec8e0a0acd3d7d67875082cab1d123adf47467bf9eef63ba147f533deb0d873f5f58f046c5209cba751647f95abb08137c96fe28f7e7e68ab60cf274f1038f97ede15b3ba58f385908738a9b63993c715fb8224d9f570b9a893045ee64a11570651b1c7805d8dc46dc3090aa49e1df48619c60733edf0e98b0fad8e99d1ed74c696972de9135f3e2098a92f8955ffe96bf19d45a15e45f6d3a2a5983c0d744e0ffcd0023b53f5bd25c07d31c62e8d31c643c718b2e64f0d0687008d62f93b842f8a1424e94155da4e155ada92d1c1bcda65ff26b8bf9fae17b97548384b01f881ee2c2cd35a31aa688c5a3551bc27e69e39620fedaa78b068f91395f534efe12c25e7b85a9dbdccc7bfcf8e4c24aaa92a8e6e8d2755df59a472f8f702db8dd6f0c512c5570d881c12caccd4b719d407d27321fd45da2f7c33d394b2cba4010afecfaaa36d22fe0a86de4f5a3051836d5d8d9d20e68e7d746085be921c5d5b755ba38dc0e171cf7b0f9036f12f22e111ceb86c7f36cd62dee7d04c2ef94d82e923ae5e947d3c62bf651275c6c5358fa85927b262e466a7e37303ab69c92cd0449eebe584908de3b76dc3c28a5f02615849764a8acefe143a0c5d2de26adebc9e1b5bca3b92e84cac47a10c97e874d2021d252042d4a1a13a1b2ebc8781aa3f8dda78ed84c9b4ab1c29cbf1c3f6df66c29c25bbb6a6bcb77a621b3d055aa7d6aebbc3271e8d4ca4d39be87817af8ad93f0077059a3c0d6633ae687b083f687f94a9728799fb985010d2af75b5e0b3a91f630349e3db64415476d6ab1805df39cca67921ffe8165cfc54845fc5a91be1ee99e5a4237a0d479a34f067dc4da21f3869c0b873807dfa9fe4f8886b67ac4709567ef863f5f434d556f3ce55fbc221fc7597ab5a5043a0065c3b7f5fb6eb5c05517a56d2447b964b7441faed21e041529778dba6c2ada0fff5e9c593ec4e8a307606eaf1c7854ac59f579544f598b75b0175c915609a2ccd1d84cf107b8f5173d35e8a5eaabab563b73df4b3fe35bdcd398a04a3c884b39a1b663db515fd76eaf9b42cf22f076fb0ea0e6fd22789591a153a18cec514bdeaa5dd26f40f7bae8ac7c36a27620ab86b28d432bda7180decd951daae04b1f90eba942065fd74b29a33ece7b0973df313b366a33c69f5cc2edd719f9dcf3b3010039650d5180e70052d4155066635f523f32ef658df1548f24a0e446023a8a9f76f3d5021b0a11a9ad0d6522716b3cf7d442be2337c7f80f98fe38d82f6bbaf129728943250224b078b3e23840818bb9028d6538acd6a2a5ae0da70ac7a769e1cd558e2a203578d7a102d8227821ec2b5a7036b5a1d706636004fa8d248722dc644891dfb6e749daa46014bc7ed6cc4eade82b0d0396ebeebd05facffe9f19ea3d0fd679ca12788185baf05b19c33e363c8c9f2289aab76ac9d7aad7b5901186679e15c5747987577f23f4529789321dc884f227338cc2a27a1bb80c4cf6a66e14af331c4ed58038d2168a522deffb928675626dca8b73608dfe39ecfd0483abd36def3df4fa41c329adb356269932cbf793b1be3d07a43cfc3144df3d222dd85677a2e66452b8db73820a707e57620c8bdb36607cd00007fbf6deb00479aefa3f648e242a6cea052f594fc90c4257a80bb28328cbfc86efa844368fd85c05939997bbdd52eb8893422f86b915b4a8d45aa8693fcebd766ec62bc58c9939bb7d48c550aa8312732b1fc2f3e3018c9bcfecd2df11ee667c82eddba4e48ce9f51d78bcdc452d684255225740e24bae4bf7ace86de1caa2935c3b8329d9bcd5a080742ea8e89498dee132c91b0290e49dfc5f47a45bb8842a77b46f4112049abc9bfcaaff484b3f2d41c33b94a50802dd0dfaf2f07c5de8c62a494c95a1b0403f5b6ab5cbf4adcf75a82742a71e9a998134c532ecfda141521d8646ff75015319cf57112da2fd134fe6f9c06de9e507347c81a44a804ce83bbb40a573081b9e052eb32930b4b35f80cd03f39f5e8e07f16c55eb45a137b77aa6baeba5c4557ccc72f1810604a65e6efcd8c6b45d8a541fa27c447dce8359cc3a14225119461697d77d487451ae7f48ec7b5c2a7d53919c7f53d34b4007d78768c9047712a698d9e13a5e1b24b0e11f7dbe9579d86c9b0eef08d381bf55a8eae7baaeb1addeedc7c752358d702ee134d03b49aad9397d84e961aeb6953bc2bc894a29b3981429ee5354b4cc9fc23150cdc4b1fc5758ad50219c721fb578f4701281f1ccd84dc9f12de942da9c00032ff2a040486043227ee66c3556e39e39fc46de144d263605dc2081e3ab145e6e0448983fd67bab51e1d911efd432e09f5a58ff9c44d490e578c6cb5161056901bae03461aed6f1220585b047ddd665de9ce639787dc05980887e32419142a534d2668ddb4bec9f0a2fe7de03ce19f9421438e464ac545b4e3466d20dc81b182ff5ab35bd296a55684d6c5fe600a5d09d34c1f62e23cdca28160f58ca58eb35b7e7036ee962166749e64dfe3f680359938515bd85e873d1b20af65a3adde5504cc65c86273427668a723c343201f47f56cf28cca66745723c94a51805e3c247e50aa2dc4f0fc4f5082ee57d98254c8400aa40d492c01453c9973f03cb1291f6ba573d8f559213031de61e2dfaf7fb0f3cbc366eb737ae6d1a545ff8b82881ada5e3ffee51753442e908935a77a9cb0433413f0bac4b002d8582e30e4e34cc312911da407dd052a29f88c53fd4db93e9b984b18494a2e98bf51cce9d0cc781a9824b19f956834136e15f3b660a464223c94e674a4d6509b3b22655536036e688178ec4cba14db98d2fe57d9c012458690b80543e887b347c66e474fddce9a9a1d994aa2018ab4d146b68502f378d25a3ee215440865715ed8ed9974131ee3b3d380134af7fd0459478cd2186dd1075bf61aeccf05fb0756f001470df6d9e3dd09206210a13029dfd0aff80ba8e03bcf72acc0db82bc7fd003d7c77287e1d6c9de11a16288f5c5dfb70d0a1b2a9456cbca4e7e82716a4e8c6a190528e052e753b54908e075c15491f645a76b30cbba4dcbfd5a6e6144edfb9b4010c5c0e9dbd899c80a966db941d4870db4e1e8fc93ebdd292ad4b2cefffb372f70c4c022620b08367227c248f93130b18bb6d8c54a2700239656722de7f370f4ef11fcd8ee575c562edb7f9aace1256984cc4db848715f2f0db2cc3d8b3137b2559a2604e42c810b36ed20dbd9abce08f832da49b371431bb508387c4ee320aae292ba7aaae22867c9e6af560d7a3bbe9ed3e2a3603c54a59ebcc3943f2ad7bad8e70462f4fcd4fde877b238cf4c9dcdb2c7bb8ed00dc74983ecedeada3635de298bf511fadbc74d21a2ebd0a22b7f50a043335de67d1f835f45df319e4b799cac84ccce0d8037cb045029a6b2e73f56f4009a88f753a50b8467a739cee894db1cd9fc1c2d51f091f52cf85429dc08a82503c7e6878f42294de92ae48d1363d3e15f7db04b83eab6473d3502b1f2867e877c3b09729eb1b2720726e6274c7f93624efc973b7543a95f494bc7f15cdf7e599847969f043c200bf53339f85201bcad6ce5e3d08a34bd250f23685f4ba13583cf54730353c41290cd395eb4cbd0a2a4166dc29fba50473fcee7ee07284a170d8dc6fbb60efdf4dc2ffe47c6e4f4a3dc65988105ceaad38c97a7c9355f9317230f62f4ab9fb5201652a48640f5280fc1dd501a472780311b6ed586d4c03dc52e26bccc5e7fffb78d061331aebb31ab31674c56848f9eefa8ef5008823309f45b05628ea916acfe58596c6bf576d5b2f575258626516559cc9a40df58dcb12e9b3220fff9d3a4c0c11d16ad9074a29076763fbe208fe8bb7c2b395bf7a8db5aa9096de975cfe2f18532cf8085471c0fd1d8389155347e5a62d6b09fcf300c1078ec2e841022611cfb36285c9ff81b8b513923aa97bbe26cfb8b3efabf7c3e604bb4780a7df6f62d20bffee9eec06481a45abd8c9fa75faaec5b928b3e25e406daf44278d1a8c8b7c8fe7a2ac16efb5c5050ddede6d2b1b59ab3527015ae60a46a9cce4edf5418bc61dc5b9e7df0952f6fd847c0763b30019a2b796089266f8e902db3cdc448c19d8ebf1b8109a2be0c89472d2202c7986bbd8c3ac820a4bad69e07f00b30394f3f8686a1b88ee20e708a5d394294aecf95921141d3b1a1790333ac2e949a10fba602219236e9b14a00a29531f82f8efc105bf38d3feadb26711bddb825e6e4408e512f67f4178446466be00573d1b9ba5d1acf3fc07434ec13b5c21d697134f0fdbefcd15cb76a52365c49839398e055938f87d9dbbba53c2926746d380528f1260341550e6f3047da81e8ad95ec65a67567d4d3cd0b228d830b8d834b998f110b6edff497388c908e42d620ec31aa3cdcd390738901653273c2e8cb6229135680c9e344b0db00d92c64ff236711afdae837d7f67252b4f420912e2b425c3ca8c6dd2b490e99378384547010f4ebc24a6c60d761006b7ea36cc32e2267b87bf8e5e938a2c898702031b3b667e4e5c226c18255273004c045e283b7712f21abb5c50657d62266d5b47f195cd33b5384f00a613808a3ce35d9c9024c585885ffe80c4c7e0afb4da0de76b016ad315fa7b5efd1fa747ef22c16d418b9a8e6ce3c9be3b41ad1d1ccd65cf4f33d2d48af6f3561ea3ff2688401493561c68ea63fe0c0ecafa747a44f327c5641529864c77fba57dfb3bbe665cff2a79a4a6e3fddd166f1d7d7dcd2625a29839ef5f1ffc3e7877cfbad53332857609aeb77eb5080ab25f2758bdf173b3884f20f378fa3c4ead3a2ce01088753ff7b9c3bdd0bcf8c954bc6604a81fd5715af190adb2636640da3f6b9639d8bc65dafd2a9d2357387748b8dc0189ce06bd17c847621a694fc89b6a45765a62205622c43a40c5da2bc4e737c0ae468a91bb2c09d18e4d02081fac324000378124d099997443c9a990ff01fe3311354286ae92fa72e38fc844bdd41ece3fe4cea5e7cf500d2aa26bf53d296095b08f10e29a58899d859467529b515b59a266b7572e22c28fe323c23fad31cf9f91f7a4011d7556b516b0018584d690cc5f2634941fe0ee58a09bd5ece8ea9017378f82e05bce1d94d115292c548b12d059bab4d525aef5f670bc58217900c3c7f255326806adc9c8e56d927415c0573130fd718c04cc733762e14722dfade186d5af60d74fb58de41048982232d5d202ade40f3a06410ecde80f3835c6a96418964dc90e158138937090074b5e79e53d505e7a60e28974d2fbae7e0984328db7eea92bb2d71025588e7823a472690e1588880c99b3982735e31c178af0f30cf68b2acb33018750bcce90715c49605297dd7ca047cb2681972b7f2c5f328be4602d76db030521ca9b1a67e3343ae08a5ddd0c3f067f70df07de729612986124562a8e3650587696bd9a5e86854568b10e0f994ed59de30d8490ff7d084e4f04b66e706f2a2a9505c9ba5e99e64070c5c3fa26ad21ddfa1381b7daa19ca7534549b0f4f14fa9a00ca0134d07551d999a506e33dc2b267df7bf9783b5e6e99edc8172bd368029a1469f5ac72042111f1ed9dbd4140f715ddd87ebc82ecb7117f42afe4fba33c03c5b6af4579098f607f53a08e49a543497461f9a64fd3f3068b03ea015a220798da307913c707e098ca49c611a7d9acf8a882f45f196469e21613f96206449ed74fb12fe9003b1765c1fc13d485e171f46deea7af63686c0b18abe440197c8bae4f148e564c8ab3576c614b15dc336e07b4efe7fbb799229a0a52cb2c7ba60bb461bf65fe3548ddc7cf28d91bd3d8557191f9d0777f792c9bd1eb63d17ba0fc37f3b4458214f7ba96b3116ac8bd11bf08a9985e5ddddeff8419a33af431db115853ca1d48351cc21175a80caa93a3078bc7f6a2c1d5912d45d2b53974ed5db87e99b817960e386593e4db7a816824cb93853d31fe5c68a268e70715a18a4e6ad2486fbc79d928818ec686fc95338c690303558033074e8ed0d141b5119527f0d59bfb1019cd037e739ff5fb86a4cfd7784c4dbbd4d565a6b7912312e37b865499094146c30bfde2ae6254ef4a3deaefc043a45a49c32901cf0ec23fabf5409dcad02869937537f6e4e91ab2d20b53cd18f47aa498a7bf882b4ebc813958496f4ef53ed6a1caf48a7f7502671190e15ad6c3d42d780c4a2e3f54b0521d94927b983ef690ccab4ee5daaa7f76267e93475c30fe4493fa10064aaf790c8abc7e352784597c1b9277e30c4840471411f69bfdebcee7acc949c8f17b6af6cb3010b31cb2cc5423780acf2a7b5e46c7a7afe1806fd2adcb4e0cad5c26fc3424d492ee8cb1798d5c83530fbf608c8465a88b49171b331a1589cbbd5eb10e4e4f96f82dbb236c9c57986275d0fa3257124a31fa75511a45056bcb22cf1a060c14209271826eadf5ee5f18b94d7e2386f100ca56b27fe17e8c326a558e214f587fc79312a3f15084f3d96c5536215bc01d68cb6d13e07e161fc81ef3eba9f43124673d0d5c6b7441aeb8928473b2cbcb1408293c8d197a41535fdcae210a27d6048081d34da7137918acb29d30fc6fbf6a1421eeed08e0fdf48b6aaead5dd92904960ea9a09b9745c28d99a2d64c31edb10c7b46ad9d794dffe25c8dad5cd88dd89bcb760ec21c48a53c68e45abbd70416ef9796e9de21e27c6383eb4b08d40b57f36b4778d27e5296c7006a11dbbeb79458f6a84f6a0ec251c48a653637afba68180f671fec90c7322b8fd931ad6ac300913627f339751d583cdaf7776ca43aa48941a8a508bae71d19822e8031c64394d98b9748056831587f99290839524b13f0bcc9ec5211238c74acf6fd8c276a1a21438fb7fd2a1d47eea4f0e8cbbe460879934182c45b368c7a4acc5271d3ac185a16b54de14688cdacf3e68ee9bd6c0c582d930aebe7693538328be3b38e6a7e31cf1476e703d6c7058cc0e7a96e2eed33ddbd015f219d1f5c915a80ef6033b54da8043920402c9746e4271b9fb8fa5a68bb43650316477ba57b3825a58bc749a56aa5c40ec8667191072999f73a91fd81a797960e44403d4341cd5b9f75c2b420eef831ce7db932fb52f8ad3e0ef819712a816a7830df8085a9cb10f460fb5ec81ca28a7ca3fcbe8508966d8c40c245508b47e6be1bf49d82884846fc1c0537fef7ba1254b2b00e0f00eaf5f1a4a2275ab6939d82492a0ef314a47d5c86b8950d919ffea85e4b5fb8bad583ab85689266654ea3c741b40f7e414b7fc3c06800cd665d2b3e072d8eb0884df2e8569664301a2ce6429b1282039afcec2c738331b778b94f8d4fbf704a0b66782a6bc4be5d63a2727558e5d00a2f41636374d9929c09bbfd141e0f53ce19e43f1afa5c99191a2c4a5b32d63877a2a169edc92da141a40b5ff3b94676b21831d0f6fb6321dbe258bc6fac27f58f73d63b4a81e53724cf21a0be6bd5e77c38b28803e01acdb435d4a6ca7de52f72a2d5703babb3857667f2fc656a088b932d4c4f9fe96890322e5bf80cac191a2505e4e6cbfd216fd532836d3c0439d403e19e5b1712cf04fc5f9b16aa9b5216e8889e09b772daf2b2b43160700b8f6b5b4c6886b417fb4d5ff4eb886530d6187684a45a82438b5cb610ceb054e53ef3d57e7fc5731f2c467bfe9096e79f4c352538b761855ca56d59ee8313bbd3d16d85490a8c56011633978c8cb592b75f023f59f0525b52c2ea3def029e0e99c9e574fb08a3b36d8a276fae963027b4becff367068dc7a76b17fbfe3b16f23e85491c8db65947da07e42d0e01e2154c0e4b97330ae042601e5de5390e7c4c414ef53c8b52a947fdcf2719589329fc8718a462a92d38438451160654ff3034a92033a1fdd734490988eb32e91b15878ee62399e2e08518c5fea38ea5634f112feb71f5b3b4e1bd77e4c45fc57d5fa62d1b6eb2c8a06afb0b8f688e5fd315f901314f94577b2a668e717f45b2dea18f7b6c8a7e3264f71dcafa3ba73cbc2e102683b11daf656e41c97b5dfe33b20ed89ab7c6524620c8df840ea1742e1d375b7ba1ccba77a3ea5b2f64c151af926fbf46a3753cb3a587271e9d9cee3febdfd72f3565596ec372c0b02a736806bb8417e95a5b7d8968f50d0184ac1e337c055d3191f65c5fbfce9b9406b1f64b5e766667e404d1762633c766b5500a0f57abd3a3763f7b2bce69622593915b16a26d21346504c257ff8aacb7337d995f1e8e75db94be8277e1200c8abd86e33d9508af2025023804579d5d2e8d9dccbaaa6a401ce336a4b56a95ae23e0648278955afbe868880f45ac2c2df9b727b5f1359992d2c95069343dd2364b1eded4533c796481e05e121df0709610fb6fe2d25d444a9ae3ac81ec7652e4e2af0f6a06e31185539bce4da54507ab286a7c5e7d6cb167a92c802379db18c30f60b193876e4a27cacca208de1fc67499831a4369ddeed845460b95187fd8d76563e391e2ebd097259839dc79f994ce629929a6b07059402cf3035004c2402e86173330e4dc1569dbb497475134c59ded811a3cb1b1025f3ab12c97cb464faf311a805e8ebccddf40824cbac7e1393f5aa7ba8342e035c434d649a4b5a7e010aa718f5ff0c04aa1d7769d14a4c8b95c8e564c6d3753a94b216136ac1241ec222a2e4ed5550c418e08696d5d383ec9dce6c9cf6dbe270fbf326508097e45fb1d25d188c5c9149feb377d7dcf23dc8ac8b8c779e379b663fd71efb712afec0dc321112bdc6d175036bd3a83bca54134ac678d62c2db369cbc2f4a9bd06f799d8a632ea7c7ee00a27a0f74313a9f46e47791fcf3dacf59c30465d8c69e505f07602bbe27c14004f89c535400f47329bd9348bd4424b9e5c555591bc6f3b5ea6f17d4e2a7064be73b834520bedeab3a19fc0a754d0f44231232b42ec74a6b5d2c7e0cbf0ceb88fbb1f90c2f5cc338347e5ba16063eadabe09ea63339d1f624fda3cbaf1301419f521663fa2e6a3a60f480c28245feaefe5f78319396e8aac002971c5720038bd56625c404056e453ebb79e1f0f59e68a671f127cbf6cc9df783b2469aa94bdbcac1f6737e1d13f4e193d198ba9e18a1a61889c274a9ce44049b3ae5bf7e973650cc3a23a8666755967d98f3ae30b73589f9abdfa537f93ed066ae449134a59dce0c683573f723a6284303b704429ffcaaebb0c6cfbc9e421f01a1dce74eb78a24951bd47fb16938cbb077a05fe8e9d34f9da9d6cea1862300a6638fda5d7229dbb1ba17015f153d3c02eb23ac62d6959d034a78b5f818c624638532262e8f8ab4ea4897f6ee94849637ec554a47b5a173a8eba361ce97c69054a5315c5bc81a891a8401d7d731c09d22836d9a15a7868f6aff147c1d98b6d4c1aed5ae404b67b2283a496ec6c807c9f2bb6cb3b1df01b4a553b87ea0534f307e8fa5b6fe07a62793bffa84af00408d889ab43abaad2d4a4190eb37ed64e6a4f3d339086f881fc6fa1c15fcd83c86213ebf2a93ea5a99ee46abf3257e68a1ec401a302863a0e079b8f65955fb259ac3ac465ec5d511dca46a5920967ed722ae311955cf50eb1398082bf5d7765eb54758aa2adfa9e54fe4dbdc0dccb3bf92615df839f555c426ed9b8a55c9607e692804223c95dc266525d52da4d54d8b4c7dbcdb7bdcd8f559cd17642c37a1f27ec62c8686da038b5c34f419ce52743e9d09ed30c5e7e9460db68706c4c223f5efa51e9b13b1d66f35d3da316379f2aaec652ff82b4064384123019407bb9dddba5c9f25ccad20a65989071bcc5e548b9d24bc57ee88ece503b6354e4c0e35f1c0c5c49c91a54ca15e8412dec6ef576864e3f2e54c2caa74edb3f103d57ae165c2b02661ee37233d421c912f639d0966b5b41f3dd42dfd34bfd306df2394754b3d0df79063b1ec6ea6658ab67a03c5543f50a0241292e83cadea9ccdd82e6d85ab53d04a1b18dc1ab96dfe705584251d4c3a645d4884fdcbad28b853def219d7e6fab0ec2bbef7093075c927b716fe8c645cc4f5975bc61b3a0366c7c39818642bb6369f2a13726af8c29dae285bb8c6b0baf41b965324552806ba2b8af6c692f928ed2887596af77faab19d7592e9ee751f50828f67b314ea2a3f108f85a3a4f173385322ca6ce08e529068674e485e6f3f5d55815f5ee72fe10909b49ea5ffa7b727e526ab17e32fc11b02a24b7331836a5a911ab6cd1d3a298dc5359d75771c77b6795bf6796ad258c59598b169981e1c556d165f3f39d5254f433ad4243949a886c553610feb2c77956eeb786216025a914fecafb95c13c2bbdcf4912449afe64e4af198fbd999c72701b2040dcc2b8fa52bcf522f375dcdc9133c83e464b376be00e0c78b7a1cdf107201bc53107087be5c0fb20fdefa1f72771c9105df153c3aa2ee41e1bfd5742ee2089d650db44011cd3d6e324c98c1269b52fc76e1d737ab967de5b233c599cbd3c325f92eadd6f8e7497327624eba050ee1630de121df4d66632a142a2c714edc992833af00b4c08e313591bf74e7e5c1a7f560fa9422e26491180d9935630b0be05040ba915bf59417b91b5326647ac6df16cdf6ab8f3497e2b566ceb53948b685703425c15f0e9eb8732526980ddebc75e6ab28778d3adb08e48f24ea8b021e94a35a60a9e8b6f0f13d5ca7c6bc73e86643b6cd430e02337971e9fab08e2590e97675c9ed3950c60e6aca834a5628171e8ee65f98478f97238e53f1b5fb5ca1bd1ba7c942abff881c3a855e701878b28b358736ff0ffce1568f2443bdbfd72a3120018fdec63aa6dbb12ae35a7e3727dce6ba612b297e36f8ea80adcd2b4c921c8042a75aa3070798749cda80a6b5c8d4f1292f54407093f308cace2a5c9724813b1e1e0af34fdd1a613d89c61469786480b235ccddb7b41f7c4ab1eb6fb585b352e02376f7777f075d6256fa9ac0df27d36dc3ce3e6e3fe156a06f0fb94e250c19ea826e1ddc18194f138b02b138c7feb33cdcb0308dd214071a3c35612c9465f8baff5cc74c8e62a76b11e59f5e0519cc9f0f2c7bfdd9b05a37b9ece3020cd80e45124b4ce128bade7beb64335ae8c30f7428e418046f921b5ac743b3df4d4a43922cd896bb0a5aeaaab07721e512b4df49a8c08ff37d5a0df2a2ab74fa75a0fa8a3258249a6011f6df8b2ef4fe35f591f1b9ed239b2ba12c7663d9d2b171fddcab91ae9ab811b107f2b8abd4ade39c450737cb2abfeac93848bf17045fdbaddfc88e34e594f70c7fbea50cce06f610042d6e4522f06096f862dcfc4cd798422868e719dba6a1537d6393b23601756c2af26d1c1b8db17b9c65082c27d0ba9cc13eddc10a160a3d92f673bab6c2a655919a7d947eb090aa387c0bbbe7aaf0e35150f342d66eac4fc5f4fa24606bbe2e2789cf6e3e09adb9757677e641e882837bff5faad29e32325b44fb66610ccd3d2a2675cb955a89b56132c92519238890cef5d87652a976e770fc83bd109a03281d1cd2667e8876186e825913df6b5348b04bddacd51d4eddb890c77bbb87ab9508318540ca9beb2c5bf823ae998f42c6ee57b81cbfb57b6a81dd85a101cc7c5236598ba8121a1e30fe602d8bb8ccc147d2e4ba74da1b4f1a3d632f42ed7ec0aacee94da4ab68e9fe40c8ebd11f580cd1b649951cade2e926918798bd9aedcf46483e0f9c1822baef3faac31e30b1277962b2c8735b2225faadccfbbb7fa2a07cce96b8f34bfba77abb0a95ce377f6502bb9b0d2b708b11f0be1ad8f602c2636ef4643fa585b3d5bf020708ae7687a64239a5ec960adc28ff394b0ff23357024189fe0c06246fca0da2eaf8e4f8c0f195d60984b6829d77cde762525a71ad674501c7028ce53e6c7a19114227f32914e6f5cee3e41d8ef2171de3e80bccf9ced21a9a927328345344cd21aaf85fe89f0db867c0232d9d719796b893e7a74bd2f09c7c63e7d2f26c545ac3c681df09906a513adc533348bb3e5c5ca7bc03bfc4788fe4fd47be3fdfd9c62540004a8abd713b3ef5570e4d943f6e9cf5a7d19a0d68de84c944f839249be93880f7ce65ff1018ca493c559f46bc53f391c6f63cb3e32141b0d682ceaefa4f96fc1e462e43356ee26ba88388df9bc74812be6f7ee23d71beacb3d8a5a4e30545fee82c05eeeb567eb99d14895a7d78ad30a5a1822fc4e75ba3697915d6a51d54e72063323d1a434b6a299680da322f5340858c6eb6b73a82af346abd7fe9c387261ce3f14802d1c11a29b342e5e36b83a3cce24041fbc16a1d09adcfef965ebee1bcbc3b6a60b618a27a987efbd9d062ac5cf228e157a9fdd0f1f9f9eae5c17e32488e8ce1093ab90fe10550a62f171629af0161a401106f164e636e5ac79ea51e2e6a646d30fc8aed48b0fe7ecb437a863f4376dc938a17d533605ca62c37daa77ea56a3451018c840968b6eb51aad594975ea6cfeeb9d7d9ef725e6d25131495e4de045251b78d75f4c30588cfb256a1cdd678164e4bd463d32c314e003e969569d10a4c9058ac09081a81df2c4d5b35f9db09c390a0b9091cdaa444705fc132652c7a440a7645b699f3939ac3a19605262f16c86471e34cb68b6e1fac7b8971827f8485458179cdeb5ae0b6d0c18d6f3b46008f5a754fbc067ff987bd165fa224ff246a6db9b5b6a7e8e774a06fc7e89f355edb0bd53f097bcce083d0b4a2a0911b9c3d91242d82eeed8f639afb553191eb74a41d1f71bb61496fed0aca3961de95e64acddce603a1d609a9e235b4b217d7c721eaf5e6a30f3b49d1c2e8700b08740de94204bd81c87ab5bf027889c92fa85d1d99fd3366a1689cf9773191f32e3a79267a13e7330c668deaa9bc13385f160944151a1d86752ab92d52ae61e40e2068ac491902a289af0fb31608e414d9dc691e8f128a5ecfb2e312d7e21bc4eb0400de8c83ae7a6cabf9300ffaf66fa862236b28697f332813116a01df859e26b4bcea7cdf795d61f512c9146d6c2b830daf4f58a519da2f7b919b215d89551a23db0d955e33c810be00af9e9df534cc8361fa1f93dcabaa7b3cff7dbb7477e08d6839756d859ec6bf617170382dca2bf4c59751c2f4f3a891f423629cc271cdbf7d818cfb6ef1f8208d793b23a27fa54e57111fc3e279282b9d20be0b284fa02279c50e4edfbad287c4dc3265b594ffb134916039256cfbc5fa7c377f0f896d06f09551e11b0a1ea26c3505bc08e308d0eccbf1d961164e67b1c5615980ff740733682c967a33ad2cc1e0e54671fc84216ca1a2886c4c85f78b97bdeb8ee7f0cc0c051a6f5505e3cbc6d7df5ece46db0b20f250b365a16f5d92dfb3a634ff5d90479bdbb3a0b7e76e0c202cdb1cf6a01bcdb9a8cae66b7f12c2c1dcd6093e86f15d3b47d0793184a2aa8f74fa249e06be6275f91e99e33245b1df5a97646492bbe86ad8dd60bf9196bd5507a20f43dbd47239dd72c9ff0d57c5d935210e74e1cff8ba45f3948931c1062430ca88b015b6ba857421070b56ad7d71b101f5da1bf6b2b60744d543d14915f8e92076b97d588f3ea9440c48eb72b5db09d08aa0e9b256a6518821c4c8b09b3483e8d0200b3b2b452896efbaa337e85cd32ed782291382026a413eeb2339b31a1e6b5d5bce5883c1a892cc5beaaf5703284a2cdac0e30bb24381ea69aa60aa6c42867e7d7699c20b3a431784de79d0571813a9f2aa4e4c8772f15f9ddc2833cab1161160d3778f1a85bd2d56cd7e7715383dcc26e3ee3b9fed0b5f931963d38ca696a70e3faaa00917c9dffa61c8f5780fe2a9abed9c6d694921161eb5613751132cfe5b0712fa2052ce94f7a72e9adbc81e6ef4d52785dfa8963ab7b6828a9f7515bdd10762ae296f9f0141b3385abf2433c7460adce8688996eecbea34a571ffdfe1018c1e6dd53a8abf69cfcbcab234a30dd39dc8f3ac719bbbff25e17f0b4a00d388f5680082bd729766927e73966134bc531e487eef8abb3636ca69a7724ae615a3a30b4820d6af935d7a1417912be154072c7bdfeda8cd4bc1634ae23d664fd35f2d7b29b495fcb4b5cdd4e4bdf9f2d0d362f0fafa7188cc0aef0779073b8eee8eb9135053bb8e3d737fd8cc08251009fc5411821175b9ebb68bb82d0023805c0bd52bc104378722eda9315d34ee711088ce81913a63a08130846d964381a113785f278df65dd5c7e846641b88e5071bb852b04c91b980cf9b913b0ede2737beb937e428b29eb5d8671281da7a8fbc58f718b53a8aa97c230626523a0e211b672b21bebd84176acd56425619b88306022941a7899ac45447f683d546f464b213d0f9c3beab2aecfa672be7c2996be62485e12538a8b24486e733d2f3c2f379dfb7048cf4956f278a76137565d9f5699e9f3f1796f477785f410dbeb79b5e4cea0a9ad47fa63484d1218b9728268f73d6fcab6fba71163f09ee201a3bb4acb33dd84503f16593b856b0ce78467cb3a1b319a05ede0a8f8998add885f59476cf84226a73775f6705e5e18f19b51b9a9ba941c0bdf6c4946053910e05627778ea284596923764c6b327aa2c49f3fe9ea4b6dc6791b1ff431ba222a452223801a20dae2cc1a1b003325f55e067cba67a75b2fd6cce9720207be70c6977cfb8d346cde8e7b69bf89234229e5abf168ccf142d603ae324d5610718e16c92aae09bb197cd7e5a9dce77c45587c04c1227b5a8973ae689b8425290929249f17bc213f8c719f3ef774d1f48811513a4c6e197a15ccb75fa33a50b55f61c40f78bb7947418a0f33088c8852e226070d1183073e9455f28a7cde75dd8308ad79061eff79b361d8950688351c9b8b9d0bc79fcf76276019b9629e7472c0d4e5e8bd41aa85becf9471f80820f3e7c50ccc8df506d597412c5110bbaf99ef31d1fb22210caa983bb4f8e52cb7acba0e8e791737ee1b86d5f7fe05718d3f928dbdbf3bbd44d7a4b6ad7c61365b52b9df779d0f2ba5b34d988e0bc42b0960cfd726fcbbec0d3037222bf3642b9a5c4be4c6c8977d78d7567df7dca69fc66d472889fd092b4e38a59fad6e35837940c3e9a380628d38ff9fabe1a0e8888c74b8a5461ba982b33f30d641eba669fc626e829519e0d770b7436096a295f0f69643f09bc4c731fee714832318e8bd9b8a3b042d62dbae443a8e5b6a11491a768c5ade820468eeccf4b48428da64a120765293b5df7b365dd6fe7ec89cee12578f2d95311bafcd7fc79086e3c78b2f4fd70e865039e9ebb0bf2069119c5be74c40a778710d436893d9a446256b2aa070aa2be201cab82b99421b6d5e3818b017a261659ae72abc5a132feb81d43b991bdfc4a74ba529b873910bf7782a9a1ea8ca8a782ae98fb6a5e226115b66002b698fcc4309dfccf27757016dd6dddbdba9f727ca3e729baba9924a9ac9327ba69079bcf9f0eaa44a85bf6a00e5ffa9a83824f0fd70c6136e34bb356ffd8d3f644ea4679cb8045a748661f74f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>题集整理</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 算法解题Tricks（持续更新）</title>
    <url>/2022/02/02/e7e76d98fb52/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="48a19f5fc8e92bbfcd92f6b1cfa38edd5bb0e1cfef63cfea388c6ab5011f40d9">0b64cd3abe5b0a0a039a37d86c66d75e6ec8e220ebc13f2625638343d94e3b65f9d86782f69c158406c39071ab7e76a8d5cc95c136b737bb12ebe1033945ebf69ae7711e0f9664644f3bd4df64f659ee684506f786f8e3beeb0f5c810ef1aa85b2f7c0ecc8c7e21430346aad87dbc3fb5b36e37311a56ee0c28f8177dfdc0c4ce1f014da184041183e4dad1cb841e9b7cd9daaf2a180b8bc459f71cf44a1b09c0758b403f805704aa22ccdf62aa0d94334b5e4927e97c6378606c74ebc684a24227ab47441c8aade6b59cd39c4d74073e57f972117a956b9a39de39c651a635f3a3b263fb89a02b2e64bbcdb00a01e37fd0b211a49788cb8050e628abbcc02a44fe8274f191cba721f7835d8e734a422bb8eed312ce7b16b04a9a9d41ffd21410f316159e99edbada25ad170d3dabfe9535d5cd5cae3c4c685ab521adac136783bf90f99aa7c2d75e5abda6579b754c070456fdd4064632d95f49ef94a4e760e970ff04b20ee63ba14dab1ba9766563abe4c727eb1784af3361906a674579a328999ddce6720acb642cd6e08b5111ed9869c260b03b24c87f21e4c75a10327973636c98d159e608eb6f0aa7478212092d1192e62a58a843323e0a5d75f9a332e22ea95e4e66ccb66c1e7c2c52d9102a4b33969a385ddef8303b44360c5e2f8354107875d74e1d54b2d3d68d18517643cac87cd6fe05048bce0d0a928d75e1eb91ab005fc7ab56f1e4d4bbf1788a4bd48adbf0894f13af19218c2c9d1a7c206b9303f58640bf7e666703e32150fc29f876986d066006c6126ab676ed474c4e70705076913f14ad0d836995fa042173c3c98bb033074ca54e2ce1e110a92a2c64ded4ac35d3d11294b66c30dbd1723ec84ee8bd6bae914a18392fd6b96287668614ff41437d5345b015b1d2363dc82bdc3b48a6e1dc47ac9c8e3e3fa16683a7b58e0f7629690f083741a2c1aab04e0b9eb3106a96c22dbc2878cbbe8f344c958aa647e198282d65534c48bf710c2b015361db79353de260c9cd325ab3c39b4de74c3a98d01f385c7e970ffd25c2e47071f15e6993297f0090ca3524f27797b47cd1b2179ea82de87e070835bd6341af98c5fcb2b96166b813b6ac49e4dc03ff65423014a3bddb54f3609d6c7a2568c58ddacc8b62ae8c776e008f06c5eb4c3f01e0d9f8de813d2d50d869bf0a94b16e0817abcbfcde0bcf531a0550ae5a99bfb51a23f476841a8380da7d6e29397102e215db81ffe7d518a1fa64e032bb33723595bec61b8c279d323e68ab532da8a4c08e6b9921aa595a2cb04c835c438f781dad84c3c1a1f7249798e413bf9a3af362d251a630aef80f2fd4e60aa98b2493788df48fd53314ee5d688f515bfc59de8131cdd240955704149d9193b53094a69ef0b0e8dfdc122d7bd227ec4e2041cf213069148e431787c0a164f38aeb5d1a6e47bb64abb0445246e193f5ec4a1d078b3e947ace6e7d2a68dc142b79319e2d477dca081a467ea849669effac28372130ed05386187904c0aee9b4c9940106eb6ab87463060beec23f86951667033d44fe3bb752493a4e209464e63de1ec785f200b36da004a75fecb9cc1dd8b84f92b6ad5dda435b51475151617e2f79ae673c7aedd45df150cab6f3c017318d6a8150c9275081cae7ff3a7a13481938e5c2092be071364993bc373db72d4dd1fe2807edc91076106bd011d7e6c9f4915163e941ff9352b05405099b45726aee8039db5954acb02c1ddceea1c073ce9b4f121c790846b203342df3f95c8642ab023185b6a547af1a935670a4d1f7ea56c5444325c07f93fa209cdb5114366cb55babfb6544a5f88cb2188a58888cec9d9fe677ca9c6461beb298f78378a7620330b2db03197d3a49a980de1e122cc74c813b17b886f1785a119332d9477d87dd6e9208ef29b19f7586facaf2b4a20643dddafc2e1d4e034a85d0c6ccbbb4d6933f6b0bd7573b336d2f1022e6961e60cb40e867df0a7f73f13419ac1bc0aa2efa64b0ce79d19963830a23220ecf9168d90b86a8754804ebb41bc053a3fc1349679f6dfd5dce622a8e429a6dd6269022f5f9ab75fed32e8244eba9bf80c14bc696e10b9b8cbe38a9ef6557e8a294fc8e307b782788d6ea060ee465012d97fb7a4bdb32806301be25be23a966359d8d0be5a24a55d321dd71ff0f49590682d2b7b677f741e78e1b18805fba37d877fc03fb90ea712688fc40457bcc714e3489977c111ab41a88951a5e33d324027dcf4d0ba83b3a7cc4fc323bc53c0aaf9ac0dbf47ed17269379abdc14131d44518fd065d979f1310fbc6da95023cc58e3a649f2c030751abaddeec7f53d98d8e1404146e144f1ea4208a1d72dd6a2aac6986e0ece996a44ef9e71916e1a3bf9b2d3746921c7b24d987f95bb70131842f922d5f7b807a3a7d82f9bf0553272acc49c43d8f05c667e7ffeba075e48b83667c3a98bfcb7b6c4c91dafce58b8d6cc3be00462b33e73b084c425d8606f18ef28996603873ef9440df1bf933b2a2a5df31036451ca7617f3c4eb0fefd15a92a7884f81146faa71761b7e03f478f5db363ddb5ec816a716f173954ce189b059aa17c24e67a582e9973a8407eca416695bce27657eb90fecd5200801ce753bb6807faf486f883aeb0969916ee37a973117187fecee95214ac409dc33e6b395d27f43f2fa14292344d5ff0fe7ce3d940f0e0a3fa2a202088ff7fa5584c2adb7f7f340f1ac790a0e70d7ce01cf81e748566bb09b6c6523a1e8d0330674e2d7f62e959f2f345cc838a404a75d87b11d4b3b4471e26de279a8eafc99a417652fce4fe9fb1fa665e882dbceaa96ad9fbcaca2e420951944c916752dde271cf46f9c63551b82d75c17e26fde35fdc8fbf7b480a5fe9258ed62d124fc99cca079000d47cebbe661ab999e07953e54835389eeef287a73318709a82e10cbc32f5b132e3d2d04cb3ef4c4bfc31d53bddb6afda4c560021642d5ccbdb3ec9f2dbd987409b5152c9f4752eff6a2b6a50a563729fc3273e4c0401f46062221c506a894a5d63657c268e69a7bcb74e1084fb94567e9c05fb777880baf9ba0ecb0c09a75071b6bf17a2d9b1c89763029cc6fb23a181e2e6006d05e93bc24924408498f757a6a99a5eb4022057f3136c570d35c2c21806362df938fe49df86328db4b8b6afc1bbb5d37b6130855812b3db5d1d6da962bb85551d964796934123574185c98965098edd65fd178f3c66e4fa82a34b324ec7fc007e61734e61a13290b408614f6afc6729a8d2b8fb8300d530c73273d98bc2da2ee8e9398a9c7bbebe89b5eeb05dc819503077fab864bf4c648bbca8451da54903c3ec92b234a9c13b8a5165a5a903be2951e47bd85c30c3dde7fc4dc3d3d7d7731c7d6e14f9c632ba216529e8bd73e2a99ed086c034e21a8ef18acf9edd874645be49977bef56d03006883e10d8a3daf0c63c8329f7651043fd3edcda304e0f84b07d1fc1bdb88375f2435a213c933e726ea9f05974f9e7ee3fc86c5fad852d3db04b14b9d9fcb6de4541c8639e99702c2eb7d8a33b320babdde206aad3965bc73ed4aab8eb4c38770ef0d4cecf463b5d44438653fff03598438ecea01174f34f969b2828d080ab3fdde7b98a82e02b50e6ebc79d16321b4f0e628d83d3a55e1dac2a8395f0c51e82c77079fa10386b816e90c63c83c043550eb5d9b836391e97bed7dd36a5df23aebdb1a58cb300a1b48b5202fd467648c4be700be1c9e63303cc4ae1df895c0ae872a7004f2deb51bfa5b34fda8f448a9f5c38f2405bac3d5459569fca94b5ef2226c144f78d1c6ddf79926d36a576aa892440b237f479c4336e24e13a4b25c1fb489e60a2b33d4a5eceb725d84f0418700ae3c28fd7c1d9a96e4e572654709dec4fb3efa676cf7e97a4b780f839d96a9b205e4a2cd81f53576d02e189c52609534210ee287f4cf0033f2e1ff370c3c7d406eebd88b6be6e8ecd7713f31172aa80f5cda23b798bf41a01be23692d10669b4bdbaf97333ae9a9d61ead478556b0fd8f811596a0b6f325be9fac551566e48c2b5e7538909de8d5af3cfba6cff86a5c00eaa012102bb8e1626d83b695c6b6ff4b33f3a8336e7b43a6ffda46b410079b3e80871396d2ba444542c5fd644e5947171a2fa119f4e474936ccefbbc9718c73620a83cb0d26af176040094121ac55038557dbd18339b7fcc6c538c0ed995d44d8dd3f3fc1bb893d48c25ae475d8f2dcf663f8f708d443fe251b5cda9653dbabedf1c94ed4b25574672f8d9593e640fa502508a976716f7175e41b28e76b059ce5a1b821a6d2af14478ddc43d34015c1bf3a72eaaeec8292de705b8c2309ba5089d5be72432277f82a42caaa914a442385f5647e41d0e1d4f718560285b8b5089aecb32c6eb5159baa0a77c0a234813431d43c66b058e4b33f450359fd757794e014cb3ab9c1468d099429d065402387e0717095c13c52ce5d777c690652afc52f88ce6ccfeb9471273e72319cf5df4e5ada174096a2b1b62aaffc3f5a02ab3159b7a79432aed3f6558a6c8405408f48fc0a7af49bd46fc50929dbd68e51a915f954af9ecefc1cb104c44ec762ab922c57720f4038df2c842d7cf82f2962d126adee9bb43055439e9ad5acae91b1370ac4ca7b48aea23b5f819f706b571c5653a2ecf31fd918e4de358926be3cc6aee4347f5d489ac87455f4ae1711b84f3a898eb5349779ea2e3013eec3d17af6b9f20ee363c357e8a2f47c79872e6f0084680d33f147d9c139245d5b2c47fa8bd63f1d255f56f57d304739a48c3cd654f994ebcab3b57d56301c727132b670e46e52aae6df4b71532d14e45a0ac15f8fbd67470981468b117166de101a2d81ed815658ead7ffaaecacfdc42ba888a0fc3b98ecdeb602a5bc4ae7c37e125ca35b23c74c82ce7ca765e0d74b6f3723612be6db7768ce61ecb5db3ca2a230bdaaed77cd19a764e66751ca5c9f8efbe4add54ed0b94efb539b7dc60546f1fe82e9e518abdf9ca0bdff389db2318762559dac96ebf03d2b1b07f232995b471b80446a3a9125fcc6404ffcc5f07e13458369f8c2462231d9561c16acd93bacbc5be2f77da560e79c119337cbd57cddf52429fa7916c770c0f9d26198ee614d841a51d4fb0f3d35cf76825888a5893cc01a3ec962746bfa68da554734f6e3307c52f69add55bba87ea360ea8f78e0be2b82b695510f273f89fd264c50999c1e7433706051248dda5aa0b4fe8f7198ebbd392e51c66e33fb37c897a9ef9ee5ecf03c69655b3ab96c40f58a887d57fc96beeb63b31ea1c3936b29f0032f48d1710c0863fb775d2e535d51b8eb1180d0aeffed024e7f7181a51cfffc60f7daaa21c42e2607de58c1b1aff310a22aa65a20b89d2b99149ad76866862bc0b785829f2af8fd22b0f213c6fab5c63d485aca230dbeea6442ed38ee45a2a1712be1be645e67062f2c86835bbd1502dc347269712ed1aa2dd62cab8beba0a9dfd17d359f26109e411ab037113d921a3ede55be6f3cbf89be78d78b25dc83187b9c7ecb1ae5c09dea894b7b817daa22b2f28f9173fedcf3e849e37b11bb79b6b4d465c2765ddf73aff1f34477fe2d5b57639ab9d55eaf4cf166bd9be3597ac5d306162748eaf33d0dfe8c721ead8c286338e0ab060f724169dbbf5e5b627359a076174fac2f7ebcccdd824095d99c6d8c706f05c0a0d136b766b3183c2d3b6bbd13717e2519d0f42f341d920c59c45117103fe476828c5a029fb4d6a51fbf8b72d44c301fc0751c7c5b57035a9622671b5a8628572d5c687a8352dd8be5fc4823736c9973733e3f6f46887c0bc4d175a929299e9ea13b61e5d14a1a34f91a2135f478f0fbfa718882410f3da687cc0cdf563f3928cdce9e338c46d17dfb2504eac943b2484f6c92b7beb7dc1c289eaa6d9601ac534efdb9214cbcbed371b1832a8ac6a28ddbf6474b6f60b42138900d9d24d6b27156c452a3eb9a78702a5afd8211d87b2810f437e04cac8f73845e4c5c68f53ab63f1f59baefa8d28ed7bbe8d3a9155b8b2778c8b6fabad6e9a70662effc4694adece146f4da37de1280be1b2789db6b73ddbaef2445f5e04b0cf5dc4dd651e6e2ac832352fee161b944502b1b64e0368bf55ef68e1f99060809f2ce5d7b264a73344a34c5f283ada627a4cde1130233b422211e7b1ce24256dd652cb1addb81805fa7065643f14ecbd222e87e17d23a3cb93fcd78e2ab6ba9ef212934ff8c54903e54f02ed6c940323e3cbcb13ac7fb3d448b4078b4cc71bdaf06c7ad544f18e71526d5d3dcac5f574bc82953f27c0dd54e65f0bc98f61e373f0df32fd194cbae897c21285d5a88444ae80da4291c6cd96b9889c185bed8863f72fbf7569d2bcb158945dd6f4cf0ab89e8c7d24af7de1ba25d2fca4f0fd122e25144aa0022753a54dda195d</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>题集整理</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot2【核心功能】——Chap6 数据访问场景与单元测试</title>
    <url>/2022/12/05/2ae665efb210/</url>
    <content><![CDATA[<h3 id="一整合mybatisplus操作数据库">一、整合MyBatisPlus操作数据库</h3>
<p><a
href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a>（简称
MP）是一个 <a
href="http://www.mybatis.org/mybatis-3/">MyBatis</a>的增强工具，在
MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p>
<p>添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>MybatisPlusAutoConfiguration</code>配置类，<code>MybatisPlusProperties</code>配置项绑定。</p></li>
<li><p><code>SqlSessionFactory</code>自动配置好，底层是容器中默认的数据源。</p></li>
<li><p><code>mapperLocations</code>自动配置好的，有默认值<code>classpath*:/mapper/**/*.xml</code>，这表示任意包的类路径下的所有mapper文件夹下任意路径下的所有xml都是sql映射文件。
建议以后sql映射文件放在 mapper下。</p></li>
<li><p>容器中也自动配置好了<code>SqlSessionTemplate</code>。</p></li>
<li><p><code>@Mapper</code> 标注的接口也会被自动扫描，建议直接
<code>@MapperScan("com.lun.boot.mapper")</code>批量扫描。</p></li>
<li><p>MyBatisPlus<strong>优点</strong>之一：只需要我们的Mapper继承MyBatisPlus的<code>BaseMapper</code>
就可以拥有CRUD能力，减轻开发工作。</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.lun.hellomybatisplus.model.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4
id="数据访问-crud实验-数据列表展示">1、数据访问-CRUD实验-数据列表展示</h4>
<p><a href="https://baomidou.com/guide/crud-interface.html">官方文档 -
CRUD接口</a></p>
<p>使用MyBatis
Plus提供的<code>IService</code>，<code>ServiceImpl</code>，减轻Service层开发工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lun.hellomybatisplus.model.User;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Service 的CRUD也不用写了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">	<span class="comment">//此处故意为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lun.hellomybatisplus.model.User;</span><br><span class="line"><span class="keyword">import</span> com.lun.hellomybatisplus.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> com.lun.hellomybatisplus.service.UserService;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper,User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">	<span class="comment">//此处故意为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二整合redis">二、整合Redis</h3>
<p><strong>添加依赖</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- redis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- spring2.X集成redis所需common-pool2--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><code>RedisAutoConfiguration</code>自动配置类，RedisProperties
属性类 --&gt; spring.redis.xxx是对redis的配置。</li>
<li>连接工厂<code>LettuceConnectionConfiguration</code>、<code>JedisConnectionConfiguration</code>是准备好的。</li>
<li>自动注入了<code>RedisTemplate&lt;Object, Object&gt;</code>，<code>xxxTemplate</code>。</li>
<li>自动注入了<code>StringRedisTemplate</code>，key，value都是String</li>
<li>底层只要我们使用<code>StringRedisTemplate</code>、<code>RedisTemplate</code>就可以操作Redis。</li>
</ul>
<h4 id="redis操作与统计小实验">1、Redis操作与统计小实验</h4>
<p>相关Redis配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Redis服务器地址</span></span><br><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">192.168.140.136</span></span><br><span class="line"><span class="comment">#Redis服务器连接端口</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment">#Redis数据库索引b（默认为0）</span></span><br><span class="line"><span class="attr">spring.redis.database</span>= <span class="string">0</span></span><br><span class="line"><span class="comment">#连接超时时间（毫秒）</span></span><br><span class="line"><span class="attr">spring.redis.timeout</span>=<span class="string">1800000</span></span><br><span class="line"><span class="comment">#连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-active</span>=<span class="string">20</span></span><br><span class="line"><span class="comment">#最大阻塞等待时间(负数表示没限制)</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment">#连接池中的最大空闲连接</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-idle</span>=<span class="string">5</span></span><br><span class="line"><span class="comment">#连接池中的最小空闲连接</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.min-idle</span>=<span class="string">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>Redis配置类：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"><span class="comment">//key序列化方式</span></span><br><span class="line">        template.setKeySerializer(redisSerializer);</span><br><span class="line"><span class="comment">//value序列化</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"><span class="comment">//value hashmap序列化</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line"><span class="comment">//解决查询缓存转换异常的问题</span></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"><span class="comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span></span><br><span class="line">        <span class="type">RedisCacheConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(<span class="number">600</span>))</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line">        <span class="type">RedisCacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试Redis连接：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/redisTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTestController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testRedis</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//设置值到redis</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">        <span class="comment">//从redis获取值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String)redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>URL统计拦截器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisUrlCountInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认每次访问当前uri就会计数+1</span></span><br><span class="line">        redisTemplate.opsForValue().increment(uri);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册URL统计拦截器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminWebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisUrlCountInterceptor redisUrlCountInterceptor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line"></span><br><span class="line">        registry.addInterceptor(redisUrlCountInterceptor)</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/css/**&quot;</span>,<span class="string">&quot;/fonts/**&quot;</span>,<span class="string">&quot;/images/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/js/**&quot;</span>,<span class="string">&quot;/aa/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Filter、Interceptor 几乎拥有相同的功能？</p>
<ul>
<li>Filter是Servlet定义的原生组件，它的好处是脱离Spring应用也能使用。</li>
<li>Interceptor是Spring定义的接口，可以使用Spring的自动装配等功能。</li>
</ul>
<p>调用Redis内的统计数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexController</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate redisTemplate;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@GetMapping(&quot;/main.html&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">mainPage</span><span class="params">(HttpSession session,Model model)</span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;当前方法是：&#123;&#125;&quot;</span>,<span class="string">&quot;mainPage&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ValueOperations&lt;String, String&gt; opsForValue =</span><br><span class="line">                redisTemplate.opsForValue();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> opsForValue.get(<span class="string">&quot;/main.html&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> opsForValue.get(<span class="string">&quot;/sql&quot;</span>);</span><br><span class="line"></span><br><span class="line">        model.addAttribute(<span class="string">&quot;mainCount&quot;</span>,s);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;sqlCount&quot;</span>,s1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;main&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三单元测试-junit5">三、单元测试-JUnit5</h3>
<p><strong>Spring Boot 2.2.0 版本开始引入 JUnit 5
作为单元测试默认库</strong></p>
<p><a
href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations">JUnit
5官方文档</a></p>
<p>作为最新版本的JUnit框架，JUnit5与之前版本的JUnit框架有很大的不同。由三个不同子项目的几个不同模块组成。</p>
<p><strong>JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit
Vintage</strong></p>
<ul>
<li><p><strong>JUnit Platform</strong>: Junit
Platform是在JVM上启动测试框架的基础，不仅支持Junit自制的测试引擎，其他测试引擎也都可以接入。</p></li>
<li><p><strong>JUnit Jupiter</strong>: JUnit
Jupiter提供了JUnit5的新的编程模型，是JUnit5新特性的核心。内部包含了一个<strong>测试引擎</strong>，用于在Junit
Platform上运行。</p></li>
<li><p><strong>JUnit Vintage</strong>:
由于JUint已经发展多年，为了照顾老的项目，JUnit
Vintage提供了兼容JUnit4.x，JUnit3.x的测试引擎。</p></li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li><p>SpringBoot 2.4 以上版本移除了默认对 Vintage
的依赖。如果需要兼容JUnit4需要自行引入（不能使用JUnit4的功能 <span
class="citation" data-cites="Test">@Test</span>）</p></li>
<li><p>JUnit 5’s
Vintage已经从<code>spring-boot-starter-test</code>从移除。如果需要继续兼容Junit4需要自行引入Vintage依赖：</p></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hamcrest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hamcrest-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用添加JUnit 5，添加对应的starter：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Spring的JUnit
5的基本单元测试模板（Spring的JUnit4的是<code>@SpringBootTest</code>+<code>@RunWith(SpringRunner.class)</code>）：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Assertions;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;<span class="comment">//注意不是org.junit.Test（这是JUnit4版本的）</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringBootApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//@Transactional 标注后连接数据库有回滚功能</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">		Assertions.assertEquals(<span class="number">5</span>, component.getFive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="常用测试注解">1、常用测试注解</h4>
<p><a
href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations">官方文档
- Annotations</a></p>
<ul>
<li><strong><span class="citation"
data-cites="Test">@Test</span></strong>：表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试</li>
<li><strong><span class="citation"
data-cites="ParameterizedTest">@ParameterizedTest</span></strong>：表示方法是参数化测试。</li>
<li><strong><span class="citation"
data-cites="RepeatedTest">@RepeatedTest</span></strong>：表示方法可重复执行。</li>
<li><strong><span class="citation"
data-cites="DisplayName">@DisplayName</span></strong>：为测试类或者测试方法设置展示名称。</li>
<li><strong><span class="citation"
data-cites="BeforeEach">@BeforeEach</span></strong>：表示在<strong>每个</strong>单元测试<strong>之前</strong>执行。</li>
<li><strong><span class="citation"
data-cites="AfterEach">@AfterEach</span></strong>：表示在<strong>每个</strong>单元测试<strong>之后</strong>执行。</li>
<li><strong><span class="citation"
data-cites="BeforeAll">@BeforeAll</span></strong>：表示在<strong>所有</strong>单元测试<strong>之前</strong>执行。</li>
<li><strong><span class="citation"
data-cites="AfterAll">@AfterAll</span></strong>：表示在<strong>所有</strong>单元测试<strong>之后</strong>执行。</li>
<li><strong><span class="citation"
data-cites="Tag">@Tag</span></strong>：表示单元测试类别，类似于JUnit4中的@Categories。</li>
<li><strong><span class="citation"
data-cites="Disabled">@Disabled</span></strong>：表示测试类或测试方法不执行，类似于JUnit4中的@Ignore。</li>
<li><strong><span class="citation"
data-cites="Timeout">@Timeout</span></strong>：表示测试方法运行如果超过了指定时间将会返回错误。</li>
<li><strong><span class="citation"
data-cites="ExtendWith">@ExtendWith</span></strong>：为测试类或测试方法提供扩展类引用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@DisplayName(&quot;junit5功能测试类&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Junit5Test</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@DisplayName(&quot;测试displayname注解&quot;)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testDisplayName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">        System.out.println(jdbcTemplate);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ParameterizedTest</span></span><br><span class="line">    <span class="meta">@ValueSource(strings = &#123; &quot;racecar&quot;, &quot;radar&quot;, &quot;able was I ere I saw elba&quot; &#125;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">palindromes</span><span class="params">(String candidate)</span> &#123;</span><br><span class="line">        assertTrue(StringUtils.isPalindrome(candidate));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Disabled</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;测试方法2&quot;)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RepeatedTest(5)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 规定方法超时时间。超出时间测试出异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Timeout(value = 500, unit = TimeUnit.MILLISECONDS)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testTimeout</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.sleep(<span class="number">600</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testBeforeEach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试就要开始了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testAfterEach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试结束了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testBeforeAll</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;所有测试就要开始了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAfterAll</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;所有测试以及结束了...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="断言机制">2、断言机制</h4>
<p>断言Assertion是测试方法中的核心部分，用来对测试需要满足的条件进行验证。这些断言方法都是org.junit.jupiter.api.Assertions的静态方法。检查业务逻辑返回的数据是否合理。所有的测试运行结束以后，会有一个详细的测试报告。</p>
<p>JUnit 5 内置的断言可以分成如下几个类别：</p>
<h5 id="简单断言">简单断言</h5>
<p>用来对单个值进行简单的验证。如：</p>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>assertEquals</td>
<td>判断两个对象或两个原始类型是否相等</td>
</tr>
<tr class="even">
<td>assertNotEquals</td>
<td>判断两个对象或两个原始类型是否不相等</td>
</tr>
<tr class="odd">
<td>assertSame</td>
<td>判断两个对象引用是否指向同一个对象</td>
</tr>
<tr class="even">
<td>assertNotSame</td>
<td>判断两个对象引用是否指向不同的对象</td>
</tr>
<tr class="odd">
<td>assertTrue</td>
<td>判断给定的布尔值是否为 true</td>
</tr>
<tr class="even">
<td>assertFalse</td>
<td>判断给定的布尔值是否为 false</td>
</tr>
<tr class="odd">
<td>assertNull</td>
<td>判断给定的对象引用是否为 null</td>
</tr>
<tr class="even">
<td>assertNotNull</td>
<td>判断给定的对象引用是否不为 null</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;simple assertion&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">simple</span><span class="params">()</span> &#123;</span><br><span class="line">     assertEquals(<span class="number">3</span>, <span class="number">1</span> + <span class="number">2</span>, <span class="string">&quot;simple math&quot;</span>);</span><br><span class="line">     assertNotEquals(<span class="number">3</span>, <span class="number">1</span> + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">     assertNotSame(<span class="keyword">new</span> <span class="title class_">Object</span>(), <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">     <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">     assertSame(obj, obj);</span><br><span class="line"></span><br><span class="line">     assertFalse(<span class="number">1</span> &gt; <span class="number">2</span>);</span><br><span class="line">     assertTrue(<span class="number">1</span> &lt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">     assertNull(<span class="literal">null</span>);</span><br><span class="line">     assertNotNull(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="数组断言">数组断言</h5>
<p>通过 assertArrayEquals
方法来判断两个对象或原始类型的数组是否相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;array assertion&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">array</span><span class="params">()</span> &#123;</span><br><span class="line">	assertArrayEquals(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="组合断言">组合断言</h5>
<p><code>assertAll()</code>方法接受多个
<code>org.junit.jupiter.api.Executable</code>
函数式接口的实例作为要验证的断言，可以通过 lambda
表达式很容易的提供这些断言。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;assert all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">all</span><span class="params">()</span> &#123;</span><br><span class="line"> assertAll(<span class="string">&quot;Math&quot;</span>,</span><br><span class="line">    () -&gt; assertEquals(<span class="number">2</span>, <span class="number">1</span> + <span class="number">1</span>),</span><br><span class="line">    () -&gt; assertTrue(<span class="number">1</span> &gt; <span class="number">0</span>)</span><br><span class="line"> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="异常断言">异常断言</h5>
<p>在JUnit4时期，想要测试方法的异常情况时，需要用<code>@Rule</code>注解的<code>ExpectedException</code>变量还是比较麻烦的。而JUnit5提供了一种新的断言方式<code>Assertions.assertThrows()</code>，配合函数式编程就可以进行使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;异常测试&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ArithmeticException</span> <span class="variable">exception</span> <span class="operator">=</span> Assertions.assertThrows(</span><br><span class="line">           <span class="comment">//扔出断言异常</span></span><br><span class="line">            ArithmeticException.class, () -&gt; System.out.println(<span class="number">1</span> % <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="超时断言">超时断言</h5>
<p>JUnit5还提供了Assertions.assertTimeout()为测试方法设置了超时时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;超时测试&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">timeoutTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//如果测试方法时间超过1s将会异常</span></span><br><span class="line">    Assertions.assertTimeout(Duration.ofMillis(<span class="number">1000</span>), () -&gt; Thread.sleep(<span class="number">500</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="快速失败">快速失败</h5>
<p>通过 fail 方法直接使得测试失败。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;fail&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shouldFail</span><span class="params">()</span> &#123;</span><br><span class="line">	fail(<span class="string">&quot;This should fail&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="前置条件">3、前置条件</h4>
<p>Unit 5
中的前置条件（assumptions【假设】）类似于断言，不同之处在于不满足的<strong>断言assertions</strong>会使得测试方法失败，而<strong>不满足的前置条件只会使得测试方法的执行终止</strong>。</p>
<p>前置条件可以看成是测试方法执行的前提，当该前提不满足时，就没有继续执行的必要。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DisplayName(&quot;前置条件&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AssumptionsTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">environment</span> <span class="operator">=</span> <span class="string">&quot;DEV&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;simple&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">simpleAssume</span><span class="params">()</span> &#123;</span><br><span class="line">        assumeTrue(Objects.equals(<span class="built_in">this</span>.environment, <span class="string">&quot;DEV&quot;</span>));</span><br><span class="line">        assumeFalse(() -&gt; Objects.equals(<span class="built_in">this</span>.environment, <span class="string">&quot;PROD&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;assume then do&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">assumeThenDo</span><span class="params">()</span> &#123;</span><br><span class="line">        assumingThat(</span><br><span class="line">            Objects.equals(<span class="built_in">this</span>.environment, <span class="string">&quot;DEV&quot;</span>),</span><br><span class="line">            () -&gt; System.out.println(<span class="string">&quot;In DEV&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>assumeTrue</code> 和 <code>assumFalse</code> 确保给定的条件为
<code>true</code> 或
<code>false</code>，不满足条件会使得测试执行终止。</p>
<p><code>assumingThat</code> 的参数是表示条件的布尔值和对应的 Executable
接口的实现对象。只有条件满足时，<code>Executable</code>
对象才会被执行；当条件不满足时，测试执行并不会终止。</p>
<h4 id="嵌套测试">4、嵌套测试</h4>
<p><a
href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-nested">官方文档
- Nested Tests</a></p>
<p>JUnit 5 可以通过 Java 中的内部类和<code>@Nested</code>
注解实现嵌套测试，从而可以更好的把相关的测试方法组织在一起。在内部类中可以使用<code>@BeforeEach</code>
和<code>@AfterEach</code>注解，而且嵌套的层次没有限制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DisplayName(&quot;A stack&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestingAStackDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Object&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;is instantiated with new Stack()&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">isInstantiatedWithNew</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;when new&quot;)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WhenNew</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@BeforeEach</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">createNewStack</span><span class="params">()</span> &#123;</span><br><span class="line">            stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;is empty&quot;)</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">            assertTrue(stack.isEmpty());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;throws EmptyStackException when popped&quot;)</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">throwsExceptionWhenPopped</span><span class="params">()</span> &#123;</span><br><span class="line">            assertThrows(EmptyStackException.class, stack::pop);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;throws EmptyStackException when peeked&quot;)</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">throwsExceptionWhenPeeked</span><span class="params">()</span> &#123;</span><br><span class="line">            assertThrows(EmptyStackException.class, stack::peek);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nested</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;after pushing an element&quot;)</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">AfterPushing</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">anElement</span> <span class="operator">=</span> <span class="string">&quot;an element&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@BeforeEach</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">pushAnElement</span><span class="params">()</span> &#123;</span><br><span class="line">                stack.push(anElement);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Test</span></span><br><span class="line">            <span class="meta">@DisplayName(&quot;it is no longer empty&quot;)</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">isNotEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">                assertFalse(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Test</span></span><br><span class="line">            <span class="meta">@DisplayName(&quot;returns the element when popped and is empty&quot;)</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">returnElementWhenPopped</span><span class="params">()</span> &#123;</span><br><span class="line">                assertEquals(anElement, stack.pop());</span><br><span class="line">                assertTrue(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Test</span></span><br><span class="line">            <span class="meta">@DisplayName(&quot;returns the element when peeked but remains not empty&quot;)</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">returnElementWhenPeeked</span><span class="params">()</span> &#123;</span><br><span class="line">                assertEquals(anElement, stack.peek());</span><br><span class="line">                assertFalse(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单元测试-参数化测试">5、单元测试-参数化测试</h4>
<p><a
href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests">官方文档
- Parameterized Tests</a></p>
<p>参数化测试是JUnit5很重要的一个新特性，它使得用不同的参数多次运行测试成为了可能，也为我们的单元测试带来许多便利。</p>
<p>利用@ValueSource等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。</p>
<p>利用<strong><span class="citation"
data-cites="ValueSource">@ValueSource</span></strong>等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。</p>
<ul>
<li><strong><span class="citation"
data-cites="ValueSource">@ValueSource</span></strong>:
为参数化测试指定入参来源，支持八大基础类以及String类型,Class类型</li>
<li><strong><span class="citation"
data-cites="NullSource">@NullSource</span></strong>:
表示为参数化测试提供一个null的入参</li>
<li><strong><span class="citation"
data-cites="EnumSource">@EnumSource</span></strong>:
表示为参数化测试提供一个枚举入参</li>
<li><strong><span class="citation"
data-cites="CsvFileSource">@CsvFileSource</span></strong>：表示读取指定CSV文件内容作为参数化测试入参</li>
<li><strong><span class="citation"
data-cites="MethodSource">@MethodSource</span></strong>：表示读取指定方法的返回值作为参数化测试入参(注意方法返回需要是一个流)</li>
</ul>
<p>当然如果参数化测试仅仅只能做到指定普通的入参还达不到让我觉得惊艳的地步。让我真正感到他的强大之处的地方在于他可以支持外部的各类入参。如:CSV,YML,JSON
文件甚至方法的返回值也可以作为入参。只需要去实现<strong><code>ArgumentsProvider</code></strong>接口，任何外部文件都可以作为它的入参。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource(strings = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;)</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;参数化测试1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parameterizedTest1</span><span class="params">(String string)</span> &#123;</span><br><span class="line">    System.out.println(string);</span><br><span class="line">    Assertions.assertTrue(StringUtils.isNotBlank(string));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@MethodSource(&quot;method&quot;)</span>    <span class="comment">//指定方法名</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;方法来源参数&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWithExplicitLocalMethodSource</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    Assertions.assertNotNull(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Stream&lt;String&gt; <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>⑨ 工程类笔记</category>
        <category>SpringBoot2</category>
      </categories>
      <tags>
        <tag>SpringBoot2</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot2【核心功能】——Chap5 Web开发场景</title>
    <url>/2022/12/05/0496c1c14e1c/</url>
    <content><![CDATA[<h3 id="一springmvc的自动配置">一、SpringMVC的自动配置：</h3>
<p>​ 其提供了基本的所有配置，包括如下内容：</p>
<ul>
<li>内容协商视图解析器和BeanName视图解析器</li>
<li>静态资源，包括webjars</li>
<li>自动注册Converter，GenericConverter，Formatter</li>
<li>支持HttpMessageConverters</li>
<li>自动注册MessageCodesResolver（国际化用）</li>
<li>静态index.html页支持</li>
<li>自定义Favicon</li>
<li>自动使用ConfigurableWebBindingInializer（DataBinder负责将请求数据绑定到JavaBean上）</li>
</ul>
<h3 id="二静态资源规则与定制化">二、静态资源规则与定制化：</h3>
<ul>
<li><p>说明：</p>
<ul>
<li>只要静态资源放在类路径下的如下文件夹内： <code>/static</code> (or
<code>/public</code> or <code>/resources</code> or
<code>/META-INF/resources</code></li>
<li>然后用户访问 ： 当前项目根路径/ + 静态资源名</li>
</ul></li>
<li><p>处理过程：</p>
<ul>
<li>请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面。</li>
</ul></li>
<li><p>可以改变默认静态资源路径，这样的话会使得原先的路径失效：在yaml配置文件中更改</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">resources:</span></span><br><span class="line">	<span class="string">static-locations:[classpath:/haha/]</span></span><br></pre></td></tr></table></figure></li>
<li><p>静态资源访问前缀更改：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/res/**</span></span><br></pre></td></tr></table></figure>
<p>当前项目 + static-path-pattern + 静态资源名 =
静态资源文件夹下查找</p></li>
</ul>
<h3 id="三常用参数获取方法">三、常用参数获取方法：</h3>
<h4 id="路径变量restful-api风格">1、路径变量（RESTFUL API风格）</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/car/&#123;id&#125;/owner/&#123;username&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title function_">getCar</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@PathVariable(&quot;username&quot;)</span> String name)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="请求头获取-requestheader">2、请求头获取 RequestHeader</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/car&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title function_">getCar</span><span class="params">(<span class="meta">@RequestHeader(&quot;User-Agent&quot;)</span> String userAgent,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@RequestHeader</span> Map&lt;String,String&gt; header)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="请求参数-requestparam">3、请求参数 RequestParam</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/car&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title function_">getCar</span><span class="params">(<span class="meta">@RequestParam(&quot;age&quot;)</span> Integer age,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@RequestParam(&quot;inters&quot;)</span> List&lt;String&gt; inters,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@RequestParam</span> Map&lt;String,String&gt; params)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="获取cookie值">4、获取Cookie值：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/car&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title function_">getCar</span><span class="params">(<span class="meta">@CookieValue(&quot;_ga&quot;)</span> String _ga,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@CookieValue(&quot;_ga&quot;)</span> Cookie cookie)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="请求体内容requestbody">5、请求体内容RequestBody：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Map <span class="title function_">postMethod</span><span class="params">(<span class="meta">@RequestBody</span> String content)</span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;content&quot;</span>,content);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四themeleaf模板引擎">四、Themeleaf模板引擎：</h3>
<p>​
服务器端的模板引擎，并不是高性能的，比较适合用于后台管理系统的搭建</p>
<p>​ <a
href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#attribute-precedence">官方文档
- 10 Attribute Precedence</a></p>
<h3 id="五登录拦截器与放行静态资源">五、登录拦截器与放行静态资源：</h3>
<p>过程如下：</p>
<ol type="1">
<li><p>编写一个拦截器实现<code>HandlerInterceptor</code>接口</p></li>
<li><p>拦截器注册到容器中（实现<code>WebMvcConfigurer</code>的<code>addInterceptors()</code>）</p></li>
<li><p>指定拦截规则（<span
style="color:red;">注意</span>，如果是拦截所有，静态资源也会被拦截】</p></li>
</ol>
<p>编写一个实现<code>HandlerInterceptor</code>接口的拦截器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 目标方法执行之前</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">requestURI</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        log.info(<span class="string">&quot;preHandle拦截的请求路径是&#123;&#125;&quot;</span>,requestURI);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//登录检查逻辑</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">loginUser</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;loginUser&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(loginUser != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//放行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拦截住。未登录。跳转到登录页</span></span><br><span class="line">        request.setAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;请先登录&quot;</span>);</span><br><span class="line"><span class="comment">//        re.sendRedirect(&quot;/&quot;);</span></span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;/&quot;</span>).forward(request,response);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 目标方法执行完成以后</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(<span class="string">&quot;postHandle执行&#123;&#125;&quot;</span>,modelAndView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 页面渲染以后</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(<span class="string">&quot;afterCompletion执行异常&#123;&#125;&quot;</span>,ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拦截器注册到容器中 &amp;&amp; 指定拦截规则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminWebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())<span class="comment">//拦截器注册到容器中</span></span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>)  <span class="comment">//所有请求都被拦截包括静态资源</span></span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/css/**&quot;</span>,<span class="string">&quot;/fonts/**&quot;</span>,<span class="string">&quot;/images/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/js/**&quot;</span>,<span class="string">&quot;/aa/**&quot;</span>); <span class="comment">//放行的请求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="六文件上传功能">六、文件上传功能：</h3>
<ul>
<li>控制层代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FormTestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(<span class="meta">@RequestParam(&quot;email&quot;)</span> String email,</span></span><br><span class="line"><span class="params">                         <span class="meta">@RequestParam(&quot;username&quot;)</span> String username,</span></span><br><span class="line"><span class="params">                         <span class="meta">@RequestPart(&quot;headerImg&quot;)</span> MultipartFile headerImg,</span></span><br><span class="line"><span class="params">                         <span class="meta">@RequestPart(&quot;photos&quot;)</span> MultipartFile[] photos)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;上传的信息：email=&#123;&#125;，username=&#123;&#125;，headerImg=&#123;&#125;，photos=&#123;&#125;&quot;</span>,</span><br><span class="line">                 email,username,headerImg.getSize(),photos.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!headerImg.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//保存到文件服务器，OSS服务器</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> headerImg.getOriginalFilename();</span><br><span class="line">            headerImg.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;H:\\cache\\&quot;</span>+originalFilename));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(photos.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (MultipartFile photo : photos) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!photo.isEmpty())&#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> photo.getOriginalFilename();</span><br><span class="line">                    photo.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;H:\\cache\\&quot;</span>+originalFilename));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;main&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文件上传相关的配置类：</p>
<ul>
<li><code>org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration</code></li>
<li><code>org.springframework.boot.autoconfigure.web.servlet.MultipartProperties</code></li>
</ul>
<p>文件大小相关配置项：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.servlet.multipart.max-file-size</span>=<span class="string">10MB</span></span><br><span class="line"><span class="attr">spring.servlet.multipart.max-request-size</span>=<span class="string">100MB</span></span><br></pre></td></tr></table></figure>
<h3 id="七错误处理">七、错误处理：</h3>
<p><a
href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#boot-features-error-handling">Spring
Boot官方文档 - Error Handling</a></p>
<p><strong>默认规则</strong>：</p>
<ul>
<li><p>默认情况下，Spring
Boot提供<code>/error</code>处理所有错误的映射</p></li>
<li><p>如果是机器客户端，它将生成JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。对于浏览器客户端，响应一个“
whitelabel”错误视图，以HTML格式呈现相同的数据</p></li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2020-11-22T05:53:28.416+00:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">404</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Not Found&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;No message available&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/asadada&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>要对其进行自定义，添加<code>View</code>解析为<code>error</code></p></li>
<li><p>要完全替换默认行为，可以实现
<code>ErrorController</code>并注册该类型的Bean定义，或添加<code>ErrorAttributes类型的组件</code>以使用现有机制但替换其内容。</p></li>
<li><p><code>/templates/error/</code>下的4xx，5xx页面会被自动解析</p></li>
</ul>
]]></content>
      <categories>
        <category>⑨ 工程类笔记</category>
        <category>SpringBoot2</category>
      </categories>
      <tags>
        <tag>SpringBoot2</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot2【核心功能】——Chap4 配置文件YAML</title>
    <url>/2022/12/05/8c3575776f2f/</url>
    <content><![CDATA[<h3 id="一yaml配置文件">一、YAML配置文件：</h3>
<p>​
SpringBoot在支持application.properties配置文件的同时，还支持一种配置文件格式叫做yaml。<strong>非常适合用来做以数据为中心的配置文件</strong>。</p>
<h4 id="基本语法">1、基本语法</h4>
<ul>
<li>key: value；kv之间有空格</li>
<li>大小写敏感</li>
<li>使用缩进表示层级关系</li>
<li>缩进不允许使用tab，只允许空格</li>
<li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li>
<li>'#'表示注释</li>
<li>字符串无需加引号，如果要加，单引号''、双引号""表示字符串内容会被
转义、不转义</li>
</ul>
<h4 id="数据类型">2、数据类型：</h4>
<ul>
<li>字面量：单个的、不可再分的值。date、boolean、string、number、null</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">k:</span> <span class="string">v</span></span><br></pre></td></tr></table></figure>
<ul>
<li>对象：键值对的集合。map、hash、set、object</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#行内写法：  </span></span><br><span class="line"></span><br><span class="line"><span class="attr">k:</span> &#123;<span class="string">k1:v1</span>,<span class="string">k2:v2</span>,<span class="string">k3:v3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#或</span></span><br><span class="line"></span><br><span class="line"><span class="attr">k:</span> </span><br><span class="line">  <span class="attr">k1:</span> <span class="string">v1</span></span><br><span class="line">  <span class="attr">k2:</span> <span class="string">v2</span></span><br><span class="line">  <span class="attr">k3:</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>数组：一组按次序排列的值。array、list、queue</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#行内写法：  </span></span><br><span class="line"></span><br><span class="line"><span class="attr">k:</span> [<span class="string">v1</span>,<span class="string">v2</span>,<span class="string">v3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"></span><br><span class="line"><span class="attr">k:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">v1</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">v2</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure>
<h4 id="实例">3、实例：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Pet pet;</span><br><span class="line">    <span class="keyword">private</span> String[] interests;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; animal;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; score;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Double&gt; salarys;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, List&lt;Pet&gt;&gt; allPets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用yaml表示以上对象，创建application.yaml文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">userName:</span> <span class="string">zhangsan</span></span><br><span class="line">  <span class="attr">boss:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">birth:</span> <span class="number">2019</span><span class="string">/12/12</span> <span class="number">20</span><span class="string">:12:33</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">  <span class="attr">pet:</span> </span><br><span class="line">    <span class="attr">name:</span> <span class="string">tomcat</span></span><br><span class="line">    <span class="attr">weight:</span> <span class="number">23.4</span></span><br><span class="line">  <span class="attr">interests:</span> [<span class="string">篮球</span>,<span class="string">游泳</span>]</span><br><span class="line">  <span class="attr">animal:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">jerry</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mario</span></span><br><span class="line">  <span class="attr">score:</span></span><br><span class="line">    <span class="attr">english:</span> </span><br><span class="line">      <span class="attr">first:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">second:</span> <span class="number">40</span></span><br><span class="line">      <span class="attr">third:</span> <span class="number">50</span></span><br><span class="line">    <span class="attr">math:</span> [<span class="number">131</span>,<span class="number">140</span>,<span class="number">148</span>]</span><br><span class="line">    <span class="attr">chinese:</span> &#123;<span class="attr">first:</span> <span class="number">128</span>,<span class="attr">second:</span> <span class="number">136</span>&#125;</span><br><span class="line">  <span class="attr">salarys:</span> [<span class="number">3999</span>,<span class="number">4999.98</span>,<span class="number">5999.99</span>]</span><br><span class="line">  <span class="attr">allPets:</span></span><br><span class="line">    <span class="attr">sick:</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">tom</span>&#125;</span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">jerry</span>,<span class="attr">weight:</span> <span class="number">47</span>&#125;</span><br><span class="line">    <span class="attr">health:</span> [&#123;<span class="attr">name:</span> <span class="string">mario</span>,<span class="attr">weight:</span> <span class="number">47</span>&#125;]</span><br></pre></td></tr></table></figure>
<p>此时，这样子书写是没有提示的，即自定义的类和配置文件绑定一般没有提示。若要提示，添加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 下面插件作用是工程打包时，不将spring-boot-configuration-processor打进包内，让其只在编码的时候有用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>⑨ 工程类笔记</category>
        <category>SpringBoot2</category>
      </categories>
      <tags>
        <tag>SpringBoot2</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot2【基础入门】——Chap3 最佳实践</title>
    <url>/2022/12/04/4e9e8b501870/</url>
    <content><![CDATA[<h3 id="一如何编写">一、如何编写？</h3>
<ul>
<li>Step1：引入场景依赖，看看有哪些场景依赖然后选取（比如web）
<ul>
<li>https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter</li>
</ul></li>
<li>Step2：查看自动配置了哪些（不关心源码可以不管）
<ul>
<li>在配置文件中，书写debug=true，启动的时候会出现所有的配置成功的一些组件，Negative为不生效的配置，Positive为生效的配置</li>
</ul></li>
<li>Step3：是否需要修改配置项：
<ul>
<li>参照文档来修改配置项
<ul>
<li>https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#common-application-properties</li>
</ul></li>
<li>自定义加入或者替换组件
<ul>
<li><span class="citation" data-cites="Bean">@Bean</span>、<span
class="citation" data-cites="Component等等">@Component等等</span></li>
</ul></li>
</ul></li>
</ul>
<h3 id="二lombok简化开发">二、LomBok简化开发：</h3>
<p>Lombok用标签方式代替构造器、getter/setter、toString()等鸡肋代码。</p>
<p>其可以简化JavaBean的开发，简化getter/setter函数以及toString()函数。</p>
<p>spring boot已经管理Lombok。引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>IDEA中File-&gt;Settings-&gt;Plugins，搜索安装Lombok插件。随后如下使用：</p>
<p>​ 可以使用@Data在编译的时候产生getter，setter，<span class="citation"
data-cites="ToString编译的时候产生ToString函数">@ToString编译的时候产生ToString函数</span>，<span
class="citation"
data-cites="NoArgsConstructor">@NoArgsConstructor</span>，<span
class="citation"
data-cites="AllArgsConstructor在编译的时候产生有参无参构造">@AllArgsConstructor在编译的时候产生有参无参构造</span>，<span
class="citation"
data-cites="EqualsAndHashCode在编译时产生Hash函数">@EqualsAndHashCode在编译时产生Hash函数</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="comment">//@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Pet pet;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name,Integer age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>还可以用@Slf4j 简化日志开发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handle01</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;请求进来了....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, Spring Boot 2!&quot;</span>+<span class="string">&quot;你好：&quot;</span>+name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三devtools">三、DevTools：</h3>
<p>添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在IDEA中，项目或者页面修改以后：Ctrl+F9，就可以进行热更新。</p>
<h3 id="四springinitializer">四、SpringInitializer：</h3>
<ul>
<li>快速创建SpringBoot应用</li>
<li>在IDEA中，菜单栏New -&gt; Project -&gt; Spring Initailizr。</li>
</ul>
]]></content>
      <categories>
        <category>⑨ 工程类笔记</category>
        <category>SpringBoot2</category>
      </categories>
      <tags>
        <tag>SpringBoot2</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot2【基础入门】——Chap2 底层注解</title>
    <url>/2022/12/04/b79928678bf4/</url>
    <content><![CDATA[<h3 id="一configuration-配置类">一、<span class="citation"
data-cites="Configuration">@Configuration</span> 配置类：</h3>
<ul>
<li>基本使用：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、配置类里面使用<span class="doctag">@Bean</span>标注在方法上给容器注册组件，默认也是单实例的</span></span><br><span class="line"><span class="comment"> * 2、配置类本身也是组件</span></span><br><span class="line"><span class="comment"> * 3、proxyBeanMethods：代理bean的方法</span></span><br><span class="line"><span class="comment"> *      Full(proxyBeanMethods = true)（保证每个<span class="doctag">@Bean</span>方法被调用多少次返回的组件都是单实例的）（默认）</span></span><br><span class="line"><span class="comment"> *      Lite(proxyBeanMethods = false)（每个<span class="doctag">@Bean</span>方法被调用多少次返回的组件都是新创建的）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span> <span class="comment">//告诉SpringBoot这是一个配置类 == 配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">zhangsan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="comment">//user组件依赖了Pet组件（Full(proxyBeanMethods = true)模式）</span></span><br><span class="line">        zhangsan.setPet(tomcatPet());</span><br><span class="line">        <span class="comment">//如果Lite(proxyBeanMethods = false)那么实际上user组件并没有依赖下方的pet组件</span></span><br><span class="line">        <span class="keyword">return</span> zhangsan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;tom&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Pet <span class="title function_">tomcatPet</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pet</span>(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.atguigu.boot&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//1、返回我们IOC容器</span></span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">run</span> <span class="operator">=</span> SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、查看容器里面的组件</span></span><br><span class="line">        String[] names = run.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、从容器中获取组件</span></span><br><span class="line">        <span class="type">Pet</span> <span class="variable">tom01</span> <span class="operator">=</span> run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line">        <span class="type">Pet</span> <span class="variable">tom02</span> <span class="operator">=</span> run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;组件：&quot;</span>+(tom01 == tom02));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、@Configuration(proxyBeanMethods = true)本身调用拿到的就是代理对象，如果@Configuration(proxyBeanMethods = false)本身拿到的并不是代理对象com.atguigu.boot.config.MyConfig$$EnhancerBySpringCGLIB$$51f1e1ca@1654a892</span></span><br><span class="line">        <span class="type">MyConfig</span> <span class="variable">bean</span> <span class="operator">=</span> run.getBean(MyConfig.class);</span><br><span class="line">        System.out.println(bean);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果@Configuration(proxyBeanMethods = true)代理对象调用方法。SpringBoot总会检查这个组件是否在容器中有，就会保持组件单实例</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> bean.user01();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> bean.user01();</span><br><span class="line">        System.out.println(user == user1);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user01</span> <span class="operator">=</span> run.getBean(<span class="string">&quot;user01&quot;</span>, User.class);</span><br><span class="line">        <span class="type">Pet</span> <span class="variable">tom</span> <span class="operator">=</span> run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;用户的宠物：&quot;</span>+(user01.getPet() == tom));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>最佳实践：
<ul>
<li>配置
类组件之间<strong>无依赖关系</strong>用Lite模式加速容器启动过程，减少判断</li>
<li>配置
类组件之间<strong>有依赖关系</strong>，方法会被调用得到之前单实例组件，用Full模式（默认）</li>
</ul></li>
<li><code>Alt + Ins</code>:生成getter，setter、构造器等代码。</li>
<li><code>Ctrl + Alt + B</code>:查看类的具体实现代码。</li>
</ul>
<h3 id="二import导入组件">二、<span class="citation"
data-cites="Import导入组件">@Import导入组件</span>：</h3>
<ul>
<li><span class="citation" data-cites="Bean">@Bean</span>、<span
class="citation" data-cites="Component">@Component</span>、<span
class="citation" data-cites="Controller">@Controller</span>、<span
class="citation" data-cites="Service">@Service</span>、<span
class="citation"
data-cites="Repository">@Repository</span>，它们是Spring的基本标签，在Spring
Boot中并未改变它们原来的功能。</li>
<li><span class="citation"
data-cites="Import">@Import</span>({User.class, DBHelper.class})</li>
<li>其会给容器中<strong>自动创建出这两个类型的组件</strong>、默认组件的名字就是全类名,其需要在容器中的组件类上进行标注</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;User.class, DBHelper.class&#125;)</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span> <span class="comment">//告诉SpringBoot这是一个配置类 == 配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如何测试：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1、返回我们IOC容器</span></span><br><span class="line"><span class="type">ConfigurableApplicationContext</span> <span class="variable">run</span> <span class="operator">=</span> SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5、获取组件</span></span><br><span class="line">String[] beanNamesForType = run.getBeanNamesForType(User.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String s : beanNamesForType) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">DBHelper</span> <span class="variable">bean1</span> <span class="operator">=</span> run.getBean(DBHelper.class);</span><br><span class="line">System.out.println(bean1);</span><br></pre></td></tr></table></figure>
<h3 id="三conditional条件装配">三、<span class="citation"
data-cites="Conditional条件装配">@Conditional条件装配</span></h3>
<ul>
<li>满足Conditional指定的条件，则进行组件注入</li>
<li>其有非常多的子注解，以@ConditionalOnMissingBean举例说明</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &quot;tom&quot;)</span><span class="comment">//没有tom名字的Bean时，MyConfig类的Bean才能生效。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">zhangsan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        zhangsan.setPet(tomcatPet());</span><br><span class="line">        <span class="keyword">return</span> zhangsan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;tom22&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Pet <span class="title function_">tomcatPet</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pet</span>(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//1、返回我们IOC容器</span></span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">run</span> <span class="operator">=</span> SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、查看容器里面的组件</span></span><br><span class="line">    String[] names = run.getBeanDefinitionNames();</span><br><span class="line">    <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">tom</span> <span class="operator">=</span> run.containsBean(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;容器中Tom组件：&quot;</span>+tom);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">user01</span> <span class="operator">=</span> run.containsBean(<span class="string">&quot;user01&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;容器中user01组件：&quot;</span>+user01);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">tom22</span> <span class="operator">=</span> run.containsBean(<span class="string">&quot;tom22&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;容器中tom22组件：&quot;</span>+tom22);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四底层注解-importresource导入spring配置文件">四、底层注解-<span
class="citation"
data-cites="ImportResource导入Spring配置文件">@ImportResource导入Spring配置文件</span></h3>
<p>比如，公司使用bean.xml文件生成配置bean，然而你为了省事，想继续复用bean.xml，<span
class="citation"
data-cites="ImportResource粉墨登场">@ImportResource粉墨登场</span>。</p>
<p>bean.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&quot;&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;haha&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lun.boot.bean.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;zhangsan&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hehe&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lun.boot.bean.Pet&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tomcat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ImportResource(&quot;classpath:beans.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//1、返回我们IOC容器</span></span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">run</span> <span class="operator">=</span> SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">haha</span> <span class="operator">=</span> run.containsBean(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">hehe</span> <span class="operator">=</span> run.containsBean(<span class="string">&quot;hehe&quot;</span>);</span><br><span class="line">	System.out.println(<span class="string">&quot;haha：&quot;</span>+haha);<span class="comment">//true</span></span><br><span class="line">	System.out.println(<span class="string">&quot;hehe：&quot;</span>+hehe);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五configurationproperties配置绑定">五、<span class="citation"
data-cites="ConfigurationProperties配置绑定">@ConfigurationProperties配置绑定</span></h3>
<ul>
<li><p>读取properties文件中的内容，并且把它封装到JavaBean中，以供随时使用</p></li>
<li><p>Spring Boot一种配置配置绑定：<span class="citation"
data-cites="ConfigurationProperties">@ConfigurationProperties</span> +
<span class="citation" data-cites="Component">@Component</span></p></li>
<li><p>假设有配置文件application.properties</p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mycar.brand=BYD</span><br><span class="line">mycar.price=100000</span><br></pre></td></tr></table></figure>
<ul>
<li>只有在容器中的组件，才会拥有SpringBoot提供的强大功能</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mycar&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>⑨ 工程类笔记</category>
        <category>SpringBoot2</category>
      </categories>
      <tags>
        <tag>SpringBoot2</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot2【基础入门】——Chap1 基础入门</title>
    <url>/2022/12/04/fb4e64940906/</url>
    <content><![CDATA[<h3 id="一spring生态圈">一、Spring生态圈：</h3>
<ul>
<li><p>Spring的生态覆盖了:web开发、数据访问、安全控制、分布式、消息服务等等</p></li>
<li><p>为什么要使用SpringBoot2呢？（SpringBoot2的底层实际上是Spring
FrameWork）能够快速创建出生产级别的Spring应用（快速整合）</p>
<ul>
<li><p>Create stand-alone Spring applications</p>
<ul>
<li>创建独立Spring应用</li>
</ul></li>
<li><p>Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR
files)</p>
<ul>
<li>内嵌web服务器</li>
</ul></li>
<li><p>Provide opinionated 'starter' dependencies to simplify your build
configuration</p>
<ul>
<li>自动starter依赖，简化构建配置</li>
</ul></li>
<li><p>Automatically configure Spring and 3rd party libraries whenever
possible</p>
<ul>
<li>自动配置Spring以及第三方功能</li>
</ul></li>
<li><p>Provide production-ready features such as metrics, health checks,
and externalized configuration</p>
<ul>
<li>提供生产级别的监控、健康检查及外部化配置</li>
</ul></li>
<li><p>Absolutely no code generation and no requirement for XML
configuration</p>
<ul>
<li>无代码生成、无需编写XML</li>
</ul></li>
<li><p>SpringBoot是整合Spring技术栈的一站式框架</p></li>
<li><p>SpringBoot是简化Spring技术栈的快速开发脚手架</p></li>
</ul></li>
</ul>
<h3
id="二时代背景微服务分布式云原生">二、时代背景：微服务+分布式+云原生：</h3>
<ul>
<li>微服务是一种架构风格，一个应用拆分为一组小型服务，每个服务运行在自己的进程内，也就是可独立部署和升级。服务之间使用轻量级HTTP交互，服务围绕业务功能拆分，可以由全自动部署机制独立部署，去中心化，服务自治。服务可以使用不同的语言、不同的存储技术。</li>
<li>分布式的解决方案：SpringBoot+SpringCloud（主要是需要远程调用、服务发现、负载均衡、服务容错、配置管理等）</li>
<li>云原生解决方案：CloudNative（主要是需要服务自愈、弹性伸缩、服务隔离、自动化部署、灰度发布等等）</li>
</ul>
<h3 id="三helloworld">三、HelloWorld</h3>
<ul>
<li><p>建立一个Maven工程，编写pom.xml,引入SpringBoot2:</p></li>
<li><p>``` <parent> <groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-parent</artifactId>
<version>2.3.4.RELEASE</version> </parent></p>
<p><dependencies> <dependency>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-web</artifactId> </dependency>
</dependencies> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- SpringBoot将所有的配置约定好统一在application.properties文件中</span><br><span class="line"></span><br><span class="line">- 同时我们可以在pom.xml添加如下内容把SpringBoot2直接打包成Jar包，可以直接运行部署，将jar包直接在目标服务器执行即可。</span><br><span class="line"></span><br><span class="line">  ```xml</span><br><span class="line">  &lt;build&gt;</span><br><span class="line">  	&lt;plugins&gt;</span><br><span class="line">  		&lt;plugin&gt;</span><br><span class="line">  			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  			&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">  		&lt;/plugin&gt;</span><br><span class="line">  	&lt;/plugins&gt;</span><br><span class="line">  &lt;/build&gt;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3 id="四springboot的依赖管理特性">四、SpringBoot的依赖管理特性：</h3>
<p>​ 其是通过父项目进行统一的版本依赖管理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">其通过以下父工程依赖管理</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.3.4.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">而上面项目还有个父项目如下：</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.3.4.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">它几乎声明了所有开发中常用的依赖的版本号，自动版本仲裁机制</span><br></pre></td></tr></table></figure>
<ul>
<li><p>所以只要引入其内部的依赖，都可以不写版本号</p></li>
<li><p>可以修改默认版本号</p>
<ol type="1">
<li>查看spring-boot-dependencies里面规定当前依赖的版本 用的 key。</li>
<li>在当前项目里面重写配置文件，如下面的代码，就可以将其内部的版本修改掉</li>
</ol></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.43<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>开发导入的starter场景启动器
<ul>
<li>spring-boot-starter-* ： *就某种场景</li>
<li>只要引入starter，这个场景的所有常规需要的依赖我们都自动引入</li>
</ul></li>
</ul>
<ol type="1">
<li><a
href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter">更多SpringBoot所有支持的场景</a></li>
<li>见到的 *-spring-boot-starter：
第三方为我们提供的简化开发的场景启动器。</li>
</ol>
<p>IDEA快捷键：</p>
<ul>
<li><code>ctrl + shift + alt + U</code>：以图的方式显示项目中依赖之间的关系。</li>
<li><code>alt + ins</code>：相当于Eclipse的 Ctrl +
N，创建新类，新包等。</li>
</ul>
<h3 id="五springboot的自动配置特性">五、SpringBoot的自动配置特性：</h3>
<ul>
<li><p>其会自动帮我们配好Tomcat</p>
<ul>
<li>引入依赖、配置Tomcat</li>
</ul></li>
<li><p>其会自动帮我们配好SpringMVC</p>
<ul>
<li><p>引入SpringMVC全套组件，自动配好SpringMVC常用组件（功能）</p></li>
<li><p>帮我们配置好了所有web开发的常见场景，比如字符编码、文件上传等等</p></li>
</ul></li>
<li><p>可以通过下面内容来查看SpringBoot帮我们加载了多少组件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//1、返回我们IOC容器</span></span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">run</span> <span class="operator">=</span> SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、查看容器里面的组件</span></span><br><span class="line">    String[] names = run.getBeanDefinitionNames();</span><br><span class="line">    <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>默认的包结构</p>
<ul>
<li><p>主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来（约定，也不需要再进行xml的配置了）</p></li>
<li><p>如想要改变扫描路径</p>
<ul>
<li><span class="citation"
data-cites="SpringBootApplication">@SpringBootApplication</span>(scanBasePackages="com.lun")</li>
</ul></li>
</ul></li>
<li><p>各种配置拥有默认值（你也可以在application.properties里书写）</p>
<ul>
<li>默认配置最终都是映射到某个类上，如：<code>MultipartProperties</code></li>
<li>配置文件的值最终会绑定每个类上，这个类会在容器中创建对象</li>
</ul></li>
<li><p>按需加载所有自动配置项</p>
<ul>
<li><p>SpringBoot有非常多的starter，但是只有引入了哪些场景这个场景的自动配置才会开启</p></li>
<li><p>SpringBoot所有的自动配置功能都在
有一个叫做spring-boot-autoconfigure的包里面</p></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>⑨ 工程类笔记</category>
        <category>SpringBoot2</category>
      </categories>
      <tags>
        <tag>SpringBoot2</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis Chap4——MyBatis逆向工程和分页插件</title>
    <url>/2022/11/30/bd661c23b30a/</url>
    <content><![CDATA[<h3 id="一逆向工程">一、逆向工程</h3>
<h4
id="什么是正向工程什么是逆向工程">1、什么是正向工程？什么是逆向工程？</h4>
<ul>
<li>正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate是支持正向工程
的。</li>
<li>逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源：
<ul>
<li>Java实体类</li>
<li>Mapper接口</li>
<li>Mapper映射文件</li>
</ul></li>
</ul>
<h4 id="创建逆向工程步骤">2、创建逆向工程步骤：</h4>
<ul>
<li>添加maven依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 控制Maven在构建过程中相关配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 构建过程中用到的插件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 插件的依赖 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 逆向工程的核心依赖 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建逆向工程的配置文件：generatorConfig.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">generatorConfiguration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    targetRuntime: 执行生成的逆向工程的版本</span></span><br><span class="line"><span class="comment">    MyBatis3Simple: 生成基本的CRUD（清新简洁版）</span></span><br><span class="line"><span class="comment">    MyBatis3: 生成带条件的CRUD（奢华尊享版）</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;DB2Tables&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3Simple&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库的连接信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://rm-bp1h2yb6a1g2p9yb4go.mysql.rds.aliyuncs.com:3306/hardware_gateway_develop&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">userId</span>=<span class="string">&quot;jadefoci&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">password</span>=<span class="string">&quot;Jadefoci12345&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- javaBean的生成策略(实体类) enableSubPackages 是否子包  trimStrings 是否把字段名前后空格自动去掉--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.fantast.mybatis.bean&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\java&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- SQL映射文件的生成策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.fantast.mybatis.mapper&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\resources&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- Mapper接口的生成策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">targetPackage</span>=<span class="string">&quot;com.fantast.mybatis.mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\java&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 逆向分析的表 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;hardware&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Hardware&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;hardware_user&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;HardwareUser&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;print_record&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;PrintRecord&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;user&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;User&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;callback_record&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;CallbackRecord&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>执行MBG插件的generate目标</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221130163847072.png" /></p>
<ul>
<li>根据条件查询QBC(Query By Criteria)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMBG</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">    <span class="title class_">SqlSessionFactoryBuilder</span>().build(is).openSession(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line">    </span><br><span class="line">    <span class="type">EmpExample</span> <span class="variable">empExample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmpExample</span>();</span><br><span class="line">    <span class="comment">//创建条件对象，通过andXXX方法为SQL添加查询添加，每个条件之间是and关系</span></span><br><span class="line">    empExample.createCriteria().andEnameLike(<span class="string">&quot;a&quot;</span>).andAgeGreaterThan(<span class="number">20</span>).andDidIsNotNull();</span><br><span class="line">    <span class="comment">//将之前添加的条件通过or拼接其他条件</span></span><br><span class="line">    empExample.or().andSexEqualTo(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    List&lt;Emp&gt; list = mapper.selectByExample(empExample);</span><br><span class="line">    <span class="keyword">for</span> (Emp emp : list) &#123;</span><br><span class="line">    System.out.println(emp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分页插件">二、分页插件：</h3>
<ul>
<li>添加依赖：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">&lt;/dependency</span><br></pre></td></tr></table></figure>
<ul>
<li>配置分页插件：在mybatis核心配置中配置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;!--设置分页插件--&gt;</span><br><span class="line">	&lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;&lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用：</p></li>
<li><p>在查询功能之前使用PageHelper.startPage(int pageNum, int
pageSize)开启分页功能</p>
<ul>
<li>pageNum：当前页的页码</li>
<li>pageSize：每页显示的条数</li>
</ul></li>
<li><p>在查询获取list集合之后，使用PageInfo<T> pageInfo = new
PageInfo&lt;&gt;(List<T> list, int navigatePages)获取分页相关数据</p>
<ul>
<li>list：分页之后的数据</li>
<li>navigatePages：导航分页的页码数</li>
</ul></li>
<li><p>分页相关数据</p>
<ul>
<li>PageInfo{ pageNum=8, pageSize=4, size=2, startRow=29, endRow=30,
total=30, pages=8, list=Page{count=true, pageNum=8, pageSize=4,
startRow=28, endRow=32, total=30, pages=8, reasonable=false,
pageSizeZero=false}, prePage=7, nextPage=0, isFirstPage=false,
isLastPage=true, hasPreviousPage=true, hasNextPage=false,
navigatePages=5, navigateFirstPage4, navigateLastPage8,
navigatepageNums=[4, 5, 6, 7, 8] }</li>
</ul></li>
<li><p>常用数据：</p>
<ul>
<li>pageNum：当前页的页码</li>
<li>pageSize：每页显示的条数</li>
<li>size：当前页显示的真实条数</li>
<li>total：总记录数</li>
<li>pages：总页数</li>
<li>prePage：上一页的页码</li>
<li>nextPage：下一页的页码</li>
<li>isFirstPage/isLastPage：是否为第一页/最后一页</li>
<li>hasPreviousPage/hasNextPage：是否存在上一页/下一页</li>
<li>navigatePages：导航分页的页码数</li>
<li>navigatepageNums：导航分页的页码，[1,2,3,4,5]</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>⑨ 工程类笔记</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis Chap3——动态SQL、缓存机制</title>
    <url>/2022/11/30/0f32141cfe00/</url>
    <content><![CDATA[<h3 id="一动态sql">一、动态SQL</h3>
<h4 id="if-where">1、if &amp; where</h4>
<p>where和if一般结合使用：</p>
<ul>
<li>若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字</li>
<li>若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的
and去掉注意：where标签不能去掉条件最后多余的and</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpListByMoreTJ2&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">	select * from t_emp</span><br><span class="line">	<span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ename != &#x27;&#x27; and ename != null&quot;</span>&gt;</span></span><br><span class="line">        	ename = #&#123;ename&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != &#x27;&#x27; and age != null&quot;</span>&gt;</span></span><br><span class="line">        	and age = #&#123;age&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != &#x27;&#x27; and sex != null&quot;</span>&gt;</span></span><br><span class="line">        	and sex = #&#123;sex&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="trim">2、trim:</h4>
<p>trim用于去掉或添加标签中的内容 常用属性：</p>
<ul>
<li>prefix：在trim标签中的内容的前面添加某些内容</li>
<li>prefixOverrides：在trim标签中的内容的前面去掉某些内容</li>
<li>suffix：在trim标签中的内容的后面添加某些内容</li>
<li>suffixOverrides：在trim标签中的内容的后面去掉某些内容</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpListByMoreTJ&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    select * from t_emp</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;and&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ename != &#x27;&#x27; and ename != null&quot;</span>&gt;</span></span><br><span class="line">        	ename = #&#123;ename&#125; and</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != &#x27;&#x27; and age != null&quot;</span>&gt;</span></span><br><span class="line">        	age = #&#123;age&#125; and</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != &#x27;&#x27; and sex != null&quot;</span>&gt;</span></span><br><span class="line">        	sex = #&#123;sex&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="choose-when-otherwise">3、choose when otherwise</h4>
<p>​ 相当于 if else if else</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpListByChoose(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpListByChoose&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;empColumns&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span> from t_emp</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;ename != &#x27;&#x27; and ename != null&quot;</span>&gt;</span></span><br><span class="line">            	ename = #&#123;ename&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;age != &#x27;&#x27; and age != null&quot;</span>&gt;</span></span><br><span class="line">            	age = #&#123;age&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;sex != &#x27;&#x27; and sex != null&quot;</span>&gt;</span></span><br><span class="line">            	sex = #&#123;sex&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;email != &#x27;&#x27; and email != null&quot;</span>&gt;</span></span><br><span class="line">            	email = #&#123;email&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="foreach">4、foreach</h4>
<ul>
<li>collection：设置要循环的数组或集合</li>
<li>item：表示集合或数组中的每一个数据</li>
<li>separator：设置循环体之间的分隔符</li>
<li>open：设置foreach标签中的内容的开始符</li>
<li>close：设置foreach标签中的内容的结束符</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertMoreEmp(List&lt;Emp&gt; emps);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertMoreEmp&quot;</span>&gt;</span></span><br><span class="line">	insert into t_emp values</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">    	(null,#&#123;emp.ename&#125;,#&#123;emp.age&#125;,#&#123;emp.sex&#125;,#&#123;emp.email&#125;,null)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--int deleteMoreByArray(int[] eids);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteMoreByArray&quot;</span>&gt;</span></span><br><span class="line">    delete from t_emp where</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;eids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;or&quot;</span>&gt;</span></span><br><span class="line">        eid = #&#123;eid&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--int deleteMoreByArray(int[] eids);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteMoreByArray&quot;</span>&gt;</span></span><br><span class="line">    delete from t_emp where eid in</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;eids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;eid&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="二mybatis缓存机制">二、MyBatis缓存机制：</h3>
<h4 id="一级缓存">1、一级缓存：</h4>
<ul>
<li>SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就
会从缓存中直接获取，不会从数据库重新访问</li>
</ul>
<p>使一级缓存失效的四种情况： 1) 不同的SqlSession对应不同的一级缓存 2)
同一个SqlSession但是查询条件不同 3)
同一个SqlSession两次查询期间执行了任何一次增删改操作 4)
同一个SqlSession两次查询期间手动清空了缓存</p>
<h4 id="二级缓存">2、二级缓存：</h4>
<p>​
二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被
缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取</p>
<p>如何开启？</p>
<ul>
<li>在核心配置文件中，设置全局配置属性cacheEnabled="true"，默认为true，不需要设置</li>
<li>在映射文件中设置标签<cache /></li>
<li>二级缓存必须在SqlSession关闭或提交之后有效</li>
<li>查询的数据所转换的<strong>实体类类型必须实现序列化的接口</strong></li>
</ul>
<p>使二级缓存失效的情况：</p>
<ul>
<li>两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效</li>
</ul>
<h4 id="二级缓存的配置">3、二级缓存的配置：</h4>
<p>在mapper配置文件中添加的cache标签可以设置一些属性：</p>
<ul>
<li>eviction属性：缓存回收策略，默认的是 LRU。
<ul>
<li>LRU（Least Recently Used） –
最近最少使用的：移除最长时间不被使用的对象。</li>
<li>FIFO（First in First out） –
先进先出：按对象进入缓存的顺序来移除它们。</li>
<li>SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。</li>
<li>WEAK –
弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。</li>
</ul></li>
<li>flushInterval属性：刷新间隔，单位毫秒
<ul>
<li>默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新</li>
</ul></li>
<li>size属性：引用数目，正整数
<ul>
<li>代表缓存最多可以存储多少个对象，太大容易导致内存溢出</li>
</ul></li>
<li>readOnly属性：只读，true/false
<ul>
<li>true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。</li>
<li>false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false。</li>
</ul></li>
</ul>
<h4 id="缓存查询顺序">4、缓存查询顺序</h4>
<ul>
<li>先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用。</li>
<li>如果二级缓存没有命中，再查询一级缓存</li>
<li>如果一级缓存也没有命中，则查询数据库</li>
<li>SqlSession关闭之后，一级缓存中的数据会写入二级缓存</li>
</ul>
<h4 id="第三方缓存库ehcache">5、第三方缓存库EHCache</h4>
<ul>
<li>添加依赖：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Mybatis EHCache整合包 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- slf4j日志门面的一个具体实现 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建ehcache.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;../config/ehcache.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 磁盘保存路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;D:\atguigu\ehcache&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">        <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">maxElementsOnDisk</span>=<span class="string">&quot;10000000&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">overflowToDisk</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>设置二级缓存类型：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>存在SLF4J时，作为简易日志的log4j将失效，此时我们需要借助SLF4J的具体实现logback来打印日志。</p></li>
<li><p>创建logback的配置文件logback.xml</p></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定日志输出的位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span></span></span><br><span class="line"><span class="tag">    	<span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 日志输出的格式 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 -</span></span><br><span class="line"><span class="comment">    -&gt;</span></span><br><span class="line"><span class="comment">    &lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;] [%-5level] [%thread] [%logger]</span></span><br><span class="line"><span class="comment">    [%msg]%n&lt;/pattern&gt;</span></span><br><span class="line"><span class="comment">    &lt;/encoder&gt;</span></span><br><span class="line"><span class="comment">    &lt;/appender&gt;</span></span><br><span class="line"><span class="comment">    &lt;!-- 设置全局日志级别。日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 根据特殊需求指定局部日志级别 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.atguigu.crowd.mapper&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>EHCache配置文件说明：</li>
</ul>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 8%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="header">
<th>属性名</th>
<th>是否必须</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>maxElementsInMemory</td>
<td>是</td>
<td>在内存中缓存的element的最大数目</td>
</tr>
<tr class="even">
<td>maxElementsOnDisk</td>
<td>是</td>
<td>在磁盘上缓存的element的最大数目，若是0表示无<br/>穷大</td>
</tr>
<tr class="odd">
<td>eternal</td>
<td>是</td>
<td>设定缓存的elements是否永远不过期。
如果为<br/>true，则缓存的数据始终有效，
如果为false那么还<br/>要根据timeToIdleSeconds、timeToLiveSeconds<br/>判断</td>
</tr>
<tr class="even">
<td>overflowToDisk</td>
<td>是</td>
<td>设定当内存缓存溢出的时候是否将过期的element<br/>缓存到磁盘上</td>
</tr>
<tr class="odd">
<td>timeToIdleSeconds</td>
<td>否</td>
<td>当缓存在EhCache中的数据前后两次访问的时间超<br/>过timeToIdleSeconds的属性取值时，
这些数据便<br/>会删除，默认值是0,也就是可闲置时间无穷大</td>
</tr>
<tr class="even">
<td>timeToLiveSeconds</td>
<td>否</td>
<td>缓存element的有效生命期，默认是0.,也就是<br/>element存活时间无穷大</td>
</tr>
<tr class="odd">
<td>diskSpoolBufferSizeMB</td>
<td>否</td>
<td>DiskStore(磁盘缓存)的缓存区大小。默认是<br/>30MB。每个Cache都应该有自己的一个缓冲区</td>
</tr>
<tr class="even">
<td>diskPersistent</td>
<td>否</td>
<td>在VM重启的时候是否启用磁盘保存EhCache中的数<br/>据，默认是false。</td>
</tr>
<tr class="odd">
<td>diskExpiryThreadIntervalSeconds</td>
<td>否</td>
<td>磁盘缓存的清理线程运行间隔，默认是120秒。每<br/>个120s，
相应的线程会进行一次EhCache中数据的<br/>清理工作</td>
</tr>
<tr class="even">
<td>memoryStoreEvictionPolicy</td>
<td>否</td>
<td>当内存缓存达到最大，有新的element加入的时<br/>候，
移除缓存中element的策略。
默认是LRU（最<br/>近最少使用），可选的有LFU（最不常使用）和<br/>FIFO（先进先出）</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>⑨ 工程类笔记</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis Chap2——特殊SQL与自定义映射</title>
    <url>/2022/11/30/2b283f7c4252/</url>
    <content><![CDATA[<h3 id="一特殊sql">一、特殊SQL</h3>
<h4 id="模糊查询">1、模糊查询：</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; testMohu(@Param(&quot;mohu&quot;) String mohu);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;testMohu&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--select * from t_user where username like &#x27;%$&#123;mohu&#125;%&#x27;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--select * from t_user where username like concat(&#x27;%&#x27;,#&#123;mohu&#125;,&#x27;%&#x27;)--&gt;</span></span><br><span class="line">select * from t_user where username like &quot;%&quot;#&#123;mohu&#125;&quot;%&quot;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="批量删除">2、批量删除</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--int deleteMore(@Param(&quot;ids&quot;) String ids);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteMore&quot;</span>&gt;</span></span><br><span class="line">	delete from t_user where id in ($&#123;ids&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="动态设置表名">3、动态设置表名：</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getAllUser(@Param(&quot;tableName&quot;) String tableName);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">	select * from $&#123;tableName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="获取新添加的记录的自增主键">4、获取新添加的记录的自增主键：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 添加用户信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">* useGeneratedKeys：设置使用自增的主键</span></span><br><span class="line"><span class="comment">* keyProperty：因为增删改有统一的返回值是受影响的行数，因此只能将获取的自增的主键放在传输的参</span></span><br><span class="line"><span class="comment">数user对象的某个属性中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertUser</span><span class="params">(User user)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertUser(User user);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">insert into t_user values(null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="二自定义映射resultmap">二、自定义映射ResultMap:</h3>
<h4 id="处理字段和属性的映射关系">1、处理字段和属性的映射关系</h4>
<p>​
若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">resultMap：设置自定义映射</span></span><br><span class="line"><span class="comment">属性：</span></span><br><span class="line"><span class="comment">id：表示自定义映射的唯一标识</span></span><br><span class="line"><span class="comment">type：查询的数据要映射的实体类的类型</span></span><br><span class="line"><span class="comment">子标签：</span></span><br><span class="line"><span class="comment">id：设置主键的映射关系</span></span><br><span class="line"><span class="comment">result：设置普通字段的映射关系</span></span><br><span class="line"><span class="comment">association：设置多对一的映射关系</span></span><br><span class="line"><span class="comment">collection：设置一对多的映射关系</span></span><br><span class="line"><span class="comment">属性：</span></span><br><span class="line"><span class="comment">property：设置映射关系中实体类中的属性名</span></span><br><span class="line"><span class="comment">column：设置映射关系中表中的字段名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--List&lt;User&gt; testMohu(@Param(&quot;mohu&quot;) String mohu);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;testMohu&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userMap&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--select * from t_user where username like &#x27;%$&#123;mohu&#125;%&#x27;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>或者如果是字段名符合数据库的规则（使用_），实体类中的属性名符合Java的规则（使用驼峰）,也可以在mybatis的核心配置文件中设置一个全局配置信息：mapUnderscoreToCamelCase，可以在查询表中数据时，自动将_类型的字段名转换为驼峰</li>
</ul>
<h4 id="多对一映射处理">2、多对一映射处理：</h4>
<ul>
<li>使用级联方式处理映射关系：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empDeptMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">property</span>=<span class="string">&quot;ename&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dept.did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dept.dname&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Emp getEmpAndDeptByEid(@Param(&quot;eid&quot;) int eid);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptByEid&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empDeptMap&quot;</span>&gt;</span></span><br><span class="line">    select emp.*,dept.* from t_emp emp left join t_dept dept on emp.did =</span><br><span class="line">    dept.did where emp.eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用association处理映射关系：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empDeptMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">property</span>=<span class="string">&quot;ename&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dname&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Emp getEmpAndDeptByEid(@Param(&quot;eid&quot;) int eid);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptByEid&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empDeptMap&quot;</span>&gt;</span></span><br><span class="line">    select emp.*,dept.* from t_emp emp left join t_dept dept on emp.did =</span><br><span class="line">    dept.did where emp.eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>分步查询</li>
</ul>
<h4 id="一对多映射处理">3、一对多映射处理：</h4>
<ul>
<li>collection</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* 根据部门id查新部门以及部门中的员工信息</span><br><span class="line">* @param did</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">Dept getDeptEmpByDid(@Param(&quot;did&quot;) int did);</span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;deptEmpMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dname&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    ofType：设置collection标签所处理的集合属性中存储数据的类型</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">column</span>=<span class="string">&quot;ename&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Dept getDeptEmpByDid(@Param(&quot;did&quot;) int did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptEmpByDid&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;deptEmpMap&quot;</span>&gt;</span></span><br><span class="line">    select dept.*,emp.* from t_dept dept left join t_emp emp on dept.did =</span><br><span class="line">    emp.did where dept.did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>分步查询
<ul>
<li>分步查询的优点：可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息：</li>
<li>lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载</li>
<li>aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。
否则，每个属性会按需加载此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。此时可通过association和collection中的fetchType属性设置当前的分步查询是否使用延迟加载，fetchType="lazy(延迟加载)|eager(立即加载)"</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>⑨ 工程类笔记</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Git Flow项目管理思维</title>
    <url>/2022/11/30/2f4fcd6e89f6/</url>
    <content><![CDATA[<p>GitFlow是一种代码开发合并管理流程的思维模式或者是管理方法。大家一起开发的一种软约定</p>
<h4 id="需求">1、需求：</h4>
<ul>
<li>有一个稳定版本的代码分支，可以安心的用在线上发布。</li>
<li>在代码提测前或者说是代码达到预发状态时，在测试交付的过程中程序员们还可以继续进行下一个版本的开发工作</li>
<li>有一个分支可以让我们及时的对线上的bug进行修复，这个过程中我们不希望将正在开发中的代码提交到线上生产中去。</li>
</ul>
<h4 id="gitflow分支角色">2、GitFlow分支角色</h4>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221130110448590.png" /></p>
<ul>
<li>Master 分支：
稳定版本代码分支，用作发布环境，上面的每次提交都是可以发布的。</li>
<li>Feature 分支：
功能分支，用于开发功能（需求），<strong>用于开发环境</strong></li>
<li>Developer 分支: 开发分支，
一旦Feature分支内功能开发完成就将Feature中的代码合并到Developer分支中，合并完成后，删除该功能分支。<strong>这个分支对应的是集成测试环境。</strong></li>
<li>Release
分支：预发分支，做发布前的准备工作，<strong>对应的是预发环境。</strong>这个分支可以确保们开发继续向前，不会因为要发布不被停滞住。<strong>一旦Release分支达到了可发布的状态，我们需要把Release分支同时向Master，Developer分支上合并，保持代码的一致性，然后把Release分支删除。</strong></li>
<li>Hotfix 分支：
<strong>线上bug修缮用的分支</strong>，每次修改线上代码的bug时都要用hotfix来维护，完成后向Developer和Master同时合并。完成后删除分支</li>
</ul>
<p>注意：实际上想要达到较高的生产效率，还是需要配置好DevOps以及一些自动化脚本</p>
<p>参考博文：https://blog.csdn.net/weixin_46674610/article/details/115396404</p>
]]></content>
      <categories>
        <category>⑦  工具使用类笔记</category>
      </categories>
      <tags>
        <tag>GitFlow</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatisPlus Chap1——简介与基本操作</title>
    <url>/2022/11/29/4b24005dfff4/</url>
    <content><![CDATA[<h3 id="一mybatisplus简介与基本操作">一、MyBatisPlus简介与基本操作</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDE：idea 2019.2 </span><br><span class="line">JDK：JDK8+ </span><br><span class="line">构建工具：maven 3.5.4 </span><br><span class="line">MySQL版本：MySQL 5.7 </span><br><span class="line">Spring Boot：2.6.3 </span><br><span class="line">MyBatis-Plus：3.5.1</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化SpringBoot工程</li>
<li>引入依赖：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>	</span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>application.yaml</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    # 配置数据源信息</span><br><span class="line">    datasource:</span><br><span class="line">        # 配置数据源类型</span><br><span class="line">        type: com.zaxxer.hikari.HikariDataSource</span><br><span class="line">        # 配置连接数据库信息</span><br><span class="line">        driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">        url: jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false</span><br><span class="line">        username: root</span><br><span class="line">        password: 123456</span><br><span class="line"># 配置MyBatis日志</span><br><span class="line">mybatis-plus:</span><br><span class="line">    configuration:</span><br><span class="line">    	log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br></pre></td></tr></table></figure>
<ul>
<li>在SpringBoot启动类中添加@MapperScan注解，来扫描mapper包：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.fantast.mybatisplus.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisplusApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    	SpringApplication.run(MybatisplusApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>添加实体：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span> <span class="comment">//lombok注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>添加mapper</li>
</ul>
<p>​
BaseMapper是MyBatis-Plus提供的模板mapper，其中包含了基本的CRUD方法，泛型为操作的
实体类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectList</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//selectList()根据MP内置的条件构造器查询一个list集合，null表示没有条件，即查询所有</span></span><br><span class="line">        userMapper.selectList(<span class="literal">null</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="二基本curd操作">二、基本CURD操作：</h3>
<p>MyBatis-Plus中的基本CRUD在内置的BaseMapper中都已得到了实现，我们可以直接使用。</p>
<h4 id="插入">1、插入：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="literal">null</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">23</span>, <span class="string">&quot;zhangsan@atguigu.com&quot;</span>);</span><br><span class="line"><span class="comment">//INSERT INTO user ( id, name, age, email ) VALUES ( ?, ?, ?, ? )</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.insert(user);</span><br><span class="line">        System.out.println(<span class="string">&quot;受影响行数：&quot;</span>+result);</span><br><span class="line"><span class="comment">//1475754982694199298</span></span><br><span class="line">        System.out.println(<span class="string">&quot;id自动获取：&quot;</span>+user.getId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​ 最终执行的结果，所获取的id为1475754982694199298</p>
<p>​
这是因为MyBatis-Plus在实现插入数据时，会默认基于雪花算法的策略生成id</p>
<h4 id="删除">2、删除</h4>
<ul>
<li>通过ID删除单个</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteById</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//通过id删除用户信息</span></span><br><span class="line"><span class="comment">//DELETE FROM user WHERE id=?</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteById(<span class="number">1475754982694199298L</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;受影响行数：&quot;</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过ID批量删除</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteBatchIds</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//通过多个id批量删除</span></span><br><span class="line">    <span class="comment">//DELETE FROM user WHERE id IN ( ? , ? , ? )</span></span><br><span class="line">    List&lt;Long&gt; idList = Arrays.asList(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">3L</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteBatchIds(idList);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响行数：&quot;</span>+result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>通过map条件删除</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteByMap</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//根据map集合中所设置的条件删除记录</span></span><br><span class="line">    <span class="comment">//DELETE FROM user WHERE name = ? AND age = ?</span></span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;age&quot;</span>, <span class="number">23</span>);</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteByMap(map);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响行数：&quot;</span>+result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="修改">3、修改</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdateById</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">4L</span>, <span class="string">&quot;admin&quot;</span>, <span class="number">22</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//UPDATE user SET name=?, age=? WHERE id=?</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.updateById(user);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响行数：&quot;</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查询">4、查询</h4>
<ul>
<li>通过ID查询单个</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectById</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//根据id查询用户信息</span></span><br><span class="line">    <span class="comment">//SELECT id,name,age,email FROM user WHERE id=?</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">4L</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>通过ID查询删除</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectBatchIds</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//根据多个id查询多个用户信息</span></span><br><span class="line">    <span class="comment">//SELECT id,name,age,email FROM user WHERE id IN ( ? , ? )</span></span><br><span class="line">    List&lt;Long&gt; idList = Arrays.asList(<span class="number">4L</span>, <span class="number">5L</span>);</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectBatchIds(idList);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>通过map条件查询</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectByMap</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//通过map条件查询用户信息</span></span><br><span class="line">    <span class="comment">//SELECT id,name,age,email FROM user WHERE name = ? AND age = ?</span></span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;age&quot;</span>, <span class="number">22</span>);</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectByMap(map);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>查询所有数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//查询所有用户信息</span></span><br><span class="line">    <span class="comment">//SELECT id,name,age,email FROM user</span></span><br><span class="line">    List&lt;User&gt; list = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="通用service">5、通用Service</h4>
<ul>
<li><p>Service CRUD封装IService接口，进一步封装CRUD</p></li>
<li><p>泛型T为任意实体对象</p></li>
<li><p>建议如果存在自定义通用 Service 方法的可能，请创建自己的
IBaseService 继承 Mybatis-Plus 提供的基类</p></li>
</ul>
<h5 id="简介">1) 简介：</h5>
<p>MyBatis-Plus中有一个接口 IService和其实现类
ServiceImpl，封装了常见的业务层逻辑</p>
<h5 id="创建service接口和实现类">2) 创建Service接口和实现类</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* UserService继承IService模板提供的基础功能</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ServiceImpl实现了IService，提供了IService中基础功能的实现</span></span><br><span class="line"><span class="comment">* 若ServiceImpl无法满足业务需求，则可以使用自定的UserService定义方法，并在实现类中实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span></span><br><span class="line"><span class="title class_">UserService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="测试查询记录数">3）测试查询记录数</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetCount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> userService.count();</span><br><span class="line">    System.out.println(<span class="string">&quot;总记录数：&quot;</span> + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="批量插入">4)批量插入：</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSaveBatch</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// SQL长度有限制，海量数据插入单条SQL无法实行，</span></span><br><span class="line">    <span class="comment">// 因此MabtisPlus将批量插入放在了通用Service中实现，而不是通用Mapper</span></span><br><span class="line">    ArrayList&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;ybc&quot;</span> + i);</span><br><span class="line">        user.setAge(<span class="number">20</span> + i);</span><br><span class="line">        users.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//SQL:INSERT INTO t_user ( username, age ) VALUES ( ?, ? )</span></span><br><span class="line">    userService.saveBatch(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三常用的注解">三、常用的注解：</h3>
<h4
id="实体类型类名和要操作的表名不一致怎么办">1、实体类型类名和要操作的表名不一致怎么办？</h4>
<p>​ MyBatis-Plus在确定操作的表时，由BaseMapper的泛型决定，即实体类型决
定，且默认操作的表名和实体类型的类名一致</p>
<ul>
<li><span class="citation" data-cites="TableName">@TableName</span></li>
</ul>
<p>在实体类类型上添加注解，标识实体类对应的表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;t_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>全局配置：</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">    <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment"># 配置MyBatis日志</span></span><br><span class="line">    	<span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">    <span class="attr">global-config:</span></span><br><span class="line">    	<span class="attr">db-config:</span></span><br><span class="line">            <span class="comment"># 配置MyBatis-Plus操作表的默认前缀</span></span><br><span class="line">            <span class="attr">table-prefix:</span> <span class="string">t_</span></span><br></pre></td></tr></table></figure>
<h4 id="主键问题">2、主键问题</h4>
<p>​ MyBatis-Plus在实现CRUD时，会默认将id作为主键列，并在插入数据时，默认
基于雪花算法的策略生成id</p>
<p>​
若实体类和表中表示主键的不是id，而是其他字段，例如uid，MyBatis-Plus会自动识别uid为主
键列吗？</p>
<ul>
<li><span class="citation" data-cites="TableId">@TableId</span></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">	<span class="meta">@TableId(value=&quot;uid&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> Long uid;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><span class="citation"
data-cites="TableId的type属性">@TableId的type属性</span>：用于定义主键策略：
<ul>
<li>IdType.ASSIGN_ID：基于雪花算法的策略生成数据id，与数据库id是否设置自增无关</li>
<li>IdType.AUTO：使用数据库的自增策略，注意，该类型请确保数据库设置了id自增，
否则无效</li>
</ul></li>
<li>全局配置MyBatis-Plus的主键策略：</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">    <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment"># 配置MyBatis日志</span></span><br><span class="line">    	<span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">    <span class="attr">global-config:</span></span><br><span class="line">    	<span class="attr">db-config:</span></span><br><span class="line">            <span class="comment"># 配置MyBatis-Plus操作表的默认前缀</span></span><br><span class="line">            <span class="attr">table-prefix:</span> <span class="string">t_</span></span><br><span class="line">            <span class="attr">id-type:</span> <span class="string">auto</span></span><br></pre></td></tr></table></figure>
<h4
id="实体类属性名和字段名不一致怎么办">3、实体类属性名和字段名不一致怎么办？</h4>
<ul>
<li>驼峰和下划线的命名转换无需担忧，自动转换</li>
<li><span class="citation"
data-cites="TableField">@TableField</span></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Long uid;</span><br><span class="line">	<span class="meta">@TableField(&quot;username&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="逻辑删除与物理删除">4、逻辑删除与物理删除</h4>
<ul>
<li>数据库中设置逻辑删除状态列，默认值为false</li>
<li>实体类中添加这一属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Long uid;</span><br><span class="line">	<span class="meta">@TableLogic</span></span><br><span class="line">	<span class="keyword">private</span> Integer isDeleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 如此一来，被逻辑删除的数据默认不会被查询</p>
<h3 id="四条件构造器和常用接口">四、条件构造器和常用接口</h3>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221206093207864.png" style="zoom:50%;" /></p>
<ul>
<li>Wrapper ： 条件构造抽象类，最顶端父类
<ul>
<li>AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件
<ul>
<li>QueryWrapper ： 查询条件封装</li>
<li>UpdateWrapper ： Update 条件封装</li>
<li>AbstractLambdaWrapper ： 使用Lambda 语法
<ul>
<li>LambdaQueryWrapper ：用于Lambda语法使用的查询Wrapper</li>
<li>LambdaUpdateWrapper ： Lambda 更新封装Wrapper</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h4 id="常用条件">1、常用条件</h4>
<ul>
<li>组装查询条件：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//查询用户名包含a，年龄在20到30之间，并且邮箱不为null的用户信息</span></span><br><span class="line">    <span class="comment">//SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 AND (username LIKE ? AND age BETWEEN ? AND ? AND email IS NOT NULL)</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.like(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">                .between(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">                .isNotNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>组装排序条件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//按年龄降序查询用户，如果年龄相同则按id升序排列</span></span><br><span class="line">    <span class="comment">//SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 ORDER BY age DESC,id ASC</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper</span><br><span class="line">        .orderByDesc(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">        .orderByAsc(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>组装删除条件：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//删除email为空的用户</span></span><br><span class="line">    <span class="comment">//DELETE FROM t_user WHERE (email IS NULL)</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.isNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    <span class="comment">//条件构造器也可以构建删除语句的条件</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.delete(queryWrapper);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>条件的优先级</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span> &#123;</span><br><span class="line">QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//将（年龄大于20并且用户名中包含有a）或邮箱为null的用户信息修改</span></span><br><span class="line">    <span class="comment">//UPDATE t_user SET age=?, email=? WHERE (username LIKE ? AND age &gt; ? OR email IS NULL)</span></span><br><span class="line">    queryWrapper</span><br><span class="line">        .like(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">        .gt(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>)</span><br><span class="line">        .or()</span><br><span class="line">        .isNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setAge(<span class="number">18</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;user@atguigu.com&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(user, queryWrapper);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改</span></span><br><span class="line">    <span class="comment">//UPDATE t_user SET age=?, email=? WHERE (username LIKE ? AND (age &gt; ? OR email IS NULL))</span></span><br><span class="line">    <span class="comment">//lambda表达式内的逻辑优先运算</span></span><br><span class="line">    queryWrapper</span><br><span class="line">        .like(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">        .and(i -&gt; i.gt(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>).or().isNull(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setAge(<span class="number">18</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;user@atguigu.com&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(user, queryWrapper);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>组装select语句：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//查询用户信息的username和age字段</span></span><br><span class="line">    <span class="comment">//SELECT username,age FROM t_user</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.select(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">    <span class="comment">//selectMaps()返回Map集合列表，通常配合select()使用，避免User对象中没有被查询到的列值为null</span></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(queryWrapper);</span><br><span class="line">    maps.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>子查询：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test06</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//查询id小于等于3的用户信息</span></span><br><span class="line">    <span class="comment">//SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE (id IN (select id from t_user where id &lt;= 3))</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.inSql(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;select id from t_user where id &lt;= 3&quot;</span>);</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>更新Wrapper：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test07</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//将（年龄大于20或邮箱为null）并且用户名中包含有a的用户信息修改</span></span><br><span class="line"><span class="comment">//组装set子句以及修改条件</span></span><br><span class="line">    UpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//lambda表达式内的逻辑优先运算</span></span><br><span class="line">    updateWrapper</span><br><span class="line">        .set(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>)</span><br><span class="line">        .set(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;user@atguigu.com&quot;</span>)</span><br><span class="line">        .like(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">        .and(i -&gt; i.gt(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>).or().isNull(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">    <span class="comment">//这里必须要创建User对象，否则无法应用自动填充。如果没有自动填充，可以设置为null</span></span><br><span class="line">    <span class="comment">//UPDATE t_user SET username=?, age=?,email=? WHERE (username LIKE ? AND (age &gt; ? OR email IS NULL))</span></span><br><span class="line">    <span class="comment">//UPDATE t_user SET age=?,email=? WHERE (username LIKE ? AND (age &gt; ? OR</span></span><br><span class="line">    email IS NULL))</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(<span class="literal">null</span>, updateWrapper);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="condition-组装条件">2、Condition 组装条件：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test08UseCondition</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//定义查询条件，有可能为null（用户未输入或未选择）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">ageBegin</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">ageEnd</span> <span class="operator">=</span> <span class="number">24</span>;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//StringUtils.isNotBlank()判断某字符串是否不为空且长度不为0且不由空白符(whitespace)构成</span></span><br><span class="line">    queryWrapper</span><br><span class="line">        .like(StringUtils.isNotBlank(username), <span class="string">&quot;username&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">        .ge(ageBegin != <span class="literal">null</span>, <span class="string">&quot;age&quot;</span>, ageBegin)</span><br><span class="line">        .le(ageEnd != <span class="literal">null</span>, <span class="string">&quot;age&quot;</span>, ageEnd);</span><br><span class="line">    <span class="comment">//SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE (age &gt;= ? AND age &lt;= ?)</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="lambdaquerywrapper">3、LambdaQueryWrapper</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test09</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//定义查询条件，有可能为null（用户未输入）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">ageBegin</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">ageEnd</span> <span class="operator">=</span> <span class="number">24</span>;</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//避免使用字符串表示字段，防止运行时错误</span></span><br><span class="line">    queryWrapper</span><br><span class="line">        .like(StringUtils.isNotBlank(username), User::getName, username)</span><br><span class="line">        .ge(ageBegin != <span class="literal">null</span>, User::getAge, ageBegin)</span><br><span class="line">        .le(ageEnd != <span class="literal">null</span>, User::getAge, ageEnd);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="lambdaupdatewrapper">4、LambdaUpdateWrapper</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test10</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//组装set子句</span></span><br><span class="line">    LambdaUpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">    updateWrapper</span><br><span class="line">        .set(User::getAge, <span class="number">18</span>)</span><br><span class="line">        .set(User::getEmail, <span class="string">&quot;user@atguigu.com&quot;</span>)</span><br><span class="line">        .like(User::getName, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">        .and(i -&gt; i.lt(User::getAge, <span class="number">24</span>).or().isNull(User::getEmail)); <span class="comment">//lambda</span></span><br><span class="line">    <span class="comment">//表达式内的逻辑优先运算</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(user, updateWrapper);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五插件">五、插件：</h3>
<h4 id="分页插件">1、分页插件：</h4>
<ul>
<li>添加一个配置类：（可以将主类中的包扫描注解移到此处）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.atguigu.mybatisplus.mapper&quot;)</span> <span class="comment">//可以将主类中的注解移到此处</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用测试：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testPage()&#123;</span><br><span class="line">    //设置分页参数</span><br><span class="line">    Page&lt;User&gt; page = new Page&lt;&gt;(1, 5);</span><br><span class="line">    userMapper.selectPage(page, null);</span><br><span class="line">    //获取分页数据</span><br><span class="line">    List&lt;User&gt; list = page.getRecords();</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">    System.out.println(&quot;当前页：&quot;+page.getCurrent());</span><br><span class="line">    System.out.println(&quot;每页显示的条数：&quot;+page.getSize());</span><br><span class="line">    System.out.println(&quot;总记录数：&quot;+page.getTotal());</span><br><span class="line">    System.out.println(&quot;总页数：&quot;+page.getPages());</span><br><span class="line">    System.out.println(&quot;是否有上一页：&quot;+page.hasPrevious());</span><br><span class="line">    System.out.println(&quot;是否有下一页：&quot;+page.hasNext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="乐观锁与悲观锁">2、乐观锁与悲观锁：</h4>
<h5 id="乐观锁">1）乐观锁：</h5>
<ul>
<li>场景如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConcurrentUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1、小李</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">p1</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;小李取出的价格：&quot;</span> + p1.getPrice());</span><br><span class="line">    <span class="comment">//2、小王</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">p2</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;小王取出的价格：&quot;</span> + p2.getPrice());</span><br><span class="line">    <span class="comment">//3、小李将价格加了50元，存入了数据库</span></span><br><span class="line">    p1.setPrice(p1.getPrice() + <span class="number">50</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result1</span> <span class="operator">=</span> productMapper.updateById(p1);</span><br><span class="line">    System.out.println(<span class="string">&quot;小李修改结果：&quot;</span> + result1);</span><br><span class="line">    <span class="comment">//4、小王将商品减了30元，存入了数据库</span></span><br><span class="line">    p2.setPrice(p2.getPrice() - <span class="number">30</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result2</span> <span class="operator">=</span> productMapper.updateById(p2);</span><br><span class="line">    System.out.println(<span class="string">&quot;小王修改结果：&quot;</span> + result2);</span><br><span class="line">    <span class="comment">//最后的结果</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">p3</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    <span class="comment">//价格覆盖，最后的结果：70</span></span><br><span class="line">    System.out.println(<span class="string">&quot;最后的结果：&quot;</span> + p3.getPrice());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果是乐观锁，小王保存价格前，会检查下价格是否被人修改过了。如果被修改过了，则重新取出的被修改后的价格</p></li>
<li><p>乐观锁的直接实现流程：</p>
<ul>
<li>数据库中添加version字段，取出记录时，获取当前version</li>
<li>更新时，version +
1，如果where语句中的version版本不对，则更新失败</li>
</ul></li>
<li><p>MyBatisPlus中实现乐观锁：</p>
<ul>
<li>实体类需要修改：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="meta">@Version</span></span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>添加乐观锁插件配置：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">    <span class="comment">//添加分页插件</span></span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span></span><br><span class="line">    <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">    <span class="comment">//添加乐观锁插件</span></span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>于是整体流程如下：</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConcurrentVersionUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//小李取数据</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">p1</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    <span class="comment">//小王取数据</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">p2</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1L</span>);  <span class="comment">//会自动选择出version</span></span><br><span class="line">    <span class="comment">//小李修改 + 50</span></span><br><span class="line">    p1.setPrice(p1.getPrice() + <span class="number">50</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result1</span> <span class="operator">=</span> productMapper.updateById(p1);  <span class="comment">//会自动将version+1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;小李修改的结果：&quot;</span> + result1);</span><br><span class="line">    <span class="comment">//小王修改 - 30</span></span><br><span class="line">    p2.setPrice(p2.getPrice() - <span class="number">30</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result2</span> <span class="operator">=</span> productMapper.updateById(p2);  </span><br><span class="line">    System.out.println(<span class="string">&quot;小王修改的结果：&quot;</span> + result2);</span><br><span class="line">    <span class="keyword">if</span>(result2 == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//失败重试，重新获取version并更新</span></span><br><span class="line">        p2 = productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">        p2.setPrice(p2.getPrice() - <span class="number">30</span>);</span><br><span class="line">        result2 = productMapper.updateById(p2);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;小王修改重试的结果：&quot;</span> + result2);</span><br><span class="line">    <span class="comment">//老板看价格</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">p3</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;老板看价格：&quot;</span> + p3.getPrice());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="六通用枚举enum">六、通用枚举ENUM：</h3>
<ul>
<li>建立通用枚举类：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.mp.enums;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.EnumValue;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SexEnum</span> &#123;</span><br><span class="line">    MALE(<span class="number">1</span>, <span class="string">&quot;男&quot;</span>),</span><br><span class="line">    FEMALE(<span class="number">2</span>, <span class="string">&quot;女&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@EnumValue</span></span><br><span class="line">    <span class="keyword">private</span> Integer sex;</span><br><span class="line">    <span class="keyword">private</span> String sexName;</span><br><span class="line">    </span><br><span class="line">    SexEnum(Integer sex, String sexName) &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.sexName = sexName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>配置：</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">    <span class="attr">configuration:</span></span><br><span class="line">        <span class="comment"># 配置MyBatis日志</span></span><br><span class="line">        <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">    <span class="attr">global-config:</span></span><br><span class="line">        <span class="attr">db-config:</span></span><br><span class="line">        <span class="comment"># 配置MyBatis-Plus操作表的默认前缀</span></span><br><span class="line">        <span class="attr">table-prefix:</span> <span class="string">t_</span></span><br><span class="line">        <span class="comment"># 配置MyBatis-Plus的主键策略</span></span><br><span class="line">        <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line">    <span class="comment"># 配置扫描通用枚举</span></span><br><span class="line">    <span class="attr">type-enums-package:</span> <span class="string">com.atguigu.mybatisplus.enums</span></span><br></pre></td></tr></table></figure>
<ul>
<li>测试：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSexEnum</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;Enum&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//设置性别信息为枚举项，会将@EnumValue注解所标识的属性值存储到数据库</span></span><br><span class="line">    user.setSex(SexEnum.MALE);</span><br><span class="line">    <span class="comment">//INSERT INTO t_user ( username, age, sex ) VALUES ( ?, ?, ? )</span></span><br><span class="line">    <span class="comment">//Parameters: Enum(String), 20(Integer), 1(Integer)</span></span><br><span class="line">    userMapper.insert(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3
id="附录雪花算法与数据库分库分表">附录、雪花算法与数据库分库分表：</h3>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221205204055244.png" /></p>
<ul>
<li>水平分表:
<ul>
<li>当看到表的数据量达到千万级别时，作为架构师就要警觉起来，因为这很可能是架构的性
能瓶颈或者隐患。</li>
<li>水平分表相比垂直分表，会引入更多的复杂性，例如要求全局唯一的数据id该如何处理</li>
</ul></li>
<li>垂直分表：
<ul>
<li>垂直分表适合将表中某些不常用且占了大量空间的列拆分出去。</li>
</ul></li>
</ul>
<h4 id="section"></h4>
]]></content>
      <categories>
        <category>⑨ 工程类笔记</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis Chap1——简介与基本操作</title>
    <url>/2022/11/29/ec35995347ad/</url>
    <content><![CDATA[<h3 id="一mybatis简介与为何要使用">一、MyBatis简介与为何要使用？</h3>
<ul>
<li><p>传统的与数据库交互的方式：</p>
<ul>
<li><p>JDBC-&gt;DBUtils-&gt;JdbcTemplate
自己封装一些小的工具，来简化使用</p></li>
<li><p>SQL 夹杂在Java代码中耦合度高，导致硬编码内伤</p></li>
<li><p>维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见</p></li>
</ul></li>
<li><p>Hibernate：全自动ORM框架，旨在消除Sql</p>
<ul>
<li>操作简便，开发效率高</li>
<li>完全的黑箱操作，程序中的长难复杂 SQL 需要绕过框架</li>
<li>反射操作太多，导致数据库性能下降</li>
</ul></li>
<li><p>MyBatis：半自动ORM框架</p>
<ul>
<li>支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架</li>
<li>避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集</li>
<li>可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain
Old Java Objects，普通的Java对象）映射成数据库中的记录</li>
<li>SQL 和 Java
编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据</li>
</ul></li>
</ul>
<h3 id="二快速上手指南">二、快速上手指南：</h3>
<ul>
<li>创建Maven工程</li>
<li>引入依赖：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Mybatis核心 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- junit测试 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建MyBatis核心配置文件：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置连接数据库的环境--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/MyBatis&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入映射文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">     	<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mappers/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建mapper接口，相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要提供实现类。</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221129101242867.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 添加用户信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="type">int</span> <span class="title function_">insertUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建MyBatis的ORM映射文件：
<ul>
<li>命名规则：
<ul>
<li>表所对应的实体类的类名+Mapper.xml</li>
<li>例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml</li>
<li>因此<strong>一个映射文件对应一个实体类，对应一张表的操作</strong></li>
<li><strong>MyBatis映射文件用于编写SQL，访问以及操作表中的数据</strong></li>
<li>MyBatis映射文件存放的位置是src/main/resources/mappers目录下</li>
</ul></li>
<li>MyBatis中可以面向接口操作数据，<strong>要保证两个一致：</strong>
<ul>
<li>mapper接口的全类名和映射文件的命名空间（namespace）保持一致</li>
<li>mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致</li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line">    <span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">    <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">    <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.fantast.mybatis.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--int insertUser();--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">    	insert into t_user values(null,&#x27;张三&#x27;,&#x27;123&#x27;,23,&#x27;女&#x27;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用JUnit进行功能测试：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMapper</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//读取MyBatis的核心配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">		<span class="comment">//创建SqlSessionFactoryBuilder对象</span></span><br><span class="line">        <span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line">		<span class="comment">//通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(is);</span><br><span class="line">        <span class="comment">//创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//通过代理模式创建UserMapper接口的代理实现类对象</span></span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        <span class="comment">//调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配映射文件中的SQL标签，并执行标签中的SQL语句</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.insertUser();</span><br><span class="line">        <span class="comment">//sqlSession.commit();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>加入log4j日志：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">log4j</span>:configuration <span class="keyword">SYSTEM</span> <span class="string">&quot;log4j.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">log4j:configuration</span> <span class="attr">xmlns:log4j</span>=<span class="string">&quot;http://jakarta.apache.org/log4j/&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.log4j.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;Encoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.log4j.PatternLayout&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;ConversionPattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125;</span></span></span><br><span class="line"><span class="string"><span class="tag">        %m (%F:%L) \n&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;java.sql&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;debug&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.apache.ibatis&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;info&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;debug&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">log4j:configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>日志级别：</p>
<ul>
<li>FATAL(致命)&gt;ERROR(错误)&gt;WARN(警告)&gt;INFO(信息)&gt;DEBUG(调试)</li>
</ul></li>
</ul>
<h3 id="三mybatis配置文件解释">三、MyBatis配置文件解释：</h3>
<p>核心配置文件中的标签必须按照固定的顺序：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//MyBatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://MyBatis.org/dtd/MyBatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入properties文件，此时就可以$&#123;属性名&#125;的方式访问属性值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--将表中字段的下划线自动转换为驼峰--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--开启延迟加载--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    typeAlias：设置某个具体的类型的别名</span></span><br><span class="line"><span class="comment">    属性：</span></span><br><span class="line"><span class="comment">    type：需要设置别名的类型的全类名</span></span><br><span class="line"><span class="comment">    alias：设置此类型的别名，若不设置此属性，该类型拥有默认的别名，即类名且不区分大小写</span></span><br><span class="line"><span class="comment">    若设置此属性，此时该类型的别名只能使用alias所设置的值,这个别名用于在映射xml里指明resultType</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    &lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot;&gt;&lt;/typeAlias&gt;   --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    &lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot; alias=&quot;abc&quot;&gt;&lt;/typeAlias&gt;     --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--以包为单位，设置该包下所有的类型都拥有默认的别名，即类，名且不区分大小写--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.atguigu.mybatis.bean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    environments：设置多个连接数据库的环境</span></span><br><span class="line"><span class="comment">    属性：</span></span><br><span class="line"><span class="comment">    default：设置默认使用的环境的id</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql_test&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        environment：设置具体的连接数据库的环境信息</span></span><br><span class="line"><span class="comment">        属性：</span></span><br><span class="line"><span class="comment">        id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id，</span></span><br><span class="line"><span class="comment">        表示默认使用的环境</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql_test&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        transactionManager：设置事务管理方式</span></span><br><span class="line"><span class="comment">        属性：</span></span><br><span class="line"><span class="comment">        type：设置事务管理方式，type=&quot;JDBC|MANAGED&quot;</span></span><br><span class="line"><span class="comment">        type=&quot;JDBC&quot;：设置当前环境的事务管理都必须手动处理</span></span><br><span class="line"><span class="comment">        type=&quot;MANAGED&quot;：设置事务被管理，例如spring中的AOP</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            dataSource：设置数据源</span></span><br><span class="line"><span class="comment">            属性：</span></span><br><span class="line"><span class="comment">            type：设置数据源的类型，type=&quot;POOLED|UNPOOLED|JNDI&quot;</span></span><br><span class="line"><span class="comment">            type=&quot;POOLED&quot;：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从</span></span><br><span class="line"><span class="comment">            缓存中直接获取，不需要重新创建</span></span><br><span class="line"><span class="comment">            type=&quot;UNPOOLED&quot;：不使用数据库连接池，即每次使用连接都需要重新创建</span></span><br><span class="line"><span class="comment">            type=&quot;JNDI&quot;：调用上下文中的数据源</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置驱动类的全类名--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置连接数据库的连接地址--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置连接数据库的用户名--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置连接数据库的密码--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        	<span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入映射文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        以包为单位，将包下所有的映射文件引入核心配置文件</span></span><br><span class="line"><span class="comment">        注意：此方式必须保证mapper接口和mapper映射文件必须在相同的包下</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.atguigu.mybatis.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="四mybatis增删改查">四、MyBatis增删改查：</h3>
<ul>
<li>增</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertUser();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">    insert into t_user values(null,&#x27;admin&#x27;,&#x27;123456&#x27;,23,&#x27;男&#x27;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>删</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--int deleteUser();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span>&gt;</span></span><br><span class="line">    delete from t_user where id = 7</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>改</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--int updateUser();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span>&gt;</span></span><br><span class="line">	update t_user set username=&#x27;ybc&#x27;,password=&#x27;123&#x27; where id = 6</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查询单个对象</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.bean.User&quot;</span>&gt;</span></span><br><span class="line">    select * from t_user where id = 2</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查询集合</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserList();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.bean.User&quot;</span>&gt;</span></span><br><span class="line">    select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>1、查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射
关系</p>
<ul>
<li>resultType：自动映射，用于属性名和表中字段名一致的情况</li>
<li>resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况</li>
</ul>
<p>2、当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值</p>
<h3 id="五mybatis获取参数值">五、MyBatis获取参数值：</h3>
<p>​ 实际上就是在SQL语句中，获取Mapper接口中传入的参数。</p>
<ul>
<li><p>两种方式：</p>
<ul>
<li>${}的本质就是字符串拼接，需要注意SQL注入问题与手动写单引号</li>
<li>#{}的本质就是占位符赋值，推荐</li>
</ul></li>
<li><p>示例：</p>
<ul>
<li><p>UserMapper.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByUserName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">	select * from user where username = #&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>接口类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User <span class="title function_">getUserByUserName</span><span class="params">(String username)</span>;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="多个传入参数">1、多个传入参数：</h4>
<p>​
MyBatis会自动将这些参数放在一个map集合中，以arg0,arg1...为键，以参数为值；因此只需要通过${}和#{}访问map集合的键就可以获取相对应的值</p>
<ul>
<li><p>UserMapper.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLogin&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">	select * from user where username = #&#123;arg0&#125; and userpassword = #&#123;arg1&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>接口类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User <span class="title function_">checkLogin</span><span class="params">(String username,String userpassword)</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="map集合类型的参数">2、map集合类型的参数：</h4>
<p>​
若mapper接口中的方法需要的参数为多个时，此时可以手动创建map集合，将这些数据放在map中</p>
<p>​ 只需要通过${}和#{}访问map集合的键就可以获取相对应的值</p>
<ul>
<li><p>UserMapper.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLogin&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">	select * from user where username = #&#123;username&#125; and userpassword = #&#123;userpassword&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>接口类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User <span class="title function_">checkLogin</span><span class="params">(Map&lt;String,Object&gt; map)</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="实体类型的参数">3、实体类型的参数</h4>
<p>​
若mapper接口中的方法参数为实体类对象时，此时可以使用${}和#{}，通过访问实体类对象中的属性名获取属性值</p>
<p>​
<strong>此处，注意实际上并不是直接通过成员变量获取，而是通过set和get方法获取对应的属性。
</strong></p>
<ul>
<li><p>UserMapper.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">	insert into user values(null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>接口类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">checkLogin</span><span class="params">(User user)</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4
id="通过param注解标识mapper接口中的方法参数">4、通过@Param注解标识mapper接口中的方法参数</h4>
<ul>
<li><p>UserMapper.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">	insert into user values(null,#&#123;username&#125;,#&#123;password&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>接口类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User <span class="title function_">checkLogin</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span> String username,<span class="meta">@Param(&quot;password&quot;)</span> String userpassword)</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="六各种查询类型">六、各种查询类型：</h3>
<h4 id="实体类对象">1、实体类对象</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--User getUserById(@Param(&quot;id&quot;) int id);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="查询list集合">2、查询List集合</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserList();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="查询单个数据">3、查询单个数据</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 查询用户的总记录数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">* 在MyBatis中，对于Java中常用的类型都设置了类型别名</span></span><br><span class="line"><span class="comment">* 例如：java.lang.Integer--&gt;int|integer</span></span><br><span class="line"><span class="comment">* 例如：int--&gt;_int|_integer</span></span><br><span class="line"><span class="comment">* 例如：Map--&gt;map,List--&gt;list</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--int getCount();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getCount&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;_integer&quot;</span>&gt;</span></span><br><span class="line">select count(id) from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="查询一条数据map">4、查询一条数据——Map</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Map&lt;String, Object&gt; getUserToMap(@Param(&quot;id&quot;) int id);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserToMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">	select * from t_user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--结果：&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;--&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="查询多条数据map列表">5、查询多条数据——Map列表</h4>
<ul>
<li>Method1</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Map&lt;String, Object&gt;&gt; getAllUserToMap();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUserToMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Method2</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 查询所有用户信息为map集合</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">* 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，并</span></span><br><span class="line"><span class="comment">且最终要以一个map的方式返回数据，此时需要通过<span class="doctag">@MapKey</span>注解设置map集合的键，值是每条数据所对应的</span></span><br><span class="line"><span class="comment">map集合</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@MapKey(&quot;id&quot;)</span></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getAllUserToMap</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUserToMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">结果：</span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">1=&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;,</span></span><br><span class="line"><span class="comment">2=&#123;password=123456, sex=男, id=2, age=23, username=张三&#125;,</span></span><br><span class="line"><span class="comment">3=&#123;password=123456, sex=男, id=3, age=23, username=张三&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>⑨ 工程类笔记</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC Chap6——SpringMVC 常见组件与执行流程</title>
    <url>/2022/11/28/3bf313b3626c/</url>
    <content><![CDATA[<h3 id="一常用组件">一、常用组件：</h3>
<ul>
<li>DispatcherServlet：前端控制器，不需要工程师开发，由框架提供
<ul>
<li>作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求</li>
</ul></li>
<li>HandlerMapping：处理器映射器，不需要工程师开发，由框架提供
<ul>
<li>作用：根据请求的url、method等信息查找Handler，即控制器方法</li>
</ul></li>
<li>Handler：处理器，需要工程师开发
<ul>
<li>作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理</li>
</ul></li>
<li>HandlerAdapter：处理器适配器，不需要工程师开发，由框架提供
<ul>
<li>作用：通过HandlerAdapter对处理器（控制器方法）进行执行</li>
</ul></li>
<li>ViewResolver：视图解析器，不需要工程师开发，由框架提供
<ul>
<li>作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、
RedirectView</li>
</ul></li>
<li>View：视图
<ul>
<li>作用：将模型数据通过页面展示给用户</li>
</ul></li>
</ul>
<h3
id="二dispatcherservlet初始化的过程">二、DispatcherServlet初始化的过程：</h3>
<h4 id="初始化过程">1、初始化过程：</h4>
<h4 id="服务过程">2、服务过程：</h4>
<h3 id="三springmvc执行流程">三、SpringMVC执行流程：</h3>
<ol type="1">
<li>用户向服务器发送请求，请求被SpringMVC 前端控制器
DispatcherServlet捕获。</li>
<li>DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射：<br />
</li>
</ol>
<ul>
<li>不存在
<ul>
<li><ol type="i">
<li>再判断是否配置了mvc:default-servlet-handler</li>
</ol></li>
<li><ol start="2" type="i">
<li>如果没配置，则控制台报映射查找不到，客户端展示404错误</li>
</ol></li>
<li><ol start="3" type="i">
<li>如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404
错误</li>
</ol></li>
</ul></li>
<li>存在则执行接下去的流程：</li>
</ul>
<ol start="3" type="1">
<li>根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及
Handler对象对应的拦截器），最后以HandlerExecutionChain执行链对象的形式返回</li>
<li>DispatcherServlet
根据获得的Handler，选择一个合适的HandlerAdapter</li>
<li>如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler(…)方法【正向】</li>
<li>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。
在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：
<ul>
<li>HttpMessageConveter：
将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定
的响应信息</li>
<li>数据转换：对请求消息进行数据转换。如String转换成Integer、Double等</li>
<li>数据格式化：对请求消息进行数据格式化。
如将字符串转换成格式化数字或格式化日期等</li>
<li>数据验证：
验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</li>
</ul></li>
<li>Handler执行完成后，向DispatcherServlet
返回一个ModelAndView对象。</li>
<li>此时将开始执行拦截器的postHandle(...)方法【逆向】。</li>
<li>根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行
HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析，根据Model
和View，来渲染视图</li>
<li>渲染视图完毕执行拦截器的afterCompletion(…)方法【逆向】</li>
<li>将渲染结果返回给客户端</li>
</ol>
]]></content>
      <categories>
        <category>⑨ 工程类笔记</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC Chap5——SpringMVC 完全注解开发</title>
    <url>/2022/11/28/88fd99a9bc39/</url>
    <content><![CDATA[<p>使用配置类和注解代替web.xml和SpringMVC配置文件的功能</p>
<h4 id="一创建初始化类代替web.xml">一、创建初始化类，代替web.xml</h4>
<p>​
在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，
如果找到的话就用它来配置Servlet容器。Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配
置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为
AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自
动发现它，并用它来配置Servlet上下文。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebInit</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 指定spring的配置类</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 指定SpringMVC的配置类</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;WebConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 指定DispatcherServlet的映射规则，即url-pattern</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 添加过滤器</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        <span class="type">CharacterEncodingFilter</span> <span class="variable">encodingFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>();</span><br><span class="line">        encodingFilter.setEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        encodingFilter.setForceRequestEncoding(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">HiddenHttpMethodFilter</span> <span class="variable">hiddenHttpMethodFilter</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">        <span class="title class_">HiddenHttpMethodFilter</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[]&#123;encodingFilter, hiddenHttpMethodFilter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4
id="二创建springconfig配置类代替spring的配置文件">二、创建SpringConfig配置类，代替spring的配置文件</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">	<span class="comment">//ssm整合之后，spring的配置信息写在此类中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4
id="三创建webconfig配置类代替springmvc的配置文件">三、创建WebConfig配置类，代替SpringMVC的配置文件</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//扫描组件</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.atguigu.mvc.controller&quot;)</span></span><br><span class="line"><span class="comment">//开启MVC注解驱动</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">//使用默认的servlet处理静态资源</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer</span></span><br><span class="line"><span class="params">    configurer)</span> &#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//配置文件上传解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CommonsMultipartResolver <span class="title function_">multipartResolver</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonsMultipartResolver</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//配置拦截器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="type">FirstInterceptor</span> <span class="variable">firstInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FirstInterceptor</span>();</span><br><span class="line">        registry.addInterceptor(firstInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//配置视图控制</span></span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    public void addViewControllers(ViewControllerRegistry registry) &#123;</span></span><br><span class="line"><span class="comment">        registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="comment">//配置异常映射</span></span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    public void</span></span><br><span class="line"><span class="comment">    configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123;</span></span><br><span class="line"><span class="comment">        SimpleMappingExceptionResolver exceptionResolver = new</span></span><br><span class="line"><span class="comment">        SimpleMappingExceptionResolver();</span></span><br><span class="line"><span class="comment">        Properties prop = new Properties();</span></span><br><span class="line"><span class="comment">        prop.setProperty(&quot;java.lang.ArithmeticException&quot;, &quot;error&quot;);</span></span><br><span class="line"><span class="comment">        //设置异常映射</span></span><br><span class="line"><span class="comment">        exceptionResolver.setExceptionMappings(prop);</span></span><br><span class="line"><span class="comment">        //设置共享异常信息的键</span></span><br><span class="line"><span class="comment">        exceptionResolver.setExceptionAttribute(&quot;ex&quot;);</span></span><br><span class="line"><span class="comment">        resolvers.add(exceptionResolver);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="comment">//配置生成模板解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ITemplateResolver <span class="title function_">templateResolver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">WebApplicationContext</span> <span class="variable">webApplicationContext</span> <span class="operator">=</span></span><br><span class="line">        ContextLoader.getCurrentWebApplicationContext();</span><br><span class="line">        <span class="comment">// ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过</span></span><br><span class="line">        WebApplicationContext 的方法获得</span><br><span class="line">        <span class="type">ServletContextTemplateResolver</span> <span class="variable">templateResolver</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">        <span class="title class_">ServletContextTemplateResolver</span>(</span><br><span class="line">        webApplicationContext.getServletContext());</span><br><span class="line">        templateResolver.setPrefix(<span class="string">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class="line">        templateResolver.setSuffix(<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">        templateResolver.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        templateResolver.setTemplateMode(TemplateMode.HTML);</span><br><span class="line">        <span class="keyword">return</span> templateResolver;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//生成模板引擎并为模板引擎注入模板解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SpringTemplateEngine <span class="title function_">templateEngine</span><span class="params">(ITemplateResolver</span></span><br><span class="line"><span class="params">    templateResolver)</span> &#123;</span><br><span class="line">        <span class="type">SpringTemplateEngine</span> <span class="variable">templateEngine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringTemplateEngine</span>();</span><br><span class="line">        templateEngine.setTemplateResolver(templateResolver);</span><br><span class="line">        <span class="keyword">return</span> templateEngine;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生成视图解析器并未解析器注入模板引擎</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ViewResolver <span class="title function_">viewResolver</span><span class="params">(SpringTemplateEngine templateEngine)</span> &#123;</span><br><span class="line">        <span class="type">ThymeleafViewResolver</span> <span class="variable">viewResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThymeleafViewResolver</span>();</span><br><span class="line">        viewResolver.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        viewResolver.setTemplateEngine(templateEngine);</span><br><span class="line">        <span class="keyword">return</span> viewResolver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="四测试功能">四、测试功能</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>⑨ 工程类笔记</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC Chap3——SpringMVC RestFul风格与消息转换机制（Json与Java对象互转）</title>
    <url>/2022/11/28/29f1ae58afdc/</url>
    <content><![CDATA[<h3 id="一restful">一、RESTFUL：</h3>
<ul>
<li><p>Representational State
Transfer，表现层（视图+控制层）<strong>资源状态转移</strong></p></li>
<li><p>资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个
可命名的抽象概念</p></li>
<li><p>资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格
式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式</p></li>
<li><p>状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资
源的表述，来间接实现操作资源的目的。</p></li>
</ul>
<h4 id="restful的实现">1、RESTFUL的实现:</h4>
<ul>
<li><p>它们分别对应四种基本操作：GET 用来获取资源，POST
用来新建资源，PUT 用来更新资源，DELETE 用来删除资源</p></li>
<li><p>REST 风格提倡 URL
地址使用统一的风格设计，<strong>从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为
URL 地址的一部分，以保证整体风格的一致性</strong></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221128160019703.png" /></p></li>
</ul>
<h4 id="hiddenhttpmethodfilter">2、HiddenHttpMethodFilter</h4>
<p>由于浏览器只支持发送get和post方式的请求，那么该如何发送put和delete请求呢？</p>
<ul>
<li>SpringMVC 提供了 HiddenHttpMethodFilter 帮助我们将 POST 请求转换为
DELETE 或 PUT 请求</li>
</ul>
<p>在web.xml中注册HiddenHttpMethodFilter</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filterclass</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：HiddenHttpMethodFilter 处理put和delete请求的条件：</p>
<ul>
<li>当前请求的请求方式必须为post</li>
<li>当前请求必须传输请求参数_method_</li>
<li>满足以上条件，HiddenHttpMethodFilter
过滤器就会将当前请求的请求方式转换为请求参数
_method的值，因此请求参数_method的值才是最终的请求方式</li>
</ul>
<h3 id="二restful示例">二、RESTFUL示例：</h3>
<ul>
<li><p>示例功能：查询</p>
<ul>
<li><p>控制器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getEmployeeList</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">    Collection&lt;Employee&gt; employeeList = employeeDao.getAll();</span><br><span class="line">    model.addAttribute(<span class="string">&quot;employeeList&quot;</span>, employeeList);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;employee_list&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>html页面</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Employee Info<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/vue.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellpadding</span>=<span class="string">&quot;0&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">style</span>=<span class="string">&quot;text-align:center;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;dataTable&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;employee : $&#123;employeeList&#125;&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.id&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.lastName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.email&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>示例功能：删除：</p></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 作用：通过超链接控制表单的提交，将post请求转换为delete请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;delete_form&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- HiddenHttpMethodFilter要求：必须传输_method请求参数，并且值为最终的请求方式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;delete&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过vue来处理点击事件：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> vue = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&quot;#dataTable&quot;</span>,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="comment">//event表示当前事件</span></span><br><span class="line">        <span class="attr">deleteEmployee</span>:<span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">            <span class="comment">//通过id获取表单标签</span></span><br><span class="line">            <span class="keyword">var</span> delete_form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;delete_form&quot;</span>);</span><br><span class="line">            <span class="comment">//将触发事件的超链接的href属性为表单的action属性赋值</span></span><br><span class="line">            delete_form.<span class="property">action</span> = event.<span class="property">target</span>.<span class="property">href</span>;</span><br><span class="line">            <span class="comment">//提交表单</span></span><br><span class="line">            delete_form.<span class="title function_">submit</span>();</span><br><span class="line">            <span class="comment">//阻止超链接的默认跳转行为</span></span><br><span class="line">            event.<span class="title function_">preventDefault</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>服务器端：控制器方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.DELETE)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">deleteEmployee</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">    employeeDao.delete(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三httpmessageconverter">三、HttpMessageConverter</h3>
<ul>
<li>HttpMessageConverter，报文信息转换器，将请求报文转换为Java对象，或将Java对象转换为响应报
文。</li>
<li>HttpMessageConverter提供了两个注解和两个类型：<span class="citation"
data-cites="RequestBody">@RequestBody</span>，<span class="citation"
data-cites="ResponseBody">@ResponseBody</span>，RequestEntity，ResponseEntity</li>
</ul>
<h4 id="requestbody">1、<span class="citation"
data-cites="RequestBody">@RequestBody</span></h4>
<p>​ <span class="citation"
data-cites="RequestBody可以获取请求体">@RequestBody可以获取请求体</span>，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestBody&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestBody</span><span class="params">(<span class="meta">@RequestBody</span> String requestBody)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;requestBody:&quot;</span>+requestBody);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">requestBody:username=admin&amp;password=123456</span><br></pre></td></tr></table></figure>
<h4 id="requestentity">2、RequestEntity</h4>
<p>​
RequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的
请求报文就会赋值给该形参，可以通过getHeaders()获取请求头信息，通过getBody()获取请求体信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestEntity&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestEntity</span><span class="params">(RequestEntity&lt;String&gt; requestEntity)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;requestHeader:&quot;</span>+requestEntity.getHeaders());</span><br><span class="line">    System.out.println(<span class="string">&quot;requestBody:&quot;</span>+requestEntity.getBody());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="responsebody">3、<span class="citation"
data-cites="ResponseBody">@ResponseBody</span></h4>
<p><span class="citation"
data-cites="ResponseBody用于标识一个控制器方法">@ResponseBody用于标识一个控制器方法</span>，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testResponseBody&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testResponseBody</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//浏览器页面会显示  success</span></span><br></pre></td></tr></table></figure>
<h4 id="springmvc处理json">4、SpringMVC处理json：</h4>
<ul>
<li>导入依赖：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在HandlerAdaptor中会自动装配一个消
息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格
式的字符串</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在处理器方法上使用@ResponseBody注解进行标识,将Java对象直接作为控制器方法的返回值返回，就会自动转换为Json格式的字符串</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testResponseUser&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">testResponseUser</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1001</span>,<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;123456&quot;</span>,<span class="number">23</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">1001</span><span class="punctuation">,</span><span class="attr">&quot;username&quot;</span><span class="punctuation">:</span><span class="string">&quot;admin&quot;</span><span class="punctuation">,</span><span class="attr">&quot;password&quot;</span><span class="punctuation">:</span><span class="string">&quot;123456&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">23</span><span class="punctuation">,</span><span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span><span class="string">&quot;男&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="处理ajaxaxios">5、处理Ajax：（Axios）</h4>
<ul>
<li>vue和axios发送的请求为：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:event.<span class="property">target</span>.<span class="property">href</span>,</span><br><span class="line">    <span class="attr">params</span>:&#123;</span><br><span class="line">        <span class="attr">username</span>:<span class="string">&quot;admin&quot;</span>,</span><br><span class="line">        <span class="attr">password</span>:<span class="string">&quot;123456&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(response.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testAjax&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAjax</span><span class="params">(String username, String password)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username:&quot;</span>+username+<span class="string">&quot;,password:&quot;</span>+password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello,ajax&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="restcontroller注解">6、<span class="citation"
data-cites="RestController注解">@RestController注解</span>：</h4>
<p>​ 标识在控制器的类上，就相当于：</p>
<ul>
<li>为类添加了@Controller注解</li>
<li>并且为其中的每个方法添加了@ResponseBody注解</li>
</ul>
]]></content>
      <categories>
        <category>⑨ 工程类笔记</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC Chap4——SpringMVC 文件上传和下载、拦截器和异常处理</title>
    <url>/2022/11/28/0fcd9a57a1e6/</url>
    <content><![CDATA[<h3 id="一文件下载">一、文件下载：</h3>
<ul>
<li>利用ResponseEntity实现文件下载</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DownLoadFileController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testDown&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;<span class="type">byte</span>[]&gt; testResponseEntity(HttpSession session) <span class="keyword">throws</span></span><br><span class="line">            IOException &#123;</span><br><span class="line">        <span class="comment">//获取ServletContext对象</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> session.getServletContext();</span><br><span class="line">        <span class="comment">//获取服务器中文件的真实路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> servletContext.getRealPath(<span class="string">&quot;/static/img/img.png&quot;</span>);</span><br><span class="line">        <span class="comment">//创建输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(realPath);</span><br><span class="line">        <span class="comment">//创建字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[is.available()];</span><br><span class="line">        <span class="comment">//将流读到字节数组中</span></span><br><span class="line">        is.read(bytes);</span><br><span class="line">        <span class="comment">//创建HttpHeaders对象设置响应头信息</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; headers = <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">        <span class="comment">//设置要下载方式以及下载文件的名字</span></span><br><span class="line">        headers.add(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=1.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">//设置响应状态码</span></span><br><span class="line">        <span class="type">HttpStatus</span> <span class="variable">statusCode</span> <span class="operator">=</span> HttpStatus.OK;</span><br><span class="line">        <span class="comment">//创建ResponseEntity对象</span></span><br><span class="line">        ResponseEntity&lt;<span class="type">byte</span>[]&gt; responseEntity = <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(bytes, headers,</span><br><span class="line">                statusCode);</span><br><span class="line">        <span class="comment">//关闭输入流</span></span><br><span class="line">        is.close();</span><br><span class="line">        <span class="keyword">return</span> responseEntity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="二文件上传">二、文件上传：</h3>
<p>​
文件上传要求form表单的请求方式必须为post，并且添加属性enctype="multipart/form-data"
SpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息</p>
<ul>
<li>添加依赖：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在SpringMVC的配置文件中添加配置</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>控制器方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/testUp&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testUp</span><span class="params">(MultipartFile photo, HttpSession session)</span> <span class="keyword">throws</span></span><br><span class="line">    IOException &#123;</span><br><span class="line">    <span class="comment">//获取上传的文件的文件名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> photo.getOriginalFilename();</span><br><span class="line">    <span class="comment">//处理文件重名问题</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">hzName</span> <span class="operator">=</span> fileName.substring(fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    fileName = UUID.randomUUID().toString() + hzName;</span><br><span class="line">    <span class="comment">//获取服务器中photo目录的路径</span></span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> session.getServletContext();</span><br><span class="line">    <span class="type">String</span> <span class="variable">photoPath</span> <span class="operator">=</span> servletContext.getRealPath(<span class="string">&quot;photo&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(photoPath);</span><br><span class="line">    <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">        file.mkdir();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">finalPath</span> <span class="operator">=</span> photoPath + File.separator + fileName;</span><br><span class="line">    <span class="comment">//实现上传功能</span></span><br><span class="line">    photo.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(finalPath));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三拦截器">三、拦截器：</h3>
<ul>
<li>SpringMVC中的拦截器<strong>用于拦截控制器方法的执行</strong></li>
<li>SpringMVC中的拦截器需要实现HandlerInterceptor</li>
<li>SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.interceptor.FirstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;firstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/testRequestEntity&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;firstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过</span></span><br><span class="line"><span class="comment">mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>和Filter的区别：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221128171032117.png" style="zoom:50%;" /></p></li>
</ul>
<h4 id="拦截器的抽象方法">1、拦截器的抽象方法</h4>
<ul>
<li>preHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返
回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法</li>
<li>postHandle：控制器方法执行之后执行postHandle()</li>
<li>afterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation()</li>
</ul>
<h4 id="多个拦截器的执行顺序">2、多个拦截器的执行顺序：</h4>
<ul>
<li>若每个拦截器的preHandle()都返回true
<ul>
<li>此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关：preHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行</li>
<li>（类洋葱模型）</li>
</ul></li>
<li>若某个拦截器的preHandle()返回了false
<ul>
<li>它之前的拦截器的preHandle()都会执行，postHandle()都不执行</li>
<li>返回false的拦截器之前的拦截器的afterComplation()会执行</li>
</ul></li>
</ul>
<h3 id="四异常处理器">四、异常处理器：</h3>
<h4 id="基于配置的异常处理">1、基于配置的异常处理</h4>
<p>​
SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver</p>
<p>​
SpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver，使用方式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionMappings&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            properties的键表示处理器方法执行过程中出现的异常</span></span><br><span class="line"><span class="comment">            properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;java.lang.ArithmeticException&quot;</span>&gt;</span>error<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionAttribute&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="基于注解的异常处理">2、基于注解的异常处理</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@ControllerAdvice将当前类标识为异常处理的组件</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionController</span> &#123;</span><br><span class="line">    <span class="comment">//@ExceptionHandler用于设置所标识方法处理的异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(ArithmeticException.class)</span></span><br><span class="line">    <span class="comment">//ex表示当前请求处理中出现的异常对象</span></span><br><span class="line">  	<span class="keyword">public</span> String <span class="title function_">handleArithmeticException</span><span class="params">(Exception ex, Model model)</span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;ex&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>⑨ 工程类笔记</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC Chap2——RequestMapping注解与视图</title>
    <url>/2022/11/28/be94a86770d8/</url>
    <content><![CDATA[<h3 id="一注解功能">一、注解功能：</h3>
<p>​ <span class="citation"
data-cites="RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来">@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来</span>，建立映射关系。SpringMVC
接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。</p>
<h3 id="二注解位置">二、注解位置：</h3>
<p><span class="citation"
data-cites="RequestMapping标识一个类">@RequestMapping标识一个类</span>：设置映射请求的请求路径的初始信息
<span class="citation"
data-cites="RequestMapping标识一个方法">@RequestMapping标识一个方法</span>：设置映射请求请求路径的具体信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestMappingController</span> &#123;</span><br><span class="line">    <span class="comment">//此时请求映射所映射的请求的请求路径为：/test/testRequestMapping</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testRequestMapping&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testRequestMapping</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三注解的value与method属性">三、注解的value与method属性：</h3>
<ul>
<li><span class="citation"
data-cites="RequestMapping注解的value属性">@RequestMapping注解的value属性</span><strong>是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求</strong></li>
<li><span class="citation"
data-cites="RequestMapping注解的value属性必须设置">@RequestMapping注解的value属性必须设置</span>，至少通过请求地址匹配请求映射</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">    value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;,</span></span><br><span class="line"><span class="meta">    method = &#123;RequestMethod.GET, RequestMethod.POST&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestMapping</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用派生注解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">处理get请求的映射--&gt;@GetMapping</span><br><span class="line">处理post请求的映射--&gt;@PostMapping</span><br><span class="line">处理put请求的映射--&gt;@PutMapping</span><br><span class="line">处理delete请求的映射--&gt;@DeleteMapping</span><br></pre></td></tr></table></figure>
<h3
id="四注解的params与headers属性">四、注解的params与headers属性：</h3>
<ul>
<li>通过HTTP请求的params和headers来匹配请求，从而完成映射</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">    value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;</span></span><br><span class="line"><span class="meta">    ,method = &#123;RequestMethod.GET, RequestMethod.POST&#125;</span></span><br><span class="line"><span class="meta">    ,params = &#123;&quot;username&quot;,&quot;password!=123456&quot;&#125;</span></span><br><span class="line"><span class="meta">    ,headers = &#123;&quot;Host=localhost:8080&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestMapping</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五一些占位符与模糊匹配路径">五、一些占位符与模糊匹配路径：</h3>
<ul>
<li>？：表示任意的单个字符</li>
<li>*：表示任意的0个或多个字符</li>
<li>**：表示任意的一层或多层目录**</li>
<li>注意：在使用*<em>时，只能使用/*</em>/xxx的方式</li>
</ul>
<p>​
SpringMVC路径中的占位符常用于RESTful风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的@RequestMapping注解的value属性中通过占位符{xxx}表示传输的数据，再通过@PathVariable注解，将占位符所表示的数据赋值给控制器方法的形参。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRest/&#123;id&#125;/&#123;username&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRest</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id, <span class="meta">@PathVariable(&quot;username&quot;)</span> String username)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;id:&quot;</span>+id+<span class="string">&quot;,username:&quot;</span>+username);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终输出的内容为--&gt;id:1,username:admin</span></span><br></pre></td></tr></table></figure>
<h3
id="六在控制器方法中获取请求参数">六、在控制器方法中获取请求参数：</h3>
<h4 id="通过servlet-api">1、通过Servlet API:</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testParam&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testParam</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;username:&quot;</span>+username+<span class="string">&quot;,password:&quot;</span>+password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="控制器形参">2、控制器形参：</h4>
<p>​
在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet中就会将请求参数赋值给相应的形参</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testParam</span><span class="params">(String username, String password)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username:&quot;</span>+username+<span class="string">&quot;,password:&quot;</span>+password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="其他方法">3、其他方法：</h4>
<ul>
<li><p><span class="citation"
data-cites="RequestParam是将请求参数和控制器方法的形参创建映射关系">@RequestParam是将请求参数和控制器方法的形参创建映射关系</span>，一共有三个属性：</p>
<ul>
<li>value：指定为形参赋值的请求参数的参数名</li>
<li>required：设置是否必须传输此请求参数，默认值为true
若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有置
defaultValue属性，则页面报错400：Required String parameter 'xxx' is not
present；若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null</li>
<li>defaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为""时，则使用默认值为形参赋值</li>
</ul></li>
<li><p><span class="citation"
data-cites="RequestHeader是将请求头信息和控制器方法的形参创建映射关系">@RequestHeader是将请求头信息和控制器方法的形参创建映射关系</span></p></li>
<li><p><span class="citation"
data-cites="CookieValue是将cookie数据和控制器方法的形参创建映射关系">@CookieValue是将cookie数据和控制器方法的形参创建映射关系</span></p></li>
<li><p>POJO获取请求参数：</p>
<ul>
<li>可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testpojo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testPOJO</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终结果--&gt;User&#123;id=null, username=&#x27;张三&#x27;, password=&#x27;123&#x27;, age=23, sex=&#x27;男&#x27;,</span></span><br><span class="line">email=<span class="string">&#x27;123@qq.com&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="获取请求参数乱码怎么办">4、获取请求参数乱码怎么办？</h4>
<p>​
可以使用SpringMVC提供的编码过滤器CharacterEncodingFilter，但是必须在web.xml中进行注册。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置springMVC的编码过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filterclass</span>&gt;</span></span><br><span class="line">		org.springframework.web.filter.CharacterEncodingFilter</span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>SpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效</li>
</ul>
<h3
id="七返回请求的数据域对象共享数据">七、返回请求的数据（域对象共享数据）</h3>
<ul>
<li><p>(request,session[浏览器开启到浏览器关闭],servlet
context[服务器开启到服务器关闭])</p></li>
<li><p>request域共享数据</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testServletAPI&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testServletAPI</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    request.setAttribute(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,servletAPI&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;  <span class="comment">//视图名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testModel</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,Model&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testMap&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testMap</span><span class="params">(Map&lt;String, Object&gt; map)</span>&#123;</span><br><span class="line">    map.put(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,Map&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModelMap&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testModelMap</span><span class="params">(ModelMap modelMap)</span>&#123;</span><br><span class="line">    modelMap.addAttribute(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,ModelMap&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>session域共享数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testSession&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testSession</span><span class="params">(HttpSession session)</span>&#123;</span><br><span class="line">    session.setAttribute(<span class="string">&quot;testSessionScope&quot;</span>, <span class="string">&quot;hello,session&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>application域共享数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testApplication&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testApplication</span><span class="params">(HttpSession session)</span>&#123;</span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> session.getServletContext();</span><br><span class="line">    application.setAttribute(<span class="string">&quot;testApplicationScope&quot;</span>, <span class="string">&quot;hello,application&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="八springmvc中的视图">八、SpringMVC中的视图：</h3>
<p>​
SpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户</p>
<ul>
<li>当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置
的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转</li>
</ul>
<h4 id="转发视图">1、转发视图</h4>
<ul>
<li><p>场景：你想要跳转至某个其他的请求，而不是直接跳转至某个固定的视图解析器对应的HTML页面</p></li>
<li><p>SpringMVC中默认的转发视图是InternalResourceView</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testHello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testForward</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/testForward&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testForward</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/testHello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当控制器方法中所设置的视图名称以"forward:"为前缀时，创建InternalResourceView视图，此时的视
图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀"forward:"去掉，剩余部
分作为最终路径通过转发的方式实现跳转</li>
</ul>
<h4 id="重定向视图">2、重定向视图</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testHello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testForward</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/testRedirect&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRedirect</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/testHello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>转发和重定向的区别：
<ul>
<li>转发：算浏览器的一次请求，转发是由服务器进行转发的</li>
<li>重定向：算浏览器的两次请求，浏览器会再去请求重定向的地址。</li>
</ul></li>
</ul>
<h4 id="视图控制器-view-controller">3、视图控制器 view-controller</h4>
<p>​
当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用viewcontroller
标签进行表示.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">path：设置处理的请求地址</span></span><br><span class="line"><span class="comment">view-name：设置请求地址所对应的视图名称</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/testView&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;success&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:view-controller</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​
当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>⑨ 工程类笔记</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC Chap1——简介与入门</title>
    <url>/2022/11/28/7fbe0f73c350/</url>
    <content><![CDATA[<h3 id="一springmvc简介">一、SpringMVC简介：</h3>
<h4 id="mvc架构">1、MVC架构</h4>
<ul>
<li>MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分</li>
<li>M：Model，模型层，指工程中的JavaBean，作用是处理数据，JavaBean分为两类：
<ul>
<li>一类称为实体类Bean：专门存储业务数据的，如 Student、User 等</li>
<li>一类称为业务处理 Bean：指 Service 或 Dao
对象，专门用于处理业务逻辑和数据访问。</li>
</ul></li>
<li>V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据</li>
<li>C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器</li>
<li>用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器</li>
</ul>
<h4 id="springmvc及特点">2、SpringMVC及特点</h4>
<p>​ SpringMVC是Spring的一个后续产品，是Spring的一个子项目</p>
<ul>
<li><p>基于原生的Servlet，通过了功能强大的前端控制器DispatcherServlet，对请求和响应进行统一</p></li>
<li><p>内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可</p></li>
<li><p>性能卓著，尤其适合现代大型、超大型互联网项目要求</p></li>
</ul>
<h3 id="二springmvc快速上手指南">二、SpringMVC快速上手指南</h3>
<h4 id="创建maven-web工程">1、创建Maven Web工程：</h4>
<ul>
<li>引入依赖：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- SpringMVC --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 日志 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ServletAPI --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Spring5和Thymeleaf整合包 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="配置web.xml">2、配置web.xml</h4>
<ul>
<li>注册SpringMVC的<strong>前端控制器DispatcherServlet</strong></li>
<li>可通过init-param标签设置SpringMVC配置文件的位置和名称，通过load-on-startup标签设置
SpringMVC前端控制器DispatcherServlet的初始化时间</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- contextConfigLocation为固定值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的 src/main/resources --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--作为框架的核心组件，在启动过程中有大量的初始化操作要做,而这些操作放在第一次请求时才执行会严重影响访问速度</span></span><br><span class="line"><span class="comment">    因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- /所匹配的请求可以是/login或.html或.js或.css方式的请求路径,但是/不能匹配.jsp请求路径的请求--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="创建请求控制器">3、创建请求控制器：</h4>
<p>​
<strong>由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要
创建处理具体请求的类，即请求控制器</strong></p>
<p>​
请求控制器中每一个处理请求的方法成为控制器方法,因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过@Controller注解将其标识为一个控制层组件，交给Spring的IoC容器管理，此时SpringMVC才能够识别控制器的存在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建springmvc的配置文件">4、创建SpringMVC的配置文件：</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自动扫描包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.fantast.mvc.controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置Thymeleaf视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateEngine&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateResolver&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">bean</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 视图前缀 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 视图后缀 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.html&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateMode&quot;</span> <span class="attr">value</span>=<span class="string">&quot;HTML5&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    处理静态资源，例如html、js、css、jpg</span></span><br><span class="line"><span class="comment">    若只设置该标签，则只能访问静态资源，其他请求则无法访问</span></span><br><span class="line"><span class="comment">    此时必须设置&lt;mvc:annotation-driven/&gt;解决问题</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启mvc注解驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 处理响应中文内容乱码 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultCharset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;supportedMediaTypes&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">value</span>&gt;</span>text/html<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">value</span>&gt;</span>application/json<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="实现对首页的访问">5、实现对首页的访问：</h4>
<ul>
<li>在WEB-INF文件夹下创建templates文件夹，再创建index.html文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @RequestMapping注解：处理请求和控制器方法之间的映射关系</span></span><br><span class="line"><span class="comment">// @RequestMapping注解的value属性可以通过请求地址匹配请求，/表示的当前工程的上下文路径</span></span><br><span class="line"><span class="comment">// localhost:8080/springMVC/</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//设置视图名称</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="流程总结">6、流程总结：</h4>
<p>​
浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器DispatcherServlet处理。前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器，
​
将请求地址和控制器中@RequestMapping注解的value属性值进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视图所对应页面</p>
]]></content>
      <categories>
        <category>⑨ 工程类笔记</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven Chap4——Maven单一架构案例</title>
    <url>/2022/11/27/d75a3ba3c1a2/</url>
    <content><![CDATA[<ul>
<li><p>单一架构也叫『all-in-one』结构，就是所有代码、配置文件、各种资源都在同一个工程。</p>
<ul>
<li><p>一个项目包含一个工程</p></li>
<li><p>导出一个 war 包</p></li>
<li><p>放在一个 Tomcat 上运行</p></li>
</ul></li>
</ul>
<h3 id="一引入依赖">一、引入依赖</h3>
<ul>
<li><p>依赖搜索网址：https://mvnrepository.com/</p></li>
<li><p>确定技术选型：确定我们项目中要使用哪些技术</p></li>
<li><p>到 mvnrepository 网站搜索具体技术对应的具体依赖信息</p></li>
</ul>
<p>确定这个技术使用哪个版本的依赖</p>
<ul>
<li>考虑因素1：看是否有别的技术要求这里必须用某一个版本</li>
<li>考虑因素2：如果没有硬性要求，那么选择较高版本或下载量大的版本</li>
</ul>
<p>此Demo，依赖如下：</p>
<ul>
<li><p>持久化层所需依赖</p>
<ul>
<li><p>mysql:mysql-connector-java:5.1.37</p></li>
<li><p>com.alibaba:druid:1.2.8</p></li>
<li><p>commons-dbutils:commons-dbutils:1.6</p></li>
</ul></li>
<li><p>表述层所需依赖</p>
<ul>
<li><p>javax.servlet:javax.servlet-api:3.1.0</p></li>
<li><p>org.thymeleaf:thymeleaf:3.0.11.RELEASE</p></li>
</ul></li>
<li><p>辅助功能所需依赖</p>
<ul>
<li><p>junit:junit:4.12</p></li>
<li><p>ch.qos.logback:logback-classic:1.2.3</p></li>
</ul></li>
</ul>
<p>完整依赖信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">5.1</span><span class="number">.37</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/com.alibaba/druid --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.2</span><span class="number">.8</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/commons-dbutils/commons-dbutils --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-dbutils&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.6</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.1</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.thymeleaf/thymeleaf --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;thymeleaf&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.0</span><span class="number">.11</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/junit/junit --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">4.12</span>&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/ch.qos.logback/logback-classic --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.2</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="二建包">二、建包：</h3>
<table>
<thead>
<tr class="header">
<th>package 功能</th>
<th>package 名称</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>主包</td>
<td>com.fantast.demo</td>
</tr>
<tr class="even">
<td>子包[实体类]</td>
<td>com.fantast.demo.entity</td>
</tr>
<tr class="odd">
<td>子包[Servlet基类包]</td>
<td>com.fantast.demo.servlet.base</td>
</tr>
<tr class="even">
<td>子包[Servlet模块包]</td>
<td>com.fantast.demo.servlet.module</td>
</tr>
<tr class="odd">
<td>子包[Service接口包]</td>
<td>com.fantast.demo.service.api</td>
</tr>
<tr class="even">
<td>子包[Service实现类包]</td>
<td>com.fantast.demo.service.impl</td>
</tr>
<tr class="odd">
<td>子包[Dao接口包]</td>
<td>com.fantast.demo.dao.api</td>
</tr>
<tr class="even">
<td>子包[Dao实现类包]</td>
<td>com.fantast.demo.dao.impl</td>
</tr>
<tr class="odd">
<td>子包[Filter]</td>
<td>com.fantast.demo.filter</td>
</tr>
<tr class="even">
<td>子包[异常类包]</td>
<td>com.fantast.demo.exception</td>
</tr>
<tr class="odd">
<td>子包[工具类]</td>
<td>com.fantast.demo.util</td>
</tr>
<tr class="even">
<td>子包[测试类]</td>
<td>com.fantast.demo.test</td>
</tr>
</tbody>
</table>
<h3 id="三搭建持久化层">三、搭建持久化层：</h3>
<h4
id="数据建模新建物理模型逻辑模型">1、数据建模，新建物理模型+逻辑模型</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database db_imperial_court;</span><br><span class="line"></span><br><span class="line">use db_imperial_court;</span><br><span class="line"></span><br><span class="line">create table t_emp</span><br><span class="line">(</span><br><span class="line">    emp_id         int primary key auto_increment,</span><br><span class="line">    emp_name       char(100) not null,</span><br><span class="line">    emp_position   char(100) not null,</span><br><span class="line">    login_account  char(100) not null unique,</span><br><span class="line">    login_password char(100) not null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into t_emp(emp_name, emp_position, login_account, login_password)</span><br><span class="line">values (&#x27;爱新觉罗·玄烨&#x27;, &#x27;emperor&#x27;, &#x27;xiaoxuanzi1654&#x27;, &#x27;25325C896624D444B2E241807DCAC98B&#x27;), # 16540504</span><br><span class="line">       (&#x27;纳兰明珠&#x27;, &#x27;minister&#x27;, &#x27;brightball1635&#x27;, &#x27;A580D0EF93C22036C859E194C14CB777&#x27;),   # 16351119</span><br><span class="line">       (&#x27;赫舍里·索额图&#x27;, &#x27;minister&#x27;, &#x27;tutu1636&#x27;, &#x27;E40FD7D49B8B7EF46F47407D583C3538&#x27;); # 17030921</span><br><span class="line"></span><br><span class="line">create table t_memorials</span><br><span class="line">(</span><br><span class="line">    memorials_id          int primary key auto_increment,</span><br><span class="line">    memorials_title       char(100)     not null,</span><br><span class="line">    memorials_content     varchar(5000) not null,</span><br><span class="line">    memorials_emp         int           not null,</span><br><span class="line">    memorials_create_time char(100),</span><br><span class="line">    feedback_time       char(100),</span><br><span class="line">    feedback_content    varchar(1000),</span><br><span class="line">    memorials_status      int           not null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into t_memorials(memorials_title,</span><br><span class="line">                      memorials_content,</span><br><span class="line">                      memorials_emp,</span><br><span class="line">                      memorials_create_time,</span><br><span class="line">                      feedback_time,</span><br><span class="line">                      feedback_content,</span><br><span class="line">                      memorials_status)</span><br><span class="line">values (&#x27;浙江巡抚奏钱塘堤决口疏&#x27;, &#x27;皇上啊，不好啦！钱塘江发大水啦！堤坝冲毁啦！您看这咋弄啊！&#x27;, 2, &#x27;1690-05-07&#x27;, null, null, 0),</span><br><span class="line">       (&#x27;左都御史参鳌拜圈地疏&#x27;, &#x27;皇上啊，鳌拜这厮不是东西呀！占老百姓的地哇！还打人呀！您看咋弄啊！&#x27;, 3, &#x27;1690-04-14&#x27;, null, null, 0),</span><br><span class="line">       (&#x27;都察院劾吴三桂不臣疏&#x27;, &#x27;皇上啊，不得了啦！吴三桂那孙子想造反呀！&#x27;, 2, &#x27;1693-11-18&#x27;, null, null, 0),</span><br><span class="line">       (&#x27;兵部奏准噶尔犯境疏&#x27;, &#x27;皇上啊，不得了啦！葛尔丹要打过来了呀！&#x27;, 3, &#x27;1693-11-18&#x27;, null, null, 0),</span><br><span class="line">       (&#x27;朝鲜使臣朝拜事宜呈皇上御览&#x27;, &#x27;皇上啊！朝鲜国的人要来啦！咱们请他们吃猪肉炖粉条子吧！&#x27;, 2, &#x27;1680-06-11&#x27;, null, null, 0),</span><br><span class="line">       (&#x27;英吉利炮舰购买事宜疏&#x27;, &#x27;皇上啊！英国的小船船咱们买多少啊？&#x27;, 3, &#x27;1680-06-12&#x27;, null, null, 0),</span><br><span class="line">       (&#x27;劾杭州织造贪墨疏&#x27;, &#x27;皇上啊！杭州织造有问题啊！&#x27;, 2, &#x27;1680-06-13&#x27;, null, null, 0),</span><br><span class="line">       (&#x27;禀畅春园落成疏&#x27;, &#x27;皇上啊！畅春园修好了哇！您啥时候过来看看呀！&#x27;, 3, &#x27;1680-06-14&#x27;, null, null, 0),</span><br><span class="line">       (&#x27;请旨木兰秋狝疏&#x27;, &#x27;皇上啊！秋天到啦，又该打猎啦！&#x27;, 2, &#x27;1680-06-15&#x27;, null, null, 0),</span><br><span class="line">       (&#x27;核准西北军饷银两疏&#x27;, &#x27;皇上啊！您看看这钱数算的对不对呀！&#x27;, 3, &#x27;1680-06-16&#x27;, null, null, 0),</span><br><span class="line">       (&#x27;请旨裁撤三藩疏&#x27;, &#x27;皇上啊！咱们不裁撤三藩就芭比Q了哇！&#x27;, 2, &#x27;1680-06-17&#x27;, null, null, 0),</span><br><span class="line">       (&#x27;蒙古王公进京朝拜疏&#x27;, &#x27;皇上啊！蒙古王公要来啦！咱们请他们吃猪肉炖粉条子吧！&#x27;, 3, &#x27;1680-06-18&#x27;, null, null, 0),</span><br><span class="line">       (&#x27;礼部请旨九阿哥赐名疏&#x27;, &#x27;皇上啊！您看九阿哥该叫什么名字呀？&#x27;, 2, &#x27;1680-06-19&#x27;, null, null, 0),</span><br><span class="line">       (&#x27;户部尚书请旨告老还乡疏&#x27;, &#x27;皇上啊！臣想回家养老啦！您看看啥时候给臣把俸禄结一下啊！&#x27;, 3, &#x27;1680-06-20&#x27;, null, null, 0),</span><br><span class="line">       (&#x27;查江宁织造贪墨疏&#x27;, &#x27;皇上啊！江宁织造有问题啊！&#x27;, 2, &#x27;1680-06-21&#x27;, null, null, 0)</span><br><span class="line">       ;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Emp</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer empId;</span><br><span class="line">    <span class="keyword">private</span> String empName;</span><br><span class="line">    <span class="keyword">private</span> String empPosition;</span><br><span class="line">    <span class="keyword">private</span> String loginAccount;</span><br><span class="line">    <span class="keyword">private</span> String loginPassword;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Memorials</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer memorialsId;</span><br><span class="line">    <span class="keyword">private</span> String memorialsTitle;</span><br><span class="line">    <span class="keyword">private</span> String memorialsContent;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 奏折摘要数据库没有，这里是为了配和页面显示</span></span><br><span class="line">    <span class="keyword">private</span> String memorialsContentDigest;</span><br><span class="line">    <span class="keyword">private</span> Integer memorialsEmp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 员工姓名数据库没有，这里是为了配合页面显示</span></span><br><span class="line">    <span class="keyword">private</span> String memorialsEmpName;</span><br><span class="line">    <span class="keyword">private</span> String memorialsCreateTime;</span><br><span class="line">    <span class="keyword">private</span> String feedbackTime;</span><br><span class="line">    <span class="keyword">private</span> String feedbackContent;</span><br><span class="line">    <span class="keyword">private</span> Integer memorialsStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数据库连接信息">2、数据库连接信息</h4>
<ul>
<li>​ Maven 约定目录结构中的 resources
目录，这个目录存放各种配置文件</li>
</ul>
<h3
id="四一个最普通的java工程的逻辑架构框架如下">四、一个最普通的Java工程的逻辑架构，框架如下：</h3>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221127191410956.png" /></p>
<ul>
<li><p>entity包：</p>
<ul>
<li>里面的类是实体类</li>
</ul></li>
<li><p>dao包：</p>
<ul>
<li>完成单个SQL逻辑的类，继承自BaseDao</li>
<li>直接跟数据库完成SQL交互</li>
</ul></li>
<li><p>service包：</p>
<ul>
<li>执行业务逻辑的类，负责根据参数执行相关的业务逻辑</li>
</ul></li>
<li><p>servlet包：</p>
<ul>
<li><p>base</p>
<ul>
<li>负责模板渲染：</li>
<li>根据路径，调用不同的Servlet模块</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221127191152881.png" /></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221127191200817.png" /></p></li>
</ul></li>
<li><p>filter包：</p>
<ul>
<li><p>一些过滤器，比如说事务过滤器：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221127191142676.png" /></p></li>
</ul></li>
<li><p>util包：</p>
<ul>
<li>一些依赖项</li>
</ul></li>
<li><p>resources包：</p>
<ul>
<li>存放着配置文件，比如说jdbc的配置文件，日志文件等等</li>
</ul></li>
<li><p>webapp结构：</p>
<ul>
<li>WEB-INF
<ul>
<li>pages：一些静态的html文件</li>
</ul></li>
<li>web.xml
<ul>
<li>web应用配置，Servlet、Filter、视图都需要在里面配置</li>
</ul></li>
</ul></li>
<li><p>test包：</p>
<ul>
<li>用于做单元测试</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>⑨ 工程类笔记</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven Chap3——使用Maven IDEA环境</title>
    <url>/2022/11/26/672a767ba264/</url>
    <content><![CDATA[<h3 id="一创建父工程">一、创建父工程</h3>
<ul>
<li><p>创建一个maven的project</p></li>
<li><p>开启自动导入，因为 Project、Module 新创建或 pom.xml
每次修改时都应该让 IDEA 重新加载 Maven 信息。这对 Maven
目录结构认定、Java 源程序编译、依赖 jar
包的导入都有非常关键的影响。</p></li>
<li><p>另外也可以通过 IDEA 的 Settings 设置来开启：</p></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221126224236617.png" /></p>
<ul>
<li>每次创建 Project 后都需要设置 Maven 家目录位置，</li>
<li>否则 IDEA 将使用内置的 Maven
核心程序（不稳定）并使用默认的本地仓库位置。配置之后，IDEA
会根据我们在这里指定的 Maven 家目录自动识别到我们在 settings.xml
配置文件中指定的本地仓库。</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221126224741288.png" /></p>
<h3 id="二创建java模块工程">二、创建JAVA模块工程：</h3>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221126224858569.png" /></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221126224903591.png" /></p>
<h3 id="三创建web模块工程">三、创建Web模块工程</h3>
<ul>
<li><p>按照前面的同样操作创建模块，<strong>此时</strong>这个模块其实还是一个<strong>Java模块</strong>。</p></li>
<li><p>修改打包方式</p></li>
</ul>
<h4 id="相关web设定">1、相关Web设定：</h4>
<p>首先打开项目结构菜单</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221126225025008.png" /></p>
<p>然后到 Facets 下查看 IDEA 是否已经帮我们自动生成了 Web
设定。正常来说只要我们确实设置了打包方式为 war，那么 IDEA 2019
版就会自动生成 Web 设定。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221126225036625.png" /></p>
<p>另外，对于 IDEA 2018 诸版本没有自动生成 Web
设定，那么请参照下面两图，我们自己创建：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221126225044844.png" /></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221126225050661.png" /></p>
<ul>
<li>借助IDEA生成web.xml</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221126225102853.png" /></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221126225109037.png" /></p>
<ul>
<li><p>设置Web资源的根目录：</p></li>
<li><p>结合 Maven 的目录结构，Web 资源的根目录需要设置为 src/main/webapp
目录。</p></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221126225130334.png" /></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221126225138583.png" /></p>
<h3 id="四一些其他操作">四、一些其他操作：</h3>
<ul>
<li>IDEA中可以直接执行Maven命令，如果需要的话</li>
<li>可以在IDEA中查看某个模块的依赖信息</li>
<li>导入工程：
<ul>
<li>Git</li>
<li>工程目录，记得设置Maven home directory</li>
</ul></li>
<li>导入模块：
<ul>
<li>先将模块复制到我们的目录下</li>
<li>然后通过Project Settings - Modules - Import Module 选中
为Maven模块即可</li>
<li>完成导入后，需要修改刚才导入的module中pox.xml的父工程坐标为我们现有的父工程坐标</li>
</ul></li>
</ul>
<h3 id="五生命周期概念">五、生命周期概念：</h3>
<p>​ 为了让构建过程自动化完成，Maven
设定了三个生命周期，生命周期中的每一个环节对应构建过程中的一个操作。</p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="header">
<th>生命周期名称</th>
<th style="text-align: center;">作用</th>
<th>各个环节</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Clean</td>
<td style="text-align: center;">清理操作相关</td>
<td>pre-clean<br />clean <br />post-clean</td>
</tr>
<tr class="even">
<td>Site</td>
<td style="text-align: center;">生成站点相关</td>
<td>pre-site <br />site<br />post-site <br />deploy-site</td>
</tr>
<tr class="odd">
<td>Default</td>
<td style="text-align: center;">主要构建过程</td>
<td>validate<br />generate-sources<br />process-sources<br />generate-resources<br />process-resources
复制并处理资源文件，至目标目录，准备打包。 <br />compile 编译项目 main
目录下的源代码<br />process-classes <br />generate-test-sources
<br />process-test-sources <br />generate-test-resources
<br />process-test-resources 复制并处理资源文件，至目标测试目录。
<br />test-compile 编译测试源代码。 <br />process-test-classes test
使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。<br />prepare-package
package 接受编译好的代码，打包成可发布的格式，如JAR。
<br />pre-integration-test <br />integration-test
<br />post-integration-test <br />verify
<br />install将包安装至本地仓库，以让其它项目依赖。
<br />deploy将最终的包复制到远程的仓库，以让其它开发人员共享；或者部署到服务器上运行（需借助插件，例如：cargo）。</td>
</tr>
</tbody>
</table>
<ul>
<li>前面三个生命周期彼此是独立的。</li>
<li>在任何一个生命周期内部，执行任何一个具体环节的操作，都是从本周期最初的位置开始执行，直到指定的地方。</li>
</ul>
<p>Maven
之所以这么设计其实就是为了提高构建过程的自动化程度：让使用者只关心最终要干的即可，过程中的各个环节是自动执行的</p>
<h3 id="六插件和目标">六、插件和目标：</h3>
<ul>
<li><p>Maven 的核心程序仅仅负责宏观调度，不做具体工作。具体工作都是由
Maven 插件完成的。例如：编译就是由 maven-compiler-plugin-3.1.jar
插件来执行的</p></li>
<li><p>一个插件可以对应多个目标，而每一个目标都和生命周期中的某一个环节对应。</p>
<p>Default 生命周期中有 compile 和 test-compile
两个和编译相关的环节，这两个环节对应 compile 和 test-compile
两个目标，而这两个目标都是由 maven-compiler-plugin-3.1.jar
插件来执行的。</p></li>
</ul>
<h3 id="七仓库">七、仓库：</h3>
<ul>
<li>本地仓库：在当前电脑上，为电脑上所有 Maven 工程服务</li>
<li>远程仓库：需要联网
<ul>
<li>局域网：我们自己搭建的 Maven 私服，例如使用 Nexus 技术。</li>
<li>Internet
<ul>
<li>中央仓库</li>
<li>镜像仓库：内容和中央仓库保持一致，但是能够分担中央仓库的负载，同时让用户能够就近访问提高下载速度，例如：Nexus
aliyun</li>
</ul></li>
</ul></li>
</ul>
<p>建议：不要中央仓库和阿里云镜像混用，否则 jar
包来源不纯，彼此冲突。</p>
]]></content>
      <categories>
        <category>⑨ 工程类笔记</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap2 Maven的命令行使用</title>
    <url>/2022/11/24/857b065dd01a/</url>
    <content><![CDATA[<h3 id="一maven中的坐标">一、Maven中的坐标</h3>
<p>使用三个<strong>『向量』</strong>在<strong>『Maven的仓库』</strong>中<strong>唯一</strong>的定位到一个<strong>『jar』</strong>包。</p>
<ul>
<li><strong>groupId</strong>：公司或组织的 id
<ul>
<li>例如：com.atguigu.maven</li>
</ul></li>
<li><strong>artifactId</strong>：一个项目或者是项目中的一个模块的
id，模块的名称，将来作为 Maven 工程的工程名</li>
<li><strong>version</strong>：版本号
<ul>
<li>例如：SNAPSHOT 表示快照版本，正在迭代过程中，不稳定的版本</li>
<li>例如：RELEASE 表示正式版本</li>
</ul></li>
<li>示例：
<ul>
<li>groupId：com.atguigu.maven</li>
<li>artifactId：pro01-atguigu-maven</li>
<li>version：1.0-SNAPSHO</li>
</ul></li>
</ul>
<h5 id="坐标和仓库中-jar-包的存储路径之间的对应关系">1、坐标和仓库中 jar
包的存储路径之间的对应关系</h5>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Maven本地仓库根目录\javax\servlet\servlet-api\2.5\servlet-api-2.5.jar</span><br></pre></td></tr></table></figure>
<h3 id="二实验一">二、实验一：</h3>
<ul>
<li><p>创建工作空间</p></li>
<li><p>运行 <strong>mvn archetype:generate</strong> 命令</p></li>
<li><p>自动生成的pom.xml文件如下：</p></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当前Maven工程的坐标 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fantast.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">&lt;!-- 当前Maven工程的打包方式，可选值有下面三种： --&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- jar：表示这个工程是一个Java工程  --&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- war：表示这个工程是一个Web工程 --&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- pom：表示这个工程是“管理其他工程”的工程 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 工程构建过程中读取源码时使用的字符集 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- 当前工程所依赖的jar包 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用dependency配置一个具体的依赖 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 在dependency标签内使用具体的坐标依赖我们需要的一个jar包 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- scope标签配置依赖的范围 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="三核心概念pom">三、核心概念——POM</h3>
<ul>
<li><p><strong>P</strong>roject <strong>O</strong>bject
<strong>M</strong>odel，项目对象模型</p></li>
<li><p>POM
表示将工程抽象为一个模型，再用程序中的对象来描述这个模型。这样我们就可以用程序来管理项目了。</p></li>
<li><p>POM 理念集中体现在 Maven 工程根目录下 <strong>pom.xml</strong>
这个配置文件中。所以这个 pom.xml 配置文件就是 Maven
工程的核心配置文件。其实学习 Maven
就是学这个文件怎么配置，各个配置有什么用。</p></li>
</ul>
<h3 id="四核心概念约定的目录结构">四、核心概念：约定的目录结构：</h3>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221125150331179.png" /></p>
<p>​ Maven
为了让构建过程能够尽可能自动化完成，所以必须约定目录结构的作用。例如：Maven
执行编译操作，必须先去 Java 源程序目录读取 Java
源代码，然后执行编译，最后把编译结果存放在 target 目录。</p>
<p>​ Maven
对于目录结构这个问题，没有采用配置的方式，而是基于约定。这样会让我们在开发过程中非常方便。如果每次创建
Maven
工程后，还需要针对各个目录的位置进行详细的配置，那肯定非常麻烦。</p>
<ul>
<li><strong>目前开发领域的技术发展趋势就是：约定大于配置，配置大于编码。</strong></li>
</ul>
<h3 id="五主体程序与测试程序">五、主体程序与测试程序：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.maven;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> i + j;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.maven;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.maven.Calculator;</span><br><span class="line">	</span><br><span class="line"><span class="comment">// 静态导入的效果是将Assert类中的静态资源导入当前类</span></span><br><span class="line"><span class="comment">// 这样一来，在当前类中就可以直接使用Assert类中的静态资源，不需要写类名</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorTest</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSum</span><span class="params">()</span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 1.创建Calculator对象</span></span><br><span class="line">		<span class="type">Calculator</span> <span class="variable">calculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 2.调用Calculator对象的方法，获取到程序运行实际的结果</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">actualResult</span> <span class="operator">=</span> calculator.sum(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 3.声明一个变量，表示程序运行期待的结果</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">expectedResult</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 4.使用断言来判断实际结果和期待结果是否一致</span></span><br><span class="line">		<span class="comment">// 如果一致：测试通过，不会抛出异常</span></span><br><span class="line">		<span class="comment">// 如果不一致：抛出异常，测试失败</span></span><br><span class="line">		assertEquals(expectedResult, actualResult);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="六执行-maven-的构建命令">六、执行 Maven 的构建命令</h3>
<ul>
<li><p>mvn clean 删除target目录</p></li>
<li><p>mvn complie 主程序编译 —— 放置 target/classes 目录下</p></li>
<li><p>mvn test-compile 测试程序编译</p></li>
<li><p>mvn test 测试，测试报告存放在 target/surefire-reports</p></li>
<li><p>mvn package 打包，jar包存放在target下</p></li>
<li><p>mvn install 安装：将本地构建过程中生成的 jar 包存入 Maven
本地仓库。这个 jar 包在 Maven 仓库中的路径是根据它的坐标生成的。</p>
<ul>
<li>```xml <groupId>com.fantast.maven</groupId>
<artifactId>pro01-maven-java</artifactId>
<version>1.0-SNAPSHOT</version> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 安装操作还会将 pom.xml 文件转换为 XXX.pom 文件一起存入本地仓库。所以我们在 Maven 的本地仓库中想看一个 jar 包原始的 pom.xml 文件时，查看对应 XXX.pom 文件即可，它们是名字发生了改变，本质上是同一个文件。</span><br><span class="line"></span><br><span class="line">### 七、创建Maven版的Web工程：</span><br><span class="line"></span><br><span class="line">- 生成web工程：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```log</span><br><span class="line">mvn archetype:generate # 然后选择第10个配置项</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>生成的xml中，打包形式为war</p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;packaging&gt;war&lt;/packaging&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>在java包下创建Servlet类：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.maven;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">		</span><br><span class="line">		response.getWriter().write(<span class="string">&quot;hello maven web&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在web.xml中注册Servlet</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>helloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.atguigu.maven.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>helloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/helloServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>此时执行mvn compile
命令会出错，因为我们的Web工程用到了HttpServlet类</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221126100543941.png" /></p>
<ul>
<li><p>所以需要在pom.xml中加入以下依赖信息，然后重新执行mvn compile</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>mvn package
将web工程打包成war包，然后部署到Tomcat上运行即可</p></li>
</ul>
<h3 id="八让web工程依赖java工程">八、让Web工程依赖Java工程</h3>
<p>​ Web 工程依赖的 Java 工程其实就是 Web 工程里导入的 jar 包。最终 Java
工程会变成 jar 包，放在 Web 工程的 WEB-INF/lib 目录下。查看 war
包内的结构，我们看到被 Web 工程依赖的 Java 工程确实是会变成 Web 工程的
WEB-INF/lib 目录下的 jar 包</p>
<ul>
<li>pom.xml 中通过添加如下内容，就可以依赖java工程</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>mvn dependency:list 查看当前 Web 工程所依赖的 jar 包的列表</li>
<li>mvn dependency:tree 以树形结构查看当前 Web 工程的依赖信息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[INFO] ------------------------&lt; com.fantast.web:pro2 &gt;------------------------</span><br><span class="line">[INFO] Building pro2 Maven Webapp 1.0-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ war ]---------------------------------</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ pro2 ---</span><br><span class="line">[INFO] com.fantast.web:pro2:war:1.0-SNAPSHOT</span><br><span class="line">[INFO] +- junit:junit:jar:4.12:test</span><br><span class="line">[INFO] |  \- org.hamcrest:hamcrest-core:jar:1.3:test</span><br><span class="line">[INFO] +- javax.servlet:javax.servlet-api:jar:3.1.0:provided</span><br><span class="line">[INFO] \- com.fantast.maven:pro1:jar:1.0-SNAPSHOT:compile</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  0.901 s</span><br><span class="line">[INFO] Finished at: 2022-11-26T11:38:04+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>我们在 pom.xml 中并没有依赖
hamcrest-core，但是它却被加入了我们依赖的列表。原因是：junit
依赖了hamcrest-core，然后基于依赖的传递性，hamcrest-core
被传递到我们的工程了。</p>
<h3 id="九maven依赖的依赖范围">九、Maven依赖的依赖范围</h3>
<p>标签的位置：dependencies/dependency/<strong>scope</strong></p>
<p>标签的可选值：<strong>compile</strong>/<strong>test</strong>/<strong>provided</strong>/system/runtime/<strong>import</strong></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221126115050193.png" /></p>
<p>不同标签的可选值区别如下：</p>
<ul>
<li><p>compile：通常使用的第三方框架的 jar
包这样在项目实际运行时真正要用到的 jar 包都是以 compile
范围进行依赖的。比如 SSM 框架所需jar包。</p></li>
<li><p>test：测试过程中使用的 jar 包，以 test 范围依赖进来。比如
junit。</p></li>
<li><p>provided：在开发过程中需要用到的“服务器上的 jar 包”通常以
provided 范围依赖进来。比如 servlet-api、jsp-api。而这个范围的 jar
包之所以不参与部署、不放进 war 包，就是避免和服务器上已有的同类 jar
包产生冲突，同时减轻服务器的负担。说白了就是：“<strong>服务器上已经有了，你就别带啦！</strong>”</p></li>
<li><p>开发和部署到服务器的区别（war包部署）：通过compile范围依赖的jar包会放入war包，通过test或provided范围依赖的jar包不会放入war包。</p></li>
</ul>
<h3
id="十maven依赖的传递性与依赖排除">十、Maven依赖的传递性与依赖排除</h3>
<h4 id="传递性">1、传递性</h4>
<ul>
<li><p>在 A 依赖 B，B 依赖 C 的前提下，C 是否能够传递到 A，取决于 B 依赖
C 时使用的依赖范围。</p>
<ul>
<li><p>B 依赖 C 时使用 compile 范围：可以传递</p></li>
<li><p>B 依赖 C 时使用 test 或 provided 范围：不能传递，所以需要这样的
jar 包时，就必须在需要的地方明确配置依赖才可以</p></li>
</ul></li>
</ul>
<h4 id="依赖的排除">2、依赖的排除：</h4>
<ul>
<li><p>当 A 依赖 B，B 依赖 C 而且 C 可以传递到 A 的时候，A 不想要
C，需要在 A 里面把 C 排除掉。而往往这种情况都是为了避免 jar
包之间的冲突。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221126123336166.png" /></p></li>
</ul>
<p>​ 所以配置依赖的排除其实就是阻止某些 jar 包的传递。因为这样的 jar
包传递过来会和其他 jar 包冲突</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 使用excludes标签配置依赖的排除	--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 在exclude标签中配置一个具体的排除 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 指定要排除的依赖的坐标（不需要写version） --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="十一继承">十一、继承：</h3>
<p>​ Maven工程之间，A 工程继承 B 工程，本质上是 A 工程的 pom.xml
中的配置继承了 B 工程中 pom.xml 的配置</p>
<p>​
在父工程中统一管理项目中的依赖信息，具体来说是管理依赖信息的版本。它的背景是：</p>
<ul>
<li>对一个比较大型的项目进行了模块拆分。</li>
<li>一个 project 下面，创建了很多个 module。</li>
<li>每一个 module 都需要配置自己的依赖信息。</li>
</ul>
<p>它背后的需求是：</p>
<ul>
<li>在每一个 module
中各自维护各自的依赖信息很容易发生出入，不易统一管理。</li>
<li>使用同一个框架内的不同 jar
包，它们应该是同一个版本，<strong>所以整个项目中使用的框架版本需要统一。</strong></li>
<li>使用框架时所需要的 jar
包组合（或者说依赖信息组合）需要经过长期摸索和反复调试，最终确定一个可用组合。这个耗费很大精力总结出来的方案不应该在新的项目中重新摸索。</li>
</ul>
<p>​
通过在父工程中为整个项目维护依赖信息的组合既<strong>保证了整个项目使用规范、准确的
jar
包</strong>；又能够将<strong>以往的经验沉淀</strong>下来，节约时间和精力</p>
<h4 id="实际操作">1、实际操作：</h4>
<ul>
<li><p>创建父工程</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro03-maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!-- 当前工程作为父工程，它要去管理子工程，所以打包方式必须是 pom --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​ 只有打包方式为 pom 的 Maven 工程能够管理其他 Maven 工程。打包方式为
pom 的 Maven 工程中不写业务代码，它是专门管理其他 Maven
工程的工程</p></li>
<li><p>创建模块工程</p>
<ul>
<li><p>模块工程类似于 IDEA 中的 module，所以需要<strong>进入
pro03-maven-parent 工程的根目录</strong>，然后运行 mvn
archetype:generate 命令来创建模块工程</p></li>
<li><p>然后父工程pom.xml被添加进了新的内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">module</span>&gt;</span>pro04-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">module</span>&gt;</span>pro05-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">module</span>&gt;</span>pro06-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>子工程的pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用parent标签指定当前工程的父工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 父工程的坐标 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro03-maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子工程的坐标 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果子工程坐标中的groupId和version与父工程一致，那么可以省略 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro04-maven-module<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; --&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在父工程配置依赖的统一管理</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用dependencyManagement标签配置对依赖的管理 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 被管理的依赖并没有真正被引入到工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>子工程中引用那些被父工程管理的依赖,关键是可以省略版本号</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子工程引用父工程中的依赖信息时，可以把版本号去掉。	--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 把版本号去掉就表示子工程中这个依赖的版本由父工程决定。 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 具体来说是由父工程的dependencyManagement来决定。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>可以在父工程中声明自定义属性，然后在需要使用的地方以${}形式来自定义</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过自定义属性，统一指定Spring的版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 自定义标签，维护Spring版本数据 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">atguigu.spring.version</span>&gt;</span>4.3.6.RELEASE<span class="tag">&lt;/<span class="name">atguigu.spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;atguigu.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221126123723655.png" /></p>
<h3 id="十二聚合">十二、聚合</h3>
<p>​
使用一个“总工程”将各个“模块工程”汇集起来，作为一个整体对应完整的项目。</p>
<ul>
<li>项目：整体</li>
<li>模块：部分</li>
</ul>
<p>从继承关系角度来看：</p>
<ul>
<li>父工程</li>
<li>子工程</li>
</ul>
<p>从聚合关系角度来看：</p>
<ul>
<li>总工程</li>
<li>模块工程</li>
</ul>
<p>一键执行 Maven 命令：很多构建命令都可以在“总工程”中一键执行。</p>
<p>​ 以 mvn install 命令为例：Maven
要求有父工程时先安装父工程；有依赖的工程时，先安装被依赖的工程。我们自己考虑这些规则会很麻烦。但是工程聚合之后，在总工程执行
mvn install 可以一键完成安装，而且会自动按照正确的顺序执行。</p>
<p>​
配置聚合之后，各个模块工程会在总工程中展示一个列表，让项目中的各个模块一目了然</p>
<ul>
<li><p>在总工程中配置modules即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>pro04-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>pro05-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>pro06-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>⑨ 工程类笔记</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven Chap1——概述与解压和配置</title>
    <url>/2022/11/24/d526879dd1ca/</url>
    <content><![CDATA[<h3 id="一maven概述">一、Maven概述</h3>
<h4
id="为什么使用maven依赖管理工具">1、为什么使用Maven—依赖管理工具</h4>
<h5 id="jar包太多太杂">1）jar包太多太杂</h5>
<p>Maven 作为依赖管理工具</p>
<ul>
<li><p>现在项目中使用的jar包也越来越多。项目中，一个模块里面用到上百个jar包是非常正常的。</p></li>
<li><p>比如下面的例子，我们只用到 SpringBoot、SpringCloud
框架中的三个功能：</p>
<ul>
<li>Nacos 服务注册发现</li>
<li>Web 框架环境</li>
<li>图模板技术 Thymeleaf</li>
</ul></li>
<li><p>但是却要导入100多个jar包，但是引入jar包只需要配置三个依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- Nacos 服务注册发现启动器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- web启动器依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 视图模板技术 thymeleaf --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="jar包的来源与依赖关系">2）jar包的来源与依赖关系：</h5>
<p>​ jar包来源较多，且杂。使用 Maven 后，依赖对应的 jar
包能够<strong>自动下载</strong>，方便、快捷又规范。</p>
<p>​ jar
包之间的依赖关系是普遍存在的，如果要由程序员手动梳理无疑会增加极高的学习成本，而这些工作又对实现业务功能毫无帮助。</p>
<p>​ 而使用 Maven
则几乎不需要管理这些关系，极个别的地方调整一下即可。</p>
<h4
id="为什么使用maven构建管理工具">2、为什么使用Maven——构建管理工具</h4>
<p>脱离IDE环境仍然需要构建，怎么构建呢？</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-11-24%2011.05.35.png" /></p>
<h4 id="maven的构建功能">3、Maven的构建功能：</h4>
<h5 id="什么是构建">1）什么是构建？</h5>
<p>​
将java源码、图片、配置文件等等生产出一个可以在服务器上运行的项目的过程</p>
<h5 id="构建的主要环节">2）构建的主要环节：</h5>
<ul>
<li>清理：删除上一次构建的结果，为下一次构建做好准备</li>
<li>编译：Java 源程序编译成 *.class 字节码文件</li>
<li>测试：运行提前准备好的测试程序</li>
<li>报告：针对刚才测试的结果生成一个全面的信息</li>
<li>打包
<ul>
<li>Java工程：jar包</li>
<li>Web工程：war包</li>
</ul></li>
<li>安装：把一个 Maven 工程经过打包操作生成的 jar 包或 war 包存入 Maven
仓库</li>
<li>部署
<ul>
<li>部署 jar 包：把一个 jar 包部署到 Nexus 私服服务器上</li>
<li>部署 war 包：借助相关 Maven 插件（例如 cargo），将 war 包部署到
Tomcat 服务器上</li>
</ul></li>
</ul>
<h4 id="maven的依赖管理功能">4、Maven的依赖管理功能：</h4>
<p>​ 如果 A 工程里面用到了 B
工程的类、接口、配置文件等等这样的资源，那么我们就可以说 A 依赖 B。</p>
<ul>
<li><p>junit-4.12 依赖 hamcrest-core-1.3</p></li>
<li><p>thymeleaf-3.0.12.RELEASE 依赖 ognl-3.1.26</p></li>
<li><p>ognl-3.1.26 依赖 javassist-3.20.0-GA</p></li>
</ul>
<p>​ Maven解决的具体问题：</p>
<ul>
<li>jar 包的下载：使用 Maven 之后，jar
包会从规范的远程仓库下载到本地</li>
<li>jar 包之间的依赖：通过依赖的传递性自动完成</li>
<li>jar
包之间的冲突：通过对依赖的配置进行调整，让某些jar包不会被导入</li>
</ul>
<h4 id="maven的工作机制">5、Maven的工作机制：</h4>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221124112232945.png" /></p>
<h3 id="二maven核心程序解压和配置">二、Maven核心程序解压和配置</h3>
<ul>
<li><p>下载Maven核心程序并解压</p></li>
<li><p>关注配置文件：<strong>conf/settings.xml</strong></p>
<ul>
<li><p>指定本地仓库：<code>&lt;localRepository&gt;D:\maven-repository&lt;/localRepository&gt;</code></p></li>
<li><p>配置基础jdk版本：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">	  <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	  <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">	  <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">	  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">	  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>配置阿里云的镜像仓库：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>配置环境变量JAVA_HOME</p></li>
<li><p>配置环境变量MAVEN_HOME</p></li>
<li><p>配置PATH：</p></li>
<li><p>配置环境变量的规律：</p>
<ul>
<li>XXX_HOME 通常指向的是 bin 目录的上一级</li>
<li>PATH 指向的是 bin 目录</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>⑨ 工程类笔记</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring5 Chap4——事务管理与操作</title>
    <url>/2022/11/23/3249c9e184a2/</url>
    <content><![CDATA[<h4 id="一spring事务管理介绍">一、Spring事务管理介绍：</h4>
<ul>
<li><p>事务添加到 JavaEE 三层结构里面 Service 层（业务逻辑层）</p></li>
<li><p>两种方式：编程式事务管理和声明式事务管理（使用这种）</p></li>
<li><p>基于注解方式进行事务管理，底层使用的是AOP原理。</p></li>
<li><p>事务管理的API：PlatformTransactionManager，这是一个接口，可以根据不同的框架提供不同的实现类，比如jdbc等</p></li>
</ul>
<h4 id="二注解声明式事务管理">二、注解声明式事务管理</h4>
<ul>
<li>在 spring 配置文件 配置事务管理器</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--注入数据源--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>在 spring 配置文件，开启事务注解
<ul>
<li>引入名称空间tx，开启事务注解</li>
</ul></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag"> http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context/spring-context.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag"> http://www.springframework.org/schema/aop </span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/aop/spring-aop.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag"> http://www.springframework.org/schema/tx </span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在 service 类上面（或者 service 类里面方法上面）添加事务注解</li>
<li><span class="citation"
data-cites="Transactional">@Transactional</span>，这个注解添加到类上面，也可以添加方法上面
<ul>
<li>如果把这个注解添加类上面，这个类里面所有的方法都添加事务</li>
<li>如果把这个注解添加方法上面，为这个方法添加事务</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Transactional参数的配置：
<ul>
<li>propagation 事务传播行为
<code>@Transactional(propagation = Propagation.REQUIRED)</code>
<ul>
<li>REQUIRED</li>
<li>REQUIRED_NEW</li>
<li>SUPPORTS</li>
<li>等等</li>
</ul></li>
<li>ioslation
事务隔离级别，事务有特性成为隔离性，多事务操作之间不会产生影响
<ul>
<li><code>@Transactional(isolation= Isolation.REPEATABLE_READ)</code></li>
<li>存在问题：
<ul>
<li>脏读：一个未提交事务读取到另一个未提交事务的数据</li>
<li>不可重复读：一个未提交事务读取到另一提交事务修改数据</li>
<li>虚（幻）读：一个未提交事务读取到另一提交事务添加数据</li>
</ul></li>
<li>隔离级别：
<ul>
<li>READ UNCOMMITTED</li>
<li>READ COMMITTED 解决脏读</li>
<li>REPEATABLE READ 解决脏读、不可重复读</li>
<li>SERIALIZABLE 解决脏读、不可重复读、虚（幻）读</li>
</ul></li>
</ul></li>
<li>Timeout 超时时间
<ul>
<li>事务需要在一定时间内提交，不提交则回滚</li>
<li>默认值为-1，单位为秒</li>
</ul></li>
<li>readOnly：是否只读</li>
<li>rollbackFor：回滚
<ul>
<li>设置出现哪些异常进行事务回滚</li>
</ul></li>
<li>noRollbackFor</li>
</ul></li>
</ul>
<h4 id="三完全注解声明式事务管理">三、完全注解声明式事务管理</h4>
<ul>
<li>创建配置类，使用配置类代替xml配置文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//配置类 </span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.atguigu&quot;)</span> <span class="comment">//组件扫描 @EnableTransactionManagement //开启事务 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxConfig</span> &#123; </span><br><span class="line">	<span class="comment">//创建数据库连接池 </span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> DruidDataSource <span class="title function_">getDruidDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">  	<span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>(); </span><br><span class="line">  	dataSource.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>); </span><br><span class="line">  	dataSource.setUrl(<span class="string">&quot;jdbc:mysql:///user_db&quot;</span>); </span><br><span class="line">  	dataSource.setUsername(<span class="string">&quot;root&quot;</span>); </span><br><span class="line">  	dataSource.setPassword(<span class="string">&quot;root&quot;</span>); </span><br><span class="line">  	<span class="keyword">return</span> dataSource; </span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//创建JdbcTemplate对象 </span></span><br><span class="line">  <span class="meta">@Bean</span> </span><br><span class="line">  <span class="keyword">public</span> JdbcTemplate <span class="title function_">getJdbcTemplate</span><span class="params">(DataSource dataSource)</span> &#123; </span><br><span class="line">    <span class="comment">//到ioc容器中根据类型找到dataSource </span></span><br><span class="line">    <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(); <span class="comment">//注入dataSource 	</span></span><br><span class="line">    jdbcTemplate.setDataSource(dataSource); </span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate; </span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//创建事务管理器 </span></span><br><span class="line">  <span class="meta">@Bean</span> </span><br><span class="line">  <span class="keyword">public</span> DataSourceTransactionManager <span class="title function_">getDataSourceTransactionManager</span><span class="params">(DataSource dataSource)</span> &#123; </span><br><span class="line">    <span class="type">DataSourceTransactionManager</span> <span class="variable">transactionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(); </span><br><span class="line">    transactionManager.setDataSource(dataSource); </span><br><span class="line">    <span class="keyword">return</span> transactionManager; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>⑨ 工程类笔记</category>
        <category>Spring5</category>
      </categories>
      <tags>
        <tag>Spring5</tag>
        <tag>Transaction</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring5 Chap3——JdbcTemplate</title>
    <url>/2022/11/23/95c1a08c5828/</url>
    <content><![CDATA[<h4 id="一什么是jdbctemplate">一、什么是JdbcTemplate？</h4>
<p>​ Spring框架对JDBC进行封装，使用JdbcTemplate方便实现对数据库操作</p>
<ul>
<li>引入相关jar包</li>
<li>在spring配置文件配置数据库连接池</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///user_db&quot;</span> /&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Slks88395481&quot;</span> /&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>配置JdbcTemplate对象，注入DataSource</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- JdbcTemplate对象 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--注入dataSource--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建service类，创建dao类</li>
<li>在Service里注入Dao对象，在Dao中注入jdbcTemplate对象</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组件扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.jdbc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> <span class="keyword">implements</span> <span class="title class_">UserDaoInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">//1 创建sql语句</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into user values(?,?)&quot;</span>;</span><br><span class="line">        <span class="comment">//2 调用方法实现</span></span><br><span class="line">        Object[] args = &#123;user.getUserId(), user.getUsername()&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> jdbcTemplate.update(sql,args);</span><br><span class="line">        System.out.println(update);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        userDao.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建测试类：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJdbcTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUserId(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        user.setUsername(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        userService.addUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上述为新增操作，例如修改、删除等都差不多，不做演示，细节需查阅文档。</li>
</ul>
<h4 id="二jdbctemplate中的查询操作">二、JdbcTemplate中的查询操作：</h4>
<ul>
<li>查询返回某个值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">selectCount</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select count(*) from t_book&quot;</span>; </span><br><span class="line">	<span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql, Integer.class); </span><br><span class="line">	<span class="keyword">return</span> count; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>查询返回对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> Book <span class="title function_">findBookInfo</span><span class="params">(String id)</span> &#123; </span><br><span class="line">	<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where user_id=?&quot;</span>; <span class="comment">//调用方法 </span></span><br><span class="line">	<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;User&gt;(User.class), id); 		<span class="keyword">return</span> book; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>查询返回集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">findAllBook</span><span class="params">()</span> &#123; </span><br><span class="line">	<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user&quot;</span>; <span class="comment">//调用方法 </span></span><br><span class="line">	List&lt;User&gt; userList = jdbcTemplate.query(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;User&gt;(User.class)); </span><br><span class="line">	<span class="keyword">return</span> userList; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>批量修改、删除、新增见文档</li>
</ul>
]]></content>
      <categories>
        <category>⑨ 工程类笔记</category>
        <category>Spring5</category>
      </categories>
      <tags>
        <tag>Spring5</tag>
        <tag>JdbcTemplate</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring5 Chap2——动态代理与AOP</title>
    <url>/2022/11/22/02d438ad6496/</url>
    <content><![CDATA[<h4 id="一什么是aop">一、什么是AOP？</h4>
<p>​ 面向切面编程，利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得
业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率</p>
<p>​ <strong>不通过修改源代码方式，在主干功能里面添加新功能</strong></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221122213808532.png" /></p>
<h4 id="二什么是代理模式">二、什么是代理模式？：</h4>
<p>​
代理模式的优势是可以很好地遵循设计模式中的开放封闭原则，对扩展开发，对修改关闭。你不需要关注目标类的实现细节，通过代理模式可以在不修改目标类的情况下，增强目标类功能的行为。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221123092600631.png" /></p>
<h5 id="什么是静态代理">1、什么是静态代理？</h5>
<p>​ 静态代理，就是通过声明一个明确的代理类来访问源对象。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221123092624295.png" /></p>
<p>​ 三个关键概念：</p>
<ul>
<li><p>抽象接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UsbSell</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">sell</span><span class="params">(<span class="type">int</span> amount)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>目标类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsbKingFactory</span> <span class="keyword">implements</span> <span class="title class_">UsbSell</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sell</span><span class="params">(<span class="type">int</span> amount)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> amount * <span class="number">85</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>代理类（必须包含真实对象类的对象）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaoBao</span> <span class="keyword">implements</span> <span class="title class_">UsbSell</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">UsbSell</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsbKingFactory</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span> </span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sell</span><span class="params">(<span class="type">int</span> amount)</span>&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> factory.sell(amount); <span class="comment">//厂家的价格</span></span><br><span class="line">		<span class="keyword">return</span> price + <span class="number">100</span>; <span class="comment">//代理要增加价格，增强功能</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="什么是jdk动态代理">2、什么是JDK动态代理？</h5>
<p>​
在程序执行过程中，使用jdk的反射机制，创建代理类对象，并动态的指定要代理的目标。</p>
<p>​
动态代理是一种创建java对象的能力，让你不用创建TaoBao类，就能创建代理类对象。</p>
<p>​ 在java中，要想创建对象，正常流程如下：</p>
<ul>
<li>创建类文件，java文件编译为class文件</li>
<li>使用构造方法，创建类的对象。</li>
</ul>
<p>​
在动态代理中，相当于把第一步的操作去掉了。通过反射包java.lang.reflect，里面有三个类：InvocationHandler，Method，Proxy。</p>
<p><strong>jdk动态代理的实现：</strong></p>
<ul>
<li><p>InvocationHandler接口，有一个方法invoke()，代理类要完成的功能代码写在这个方法中即可。主要完成以下功能</p>
<ul>
<li><p>调用目标类的方法，完成目标类的功能</p></li>
<li><p>功能增强，在目标方法调用时，增加一些其他的功能。</p></li>
<li><p>invoke方法的原型：</p>
<ul>
<li>Object Proxy：jdk的代理对象，无需赋值，jdk会帮我们赋值</li>
<li>Method method：目标类中的方法，无需赋值，jdk会帮我们赋值</li>
<li>Object[] args：目标类中方法的参数</li>
</ul></li>
<li><p>如何使用？</p>
<ul>
<li>创建类实现接口InvocationHandler</li>
<li>重写invoke()方法，把原来静态代理中<strong>代理类要完成的功能写在这部分即可</strong>。</li>
</ul></li>
</ul></li>
<li><p>Method类：表示方法的，确切的说就是目标类中的方法</p>
<ul>
<li>通过Method可以执行目标类的方法，通过method.invoke()</li>
<li>等同于静态代理中的执行目标方法<code>factory.sell(amount)</code></li>
</ul></li>
<li><p>Proxy类：创建代理对象。使用Proxy类的方法，代替new的使用</p>
<ul>
<li>静态方法：newProxyInstance()
，用于代替原来的<code>new UsbKingFactory()</code></li>
<li><code>public static Object newProxyInstance(ClassLoader loader,  Class&lt;?&gt;[] interfaces, InvocationHandler h)</code>
<ul>
<li>ClassLoader：类加载器，负责向内存中加载对象，使用反射获取对象的ClassLoader。指目标对象的类加载器</li>
<li>Class&lt;?&gt;[] interfaces：
接口，目标对象实现的接口，也是反射获取的</li>
<li>InvocationHandler h：我们自己写的代理类要完成的功能类</li>
<li>返回值就是代理对象</li>
</ul></li>
</ul></li>
<li><p>具体实现：</p>
<ul>
<li><p>创建接口，定义目标类要完成的功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> dynamicproxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UsbSell</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sell</span><span class="params">(<span class="type">int</span> amount)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建目标类实现接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> dynamicproxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsbKingFactory</span> <span class="keyword">implements</span> <span class="title class_">UsbSell</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sell</span><span class="params">(<span class="type">int</span> amount)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> amount * <span class="number">85</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建InvocationHandler接口的实现类，在invoke方法中完成代理类的功能</p>
<ul>
<li>调用目标方法</li>
<li>增强功能</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> dynamicproxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxyImpl</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">//动态代理：目标对象是活动的，不是固定的，需要传入进来。</span></span><br><span class="line">    <span class="comment">//传入是谁，就给谁创建代理。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicProxyImpl</span><span class="params">(Object target)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        res = method.invoke(target,args); <span class="comment">//执行目标方法</span></span><br><span class="line">        <span class="comment">//执行功能增强</span></span><br><span class="line">        <span class="keyword">if</span>(res!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> (<span class="type">int</span>)res;</span><br><span class="line">            price = price + <span class="number">25</span>;</span><br><span class="line">            res = price;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用Proxy类的静态方法创建代理对象，并把返回值转为接口类型即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> dynamicproxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainShop</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建代理对象，使用Proxy</span></span><br><span class="line">        <span class="comment">//创建目标对象</span></span><br><span class="line">        <span class="type">UsbSell</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsbKingFactory</span>();</span><br><span class="line">        <span class="comment">//创建InvocationHandler对象</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DynamicProxyImpl</span>(factory);</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        <span class="type">UsbSell</span> <span class="variable">proxy</span> <span class="operator">=</span> (UsbSell) Proxy.newProxyInstance(factory.getClass().getClassLoader(),factory.getClass().getInterfaces(),handler );</span><br><span class="line">        <span class="comment">//通过代理执行方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> proxy.sell(<span class="number">2</span>);</span><br><span class="line">        System.out.println(price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>如此一来，不同的代理类，比如淘宝、微商、京东等等都可以不用单独的创建类，直接利用JDK动态代理就可以了。</p></li>
<li><p>故而，动态代理的作用：可以在不改变原来目标方法功能的前提下，可以在代理中增强自己的功能代码</p></li>
<li><p>一些使用场景：比如：你所在的项目中，有一个功能是其他人（公司的其它部门，其它小组的人）写好的，你可以使用
GoNong.class，GoNong gn=new
GoNong()，gn.print()；你发现这个功能，现在还存在一些缺点，不能完全满足项目的需要。我需要在gn.print()执行后，需要自己再增加代码。用代理实现gn.print()调用时，增加自己代理，而不用去改原来的GoNong文件。</p></li>
</ul>
<h5 id="什么是cglib动态代理">3、什么是cglib动态代理？</h5>
<p>​
JDK动态代理有一个前提，需要代理的类必须实现接口，如果潭有实现接口，只能通过CGLIB来实现，</p>
<p>​
cglib是第三方的工具库，创建代理对象。cglib的原理是继承，cglib通过继承目标类，创建它的子类，在子类中重写父类中同名的方法，实现功能的修改。所以其要求目标类不能是final的，方法也不能是final的。</p>
<ul>
<li><p>整体逻辑：</p>
<ul>
<li>通过继承的方式去获取到目标对象的方法</li>
<li>通过传递方法拦截器MethodInterceptor实现方法拦截，在这里面做具体的增强</li>
<li>调用生成的代理类对象具体执行重写的目标方法，直接调用方法拦截器里面的intercept方法</li>
<li>前后加上了增强操作，从而实现了不修改目标类代码却实现业务增强的逻辑</li>
</ul></li>
<li><p>具体使用示例：</p>
<ul>
<li><p>1、创建目标类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsbKingFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sell</span><span class="params">(<span class="type">int</span> amount)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sell&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> amount * <span class="number">85</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>2、创建方法拦截器,CGLIB动态代理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxyImpl</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicProxyImpl</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置增强方法&quot;</span>);</span><br><span class="line">        <span class="comment">//调用目标对象方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> methodProxy.invokeSuper(o,objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;后置增强方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>3、外层如何使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainShop</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//得到方法拦截器</span></span><br><span class="line">        <span class="type">DynamicProxyImpl</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DynamicProxyImpl</span>();</span><br><span class="line">        <span class="comment">//使用CGLIB框架，生成目标类的子类实现增强</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//设置父类字节码</span></span><br><span class="line">        enhancer.setSuperclass(UsbKingFactory.class);</span><br><span class="line">        <span class="comment">//设置拦截处理</span></span><br><span class="line">        enhancer.setCallback(interceptor);</span><br><span class="line">        <span class="type">UsbKingFactory</span> <span class="variable">usb</span> <span class="operator">=</span> (UsbKingFactory) enhancer.create();</span><br><span class="line">        usb.sell(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="三aop术语">三、AOP术语：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//假设我们的用户类有增删改查四个方法</span><br><span class="line">class User&#123;</span><br><span class="line">	add()</span><br><span class="line">	update()</span><br><span class="line">	select()</span><br><span class="line">	delete()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="连接点">1、连接点</h5>
<p>​ 类里面，哪些方法可以被增强，就称为连接点</p>
<h5 id="切入点">2、切入点</h5>
<p>​ 实际被增强的方法，称为切入点</p>
<h5 id="通知增强">3、通知（增强）</h5>
<p>​ 实际增强的逻辑部分，称为通知。通知可以有如下类型：</p>
<ul>
<li>前置通知、后置通知</li>
<li>环绕通知</li>
<li>异常通知</li>
<li>最终通知</li>
</ul>
<h5 id="切面">4、切面</h5>
<p>​ 这是一个动作，把通知应用到切入点这个过程，就叫做切面。</p>
<h4 id="四基于aspectj的aop操作">四、基于AspectJ的AOP操作：</h4>
<p>​
Spring框架一般都是基于AspectJ实现AOP操作，AspectJ不是Spring组成部分，独立AOP框架，一般把AspectJ和Spirng框架一起使用，进行AOP操作</p>
<ul>
<li>引入AOP相关依赖</li>
<li>切入点表达式：
<ul>
<li>知道对哪个类里面的哪个方法进行增强</li>
<li>execution([权限修饰符] [返回类型] [类全路径] <a
href="%5B参数列表%5D">方法名称</a> )</li>
<li>示例1：对com.fantast.UserDao类里面的add进行增强 execution(*
com.fantast.UserDao.add(..))</li>
</ul></li>
</ul>
<h5 id="基于xml文件的形式配置aop">1、基于xml文件的形式配置AOP：</h5>
<ul>
<li><p>配置bean1.xml文件</p>
<ul>
<li>主要就是增加名称空间aop,开启Aspect生成代理对象</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.aop&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启Aspect生成代理对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br><span class="line">&lt;/beans</span><br></pre></td></tr></table></figure></li>
<li><p>被增强类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(value = &quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;add.......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>增加类（代理类） 使用@Aspect来进行声明</p>
<ul>
<li>总共有五种类型的通知，如下所示，通过注解+切入点表达式的方式来声明对哪个类的哪个方法进行加强。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增强类，代理类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line">    <span class="comment">//在增强类的里面，在作为通知方法上面添加通知类型注解，使用切入点表达式配置</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;execution(* com.aop.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//前置通知</span></span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;execution(* com.aop.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//后置通知，返回通知</span></span><br><span class="line">        System.out.println(<span class="string">&quot;后置通知，返回通知......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(value = &quot;execution(* com.aop.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//最终通知</span></span><br><span class="line">        System.out.println(<span class="string">&quot;最终通知......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;execution(* com.aop.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//异常通知</span></span><br><span class="line">        System.out.println(<span class="string">&quot;异常通知......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(value = &quot;execution(* com.aop.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//环绕通知</span></span><br><span class="line">        System.out.println(<span class="string">&quot;环绕之前通知.........&quot;</span>);</span><br><span class="line">        <span class="comment">//被增强的方法执行</span></span><br><span class="line">        proceedingJoinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕之后通知.........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAop</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAopAnno</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        user.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">环绕之前通知.........</span><br><span class="line">前置通知......</span><br><span class="line">add.......</span><br><span class="line">环绕之后通知.........</span><br><span class="line">最终通知......</span><br><span class="line">后置通知，返回通知......</span><br></pre></td></tr></table></figure></li>
</ul>
<h6
id="如何抽取相同的切入点利用pointcut做一个抽取然后之后就直接调用pointdemo就可以了">1）如何抽取相同的切入点？利用PointCut做一个抽取，然后之后就直接调用pointdemo()就可以了</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut(value = &quot;execution(* com.aop.User.add(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointdemo</span><span class="params">()</span> &#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前置通知 </span></span><br><span class="line"><span class="comment">// @Before注解表示作为前置通知 </span></span><br><span class="line"><span class="meta">@Before(value = &quot;pointdemo()&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123; </span><br><span class="line">    System.out.println(<span class="string">&quot;before.........&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6
id="有多个增强类对同一个方法进行增强设置增强类优先级">2）有多个增强类对同一个方法进行增强，设置增强类优先级</h6>
<p>​ 在增强类上面添加注解 <span class="citation"
data-cites="Order">@Order</span>(数字类型值)，数字类型值越小优先级越高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="meta">@Aspect</span> </span><br><span class="line"><span class="meta">@Order(1)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonProxy</span>&#123;</span><br><span class="line">	<span class="meta">@Before(value = &quot;execution(* com.aop.User.add(..))&quot;)</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;Person before.........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="基于注解方式配置aop">2、基于注解方式配置AOP：</h5>
<p>​ 创建配置类即可，不需要创建xml配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.aop&quot;&#125;)</span> </span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigAop</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<h5 id="基于aspectj的配置文件">3、基于AspectJ的配置文件：</h5>
<ul>
<li><p>创建两个类，增强类和被增强类，创建方法</p></li>
<li><p>在spring配置文件中创建两个类对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;book&quot; class=&quot;com.atguigu.spring5.aopxml.Book&quot;&gt;&lt;/bean&gt; </span><br><span class="line">&lt;bean id=&quot;bookProxy&quot; class=&quot;com.atguigu.spring5.aopxml.BookProxy&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>在spring配置文件中配置切入点</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置aop增强--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--切入点--&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;p&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(*com.fantast.aopxml.Book.buy(..))&quot;</span>/&gt;</span> <span class="comment">&lt;!--配置切面--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;bookProxy&quot;</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!--增强作用在具体的方法上--&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;p&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>⑨ 工程类笔记</category>
        <category>Spring5</category>
      </categories>
      <tags>
        <tag>Spring5</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>装机奇遇记</title>
    <url>/2022/11/22/d1bcf1ea293d/</url>
    <content><![CDATA[<h4 id="一20200710装机小记">一、20200710装机小记</h4>
<ul>
<li>配置清单：
<ul>
<li>CPU：AMD Ryzen 7 3700X</li>
<li>主板：微星 B450M MORTAR MAX</li>
<li>显卡：NVIDIA GeForce RTX2070 Super</li>
<li>内存：芝奇G.SKILL 32GB(16G x 2) DDR4 3600 焰光戟</li>
<li>固态：三星500G M.2接口 970 EVO Plus</li>
<li>机械：西部数据WD蓝盘 1TB（WD30EZAZ）</li>
<li>散热：利民FROZEN EYE240</li>
<li>电源：海昀 FOCUS GX650 金牌全模组</li>
<li>机箱：鑫谷光昀7Plus黑色机箱</li>
</ul></li>
<li>事故现场与装机“新”得：
<ul>
<li>这是笔者第一次自己装的机，吐槽点如下：</li>
<li>1、机箱买的太小了，装机的时候特别拥挤。<strong>需要注意机箱中对水冷、显卡长度、内存高度、电源长度的尺寸限制</strong>，虽然最后我还是把所有的东西都成功的塞进去了，并且后续因为机箱小在搬动过程中享受到了许多便利。</li>
<li>2、显卡在插入过程中，有一个很长的部分，是需要刚好插到主板和机箱的缝里去的，很难放。</li>
<li>3、整个装机过程思路混乱，导致拆拆装装了很多遍，线也搞得十分混乱。</li>
<li>4、机箱内的风扇风道考虑不周，并没有起到很好的散热效果。<strong>需要注意机箱各个风扇的出风和进风位置，以保证风道正确</strong></li>
<li>5、买的主板不带WIFI，所以中途有一次学校有线网断网，还特意买了WIFI外置连接器。</li>
<li>6、最后额外花了一天时间理线，终于把整个搞得整洁了许多。</li>
</ul>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221122161707248.png" /></li>
</ul>
<h4 id="二20201012显卡送修">二、20201012显卡送修</h4>
<p>​
没想到品控很好的微星魔龙的显卡竟然三个月就坏了，经过一番排查后才确认是显卡的问题。不过京东整体的返修效率还是很高的，在京东自营旗舰店申请售后寄出显卡后，一个礼拜内微星就给我寄了一张全新的卡回来，安装好就可以用了。</p>
<ul>
<li>事故现场：
<ul>
<li>由于AMD的CPU不带核显，所以显卡送修的日子里，很苦逼的到处借别人闲置的显卡，不然电脑没法使用，十分难受。所以以后还是得买带核显的CPU以便应急.</li>
</ul></li>
</ul>
<h4 id="三20211115装机小记">三、20211115装机小记:</h4>
<p>​ 这次是帮一个同学装电脑</p>
<ul>
<li>配置清单:
<ul>
<li>CPU：Intel i5-10400F 6核12线程</li>
<li>主板：微星 B460M MORTAR WIFI迫击炮电脑主板</li>
<li>显卡：微星魔龙 NVIDIA GeForce GTX1660 Super GAMING X 6G</li>
<li>内存：威刚ADATA 16GB(8GB x 2) DDR4 3200</li>
<li>固态：三星500G M.2接口 970 EVO Plus</li>
<li>机械：西部数据WD蓝盘 1TB（WD30EZAZ）</li>
<li>散热：九州风神DEEPCOOL玄冰400幻彩</li>
<li>电源：酷冷至尊 500W G500 金牌 非模组化电源</li>
<li>机箱：Tt启航这A1钛灰银 Mini小机箱</li>
</ul></li>
<li>事故现场与装机“新”得：
<ul>
<li>了解了全模组和非模组化电源的区别</li>
<li>第一次装风冷散热器，真的扎手……</li>
<li>这次吸取了教训,买了带核显的CPU和带WIFI的主板,整个装机过程没有出现太大的岔子,但是在装系统的环节除了神奇的问题.
U盘装系统进不去,好像是因为文件系统的问题导致的,但时间比较久远了不太记得了,这是一个值得关注的问题</li>
</ul></li>
</ul>
<h4 id="四20220530主机配置更换">四、20220530主机配置更换</h4>
<p>​
因为发现之前的水冷有点压不住CPU了,清灰以后也没啥用,同时机箱太小了,最终决定在618换个机箱以及水冷</p>
<ul>
<li>配置更换清单
<ul>
<li>鑫谷光昀7Plus黑色机箱 ——&gt; 追风者G360A</li>
<li>利民FROZEN EYE240 ——&gt; 乔思伯 TF360 一体式水冷散热器</li>
</ul></li>
<li>事故现场与装机“新”得：
<ul>
<li>涂抹硅脂的时候搞得一塌糊涂……我不配</li>
<li>机箱宽敞了以后真的舒畅！有图有真相</li>
</ul></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221122162031350.png" /></p>
<h4 id="五20220608装机小记">五、20220608装机小记</h4>
<p>​ 帮一位同学装机，用于3D建模渲染等</p>
<ul>
<li>配置清单:
<ul>
<li>CPU：Intel i7-12700K</li>
<li>主板：微星 B660M MORTAR WIFI DDR5</li>
<li>显卡：微星魔龙 NVIDIA GeForce RTX3060 Ti GAMING Z TRIO 8G</li>
<li>内存：威刚ADATA 32GB(16GB x 2) DDR4 3200 ——&gt; 威刚ADATA 16GB DDR5
5200</li>
<li>固态：三星500G M.2接口 970 EVO Plus</li>
<li>机械：西部数据WD蓝盘 1TB（WD30EZAZ）</li>
<li>散热：乔思伯 TF360 一体式水冷散热器</li>
<li>电源：鑫谷 750W 全模组电源</li>
<li>机箱：追风者G360A</li>
</ul></li>
<li>事故现场与装机“新”得：
<ul>
<li>一开始买的时候没注意主板买的是DDR5的，然后内存还是买了DDR4，装的时候直接G了。插了半天发现插不进去，才发现主板是DDR5的，然后再更换内存到了DDR5</li>
<li>散热和机箱选了我刚刚换的这两款，感觉还不错</li>
<li>装系统的时候又出了一点问题，这次是因为U盘不是用UEFI进行配置的，导致系统没法安装。</li>
</ul></li>
</ul>
<h4 id="六20221122装机小记">六、20221122装机小记</h4>
<p>​ 帮公司装台式机</p>
<ul>
<li>配置清单:
<ul>
<li>CPU：Intel i7-12700F</li>
<li>主板：话说ASUS TUF GAMING B660-PLUS</li>
<li>显卡：微星魔龙 NVIDIA GeForce RTX3060 GAMING Z TRIO 12G</li>
<li>内存：KingSton FURY 16GB DDR4</li>
<li>固态：KingSton 500G NV2 PCIE4.0</li>
<li>机械：西部数据WD蓝盘 1TB（WD30EZAZ）</li>
<li>散热：乔思伯 SHADOW 光影240幻彩版二代 一体式水冷散热器</li>
<li>电源：长城 G系列 80PLUS 550W 铜牌全模组电源</li>
<li>机箱：先马SAMA 鲁班1</li>
</ul></li>
<li>事故现场与装机“新”得：
<ul>
<li>装完机开机Bios显示CPU90度，说明水冷装的有问题。首先是排查了冷头的线，发现冷头风扇线没接，只接了灯光线，这个不应该。说明书看的太不仔细了，要注意灯光和水泵是分开供电的。接上冷头的线以后，CPU还是90度，检查了半天，重涂了硅脂，还是没用。最后发现是因为冷头支架一个小的零件装错了，导致冷头和CPU表面根本没有贴合。那么为什么重涂硅脂的时候没有发现呢？因为之前涂硅脂我是手动抹匀的，所以看不出来。</li>
<li>装系统的时候也翻车了，一开始把启动引导盘选在了U盘上，就导致一个很神奇的问题：U盘不插他就不会启动了，一直卡在Bios页面，插了U盘才会启动。最后重装了系统。</li>
<li>是一台没啥灯光的机器</li>
</ul></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221122163854111.png" /></p>
]]></content>
      <categories>
        <category>⑧  经验整理类笔记</category>
      </categories>
      <tags>
        <tag>Methods</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring5 Chap1——概述与IOC容器</title>
    <url>/2022/11/20/47fc01c8ea11/</url>
    <content><![CDATA[<h4 id="一概述">一、概述：</h4>
<p>1、Spring 是轻量级的开源的 JavaEE 框架
，可以解决企业应用开发的复杂性</p>
<p>2、Spring 有两个核心部分：IOC 和 Aop</p>
<ul>
<li>IOC：控制反转，把创建对象过程交给 Spring 进行管理</li>
<li>Aop：面向切面，不修改源代码进行功能增强</li>
</ul>
<p>34、Spring 特点</p>
<ul>
<li>方便解耦，简化开发</li>
<li>Aop 编程支持</li>
<li>方便程序测试</li>
<li>方便和其他框架进行整合</li>
<li>方便进行事务操作</li>
<li>降低 API 开发难度</li>
</ul>
<p>4、Spring下载链接：</p>
<p>​
https://repo.spring.io/ui/native/release/org/springframework/spring</p>
<h4 id="二ioc容器底层原理">二、IOC容器底层原理：</h4>
<p>​ IOC本质把对象创建和对象之间的调用过程，交给 Spring 进行管理
，目的是为了耦合度降低</p>
<ul>
<li><p>在最初的对象之间的调用中，A类想要调用B类，是需要在A类中创建一个B类的对象，随后进行调用。A和B之间存在强耦合。</p></li>
<li><p>起初，我们可以通过工厂类的形式来弥补这个问题，建立一个Factory类，用于统一管理B类对象的创建，这样的话A和B之间的耦合就消失了，但是所有的类都会和Factory类存在耦合。</p></li>
<li><p>最后：IOC的实现实际上是要结合java反射机制：利用xml配置文件，创建工厂类,然后通过读取配置文件，利用反射机制完成模块之间耦合度的降低。</p></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221120212918659.png" /></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221120212926975.png" /></p>
<p>注意：IOC思想是基于IOC容器完成的，IOC容器底层其实就是对象工程。</p>
<h4 id="三spring中的ioc">三、Spring中的IOC</h4>
<p>​ 在Spring中，提供IOC容器实现的两个接口：</p>
<ul>
<li>BeanFactory：IOC 容器基本实现，是 Spring
内部的使用接口，不提供开发人员进行使用
<ul>
<li>加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象</li>
</ul></li>
<li>ApplicationContext：BeanFactory
接口的子接口，提供更多更强大的功能，一般由开发人 员进行使用
<ul>
<li>加载配置文件时候就会把在配置文件对象进行创建</li>
<li>其有具体实现类：
<ul>
<li>FileSystemXmlApplicationContext</li>
<li>ClassPathXmlApplicationContext</li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br></pre></td></tr></table></figure>
<h4 id="四ioc操作的bean管理与注入">四、IOC操作的Bean管理与注入：</h4>
<ul>
<li><p>Bean管理指：Spring创建对象+注入属性</p></li>
<li><p>管理操作的两种方式：</p>
<ul>
<li>基于xml配置文件方式的实现</li>
<li>基于注解方式的实现</li>
</ul></li>
</ul>
<h5 id="基于xml配置文件方式">1、基于xml配置文件方式：</h5>
<h6 id="创建对象">1）创建对象</h6>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221120212918659.png" /></p>
<ul>
<li><p>在spring配置文件中，使用bean标签，标签里面添加对应属性，就可以实现对象创建</p></li>
<li><p>在bean标签有很多属性，常用的属性如下：</p>
<ul>
<li><p>id属性：唯一标识</p></li>
<li><p>class属性：类全路径（包类路径）</p></li>
</ul></li>
<li><p>创建对象时候，默认也是执行无参数构造方法完成对象创建</p></li>
</ul>
<h6 id="注入属性di-依赖注入">2）注入属性：DI 依赖注入</h6>
<ul>
<li>使用set方法进行注入，创建类定义属性和对应的set方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> String bname;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBname</span><span class="params">(String bname)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.bname = bname; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.Book&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;易筋经&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用有参数构造进行注入，创建类，定义属性，创建属性对应有参数构造方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orders</span> &#123; </span><br><span class="line">	<span class="keyword">private</span> String oname; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Orders</span><span class="params">(String oname,String address)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.oname = oname; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.Orders&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;oname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;电脑&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注入一些其他类型的属性：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">null</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span>&gt;</span>   </span><br><span class="line">    <span class="comment">&lt;!--属性值包含特殊符号 1 把&lt;&gt;进行转义 &amp;lt; &amp;gt; 2 把带特殊符号内容写到CDATA --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>&lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt;<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注入对象属性
<ul>
<li>写法1：外部Bean属性注入+级联赋值：比如说UserService类中有UserDao属性，需要调用其方法</li>
</ul></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.fantast.service.UserService&quot;</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--注入userDao对象 name属性：类里面属性名称 ref属性：创建userDao对象bean标签id值 --&gt;</span> 		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDaoImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.fantast.dao.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;myname&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注入集合类型属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> String[] courses; </span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; sets; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSets</span><span class="params">(Set&lt;String&gt; sets)</span> &#123; </span><br><span class="line">    	<span class="built_in">this</span>.sets = sets; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCourses</span><span class="params">(String[] courses)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.courses = courses; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setList</span><span class="params">(List&lt;String&gt; list)</span> &#123; </span><br><span class="line">    	<span class="built_in">this</span>.list = list; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMaps</span><span class="params">(Map&lt;String, String&gt; maps)</span> &#123; </span><br><span class="line">    	<span class="built_in">this</span>.maps = maps; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.fantast.collectiontype.Stu&quot;</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--数组类型属性注入--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;courses&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>java课程<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>数据库课程<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--list类型属性注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>小三<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--map类型属性注入--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maps&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;JAVA&quot;</span> <span class="attr">value</span>=<span class="string">&quot;java&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;PHP&quot;</span> <span class="attr">value</span>=<span class="string">&quot;php&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--set类型属性注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sets&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>MySQL<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>Redis<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>集合中注入对象类型的值：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;course1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.fantast.collectiontype.Course&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Spring5框架&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;course2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Course&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;MyBatis框架&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--注入list集合类型，值是对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;courseList&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;course1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;course2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="名称空间注入">3）名称空间注入：</h6>
<p>添加一个p名称空间约束</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221121145057857.png" /></p>
<p>进行属性注入，在bean标签里面进行操作</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.Book&quot;</span> <span class="attr">p:bname</span>=<span class="string">&quot;九阳神功&quot;</span> <span class="attr">p:bauthor</span>=<span class="string">&quot;无名氏&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="工厂bean">4）工厂Bean：</h6>
<p>​
Spring有两种类型bean，一种普通bean，另外一种工厂bean（FactoryBean）</p>
<ul>
<li><p>普通bean：在配置文件中定义bean类型就是返回类型(指在代码内获取的类型)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br></pre></td></tr></table></figure></li>
<li><p>工厂bean：在配置文件定义bean类型可以和返回类型不一样</p>
<ul>
<li>创建类，实现接口FactoryBean，在实现的方法中定义返回的Bean类型”</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Course&gt; &#123; </span><br><span class="line">	<span class="comment">//定义返回bean</span></span><br><span class="line">	<span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> Course <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123; </span><br><span class="line">        <span class="type">Course</span> <span class="variable">course</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Course</span>(); </span><br><span class="line">        course.setCname(<span class="string">&quot;abc&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span> course; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123; </span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123; </span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.factorybean.MyBean&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123; </span><br><span class="line">	<span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean3.xml&quot;</span>); </span><br><span class="line">	<span class="type">Course</span> <span class="variable">course</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;myBean&quot;</span>, Course.class); <span class="comment">// 获取的是Course类对象，而非MyBean类的对象	 	</span></span><br><span class="line">	System.out.println(course); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="bean作用域">5）Bean作用域</h6>
<ul>
<li><p>在Spring里面，默认情况下，bean是单实例对象，比如说在xml定义一个以后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Course</span> <span class="variable">course1</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;myBean&quot;</span>, Course.class);</span><br><span class="line"><span class="type">Course</span> <span class="variable">course2</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;myBean&quot;</span>, Course.class);</span><br><span class="line"><span class="comment">//实际上course1和course2是同一个对象</span></span><br></pre></td></tr></table></figure></li>
<li><p>设置多实例Bean: 设置scope属性即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.Book&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;易筋经&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p>设置scope值是singleton时候，加载spring配置文件时候就会创建单实例对象
设置scope值是prototype时候，不是在加载spring配置文件时候创建
对象，在调用getBean方法时候创建多实例对象</p></li>
</ul>
<h6 id="bean生命周期">6）Bean生命周期</h6>
<p>（1）通过构造器创建bean实例（无参数构造）
（2）为bean的属性设置值和对其他bean引用（调用set方法）
（3）调用bean的初始化的方法（需要进行配置初始化的方法）
（4）bean可以使用了（对象获取到了）
（5）当容器关闭时候，调用bean的销毁的方法（需要进行配置销毁的方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orders</span> &#123;</span><br><span class="line"><span class="comment">//无参数构造 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Orders</span><span class="params">()</span> &#123; </span><br><span class="line">    	System.out.println(<span class="string">&quot;第一步 执行无参数构造创建bean实例&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">	<span class="keyword">private</span> String oname; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOname</span><span class="params">(String oname)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.oname = oname; </span><br><span class="line">        System.out.println(<span class="string">&quot;第二步 调用set方法设置属性值&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建执行的初始化的方法 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initMethod</span><span class="params">()</span> &#123; </span><br><span class="line">    	System.out.println(<span class="string">&quot;第三步 执行初始化的方法&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建执行的销毁的方法 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroyMethod</span><span class="params">()</span> &#123; </span><br><span class="line">    	System.out.println(<span class="string">&quot;第五步 执行销毁的方法&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.Orders&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initMethod&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroyMethod&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;oname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;手机&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<h6 id="bean的后置处理器">7）Bean的后置处理器</h6>
<p>如果类实现了后置处理器接口，那么Bean的生命周期有7步</p>
<ul>
<li>在原(3)步之前和之后，各自会有额外的一步：
<ul>
<li><strong>把bean实例传递bean后置处理器的方法postProcessBeforeInitialization</strong></li>
<li>原（3）步：调用bean的初始化的方法（需要进行配置初始化的方法）</li>
<li><strong>把bean实例传递bean后置处理器的方法
postProcessAfterInitialization</strong></li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPost</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123; </span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;在初始化之前执行的方法&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span> bean; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;在初始化之后执行的方法&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="自动装配略">8）自动装配：(略)</h6>
<p>​
根据指定装配规则（属性名称或者属性类型），Spring自动将匹配的属性值进行注入</p>
<h6 id="引入外部属性文件">10）引入外部属性文件：</h6>
<ul>
<li>创建外部属性文件，properties格式文件，写数据库信息</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># jdbc.properties</span></span><br><span class="line"><span class="attr">prop.driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">prop.url</span>=<span class="string">jdbc:mysql://localhost:3306/userDb</span></span><br><span class="line"><span class="attr">prop.userName</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">prop.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>把外部properties属性文件引入到spring配置文件中</p>
<ul>
<li>引入context名称空间</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用标签引入外部属性文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入外部属性文件--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--配置连接池--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.driverClass&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.userName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="基于注解方式管理">2、基于注解方式管理：</h5>
<p>​ 注解是代码特殊标记，格式：<span class="citation"
data-cites="注解名称">@注解名称</span>(属性名称=属性值,
属性名称=属性值..)，使用注解，注解作用在类上面，方法上面，属性上面。</p>
<p>​
Spring针对Bean管理中创建对象提供注解，以下四个都可以用来创建bean实例</p>
<ul>
<li><span class="citation" data-cites="Component">@Component</span></li>
<li><span class="citation" data-cites="Service">@Service</span>
常用于业务逻辑层</li>
<li><span class="citation" data-cites="Controller">@Controller</span>
常用于Web层</li>
<li><span class="citation" data-cites="Repository">@Repository</span>
常用于DAO层</li>
</ul>
<p>第一步：引入AOP依赖</p>
<p>第二步：开启组件扫描：告诉Spring去扫描哪些包中的类，有注解就可以自动读取</p>
<ul>
<li><p>如果扫描多个包，多个包使用逗号隔开</p></li>
<li><p>引入名称空间context</p></li>
<li><p>在配置文件中加入：</p></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.fantast&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第三步：创建类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(value = &quot;userService&quot;)</span> <span class="comment">//&lt;bean id=&quot;userService&quot; class=&quot;..&quot;/&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;service add.......&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="组件扫描的扩展配置">1）组件扫描的扩展配置：</h6>
<ul>
<li>使用自己配置的Filter</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">context:component-scan base-package=&quot;com.atguigu&quot; use-default-filters=&quot;false&quot;&gt;</span><br><span class="line"> <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> </span></span><br><span class="line"><span class="tag"> </span></span><br><span class="line"><span class="tag"><span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>设置哪些内容不扫描：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> </span></span><br><span class="line"><span class="tag"> </span></span><br><span class="line"><span class="tag"><span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="实现属性注入">2）实现属性注入：</h6>
<ul>
<li><span class="citation"
data-cites="Autowired">@Autowired</span>：根据属性类型进行自动装配</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">     <span class="comment">//定义 dao 类型属性</span></span><br><span class="line">     <span class="comment">//不需要添加 set 方法</span></span><br><span class="line">     <span class="comment">//添加注入属性注解</span></span><br><span class="line">     <span class="meta">@Autowired</span> </span><br><span class="line">     <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">     	System.out.println(<span class="string">&quot;service add.......&quot;</span>);</span><br><span class="line">     	userDao.add();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><span class="citation"
data-cites="Qualifier">@Qualifier</span>：根据名称进行注入</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加注入属性注解</span></span><br><span class="line"><span class="meta">@Autowired</span> <span class="comment">//根据类型进行注入</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;userDaoImpl1&quot;)</span> <span class="comment">//根据名称进行注入</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure>
<ul>
<li><span class="citation"
data-cites="Resource">@Resource</span>：可以根据类型注入，可以根据名称注入</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource(name = &quot;userDaoImpl1&quot;)</span> <span class="comment">//根据名称进行注入</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure>
<ul>
<li><span class="citation"
data-cites="Value">@Value</span>：注入普通类型属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(value = &quot;abc&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure>
<h6 id="完全注解开发">3）完全注解开发：</h6>
<ul>
<li>创建配置类，替代xml配置文件：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//作为配置类，替代 xml 配置文件</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编写测试类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Public <span class="keyword">void</span> <span class="title function_">testService2</span><span class="params">()</span> &#123;</span><br><span class="line"> 	<span class="comment">//加载配置类</span></span><br><span class="line">     <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">     <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">     System.out.println(userService);</span><br><span class="line">     userService.add();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>⑨ 工程类笔记</category>
        <category>Spring5</category>
      </categories>
      <tags>
        <tag>Spring5</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat与Servelet入门</title>
    <url>/2022/11/15/50b9c3d3d025/</url>
    <content><![CDATA[<h3 id="一tomcat配置与简单部署html">一、Tomcat配置与简单部署Html</h3>
<h4 id="安装与配置">1、安装与配置：</h4>
<ul>
<li><p>官网下载压缩包解压：https://tomcat.apache.org/download-80.cgi</p></li>
<li><p>配置环境变量JAVA_HOME：为jdk的目录</p></li>
<li><p>点击tomcat文件夹bin目录内start.bat文件，启动tomcat服务，其默认在8080端口</p></li>
</ul>
<h4
id="手动部署app的方法一个最简单的demo">2、手动部署app的方法：一个最简单的demo：</h4>
<ul>
<li>在webapps里新建一个文件夹叫test</li>
<li>test文件夹内新建一个文件夹叫WEB-INF，这个文件夹名字是定死的。</li>
<li>同时在test目录下部署项目资源</li>
<li>最简单部署完以后，既可以通过localhost:8080/test访问服务</li>
</ul>
<h4
id="在idea下建立项目并配置tomcat完成可以自动部署的流程">3、在IDEA下建立项目，并配置Tomcat，完成可以自动部署的流程：</h4>
<ul>
<li>首先建立一个空的Project</li>
<li>选择File-&gt;Project Structure-&gt;Modules-&gt; + -&gt;Web
增加一个Webapp模块</li>
<li>然后增加对应的artifacts（Artifact
是maven中的一个概念，表示某个module要如何打包。例如war
exploded、war、jar、ear等等这种打包形式； 一个module有了 Artifacts
就可以部署到应用服务器中了。不带exploded的是打包压缩过的，带exploded的是没有打包压缩过而是分开的。开发建议带exploded）</li>
<li>随后在右上角运行配置项里新增Tomcat Server，并配置On Update
action为Redeploy，On frame deactivation为Update classes and
resources，这样我们修改了代码以后它会自动更新部署。</li>
<li>在Deployment中增加之前我们增加的web模块的artifact即可。</li>
</ul>
<h3 id="二servlet">二、Servlet</h3>
<h4 id="做一个最简单的servlet-app">1、做一个最简单的Servlet App</h4>
<h5 id="工程配置">1）工程配置：</h5>
<p>​
由于想要接受前端页面的请求，我们必须要继承某个类，即HttpServlet类。这个类并不在jdk中，而是在tomcat中有，所以第一步需要将tomcat添加到模块的项目的依赖项中。</p>
<ul>
<li><p>File-&gt;Project Structure-&gt;Modules-&gt; 选中当前模块 -&gt;
Dependencies -&gt; 新增 -&gt; Library -&gt; Tomcat
即可，配置完成后会发现外部依赖项里多了Tomcat8.5</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221115145108886.png" /></p></li>
</ul>
<h5 id="写处理请求的类">2）写处理请求的类：</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myAddServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">priceStr</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">price</span> <span class="operator">=</span> Integer.parseInt(priceStr);</span><br><span class="line">        System.out.println(<span class="string">&quot;name=&quot;</span> + name);</span><br><span class="line">        System.out.println(<span class="string">&quot;price=&quot;</span> + price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="写项目中的html文件">3）写项目中的HTML文件：</h5>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;add&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">name</span>=<span class="string">&quot;price&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="配置项目目录中的web.xml文件">4）配置项目目录中的web.xml文件</h5>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myAddServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.demo.myAddServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myAddServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/add<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>至此位置，项目的目录结构如下：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221115145901182.png" /></p>
<p>请求的全过程如下：</p>
<ul>
<li>用户发请求，action=add</li>
<li>项目中，从web.xml的servlet-mapping中找到url-pattern=/add</li>
<li>知道/add对应的servlet-name=Addservlet后去servlet中找和servlet-name=Addservlet的servlet-class</li>
<li>找到对应的servlet-class为-&gt;com.demo.myAddServlet</li>
<li>由于用户发透的是post请求，因此tomcat会共行Addservlet中的doPost()方法</li>
</ul>
<h5
id="处理请求的中文字符乱码的问题">5）处理请求的中文字符乱码的问题：</h5>
<p>​ 在Tomcat8中，Post请求中，doPost函数最开始，添加如下代码即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">req.setCharacterEncoding(&quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure>
<h4
id="servlet的继承关系及service方法">2、Servlet的继承关系及Service方法：</h4>
<p>​ 自己写的类需要继承HttpServlet类， 继承关系如下：HttpServlet -&gt;
GenericServlet -&gt; Servlet</p>
<ul>
<li><p>javax.servlet.Servlet接口:</p>
<ul>
<li>void init(config) - 初始化方法</li>
<li>void service(request,response) - 服务方法</li>
<li>void destory() - 销毁方法</li>
</ul></li>
<li><p>javax.servlet.GenericServlet抽象类：</p>
<ul>
<li>void service(request,response) - 仍然是抽象的</li>
</ul></li>
<li><p>javax.servlet.http.HttpServlet 抽象子类：</p>
<ul>
<li>void service(request,response) - 不是抽象的，内部逻辑如下
<ol type="1">
<li>String method = req.getMethod(); 获取请求的方式</li>
<li>各种if判断，根据请求方式不同，决定去调用不同的do方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (method.equals(<span class="string">&quot;GET&quot;</span>)) &#123;</span><br><span class="line"> <span class="built_in">this</span>.doGet(req,resp);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;HEAD&quot;</span>)) &#123;</span><br><span class="line"> <span class="built_in">this</span>.doHead(req, resp);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line"> <span class="built_in">this</span>.doPost(req, resp);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>在HttpServlet这个抽象类中，do方法都差不多,如下：我们可以看到，就是执行报错的一个过程</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">protocol</span> <span class="operator">=</span> req.getProtocol();</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_get_not_supported&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (protocol.endsWith(<span class="string">&quot;1.1&quot;</span>)) &#123;</span><br><span class="line">     resp.sendError(<span class="number">405</span>, msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     resp.sendError(<span class="number">400</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><strong>总而言之：当有请求过来时，service方法会自动响应（其实是tomcat容器调用的），然后在HttpServlet的service方法中我们会去分析请求的方式：到底是get、post、head还是delete等等，然后再决定调用的是哪个do开头的方法。在HttpServlet中这些do方法默认都是405的报错实现风格-所以我们子类如果没有实现对应的方法，比如没有实现doGet方法但是前端请求了该url的get，就会默认报405错误</strong></p></li>
</ul>
<h4 id="servlet的生命周期">3、Servlet的生命周期：</h4>
<ul>
<li><p>对应Servlet中的三个方法：init(),service(),destroy()</p>
<ul>
<li>第一次接收请求时，这个Servlet会进行实例化(调用构造方法)、初始化(调用init())、然后服务(调用service())</li>
<li>从第二次请求开始，每一次都是服务</li>
<li>当容器关闭时，其中的所有的servlet实例会被销毁，调用销毁方法</li>
</ul></li>
<li><p>Servlet实例tomcat只会创建一个，所有的请求都是这个实例去响应。</p></li>
<li><p>Servlet的初始化时机：默认是第一次接收请求时，实例化，初始化，我们可以通过<load-on-startup>来设置servlet启动的先后顺序,数字越小，启动越靠前，最小值0</p></li>
<li><p>Servlet在容器中是：单例的、线程不安全的</p>
<ul>
<li>单例：所有的请求都是同一个实例去响应</li>
<li>线程不安全：一个线程需要根据这个实例中的某个成员变量值去做逻辑判断。但是在中间某个时机，另一个线程改变了这个成员变量的值，从而导致第一个线程的执行路径发生了变化</li>
</ul></li>
<li><p>故而：尽量不要在servlet中定义成员变量。如果不得不定义成员变量，那么</p>
<ul>
<li>①不要去修改成员变量的值</li>
<li>②不要去根据成员变量的值做一些逻辑判断</li>
</ul></li>
</ul>
<h4 id="session会话跟踪">4、Session会话跟踪：</h4>
<p>​ 通过会话跟踪技术来解决Http无状态的问题，具体如下所示：</p>
<ul>
<li>客户端第一次发请求给服务器，服务器获取session，获取不到，则创建新的，然后响应给客户端</li>
<li>下次客户端给服务器发请求时，会把sessionID带给服务器，那么服务器就能获取到了，那么服务器就判断这一次请求和上次某次请求是同一个客户端，从而能够区分开客户端</li>
</ul>
<p>常见的session相关的API：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.getSession() <span class="comment">// 获取当前的会话，没有则创建一个新的会话</span></span><br><span class="line">request.getSession(<span class="literal">true</span>) <span class="comment">// 效果和不带参数相同</span></span><br><span class="line">request.getSession(<span class="literal">false</span>) <span class="comment">// 获取当前会话，没有则返回null，不会创建新的</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">session.getId() <span class="comment">// 获取sessionID</span></span><br><span class="line">session.isNew() <span class="comment">// 判断当前session是否是新的</span></span><br><span class="line">session.getMaxInactiveInterval() <span class="comment">// session的非激活间隔时长，默认1800秒</span></span><br><span class="line">session.setMaxInactiveInterval()</span><br><span class="line">session.invalidate() <span class="comment">// 强制性让会话立即失效</span></span><br></pre></td></tr></table></figure>
<ul>
<li>书写一个Session测试用的Servlet：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mySessionServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">        System.out.println(<span class="string">&quot;Session Id:&quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>浏览器第一次请求该接口：</p>
<ul>
<li>可以看到响应头—有了一个字段Set-Cookie，即服务器返回的SESSIONID</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221115204052061.png" /></p>
<ul>
<li>随后浏览器会自动将这个字段存到Cookie中的JSESSIONID</li>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221115203959564.png" /></li>
</ul></li>
<li><p>浏览器后续请求该接口时，会自动携带该字段向服务器发起请求，服务器即能识别</p></li>
</ul>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221115203917388.png"
alt="image-20221115203917388" />
<figcaption aria-hidden="true">image-20221115203917388</figcaption>
</figure>
<h4 id="session的保存作用域">5、Session的保存作用域：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">session.setAttribute(k,v);   <span class="comment">//向当前Session保存作用域中添加一组key,value</span></span><br><span class="line">session.getAttribute(k);     <span class="comment">//获取当前Session保存作用中的key的值</span></span><br></pre></td></tr></table></figure>
<h4
id="服务器内部转发和客户端重定向">6、服务器内部转发和客户端重定向</h4>
<p>1） 服务器内部转发 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">request.getRequestDispatcher(&quot;....&quot;).forward(request,response);</span><br></pre></td></tr></table></figure>
<ul>
<li>一次请求响应的过程，对于客户端而言，内部经过了多少次转发，客户端是不知道的</li>
<li>地址栏没有变化</li>
</ul>
<p>2） 客户端重定向：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">response.sendRedirect(&quot;....&quot;);</span><br></pre></td></tr></table></figure>
<ul>
<li>两次请求响应的过程。客户端肯定知道请求URL有变化</li>
<li>地址栏有变化</li>
</ul>
<h4 id="简化servlet-url的注册方式">7、简化Servlet Url的注册方式：</h4>
<p>​
从Servlet3.0版本开始，就支持注解方式的注册，如下，这样就不需要在web.xml文件中写配置了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mySessionServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">        System.out.println(session.getAttribute(<span class="string">&quot;uname&quot;</span>));</span><br><span class="line">        session.setAttribute(<span class="string">&quot;uname&quot;</span>,<span class="string">&quot;fantast&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Session Id:&quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4
id="如何让html内动态渲染数据thymeleaf视图模板技术此处略说">8、如何让HTML内动态渲染数据？Thymeleaf视图模板技术（此处略说）</h4>
<p>​
实际上就是创建了一个类ViewBaseServlet，继承HttpServlet，其中提供了将数据渲染至对应模板文件的函数，之后所有的Servlet就可以继承他，就可以方便的返回渲染好的HTML文件，而不用重复进行渲染。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewBaseServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> TemplateEngine templateEngine;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"> 		<span class="comment">//在初始化的时候初始化一些渲染模板用的实例</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processTemplate</span><span class="params">(String templateName, HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//通过该函数，将动态数据渲染至一些对应的模板文件，从而方便直接返回直接渲染好的HTML页面</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="servlet的保存作用域">9、Servlet的保存作用域：</h4>
<p>​
其中有四个级别的保存作用域，page（已经不用了），request（一次请求响应范围），session（一次会话范围），application</p>
<ul>
<li>request：单次请求级别
<ul>
<li>如果采用服务器内部转发的形式，是能够获取到request级别的作用域的</li>
<li>如果采用客户端重定向的形式，则是获取不到request级别的作用域的</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">req.setAttribute(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;fantast&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>session：会话级别，见上</li>
<li>application：应用程序级别，只要有一个会话保存了k,v属性，那么所有会话都可以访问到对应k的属性v</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> request.getSetvletContext();</span><br><span class="line">application.setAttribute(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;fantast&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="三servlet优化mvc架构">三、Servlet优化——MVC架构：</h3>
<h4
id="简化功能类似的servlet至一个servlet">1、简化功能类似的servlet至一个servlet</h4>
<p>​
比如说，可以合并所有用户相关的增删改查操作至一个servlet中，重写其的service方法即可</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221115215818336.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">//设置编码</span></span><br><span class="line">    request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">operate</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;operate&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(StringUtil.isEmpty(operate))&#123;</span><br><span class="line">        operate = <span class="string">&quot;index&quot;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(operate)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;index&quot;</span>:</span><br><span class="line">            index(request,response);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;add&quot;</span>:</span><br><span class="line">            add(request,response);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;del&quot;</span>:</span><br><span class="line">            del(request,response);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;edit&quot;</span>:</span><br><span class="line">            edit(request,response);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;update&quot;</span>:</span><br><span class="line">            update(request,response);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;operate值非法!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4
id="使用反射机制优化一个servlet内的结构">2、使用反射机制优化一个Servlet内的结构：</h4>
<p>​ 按照第一步的简化，service方法中会存在很多的switch
case方法，来执行不同的逻辑。一旦方法逻辑多了，就很容易导致代码冗杂。通过java的反射机制改造如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">//设置编码</span></span><br><span class="line">    request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">operate</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;operate&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(StringUtil.isEmpty(operate))&#123;</span><br><span class="line">        operate = <span class="string">&quot;index&quot;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method[] methods = <span class="built_in">this</span>.getClass().getDeclaredMethods();</span><br><span class="line">    <span class="keyword">for</span>(Method m : methods)&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> m.getName();</span><br><span class="line">        <span class="keyword">if</span>(operate,equals(methodName))&#123;</span><br><span class="line">            <span class="comment">//找到和operate同名的方法，通过反射来调用</span></span><br><span class="line">            m.invoke(request,response)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="dispatcher-servlet核心控制器优化请求转发">3、Dispatcher
Servlet核心控制器优化请求转发：</h4>
<p>​ 通过Dispatcher
Servlet核心控制器，来管控所有的请求，根据不同的请求内容处理转发至对应的各个Servlet，比如FruitServlet，UserServlet，OrderServlet等等。此时，由于各个原先的Servlet不需要直接注册url了，所以本质上已经不是Servlet，已经是个普通类了，我们改名叫FruitController，UserController等，故将整个架构图改成如下所示：此时核心的Dispatcher
Servlet类代码和applicationContext.xml文件如下所示：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221116094213840.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;*.do&quot;)</span>  <span class="comment">//注册所有的*.do的路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; beanMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DispatcherServlet</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//1.创建DocumentBuilderFactory</span></span><br><span class="line">        <span class="type">DocumentBuilderFactory</span> <span class="variable">documentBuilderFactory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">        <span class="comment">//2.创建DocumentBuilder对象</span></span><br><span class="line">        <span class="type">DocumentBuilder</span> <span class="variable">documentBuilder</span> <span class="operator">=</span> documentBuilderFactory.newDocumentBuilder() ;</span><br><span class="line">        <span class="comment">//3.创建Document对象</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> documentBuilder.parse(inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.获取所有的bean节点</span></span><br><span class="line">        <span class="type">NodeList</span> <span class="variable">beanNodeList</span> <span class="operator">=</span> document.getElementsByTagName(<span class="string">&quot;bean&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;beanNodeList.getLength() ; i++)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">beanNode</span> <span class="operator">=</span> beanNodeList.item(i);</span><br><span class="line">            <span class="keyword">if</span>(beanNode.getNodeType() == Node.ELEMENT_NODE)&#123;</span><br><span class="line">                <span class="type">Element</span> <span class="variable">beanElement</span> <span class="operator">=</span> (Element)beanNode ;</span><br><span class="line">                <span class="type">String</span> <span class="variable">beanId</span> <span class="operator">=</span>  beanElement.getAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> beanElement.getAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">                <span class="type">Class</span> <span class="variable">controllerBeanClass</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">beanObj</span> <span class="operator">=</span> controllerBeanClass.newInstance() ;</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setServletContextMethod</span> <span class="operator">=</span> controllerBeanClass.getDeclaredMethod(<span class="string">&quot;setServletContext&quot;</span>,ServletContext.class);</span><br><span class="line">                setServletContextMethod.invoke(beanObj , <span class="built_in">this</span>.getServletContext());</span><br><span class="line"></span><br><span class="line">                beanMap.put(beanId , beanObj) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//设置编码</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 假设url是：  http://localhost:8080/pro15/hello.do</span></span><br><span class="line">        <span class="comment">// 那么servletPath是：    /hello.do</span></span><br><span class="line">        <span class="comment">// 我的思路是：</span></span><br><span class="line">        <span class="comment">// 第1步： /hello.do -&gt;   hello   或者  /fruit.do  -&gt; fruit</span></span><br><span class="line">        <span class="comment">// 第2步： hello -&gt; HelloController 或者 fruit -&gt; FruitController</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">servletPath</span> <span class="operator">=</span> request.getServletPath();</span><br><span class="line">        servletPath = servletPath.substring(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastDotIndex</span> <span class="operator">=</span> servletPath.lastIndexOf(<span class="string">&quot;.do&quot;</span>) ;</span><br><span class="line">        servletPath = servletPath.substring(<span class="number">0</span>,lastDotIndex);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">controllerBeanObj</span> <span class="operator">=</span> beanMap.get(servletPath);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">operate</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;operate&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtil.isEmpty(operate))&#123;</span><br><span class="line">            operate = <span class="string">&quot;index&quot;</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> controllerBeanObj.getClass().getDeclaredMethod(operate,HttpServletRequest.class,HttpServletResponse.class);</span><br><span class="line">            <span class="keyword">if</span>(method!=<span class="literal">null</span>)&#123;</span><br><span class="line">                method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                method.invoke(controllerBeanObj,request,response);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;operate值非法!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这个bean标签的作用是 将来servletpath中涉及的名字对应的是fruit，那么就要FruitController这个类来处理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;fruit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.fruit.controllers.FruitController&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="dispatcher-servlet核心控制器优化视图资源重定向">4、Dispatcher
Servlet核心控制器优化视图资源重定向：</h4>
<p>​
我们发现，在上面的架构中，Controller中不同的函数最后还是要执行视图资源的重定向，我们希望把这个事情统一交给核心控制器来管理，Controller不需要关心任何视图层的内容：</p>
<p>​
首先更改FruitController最后，将资源重定向变成返回一个字符串，交给Dispathcer
Servlet来处理重定向</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FruitController</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.设置编码</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fidStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fid&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">fid</span> <span class="operator">=</span> Integer.parseInt(fidStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">fname</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fname&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">priceStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> Integer.parseInt(priceStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">fcountStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fcount&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">fcount</span> <span class="operator">=</span> Integer.parseInt(fcountStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">remark</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;remark&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.执行更新</span></span><br><span class="line">        fruitDAO.updateFruit(<span class="keyword">new</span> <span class="title class_">Fruit</span>(fid,fname, price ,fcount ,remark ));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.资源跳转</span></span><br><span class="line">        <span class="comment">//super.processTemplate(&quot;index&quot;,request,response);</span></span><br><span class="line">        <span class="comment">//request.getRequestDispatcher(&quot;index.html&quot;).forward(request,response);</span></span><br><span class="line">        <span class="comment">//此处需要重定向，目的是重新给IndexServlet发请求，重新获取furitList，然后覆盖到session中，这样index.html页面上显示的session中的数据才是最新的</span></span><br><span class="line">        </span><br><span class="line">    	<span class="comment">//response.sendRedirect(&quot;fruit.do&quot;);</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;redirect:fruit.do&quot;</span>;    </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​ 然后更改DispatchController:
在service函数中的调用controller对应方法后，我们还需要根据controller传回的字符串来负责视图资源的处理重定向。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.controller组件中的方法调用</span></span><br><span class="line">method.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">returnObj</span> <span class="operator">=</span> method.invoke(controllerBeanObj,parameterValues);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.视图处理</span></span><br><span class="line"><span class="type">String</span> <span class="variable">methodReturnStr</span> <span class="operator">=</span> (String)returnObj ;</span><br><span class="line"><span class="keyword">if</span>(methodReturnStr.startsWith(<span class="string">&quot;redirect:&quot;</span>))&#123;        <span class="comment">//比如：  redirect:fruit.do</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">redirectStr</span> <span class="operator">=</span> methodReturnStr.substring(<span class="string">&quot;redirect:&quot;</span>.length());</span><br><span class="line">    response.sendRedirect(redirectStr);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="built_in">super</span>.processTemplate(methodReturnStr,request,response);    <span class="comment">// 比如：  &quot;edit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="dispatcher-servlet核心控制器优化参数获取">5、Dispatcher
Servlet核心控制器优化参数获取：</h4>
<p>​
由于我们发现Controller中不同的方法里面，都会从request中获取参数，只不过获取的参数不一样罢了，我们想要把这部分也交付给Dispatcher
Servlet来完成，使得Controller这一层只负责逻辑的控制，业务的处理，不需要关心参数获取、视图转移等等问题。首先简化Controller中的方法，我们发现至此根本不需要给Controller传任何请求相关的内容了，它完全不关心这部分事情</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">update</span><span class="params">(Integer fid , String fname , Integer price , Integer fcount , String remark )</span>&#123;</span><br><span class="line">    <span class="comment">//1.执行更新</span></span><br><span class="line">    fruitDAO.updateFruit(<span class="keyword">new</span> <span class="title class_">Fruit</span>(fid,fname, price ,fcount ,remark ));</span><br><span class="line">    <span class="comment">//2.资源跳转</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:fruit.do&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">add</span><span class="params">(String fname , Integer price , Integer fcount , String remark )</span> &#123;</span><br><span class="line">    <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="number">0</span>,fname , price , fcount , remark ) ;</span><br><span class="line">    fruitDAO.addFruit(fruit);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:fruit.do&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ <strong>随后，我们要在Dispathcer
Servlet中书写负责处理此部分的代码：如何根据不同的函数需要获取的参数来从request拿参数是非常核心的一个点——反射机制：</strong>以下是改造完以后，Dispatcher
Servlet的service方法最终代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">       <span class="comment">//设置编码</span></span><br><span class="line">       request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">       <span class="comment">//假设url是：  http://localhost:8080/pro15/hello.do</span></span><br><span class="line">       <span class="comment">//那么servletPath是：    /hello.do</span></span><br><span class="line">       <span class="comment">// 我的思路是：</span></span><br><span class="line">       <span class="comment">// 第1步： /hello.do -&gt;   hello   或者  /fruit.do  -&gt; fruit</span></span><br><span class="line">       <span class="comment">// 第2步： hello -&gt; HelloController 或者 fruit -&gt; FruitController</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">servletPath</span> <span class="operator">=</span> request.getServletPath();</span><br><span class="line">       servletPath = servletPath.substring(<span class="number">1</span>);</span><br><span class="line">       <span class="type">int</span> <span class="variable">lastDotIndex</span> <span class="operator">=</span> servletPath.lastIndexOf(<span class="string">&quot;.do&quot;</span>) ;</span><br><span class="line">       servletPath = servletPath.substring(<span class="number">0</span>,lastDotIndex);</span><br><span class="line"></span><br><span class="line">       <span class="type">Object</span> <span class="variable">controllerBeanObj</span> <span class="operator">=</span> beanMap.get(servletPath);</span><br><span class="line"></span><br><span class="line">       <span class="type">String</span> <span class="variable">operate</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;operate&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span>(StringUtil.isEmpty(operate))&#123;</span><br><span class="line">           operate = <span class="string">&quot;index&quot;</span> ;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Method[] methods = controllerBeanObj.getClass().getDeclaredMethods();</span><br><span class="line">           <span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">               <span class="keyword">if</span>(operate.equals(method.getName()))&#123;</span><br><span class="line">                   <span class="comment">//1.统一获取请求参数</span></span><br><span class="line">                   <span class="comment">//1-1.获取当前方法的参数，返回参数数组</span></span><br><span class="line">                   Parameter[] parameters = method.getParameters();</span><br><span class="line">                   <span class="comment">//1-2.parameterValues 用来承载参数的值</span></span><br><span class="line">                   Object[] parameterValues = <span class="keyword">new</span> <span class="title class_">Object</span>[parameters.length];</span><br><span class="line">                   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">                       <span class="type">Parameter</span> <span class="variable">parameter</span> <span class="operator">=</span> parameters[i];</span><br><span class="line">                       <span class="type">String</span> <span class="variable">parameterName</span> <span class="operator">=</span> parameter.getName() ;</span><br><span class="line">                       <span class="comment">//如果参数名是request,response,session 那么就不是通过请求中获取参数的方式了</span></span><br><span class="line">                       <span class="keyword">if</span>(<span class="string">&quot;request&quot;</span>.equals(parameterName))&#123;</span><br><span class="line">                           parameterValues[i] = request ;</span><br><span class="line">                       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;response&quot;</span>.equals(parameterName))&#123;</span><br><span class="line">                           parameterValues[i] = response ;</span><br><span class="line">                       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;session&quot;</span>.equals(parameterName))&#123;</span><br><span class="line">                           parameterValues[i] = request.getSession() ;</span><br><span class="line">                       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                           <span class="comment">//从请求中获取参数值</span></span><br><span class="line">                           <span class="type">String</span> <span class="variable">parameterValue</span> <span class="operator">=</span> request.getParameter(parameterName);</span><br><span class="line">                           <span class="type">String</span> <span class="variable">typeName</span> <span class="operator">=</span> parameter.getType().getName();</span><br><span class="line">                           <span class="type">Object</span> <span class="variable">parameterObj</span> <span class="operator">=</span> parameterValue ;</span><br><span class="line">                           <span class="keyword">if</span>(parameterObj!=<span class="literal">null</span>) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (<span class="string">&quot;java.lang.Integer&quot;</span>.equals(typeName)) &#123;</span><br><span class="line">                                   parameterObj = Integer.parseInt(parameterValue);</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                           parameterValues[i] = parameterObj ;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//2.controller组件中的方法调用</span></span><br><span class="line">                   method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                   <span class="type">Object</span> <span class="variable">returnObj</span> <span class="operator">=</span> method.invoke(controllerBeanObj,parameterValues);</span><br><span class="line"></span><br><span class="line">                   <span class="comment">//3.视图处理</span></span><br><span class="line">                   <span class="type">String</span> <span class="variable">methodReturnStr</span> <span class="operator">=</span> (String)returnObj ;</span><br><span class="line">                   <span class="keyword">if</span>(methodReturnStr.startsWith(<span class="string">&quot;redirect:&quot;</span>))&#123;        <span class="comment">//比如：  redirect:fruit.do</span></span><br><span class="line">                       <span class="type">String</span> <span class="variable">redirectStr</span> <span class="operator">=</span> methodReturnStr.substring(<span class="string">&quot;redirect:&quot;</span>.length());</span><br><span class="line">                       response.sendRedirect(redirectStr);</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       <span class="built_in">super</span>.processTemplate(methodReturnStr,request,response);    <span class="comment">// 比如：  &quot;edit&quot;</span></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">           &#125;else&#123;</span></span><br><span class="line"><span class="comment">               throw new RuntimeException(&quot;operate值非法!&quot;);</span></span><br><span class="line"><span class="comment">           &#125;</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="mvc架构搭建完成总结">6、MVC架构搭建完成总结：</h4>
<p>​
至此为止，我们已经自己基于Servlet构建了一个MVC框架的大概，整个的架构演变过程如下：</p>
<ol type="1">
<li>最初的做法是：
一个请求对应一个Servlet，这样存在的问题是servlet太多了</li>
<li>把一些类似的请求都对应一个Servlet, 比如
IndexServlet/AddServlet/EditServlet/DelServlet/UpdateServlet -&gt;
合并成FruitServlet，通过一个operate的值来决定调用FruitServlet中的哪一个方法，使用的是switch-case</li>
<li>在上一个版本中，Servlet中充斥着大量的switch-case，如果项目的业务规模扩大，那么会有很多的Servlet，也就意味着会有很多的switch-case，这是一种代码冗余。因此，我们在servlet中使用了反射技术，<strong>规定operate的值和方法名一致</strong>，那么接收到operate的值是什么就表明我们需要调用对应的方法进行响应，如果找不到对应的方法，则抛异常</li>
<li>在上一个版本中我们使用了反射技术，但是其实还是存在一定的问题：<strong>每一个servlet中都有类似的反射技术的代码。因此继续抽取，设计了中央控制器类：DispatcherServlet</strong>，DispatcherServlet这个类的工作分为两大部分：
<ul>
<li>根据url定位到能够处理这个请求的controller组件：
<ul>
<li>从url中提取servletPath : /fruit.do -&gt; fruit</li>
<li>根据fruit找到对应的组件:FruitController ，
这个对应的依据我们存储在applicationContext.xml中</li>
<li>&lt;bean id="fruit"
class="com.atguigu.fruit.controllers.FruitController/&gt;</li>
<li>通过DOM技术我们去解析XML文件，在中央控制器中形成一个beanMap容器，用来存放所有的Controller组件</li>
<li>根据获取到的operate的值定位到我们FruitController中需要调用的方法</li>
</ul></li>
<li>调用Controller组件中的方法：
<ul>
<li>获取参数 获取即将要调用的方法的参数签名信息: Parameter[] parameters
= method.getParameters(); 通过parameter.getName()获取参数的名称；
准备了Object[] parameterValues 这个数组用来存放对应参数的参数值
另外，我们需要考虑参数的类型问题，需要做类型转化的工作。通过parameter.getType()获取参数的类型</li>
<li>执行方法 Object returnObj = method.invoke(controllerBean ,
parameterValues);</li>
<li>视图处理，进行重定向 String returnStr = (String)returnObj;
if(returnStr.startWith("redirect:")){ .... }</li>
</ul></li>
</ul></li>
</ol>
<h3 id="四servlet-进阶">四、Servlet 进阶：</h3>
<h4 id="初始化方法init">1、初始化方法Init</h4>
<p>Servlet中的初始化方法有两个：init() , init(config) <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="built_in">this</span>.config = config ;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我们想要在Servlet初始化时做一些准备工作，那么我们可以重写init方法，可以通过如下步骤去获取初始化设置的数据</p>
<ul>
<li>获取config对象：ServletConfig config = getServletConfig();</li>
<li>获取初始化参数值： config.getInitParameter(key);</li>
</ul>
<p>这些初始化参数值是可以在web.xml中进行配置的，然后可以在init中获取</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>world<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以通过注解方式配置获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &#123;&quot;/demo01&quot;&#125; ,</span></span><br><span class="line"><span class="meta">	initParams = &#123;</span></span><br><span class="line"><span class="meta">        @WebInitParam(name=&quot;hello&quot;,value=&quot;world&quot;),</span></span><br><span class="line"><span class="meta">        @WebInitParam(name=&quot;uname&quot;,value=&quot;jim&quot;)</span></span><br><span class="line"><span class="meta">	&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure>
<h4
id="servletcontext和context-param">2、ServletContext和&lt;context-param&gt;</h4>
<ul>
<li><p>获取ServletContext的方法</p>
<ul>
<li><p>在初始化方法中：</p>
<p>ServletContxt servletContext = getServletContext();</p></li>
<li><p>在服务方法中也可以通过request对象获取，也可以通过session获取：</p>
<p>request.getServletContext(); session.getServletContext()</p></li>
</ul></li>
<li><p>获取初始化值： servletContext.getInitParameter();</p></li>
</ul>
<h4 id="mvc各层说明">3、MVC各层说明</h4>
<ul>
<li><p>View 视图层：用于做数据展示以及和用户交互的一个界面</p></li>
<li><p>Controller
控制层：能够接受客户端的请求，具体的业务功能还是需要借助于<strong>模型组件</strong>来完成</p></li>
<li><p>Model 模型层：模型分为很多种：有比较简单的pojo/vo(value
object)，有业务模型组件，有数据访问层组件</p>
<ul>
<li><p>pojo/vo : 值对象</p></li>
<li><p>DAO(Data Access Object) ：数据访问对象</p></li>
<li><p>BO(Business Object) ： 业务对象</p></li>
</ul></li>
<li><p>DAO中的方法都是单精度方法或者称之为细粒度方法。什么叫单精度？一个方法只考虑一个操作，比如添加，那就是insert操作、查询那就是select操作...</p></li>
<li><p>BO中的方法属于业务方法，也实际的业务是比较复杂的，因此业务方法的粒度是比较粗的</p></li>
</ul>
<p>​
根据上述思想，我们需要加一层Service业务模型组件：Service中的业务模型组件会调用DAO数据访问层组件，由此一来，Controller层不需要关注业务功能，他只要能够接受客户端的请求并借助模型组件来完成请求就可以。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FruitService</span> &#123;</span><br><span class="line">    <span class="comment">//获取指定页面的库存列表信息</span></span><br><span class="line">    List&lt;Fruit&gt; <span class="title function_">getFruitList</span><span class="params">(String keyword , Integer pageNo)</span>;</span><br><span class="line">    <span class="comment">//添加库存记录信息</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addFruit</span><span class="params">(Fruit fruit)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">FruitService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">FruitDAOImpl</span> <span class="variable">fruitDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitDAOImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Fruit&gt; <span class="title function_">getFruitList</span><span class="params">(String keyword, Integer pageNo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fruitDAO.getFruitList(keyword,pageNo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFruit</span><span class="params">(Fruit fruit)</span> &#123;</span><br><span class="line">        fruitDAO.addFruit(fruit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​ 至此为止，整个访问架构就如下所示：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221116175837292.png" /></p>
<h4 id="ioc实现">4、IOC实现：</h4>
<p>​ IOC(Inversion of
Control)控制反转：使用对象时,由主动new产生对象转换成,从外部提供对象,在这个过程中,对象的创建控制权由程序转移到外部,此思想称为控制反转</p>
<p>​
为了实现高内聚低耦合的目标，使得层与层之间的依赖关系不那么强。也就是说，我们下层的FruitService删除了以后，不会直接的引起FruitController报错。在先前，我们的FruitController是如下写的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">FruitService</span> <span class="variable">fruitService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">update</span><span class="params">(Integer fid , String fname , Integer price , Integer fcount , String remark )</span>&#123;</span><br><span class="line">        fruitService.updateFruit(<span class="keyword">new</span> <span class="title class_">Fruit</span>(fid,fname, price ,fcount ,remark ));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:fruit.do&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
第一步，我们需要将此处的<code>new FruitServiceImpl()</code>改为<code>null</code>，然后将加载类这个事情交给配置文件和另一个专门加载类的对象，如下所示，修改applicationContext.xml</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;fruitDAO&quot;</span> class=<span class="string">&quot;com.atguigu.fruit.dao.impl.FruitDAOImpl&quot;</span>/&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;fruitService&quot;</span> class=<span class="string">&quot;com.atguigu.fruit.service.impl.FruitServiceImpl&quot;</span>&gt;</span><br><span class="line">        &lt;!-- property标签用来表示属性；name表示属性名；ref表示引用其他bean的id值--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;fruitDAO&quot;</span> ref=<span class="string">&quot;fruitDAO&quot;</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;fruit&quot;</span> class=<span class="string">&quot;com.atguigu.fruit.controllers.FruitController&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;fruitService&quot;</span> ref=<span class="string">&quot;fruitService&quot;</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>​
然后，我们新建如下接口和类：此类可以通过反射机制，解除层与层之间的耦合，<strong>通过xml配置文件的方式来指定层与层之间的依赖关系，而不是将层与层之间的关系写死在代码内部。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.myssm.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactory</span> &#123;</span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(String id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassPathXmlApplicationContext</span> <span class="keyword">implements</span> <span class="title class_">BeanFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; beanMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">            <span class="comment">//1.创建DocumentBuilderFactory</span></span><br><span class="line">            <span class="type">DocumentBuilderFactory</span> <span class="variable">documentBuilderFactory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">            <span class="comment">//2.创建DocumentBuilder对象</span></span><br><span class="line">            <span class="type">DocumentBuilder</span> <span class="variable">documentBuilder</span> <span class="operator">=</span> documentBuilderFactory.newDocumentBuilder() ;</span><br><span class="line">            <span class="comment">//3.创建Document对象</span></span><br><span class="line">            <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> documentBuilder.parse(inputStream);</span><br><span class="line">            <span class="comment">//4.获取所有的bean节点</span></span><br><span class="line">            <span class="type">NodeList</span> <span class="variable">beanNodeList</span> <span class="operator">=</span> document.getElementsByTagName(<span class="string">&quot;bean&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;beanNodeList.getLength() ; i++)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">beanNode</span> <span class="operator">=</span> beanNodeList.item(i);</span><br><span class="line">                <span class="keyword">if</span>(beanNode.getNodeType() == Node.ELEMENT_NODE)&#123;</span><br><span class="line">                    <span class="type">Element</span> <span class="variable">beanElement</span> <span class="operator">=</span> (Element)beanNode ;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">beanId</span> <span class="operator">=</span>  beanElement.getAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> beanElement.getAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">                    <span class="type">Class</span> <span class="variable">beanClass</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">                    <span class="comment">//创建bean实例</span></span><br><span class="line">                    <span class="type">Object</span> <span class="variable">beanObj</span> <span class="operator">=</span> beanClass.newInstance() ;</span><br><span class="line">                    <span class="comment">//将bean实例对象保存到map容器中</span></span><br><span class="line">                    beanMap.put(beanId , beanObj) ;</span><br><span class="line">                    <span class="comment">//到目前为止，此处需要注意的是，bean和bean之间的依赖关系还没有设置</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//5.组装bean之间的依赖关系</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;beanNodeList.getLength() ; i++)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">beanNode</span> <span class="operator">=</span> beanNodeList.item(i);</span><br><span class="line">                <span class="keyword">if</span>(beanNode.getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">                    <span class="type">Element</span> <span class="variable">beanElement</span> <span class="operator">=</span> (Element) beanNode;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">beanId</span> <span class="operator">=</span> beanElement.getAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                    <span class="type">NodeList</span> <span class="variable">beanChildNodeList</span> <span class="operator">=</span> beanElement.getChildNodes();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; beanChildNodeList.getLength() ; j++) &#123;</span><br><span class="line">                        <span class="type">Node</span> <span class="variable">beanChildNode</span> <span class="operator">=</span> beanChildNodeList.item(j);</span><br><span class="line">                        <span class="keyword">if</span>(beanChildNode.getNodeType()==Node.ELEMENT_NODE &amp;&amp; <span class="string">&quot;property&quot;</span>.equals(beanChildNode.getNodeName()))&#123;</span><br><span class="line">                            <span class="type">Element</span> <span class="variable">propertyElement</span> <span class="operator">=</span> (Element) beanChildNode;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">propertyName</span> <span class="operator">=</span> propertyElement.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                            <span class="type">String</span> <span class="variable">propertyRef</span> <span class="operator">=</span> propertyElement.getAttribute(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">                            <span class="comment">//1) 找到propertyRef对应的实例</span></span><br><span class="line">                            <span class="type">Object</span> <span class="variable">refObj</span> <span class="operator">=</span> beanMap.get(propertyRef);</span><br><span class="line">                            <span class="comment">//2) 将refObj设置到当前bean对应的实例的property属性上去</span></span><br><span class="line">                            <span class="type">Object</span> <span class="variable">beanObj</span> <span class="operator">=</span> beanMap.get(beanId);</span><br><span class="line">                            <span class="type">Class</span> <span class="variable">beanClazz</span> <span class="operator">=</span> beanObj.getClass();</span><br><span class="line">                            <span class="type">Field</span> <span class="variable">propertyField</span> <span class="operator">=</span> beanClazz.getDeclaredField(propertyName);</span><br><span class="line">                            propertyField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                            propertyField.set(beanObj,refObj);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParserConfigurationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SAXException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> beanMap.get(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，有了如下组件以后，在Dispatcher
Controller中的init()函数里的加载也可以挪到这里面来进行。修改Dispathcer
Controller的init()方法。所有的内容统一从BeanFactory中进行加载：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> BeanFactory beanFactory ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="built_in">super</span>.init();</span><br><span class="line">    beanFactory = <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<p><strong>IOC 控制反转：</strong></p>
<ol type="1">
<li><p>之前在Servlet中，我们创建service对象 ， FruitService fruitService
= new FruitServiceImpl();</p>
<ul>
<li><p>这句话如果出现在servlet中的某个方法内部，那么这个fruitService的作用域（生命周期）应该就是这个方法级别；</p></li>
<li><p>如果这句话出现在servlet的类中，也就是说fruitService是一个成员变量，那么这个fruitService的作用域（生命周期）应该就是这个servlet实例级别</p></li>
</ul></li>
<li><p>之后我们在applicationContext.xml中定义了这个fruitService。然后通过解析XML，产生fruitService实例，存放在beanMap中，这个beanMap在一个BeanFactory中</p>
<ul>
<li>因此，我们转移（改变）了之前的service实例、dao实例等等他们的生命周期。<strong>控制权从程序员转移到BeanFactory。这个现象我们称之为控制反转</strong></li>
</ul></li>
</ol>
<p><strong>DI 依赖注入：</strong></p>
<ol type="1">
<li>之前我们在控制层出现代码：FruitService fruitService = new
FruitServiceImpl()；那么，控制层和service层存在耦合。</li>
<li>之后，我们将代码修改成FruitService fruitService = null ;
然后，在配置文件中配置:从而打破这种耦合</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;fruit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;FruitController&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;fruitService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;fruitService&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4
id="过滤器filter其实就是类似请求和响应拦截器">5、过滤器Filter(其实就是类似请求和响应拦截器)</h4>
<ol type="1">
<li><p>Filter也属于Servlet规范</p></li>
<li><p>Filter开发步骤：新建类实现Filter接口，然后实现其中的三个方法：init、doFilter、destroy
配置Filter，可以用注解@WebFilter，也可以使用xml文件 <filter>
<filter-mapping></p></li>
<li><p>Filter在配置时，和servlet一样，也可以配置通配符，例如 <span
class="citation"
data-cites="WebFilter">@WebFilter</span>("*.do")表示拦截所有以.do结尾的请求</p></li>
<li><p>过滤器链（遵循洋葱模型） 1）执行的顺序依次是： A B C demo03 C2 B2
A2
2）如果采取的是注解的方式进行配置，那么过滤器链的拦截顺序是按照<strong>全类名的先后顺序排序的</strong></p>
<p>3）如果采取的是xml的方式进行配置，那么按照配置的先后顺序进行排序</p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;*.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Filter01</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">        <span class="comment">//响应发出去之前要执行的内容</span></span><br><span class="line">        System.out.println(<span class="string">&quot;A2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="事务管理transaction">6、事务管理Transaction</h4>
<h5 id="为什么需要事务管理">1）为什么需要事务管理？</h5>
<ul>
<li>原因很简单：因为我们知道Service往往是由多个DAO模块组件完成的，在之前，我们的数据回滚和提交操作都在DAO内部，这样的话无法定义Service的执行成功或失败。所以我们需要在代码中进行管理：</li>
<li>大致解决思路：使用一个Filter，执行如下流程，其实就是类似一个请求异常捕获机制，那么难点就在于我们需要使得多次DAO操作使用的数据库连接都是同一个，才能让他们在数据库的同一个事务内。如果以函数思想，那么所有的DAO操作都需要传入数据库Connection对象，然后保持Connetion不关闭才可以，有一点点麻烦</li>
</ul>
<p><img
src="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221116221959452.png" /></p>
<ul>
<li>这个时候需要引入一个概念叫ThreadLocal
利用这个技术能够实现如上的需求</li>
<li>这个类有两个方法，set和get，通过set方法可以将Connection对象放到ThreadLocal中，后续就可以通过get方法可以将Connection对象取出，继续使用。</li>
</ul>
<h5
id="事务管理的实现opensessioninviewfilter">2）事务管理的实现：OpenSessionInViewFilter</h5>
<p>首先定义ConnUtil类，统一管理和数据库的连接，也就是说用于取代原来的BaseDAO类：</p>
<p>这个工具类负责创建conncetion,获取connection，关闭connection</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DRIVER</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/fruitdb?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PWD</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title function_">createConn</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.加载驱动</span></span><br><span class="line">            Class.forName(DRIVER);</span><br><span class="line">            <span class="comment">//2.通过驱动管理器获取连接对象</span></span><br><span class="line">            <span class="keyword">return</span> DriverManager.getConnection(URL, USER, PWD);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConn</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line">        <span class="keyword">if</span>(conn==<span class="literal">null</span>)&#123;</span><br><span class="line">            conn =createConn();</span><br><span class="line">            threadLocal.set(conn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get() ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeConn</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line">        <span class="keyword">if</span>(conn==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!conn.isClosed())&#123;</span><br><span class="line">            conn.close();</span><br><span class="line">            threadLocal.set(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>随后定义事务管理类：负责开启事务、提交事务、回滚事务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启事务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">beginTrans</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        ConnUtil.getConn().setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ConnUtil.getConn();</span><br><span class="line">        conn.commit();</span><br><span class="line">        ConnUtil.closeConn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回滚事务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ConnUtil.getConn();</span><br><span class="line">        conn.rollback();</span><br><span class="line">        ConnUtil.closeConn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然就可以定义我们的OpenSessionInViewFilter类了，来做统一的上层的事务管理：逻辑和之前图上分析的一摸一样。所有底层的异常都不要自己处理，都只要往外抛就可以了。或者Catch到了以后加一层信息再往外抛</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;*.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OpenSessionInViewFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            TransactionManager.beginTrans();</span><br><span class="line">            System.out.println(<span class="string">&quot;开启事务....&quot;</span>);</span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">            TransactionManager.commit();</span><br><span class="line">            System.out.println(<span class="string">&quot;提交事务...&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TransactionManager.rollback();</span><br><span class="line">                System.out.println(<span class="string">&quot;回滚事务....&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4
id="关于threadlocal的get方法和set方法原理">7、关于ThreadLocal的Get()方法和Set()方法原理：</h4>
<p>​ ThreadLocal称之为本地线程 。
我们可以通过set方法在<strong>当前线程上存储数据、通过get方法在当前线程上</strong>获取数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">   <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread(); <span class="comment">//获取当前的线程</span></span><br><span class="line">   <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);    <span class="comment">//每一个线程都维护各自的一个容器（ThreadLocalMap）</span></span><br><span class="line">   <span class="keyword">if</span> (map != <span class="literal">null</span>) map.set(<span class="built_in">this</span>, value);          </span><br><span class="line">   <span class="comment">//这里的key对应的是ThreadLocal，因为我们的组件中需要传输（共享）的对象可能会有多个（不止Connection）</span></span><br><span class="line">   <span class="keyword">else</span> createMap(t, value);   <span class="comment">//默认情况下map是没有初始化的，那么第一次往其中添加数据时，会去初始化</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread(); <span class="comment">//获取当前的线程</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);    <span class="comment">//获取和这个线程相关的ThreadLocalMap（也就是工作纽带的集合）</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">    	ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>); <span class="comment">//this指的是ThreadLocal对象，通过它知道哪一个工作纽带</span></span><br><span class="line">    	<span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">    		<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    		<span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;     <span class="comment">//entry.value就可以获取到工具箱了</span></span><br><span class="line">    		<span class="keyword">return</span> result;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="listener监听器">7、Listener监听器</h4>
<ul>
<li>ServletContextListener -
监听ServletContext对象的创建和销毁的过程</li>
<li>HttpSessionListener - 监听HttpSession对象的创建和销毁的过程</li>
<li>ServletRequestListener -
监听ServletRequest对象的创建和销毁的过程</li>
<li>ServletContextAttributeListener -
监听ServletContext的保存作用域的改动(add,remove,replace)</li>
<li>HttpSessionAttributeListener -
监听HttpSession的保存作用域的改动(add,remove,replace)</li>
<li>ServletRequestAttributeListener -
监听ServletRequest的保存作用域的改动(add,remove,replace)</li>
<li>HttpSessionBindingListener -
监听某个对象在Session域中的创建与移除</li>
<li>HttpSessionActivationListener -
监听某个对象在Session域中的序列化和反序列化</li>
</ul>
]]></content>
      <categories>
        <category>⑨ 工程类笔记</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>Servelet</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb中一些技术的逻辑关系梳理</title>
    <url>/2022/11/12/fd10fe3b2e47/</url>
    <content><![CDATA[<h3 id="一尚硅谷给出的java学习路线">一、尚硅谷给出的JAVA学习路线：</h3>
<p>JavaSE --&gt; MySQL--&gt; JDBC --&gt; JavaWeb --&gt; Spring5 --&gt;
SpringMVC --&gt; MyBatis--&gt; Maven --&gt; Ssm框架整合案例 --&gt;
Git/GitHub --&gt; Redis6 --&gt; MySQL高级优化 --&gt; MyBatisPlus --&gt;
Spring注解驱动开发 --&gt; ZooKeeper --&gt; Dubbo --&gt;
消息中间件ActiveMQ --&gt; RabbitMQ --&gt;RocketMQ--&gt;SpringBoot2
--&gt; SpringCloud</p>
<h4 id="javase">1、JavaSE:</h4>
<p>​
JAVA语言学习基础，关于一些对象、类、继承、接口、异常、集合并发等等。</p>
<h4 id="mysql">2、MYSQL：</h4>
<p>​ 最常用的开源数据库，项目开发中必备内容</p>
<h4 id="jdbc">3、JDBC:</h4>
<pre><code>JDBC（Java Database Connectivity）是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口（一组API）。</code></pre>
<p>​
JDBC为访问不同的数据库提供了一种统一的途径，为开发者屏蔽了一些细节问题。
JDBC的目标是<strong>使java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</strong></p>
<h4 id="javaweb">4、JavaWeb</h4>
<h5 id="htmlcssjs">1）html/css/js：</h5>
<p>​
前端web网页三剑客，构成静态网站的最底层的三个语言。属于web资源中的静态资源。</p>
<h5 id="jquery">2）jQuery：</h5>
<p>​ jQuery，是辅助JavaScript
开发的js类库。它实现了很多浏览器的兼容问题。</p>
<h5 id="xml">3）XML：</h5>
<p>​
XML是可扩展的标记性语言。可以用于保存数据、做为项目或者模块的配置文件或做为网络传输数据的格式（现在ISON为主）。</p>
<h5 id="nginx">4）Nginx：</h5>
<p>​
Nginx优点：负载均衡、反向代理、处理静态文件优势。nginx处理静态请求的速度高于apache；</p>
<p>​
Apache优点：相对于Tomcat服务器来说处理静态文件是它的优势，速度快。Apache是静态解析，适合静态HTML、图片等。</p>
<p>​ Tomcat：<a
href="https://www.zhihu.com/search?q=动态解析容器&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A226688632%7D">动态解析容器</a>，处理动态请求，是编译JSP，Nginx有动态分离机制，静态请求直接就可以通过Nginx处理，动态请求才转发请求到后台交由Tomcat进行处理.</p>
<p>​ Tomcat是由 Apache 组织提供的一种Web 服务器，提供对jsp 和Servlet
的支持。它是一种轻量级的javaWeb
容器（服务器），也是当前应用最广的JavaWeb 服务器。</p>
<h5 id="serveletjava程序抽象接口">5）Servelet—java程序（抽象接口）</h5>
<p>​ Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自
Web 浏览器或其他 HTTP 客户端的请求和 HTTP
服务器上的数据库或应用程序之间的中间层。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221110165842713.png" /></p>
<h5 id="jsp语言需要依托tomcat">6）JSP—语言，需要依托tomcat</h5>
<p>​ <strong>JSP 与 PHP、ASP、ASP.NET
等语言类似，运行在服务端的语言。</strong></p>
<p>​ JSP 技术是以 Java 语言作为脚本语言的，JSP 网页为整个服务器端的 Java
库单元提供了一个接口来服务于HTTP的应用程序。先前使用Serverlet开发的话，返回的HTML需要以比较复杂的过程进行构建返回，有了JSP以后，就可以以模板的形式进行渲染返回了。</p>
<h5 id="spring轻量java框架">7）Spring—轻量java框架</h5>
<p>​ Spring是Java EE编程领域的一个轻量级开源框架，该框架由一个叫Rod
Johnson的程序员在 2002
年最早提出并随后创建，是为了解决企业级编程开发中的复杂性，实现敏捷开发的应用型框架
。</p>
<h5 id="springmvc">8）SpringMVC</h5>
<h5 id="mybatis">9）MyBatis</h5>
<h5 id="maven">10）Maven</h5>
<h5 id="section">11）</h5>
]]></content>
      <categories>
        <category>⑨ 工程类笔记</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap15 事务、事务日志与锁</title>
    <url>/2022/11/10/02d829a87e69/</url>
    <content><![CDATA[<h3 id="一事务概述">一、事务概述</h3>
<h4 id="acid特性">1、ACID特性：</h4>
<ul>
<li><p>Atomicity：原子性</p></li>
<li><p>Consistency：一致性，一致性是指事务执行前后，<strong>数据从一个合法性状态变换到另外一个合法性状态。</strong>这种状态是语义上的而不是语法上的，跟具体的业务有关。</p></li>
<li><p>Isolation:
隔离性，一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰.</p></li>
<li><p>Durability：持久性，指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。<strong>持久性是通过事务日志来保证的。日志包括了重做日志和回滚日志。</strong>当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。</p></li>
</ul>
<h4 id="事务的状态">2、事务的状态：</h4>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221110143622797.png" style="zoom: 33%;" /></p>
<h4 id="显式事务和隐式事务">3、显式事务和隐式事务：</h4>
<h5 id="显式事务">1）显式事务：</h5>
<ol type="1">
<li><p>START TRANSACTION [READ ONLY/READ WRITE/WITH CONSISTENT
SNAPSHOT]</p>
<p>显式开启一个事务,READ ONLY
标识当前事务是一个只读事务，也就是属于该事务的数据库操作只能读取数据，而不
能修改数据。READ WRITE
：标识当前事务是一个读写事务，也就是属于该事务的数据库操作既可以读取数据，
也可以修改数据。</p></li>
<li><p>DML语句</p></li>
<li><p>COMMIT / ROLLBACK / ROLLBACK TO [SAVEPOINT]</p></li>
</ol>
<h5 id="隐式事务">2）隐式事务：</h5>
<ul>
<li><p>Mysql中有系统变量：autocommit，当该变量为True时，每个DML语句执行后都会默认提交。【除了显式开启事务内的DML】</p></li>
<li><p>当上述变量为False时，其在何时会隐式的提交数据呢？</p>
<ul>
<li><p>DDL 数据定义语言执行的时候</p></li>
<li><p>隐式使用或修改mysql数据库中的表</p></li>
<li><p>当我们在一个事务还没提交或者回滚时就又使用START TRANSACTION
或者BEGIN 语句开启了另一个事务时，会隐式的提交上一个事务。</p></li>
<li><p>使用LOCK TABLES 、UNLOCK TABLES
等关于锁定的语句也会隐式的提交前边语句所属的事务。</p></li>
<li><p>加载数据LOAD DATA，以及关于MYSQL复制的一些操作</p></li>
</ul></li>
</ul>
<h4 id="事务类型">4、事务类型：</h4>
<p>​ MYSQL中的事务类型参数：completion_type</p>
<ul>
<li>completion_type=0，默认情况，执行COMMIT时提交事务，执行下一个事务的时候还需要使用START_TRANSACTION或BEGIN来开启</li>
<li>completion_type=1，提交事务后相当于执行了COMMIT AND
CHAIN，相当于提交事务后又自动开启了一个相同隔离级别的事务。</li>
<li>completion_type=2，提交事务后会自动与服务器断开连接。</li>
</ul>
<h4 id="事务的隔离级别">5、事务的隔离级别：</h4>
<p>​
事务有隔离性的特性，理论上在某个事务对某个数据进行访问时，其他事务应该进行排队，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样对性能影响太大，我们既想保持事务的隔离性，又想让服务器在处理访问同一数据的多个事务时性能尽量高些，如何权衡？</p>
<h5
id="访问相同数据的事务不串行可能导致的问题">1）访问相同数据的事务不串行可能导致的问题：</h5>
<ul>
<li>脏写：事务Session A 修改了另一个<strong>未提交事务Session B
修改过的数据</strong>，那就意味着发生了脏写</li>
<li>脏读：Session A 读取了已经被 Session B
更新但还没有被提交的字段，之后若 Session B 回滚，Session A
读取的内容就是临时且无效的。</li>
<li>不可重复读：Session A 读取了一个字段，然后 Session B 更新了该字段。
之后Session A 再次读取同一个字段，
值就不同了。那就意味着发生了不可重复读。</li>
<li>幻读：Session A 从一个表中读取了一个字段, 然后 Session B
在该表中插入了一些新的行。 之后, 如果 Session A 再次读取同一个表,
就会多出几行。（幻读，并不是说两次读取获取的结果集不同，幻读侧重的方面是某一次的select操作得到的结果所表征的数据状态无法支撑后续的业务操作。更为具体一些：select某记录是否存在，不存在，准备插入此记录，但执行insert态无法支撑后续的业务操作。更为具体一些：select某记录是否存在，不存在，准备插入此记录，但执行insert
时发现此记录已存在，无法插入，此时就发生了幻读。）</li>
</ul>
<h5 id="四种隔离级别">2）四种隔离级别：</h5>
<p>​
对于上述四种问题，其严重性实际上排序如下：脏写&gt;脏读&gt;不可重复读&gt;幻读，<strong>我们愿意舍弃一部分隔离性来换取一部分性能在这里就体现在：设立一些隔离级别，隔离级别越低，并发问题发生的就越多。SQL标准中设立了4个隔离级别：</strong></p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221110151010412.png" style="zoom: 33%;" /></p>
<ul>
<li>READ UNCOMMITTED
：读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。</li>
<li>READ COMMITTED
：读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。</li>
<li>REPEATABLE READ
：可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。这是MySQL的默认隔离级别。</li>
<li>SERIALIZABLE
：可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读</li>
</ul>
<p>不同的隔离级别有不同的现象，并有不同的锁和并发机制，隔离级别越高，数据库的并发性能就越差，4种事务隔离级别与并发性能的关系如下：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221110151047171.png" style="zoom: 33%;" /></p>
<p>​ MySQL的<strong>默认隔离级别为REPEATABLE READ</strong></p>
<h3 id="二事务日志">二、事务日志：</h3>
<p>​
事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？</p>
<ul>
<li><p>事务的隔离性由锁机制实现。</p></li>
<li><p>事务的原子性、一致性和持久性由事务的 redo 日志和undo
日志来保证。</p>
<ul>
<li><p>REDO LOG
称为重做日志，提供再写入操作，恢复提交事务修改的页操作，<strong>用来保证事务的持久性</strong>。</p></li>
<li><p>UNDO LOG
称为回滚日志，回滚行记录到某个特定版本，<strong>用来保证事务的原子性、一致性</strong>。</p></li>
<li><p>REDO LOG
是存储引擎层Innodb进行记录的，记录的是物理级别的一些操作，比如页号偏移量写入了啥数据，主要为了保证数据的可靠性。</p></li>
<li><p>UNDO LOG
是存储引擎层Innodb进行记录的，记录的是逻辑操作日志，比如对某一行数据进行INSERT语句操作，那么UNDO
LOG就记录一条与之相反的DELETE操作，主要用于事务回滚和MVCC。</p></li>
</ul></li>
</ul>
<h4 id="redo日志">1、REDO日志：</h4>
<p>​
InnoDB存储引擎是以页为单位来管理存储空间的。在真正访问页面之前，需要把在磁盘上的页缓存到内存中的Buffer
Pool之后才可以访问。所有的变更都必须先更新缓冲池中的数据，<strong>然后缓冲池中的脏页会以一定的频率被刷入磁盘（checkPoint机制），通过缓冲池来优化CPU和磁盘之间的鸿沟，这样就可以保证整体的性能不会下降太快。</strong></p>
<h5 id="why需要redo日志">1）Why需要REDO日志？</h5>
<ul>
<li>缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然而由于checkpoint
并不是每次变更的时候就触发的，而是master线程隔一段时间去处理的。<strong>所以最坏的情况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。</strong></li>
<li>事务包含持久性的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失，所以我们需要一个解决方案来解决。</li>
</ul>
<h5 id="如何解决上述问题">2）如何解决上述问题？</h5>
<ul>
<li>解决方案1：可以在事务提交完成之前，将该事务所修改的所有页面都刷到磁盘上，但是这种做法有问题：
<ul>
<li>修改量与刷新磁盘工作量严重不成比例。只修改1个字节，但是要刷1个页16KB的数据到磁盘上</li>
<li>随机的IO刷盘是比较慢的</li>
</ul></li>
<li>解决方案2：REDO日志：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。<strong>所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把修改了哪些东西记录一下就好。</strong>比如，某个事务将系统表空间中第10号页面中偏移量为100
处的那个字节的值 1 改成2
。我们只需要记录一下：将第0号表空间的10号页面的偏移量为100处的值更新为
2。同时：InnoDB引擎的事务采用了WAL技术（Write-Ahead
Logging），这种技术的思想就是<strong>先写日志再写磁盘，只有日志写入成功，才算事务提交成功，</strong>这样即使事务提交了但是脏页还没有写入磁盘，还可以靠已经写入磁盘的redo
log来进行恢复。当发生宕机且数据未刷到磁盘的时候，可以通过redo
log来恢复，保证ACID中的D，这就是redo log的作用。</li>
</ul>
<h5 id="redo日志的优缺点">3）REDO日志的优缺点：</h5>
<ul>
<li>redo日志降低了刷盘频率，且因为其占用空间小，所以刷盘很快</li>
<li>redo日志是顺序写入磁盘的，也就是说是顺序IO，比直接写磁盘的随机IO快的多。</li>
<li>事务执行的过程中，redo
log是在不停的记录的，并不是只有提交了才会写。</li>
</ul>
<h5 id="redo日志的组成与刷盘策略">4）REDO日志的组成与刷盘策略：</h5>
<p>​</p>
<h4 id="undo日志">2、UNDO日志：</h4>
<h5 id="why需要undo日志">1）Why需要UNDO日志？</h5>
<p>​ redo log是事务持久性的保证，undo
log是事务原子性的保证。在事务中更新数据的前置操作其实是要先写入一个undo
log。</p>
<p>​
但有时候事务执行到一半会出现一些情况，我们需要把数据改回原先的样子，这个过程称之为回滚，这样就可以造成一个假象：这
个事务看起来什么都没做，所以符合原子性要求。</p>
<p>​ 所以我们需要执行以下操作：</p>
<p>​
每当我们要对一条记录做改动时（这里的改动可以指INSERT、DELETE、UPDATE），都需要“留一手“—-把回
滚时所需的东西记下来。比如：</p>
<ul>
<li>你插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删
掉就好了。（对于每个INSERT，InnoDB存储引擎会完成一个DELETE）</li>
<li>你删除了一条记录，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入
到表中就好了。（对于每个DELETE，InnoDB存储引擎会执行一个INSERT）</li>
<li>你修改了一条记录，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就
好了。（对于每个UPDATE，InnoDB存储引擎会执行一个相反的UPDATE，将修改前的行放回去）</li>
<li>MySQL把这些为了回滚而记录的这些内容称之为撤销日志或者回滚日志（即undo
log）。注意，由于查询操作
（SELECT）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的undo日志。</li>
</ul>
<p>​ <strong>此外，undo log会产生redo log，也就是undo
log的产生会伴随着redo log的产生，这是因为undo
log也需要持久性的保护。</strong></p>
<h5 id="undo-日志的作用">2）UNDO 日志的作用：</h5>
<ul>
<li><p>回滚数据：<strong>undo是逻辑日志，因此只是将数据库逻辑地恢复到原来的样子。</strong>所有修改都被逻辑地取消了，<strong>但是数据结构和页本身在回滚之后可能大不相同。</strong>因为在多用户并发系统中，可能会有数千个并发事务，其主要的任务就是协调对数据记录的并发访问。因此不能在物理上将一个页回滚到事务开始的时候，会影响别的事务。</p></li>
<li><p>MVCC
多版本并发控制：在InnoDB字储引擎中MVCC的实现是通过undo来完成。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。</p></li>
</ul>
<h5 id="undo-日志的存储结构">3）UNDO 日志的存储结构：</h5>
<h3 id="三锁">三、锁：</h3>
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>数据库精简笔记</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap14 数据库设计范式</title>
    <url>/2022/11/10/e7fbd86c0b92/</url>
    <content><![CDATA[<h3 id="一范式">一、范式</h3>
<p>​
目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。</p>
<p>​
一般来说，在关系型数据库设计中，最高也就遵循到BCNF，普遍还是3NF。但也不绝对，有时候为了提高某些查询性能，我们还需要破坏范式规则，也就是反规范化。</p>
<h3 id="二一些概念">二、一些概念：</h3>
<ul>
<li>超键：能唯一标识元组的属性集叫做超键</li>
<li>候选键：如果超键不包含多余的属性，则这个超键就是候选键</li>
<li>主键：我们自己选定，也就是从候选键中选择一个。</li>
<li>主属性、非主属性：包含在任一候选键中的属性称为主属性。</li>
</ul>
<h3 id="三1nf-第一范式">三、1NF 第一范式</h3>
<p>​
需要符合每个字段的值必须具有原子性，即每个字段的值不可再次拆分。<strong>值得注意的是：字段本身的原子性是主观的</strong></p>
<h3 id="四2nf-第二范式">四、2NF 第二范式</h3>
<p>​
第二范式要求，在满足第一范式的基础上，还要满足数据表里的每一条数据记录，都是可唯一标识的。</p>
<p>​
<strong>所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分。</strong></p>
<ul>
<li>完全依赖关系：如果已知属性A、属性B可以决定得到属性C，那么（A，B）—》C
就是完全依赖关系</li>
</ul>
<p>​ <strong>1NF 告诉我们字段属性需要是原子性的，而 2NF
告诉我们一张表就是一个独立的对象，一张表只表达一个意思。</strong></p>
<h3 id="五3nf-第三范式">五、3NF 第三范式</h3>
<p>​
第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关。</p>
<p>​
也就是说，要求数据表中的<strong>所有非主键字段不能依赖于其他非主键字段。</strong></p>
<p>​
（即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况，即存在“A→B→C”的决定关系）</p>
<p>​
通俗地讲，该规则的意思是所有非主键属性之间不能有依赖关系，必须相互独立。</p>
<p>​
<strong>符合3NF后的数据模型通俗地讲，2NF和3NF通常以这句话概括：“每个非键属性依赖于主键，依赖于
整个主键，并且除了主键别无他物”。</strong></p>
<h3 id="六范式优缺点">六、范式优缺点：</h3>
<ul>
<li>优点：避免数据冗余</li>
<li>缺点：降低查询的效率，需要多表联查，还可能使得一些索引失效。</li>
</ul>
<p>​
<strong>范式只是提出了设计的标准，实际上设计数据表时，未必一定要符合这些标准。开发中，我们会出现为了性能和读取效率违反范式化的原则，通过增加少量的冗余或重复的数据来提高数据库的读性能，减少关联查询，join表的次数，实现空间换取时间的目的。因此在实际的设计过程中要理论结合实际，灵活运用。</strong></p>
<h3 id="七反范式">七、反范式</h3>
<p>​
当冗余信息有价值或者能大幅度提高查询效率的时候，我们才会采取反范式的优化。</p>
<h4 id="适用场景">1、适用场景：</h4>
<ul>
<li>增加的冗余字段需要满足两个条件：
<ul>
<li>这个冗余字段不需要经常进行修改</li>
<li>这个冗余字段查询的时候不可或缺</li>
</ul></li>
<li>历史快照、历史数据的需要：
<ul>
<li><strong>在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每次发生的订单收货信息都属于历史快照，需要进行保存，但用户可以随时修改自己的信息，这时保存这些冗余信息是非常有必要的。</strong></li>
<li><strong>反范式优化也常用在数据仓库的设计中，因为数据仓库通常存储历史数据，对增删改的实时性要求不强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。</strong></li>
</ul></li>
<li>数据库和数据仓库的区别：
<ul>
<li>数据库设计的目的在于捕获数据，而数据仓库设计的目的在于分析数据；</li>
<li>数据库对数据的增删改实时性要求强，需要存储在线的用户数据，而数据仓库存储的一般是历史数据；</li>
<li>数据库设计需要尽量避免冗余，但为了提高查询效率也允许一定的冗余度，而数据仓库在设计上更偏向采用反范式设计。</li>
</ul></li>
</ul>
<h3 id="八bcnf-巴斯范式">八、BCNF 巴斯范式：</h3>
<p>​
若一个关系达到了第三范式，并且它只有一个候选键，或者它的每个候选键都是单属性，则该关系自然达到BCNF</p>
<p>​ BCNF 在 3NF
的基础上消除了主属性对候选键的部分依赖或者传递依赖关系。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221110093440365.png" /></p>
<ul>
<li>其满足第三范式，但是管理员依赖于仓库名，所以不符合BCNF，应该拆解成如下方式：</li>
<li>根据 BCNF 的要求，我们需要把仓库管理关系 warehouse_keeper
表拆分成下面这样：
<ul>
<li>仓库表：（仓库名，管理员）</li>
<li>库存表：（仓库名，物品名，数量）</li>
</ul></li>
</ul>
<h3 id="九er模型实体属性和关系">九、ER模型——实体、属性和关系</h3>
<ul>
<li>强实体 &amp; 弱实体：不需要依赖其他任何实体的为强实体</li>
<li>可以独立存在的称为实体，不可再分的称为属性。</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221110095158493.png" /></p>
<ul>
<li><p>ER模型细化：加上相关属性内容</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221110095247151.png" /></p></li>
<li><p>随后我们可以通过ER模型转换至数据表：</p></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221110095326103.png" /></p>
<h3 id="十数据库对象编写建议">十、数据库对象编写建议：</h3>
<h4 id="关于数据库">1、关于数据库：</h4>
<ul>
<li>创建数据库时必须显式指定字符集，并且字符集只能是utf8或者utf8mb4</li>
<li>对于程序连、接数据库账号，遵循权限最小原则。使用数据库账号只能在一个DB下使用，不准跨库。程序使用的账号原则上不准有drop权限。</li>
</ul>
<h4 id="关于数据表">2、关于数据表：</h4>
<ul>
<li>创建表时必须显式指定字符集为utf8或utf8mb4。</li>
<li>创建表时必须显式指定表存储引擎类型。如无特殊需求，一律为InnoDB</li>
<li>字段命名应尽可能使用表达实际含义的英文单词或缩写。如：公司
ID，不要使用corporation_id, 而用corp_id 即可</li>
<li>布尔值类型的字段命名为is_描述</li>
<li>建表时关于主键： 表必须有主键
(1)强制要求主键为id，类型为int或bigint，且为auto_increment
建议使用unsigned无符号型。</li>
<li><strong>表中所有字段尽量都是NOT NULL
属性，业务可以根据需要定义DEFAULT值。
因为使用NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题。</strong></li>
</ul>
<h4 id="关于索引">3、关于索引：</h4>
<ul>
<li>主键的名称以 pk_ 开头，唯一键以 uni_ 或 uk_ 开头，普通索引以 idx_
开头，一律使用小写格式，以字段的名称或缩写作为后缀</li>
<li>多单词组成的columnname，取前几个单词首字母，加末单词组成column_name。如:sample
表 member_id 上的索引：idx_sample_mid。</li>
<li>在建立索引时，多考虑建立联合索引，并把区分度最高的字段放在最前面。</li>
<li>在多表 JOIN 的SQL里，保证被驱动表的连接列上有索引，这样JOIN
执行效率最高。</li>
</ul>
<h4 id="sql编写">4、SQL编写：</h4>
<ul>
<li>程序端SELECT语句必须指定具体字段名称，禁止写成 *。</li>
<li>程序端insert语句指定具体字段名称，不要写成INSERT INTO t1
VALUES(…)。</li>
<li>线上环境，多表 JOIN 不要超过5个表。</li>
<li>包含了ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE
条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢</li>
<li>对单表的多次alter操作必须合并为一次，对于超过100W行的大表进行alter
table，必须经过DBA审核，并在业务低峰期执行，多个alter需整 合在一起。
因为alter
table会产生表锁，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。</li>
<li>批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep。</li>
<li>事务里包含SQL不超过5个。因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等问题。</li>
<li>事务里更新语句尽量基于主键或UNIQUE KEY，如UPDATE… WHERE
id=XX;否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。</li>
</ul>
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>数据库精简笔记</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap13 数据库索引优化和查询优化</title>
    <url>/2022/11/07/cd7b91a8821a/</url>
    <content><![CDATA[<p>SQL查询优化的技术有很多，大方向上可以分为：</p>
<ul>
<li>物理查询优化（索引、表连接方式）</li>
<li>逻辑查询优化（换一种效率更高的执行方法）</li>
</ul>
<p>具体可以从以下四个方面进行数据库调优：</p>
<ul>
<li>索引失效、没有充分利用到索引——索引建立</li>
<li>关联查询太多JOIN（设计缺陷或不得已的需求）—- SQL优化</li>
<li>服务器调优及各个参数设置（缓冲、线程数等）——调整my.cnf</li>
<li>数据过多——分库分表I</li>
</ul>
<h3 id="一索引优化与查询优化">一、索引优化与查询优化</h3>
<h4 id="索引失效案例情况">1、索引失效案例情况：</h4>
<p>​
从理论上而言，使用或者不使用索引都是由<strong>优化器</strong>来决定，其是基于cost开销（CostBaseOptimizer），它不是基于规则（Rule-Basedoptimizer），也不是基于语义。怎么样开销小就怎么来。另外，SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。</p>
<h5 id="最佳左前缀匹配法则">1）最佳左前缀匹配法则</h5>
<p>​
MySQL可以为多个字段创建索引，一个索引可以包括16个字段。<strong>对于多列索引，过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段！索引后面的字段都无法被使用。</strong>如果查询条件中没有使用这些字段中第1个字段时，多列（或联合）索引不会被使用。</p>
<p>​ 索引文件具有 B-Tree
的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p>
<h5 id="主键插入顺序">2）主键插入顺序</h5>
<p>​ 如果插入的主键忽大忽小，就容易导致某个数据页满了以后，数据还会往其中
插入，这个时候就需要把当前页面分裂成两个页面，把本页中的一些记录移动到新创建的这个页中。<strong>页面分裂和记录移位意味着什么？意味着：
性能损耗！</strong>所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的主键值依次递增，这样就不会发生这样的性能损耗了。</p>
<p>​ <strong>建议：让主键具有AUTO_INCREMENT
，让存储引擎自己为表生成主键，而不是我们手动插入。</strong></p>
<h5
id="计算函数类型转换自动或手动导致索引失效">3）计算、函数、类型转换(自动或手动)导致索引失效</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name LIKE &#x27;abc%&#x27;;</span><br><span class="line"># 未使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) = &#x27;abc&#x27;;</span><br></pre></td></tr></table></figure>
<ul>
<li>从运行结果上，上述两个SQL语句没有差别。但是从运行效率上而言，下面这条语句因为使用了函数，所以并不会使用到name上的索引进行查询，也就是查询类型会是ALL，效率非常低。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 未使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=123;</span><br><span class="line"># 使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=&#x27;123&#x27;;</span><br></pre></td></tr></table></figure>
<ul>
<li>上述，是由于name=123发生类型转换，最终导致索引失效。</li>
</ul>
<h5 id="范围条件右边的列索引失效">4）范围条件右边的列索引失效</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_age_name_classid on student(age,classid,name)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 会使用上述联合索引，但是没有用到Name这个字段上建立的索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student</span><br><span class="line">WHERE student.age=30 AND student.classId&gt;20 AND student.name = &#x27;abc&#x27; ;</span><br></pre></td></tr></table></figure>
<p>​
想要起作用，得写成如下格式：建联合索引时，把确定查询的放到前面，范围查询的放到后面.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_age_name_classid on student(age,name,classid)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.name =</span><br><span class="line">&#x27;abc&#x27; AND student.classId&gt;20 ;</span><br></pre></td></tr></table></figure>
<p>​
结论：应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。应将查询条件放置where语句最后。（即创建的联合索引中，务必把范围涉及到的字段写在最后）</p>
<h5 id="不等于导致索引失效">5）不等于导致索引失效</h5>
<h5 id="is-null可以使用索引is-not-null无法使用索引">6）is
null可以使用索引，is not null无法使用索引</h5>
<h5 id="like以通配符开头索引失效">7）like以通配符%开头索引失效</h5>
<p>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p>
<h5 id="or-前后存在非索引的列索引失效">8）OR
前后存在非索引的列，索引失效</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 未使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 10 OR classid = 100;</span><br><span class="line"># 使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 10 OR name = &#x27;Abel&#x27;;</span><br></pre></td></tr></table></figure>
<h5
id="数据库和表的字符集统一使用utf8mb4">9）数据库和表的字符集统一使用utf8mb4</h5>
<p>​
统一使用utf8mb4兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的字符集进行比较前需要进行转换会造成索引失效。</p>
<h5 id="总结建议">10）总结建议：</h5>
<ul>
<li>单列索引，尽量选择针对当前query过滤性更好的索引</li>
<li>在选择组合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li>
<li>在选择组合索引的时候，尽量选择能够包含当前query中的where子句中更多字段的索引。</li>
<li>在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面。</li>
</ul>
<h4 id="关联查询的优化情况">2、关联查询的优化情况：</h4>
<h5 id="left-join-左外连接左边驱动表右边被驱动表">1）Left Join
左外连接（左边驱动表，右边被驱动表）</h5>
<p>​ Left
Join的条件（即On上的内容）用于确定如何从右表搜索行，而左边的表一定都有，所以右边是我们的关键点,一定需要建立索引。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;</span><br><span class="line"></span><br><span class="line"># 在被驱动表book上添加索引，可以避免对book表的全表扫描。</span><br><span class="line">ALTER TABLE book ADD INDEX Y (card);</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;</span><br></pre></td></tr></table></figure>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221031110652164.png" /></p>
<h5 id="inner-join-内连接">2）INNER JOIN 内连接：</h5>
<p>​ 在INNER JOIN中，驱动表是由MySQL自动选择的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 由于驱动表是查询优化器决定的，所以如果book上建了索引，type没建，那么book会被选为被驱动表，反之type会被选为被驱动表。如果两列都建了索引，那么还是由查询优化器自动根据Cost选择。（一般都是选择小表作为驱动表，即小表驱动大表）</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM type INNER JOIN book ON type.card=book.card;</span><br></pre></td></tr></table></figure>
<h5 id="join语句的原理">3）JOIN语句的原理</h5>
<ul>
<li>驱动表和非驱动表：
<ul>
<li>内连接：优化器自动决定</li>
<li>外连接：优化器也会帮助决定驱动表</li>
</ul></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM t1 STRAIGHT_JOIN t2 ON (t1.a=t2.a);</span><br></pre></td></tr></table></figure>
<ul>
<li>Simple Nested-Loop Join 简单嵌套
<ul>
<li>假设A表有A条记录，B表有B条记录，A作为驱动表，B被驱动表</li>
<li>最终查询开销：外表扫描1次，内表扫描A次，读取记录数：A + B *
A，JOIN比较次数 B * A</li>
<li>所以使用小表驱动大表</li>
</ul></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221031112529836.png" /></p>
<ul>
<li><p>Index Nested0Loop Join 索引嵌套循环连接</p>
<p>为了减少内层表数据的匹配次数，所以被驱动表上需要有索引。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221031112116837.png" /></p>
<ul>
<li><p>假设A表有A条记录，B表有B条记录，A作为驱动表，B被驱动表</p></li>
<li><p>在这条语句里，被驱动表t2的字段a上有索引，join过程用上了这个索引，因此这个语句的执行流程是这样的：</p>
<ul>
<li>从表t1中读入一行数据 R；</li>
<li>从数据行R中，取出a字段到表t2里去查找；</li>
<li>取出表t2中满足条件的行，跟R组成一行，作为结果集的一部分；</li>
<li>重复执行步骤1到3，直到表t1的末尾循环结束。</li>
</ul>
<p>在这个流程里：</p>
<ul>
<li>对驱动表t1做了全表扫描，这个过程需要扫描100行；</li>
<li>而对于每一行R，根据a字段去表t2查找，走的是树搜索过程。由于我们构造的数据都是一一对应的，因此每次的搜索过程都只扫描一行，也是总共扫描100行；</li>
<li>所以，整个执行流程，总扫描行数是200</li>
</ul></li>
<li></li>
</ul></li>
<li><p>Block Nested Loop Join (针对Simple的优化方法)</p>
<p>​
如果存在索引，那么会使用index的方式进行join，如果join的列没有索引，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把被驱动表的记录在加载到内存匹配，这样周而复始，大大增加了I0的次数。</p>
<p>​ 为了减少被驱动表的IO次数，就出现了Block Nested-Loop
Join的方式。<strong>不再是逐条获取驱动表的数据，而是一块一块的获取，引入了join
buffer缓冲区，将驱动表join相关的部分数据列（大小受join
buffer的限制）缓存到join
buffer中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和join
buffer中的所有驱动表记录进行匹配（内存中操作），将简单嵌套循环中的多次比较合并成一次</strong>，降低了被驱动
表的访问频率。</p></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221031115027527.png" /></p>
<ul>
<li>最终查询开销：
<ul>
<li>外表扫描1次</li>
<li>内表扫描A * used_column_size / join_buffer_size + 1次</li>
<li>读取记录数：A + B * (A * used_column_size / join_buffer_size)</li>
<li>JOIN比较次数 B * A</li>
</ul></li>
</ul>
<h5 id="join语句结论">4）JOIN语句结论：</h5>
<ul>
<li>使用join语句，性能比强行拆成多个单表执行SQL语句的性能要好（能够直接多表关联的尽量直接关联，不用子查询）</li>
<li>如果使用join语句的话，需要让小表做驱动表。(在决定哪个表做驱动表的时候，<strong>应该是两个表按照各自的条件过滤，过滤完成之后，计算参与join的各个字段的总数据量，数据量小的那个表，</strong>就是“小表”，应该作为驱动表。</li>
<li>为被驱动表匹配的条件增加索引</li>
<li>增大Join Buffer
Size的大小（单次缓存的数据越多，内层包的扫表次数越少）</li>
<li>减少驱动表不必要的字段查询，字段越少，join buffer缓存的数据越多</li>
</ul>
<h5 id="hash-join">5）Hash Join</h5>
<p>​ Hash
Join是做大数据集连接时的常用方式，优化器使用两个表中较小（相对较小）的表利用Join
Key在内存中建立散列表，然后扫描较大的表并探测散列表，找出与Hash表匹配的行。</p>
<p>​
<strong>这种方式适用于较小的表完全可以放于内存中的情况，这样总成本就是访问两个表的成本之和。</strong></p>
<p>​
在表很大的情况下并不能完全放入内存，这时优化器会将它分割成若干不同的分区，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高I/O的性能。</p>
<p>​
它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。Hash
Join只能应用于等值连接，这是由Hash的特点决定的。</p>
<h4 id="子查询优化">3、子查询优化</h4>
<p>​ 子查询能够实现较复杂的语句，但是其执行效率较低，原因如下：</p>
<ul>
<li>执行子查询时，MySQL需要为内层查询语句的查询结果建立一个临时表，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表。这样会消耗过多的CPU和IO资源，产生大量的慢查询。</li>
<li>子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。</li>
<li>对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</li>
</ul>
<p>​
故而，对于能够拆解的子查询，尽可能用多个步骤的关联查询来代替子查询。</p>
<h4 id="排序优化">4、排序优化</h4>
<p>​ 在MySQL中，支持两种排序方式，分别是FileSort和Index排序。</p>
<ul>
<li>Index排序：索引可以保证数据的有序性，效率高。</li>
<li>FileSort：一般在内存中进行排序，占用CPU较多。如果结果较大则会产生临时文件IO到磁盘进行排序，效率低。</li>
</ul>
<p>​ 优化建议：</p>
<ul>
<li>SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引：目的是在 WHERE
子句中避免全表扫描，在 ORDER BY 子句避免使用FileSort
排序。<strong>当然，某些情况下全表扫描，或者 FileSort
排序不一定比索引慢。</strong>但总的来说，我们还是要避免，以提高查询效率。</li>
<li>尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY
是相同的列就使用单索引列；<strong>如果不同就使用联合索引</strong>。</li>
<li>无法使用 Index 时，需要对 FileSort 方式进行调优</li>
</ul>
<p>可以应用索引进行排序的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INDEX a_b_c(a,b,c)</span><br><span class="line"></span><br><span class="line"># 如果WHERE使用索引的最左前缀定义为常量，则order by 能使用索引</span><br><span class="line">- WHERE a = const ORDER BY b,c</span><br><span class="line">- WHERE a = const AND b = const ORDER BY c</span><br><span class="line">- WHERE a = const ORDER BY b,c</span><br><span class="line">- WHERE a = const AND b &gt; const ORDER BY b,c</span><br></pre></td></tr></table></figure>
<p>不可以应用索引进行排序的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- ORDER BY a ASC,b DESC,c DESC /* 排序不一致 */</span><br><span class="line">- WHERE g = const ORDER BY b,c /*丢失a索引*/</span><br><span class="line">- WHERE a = const ORDER BY c /*丢失b索引*/</span><br><span class="line">- WHERE a = const ORDER BY a,d /*d不是索引的一部分*/</span><br><span class="line">- WHERE a in (...) ORDER BY b,c /*对于排序来说，多个相等条件也是范围查询*/</span><br></pre></td></tr></table></figure>
<p>​
需要注意：有些可以应用索引进行排序的情况，查询优化器不一定会去使用。这会取决于具体的查询字段、数据量等等。</p>
<ul>
<li>当【范围条件】和【group by 或者 order
by】的字段出现二选一时，优先观察条件字段的过滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。反之，亦然。</li>
</ul>
<h5 id="filesort算法">1）FileSort算法：</h5>
<ul>
<li>双路排序
<ul>
<li>是两次扫描磁盘，最终得到数据。</li>
<li>第一次仅读取行指针和order by列，对他们进行排序。</li>
<li>第二次扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出，从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段</li>
</ul></li>
<li>单路排序（更消耗buffer）
<ul>
<li>直接从磁盘读取查询需要的所有列，按照order
by列在buffer对它们进行排序，然后扫描排序后的列表进行输出，
它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空间，
因为它把每一行都保存在内存中了。</li>
<li>如果buffer容量不够，反而可能会导致大量的IO操作。
<ul>
<li>尝试提高 sort_buffer_size</li>
<li>尝试提高 max_length_for_sort_data</li>
<li>Order by 时select * 是一个大忌。最好只Query需要的字段</li>
</ul></li>
</ul></li>
</ul>
<h4 id="group-by-优化">5、GROUP BY 优化：</h4>
<ul>
<li>group by 使用索引的原则几乎跟order by一致 ，group by
即使没有过滤条件用到索引，也可以直接使用索引。</li>
<li>group by 先排序再分组，遵照索引建的最佳左前缀法则</li>
<li>当无法使用索引列，增大max_length_for_sort_data 和sort_buffer_size
参数的设置</li>
<li>where效率高于having，能写在where限定的条件就不要写在having中。减少使用order
by，和业务沟通能不排序就不排序，或将排序放到程序端去做。</li>
<li>Order by、group
by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li>
<li>包含了order by、group
by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</li>
</ul>
<h4 id="优化分页查询">6、优化分页查询：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM student LIMIT 200000,10;</span><br></pre></td></tr></table></figure>
<ul>
<li>优化1：在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM student t,(SELECT id FROM student ORDER BY id LIMIT 2000000,10) a</span><br><span class="line">WHERE t.id = a.id;</span><br></pre></td></tr></table></figure>
<ul>
<li>优化2：该方案适用于主键自增的表，可以把Limit
查询转换成某个位置的查询。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM student WHERE id &gt; 2000000 LIMIT 10;</span><br></pre></td></tr></table></figure>
<h4 id="覆盖索引">7、覆盖索引：</h4>
<p>​ 一个索引包含了满足查询结果的数据就叫做覆盖索引。简单说就是，
索引列+主键 包含 SELECT 到 FROM 之间查询的列。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 不使用索引，因为如果要使用还需要回表，成本更高</span><br><span class="line">EXPLAIN SELECT * FROM student WHERE NAME LIKE &#x27;%abc&#x27;</span><br><span class="line"></span><br><span class="line"># 使用索引，因为索引中有id,age,NAME，所以不需要回表</span><br><span class="line">EXPLAIN SELECT id,age,NAME FROM student WHERE NAME LIKE &#x27;%abc&#x27;</span><br></pre></td></tr></table></figure>
<ul>
<li>好处：
<ul>
<li>避免Innodb表进行索引的二次查询（回表）</li>
<li>可以把随机IO变成顺序IO加快查询效率，因为覆盖索引是按照键值的顺序存储的，对于IO密集型的范围查找来说，对比随机从磁盘读取每一行的数据IO要少的多。</li>
</ul></li>
<li>弊端：
<ul>
<li>索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑。</li>
</ul></li>
</ul>
<h4 id="索引条件下推">8、索引条件下推：</h4>
<p>​ Index Condition Pushdown(ICP)是MySQL
5.6中新特性，是一种在存储引擎层使用索引过滤数据的一种优化方式。ICP可以减少存储引擎访问基表的次数以及MySQL服务器访问存储引擎的次数。</p>
<ul>
<li>示例： 表上有联合索引(key1,key2)
<ul>
<li>不使用ICP的查询过程：先使用联合索引(key1,key2)过滤key1&gt;'z'条件，然后回表，回表后的数据加载到数据页中，再去找满足第二第三个条件的数据</li>
<li>使用ICP的查询过程：先使用联合索引(key1,key2)过滤key1&gt;'z'条件，然后不急着回表。因为联合索引中有key2这个字段，所以可以先进行索引条件下推，也就是先筛选key2这个条件，然后由于key3不在索引内，所以只能先去回表，再筛选第三个数据了。</li>
</ul></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 where key1 &gt; &#x27;z&#x27; AND key2 LIKE &#x27;%s&#x27; AND key3 LIKE &#x27;%ss&#x27;</span><br></pre></td></tr></table></figure>
<h5 id="icp的开启和关闭">1）ICP的开启和关闭：</h5>
<p>默认情况下启用索引下推，可以通过设置系统变量optimizer_switch =
index_contidition_pushdown = on来开启。</p>
<h5 id="使用条件">2）使用条件：</h5>
<ul>
<li>只能用于二级索引(secondary index)</li>
<li>explain显示的执行计划中type值（join 类型）为range 、 ref 、 eq_ref
或者ref_or_null 。</li>
<li>并非全部where条件都可以用ICP筛选，如果where条件的字段不在索引列中，还是要读取整表的记录到server端做where过滤。</li>
<li>ICP可以用于MyISAM和InnnoDB存储引擎</li>
<li>MySQL 5.6版本的不支持分区表的ICP功能，5.7版本的开始支持。</li>
<li>当SQL使用覆盖索引时，不支持ICP优化方法。</li>
</ul>
<h4 id="其他查询优化策略">9、其他查询优化策略：</h4>
<h5 id="exists-和-in">1）EXISTS 和 IN</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM A WHERE CC IN(SELECT CC FROM B) </span><br><span class="line"></span><br><span class="line">SELECT * FROM A WHERE EXISTS(SELECT CC FROM B WHERE B.cc=A.cc)</span><br></pre></td></tr></table></figure>
<p>当A小于B时，用EXISTS，因为A是驱动表，执行顺序是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in A:</span><br><span class="line">	for j in B:</span><br><span class="line">		if j.cc == i.cc then</span><br></pre></td></tr></table></figure>
<p>当B小于A时，用IN，因为实现逻辑正好与上相反。</p>
<h5 id="count-和-count具体字段">2）COUNT(*) 和 COUNT(具体字段)</h5>
<ul>
<li>COUNT(*) 和 COUNT(1) 两者执行效率类似。</li>
<li>如果是MyISAM存储引擎，统计表的行数为O(1)复杂度，因为有元数据存储，一致性由表级锁维护。</li>
<li>如果是InnoDB，其支持事务行锁等机制，无法维护元数据，所以需要扫描全表，是O(n)复杂度，进行循环+计数方式统计。</li>
<li>InnoDB中，如果采用COUNT(具体字段)，尽可能使用二级索引，因为主键采用的是聚簇索引，包含的信息较多。对于COUNT(*)
和 COUNT(1)
而言，只是统计行数，系统回自动采用占用空间更小的二级索引来统计。</li>
</ul>
<h5 id="关于select">3）关于SELECT *</h5>
<ul>
<li>不建议使用，耗费资源和时间</li>
<li>无法使用覆盖索引</li>
</ul>
<h5 id="limit1">4）LIMIT1</h5>
<ul>
<li>针对的是会扫描全表的SQL语句，如果你可以确定结果集只有一条，那么加上LIMIT1的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。</li>
</ul>
<h5 id="多使用commit">5）多使用COMMIT</h5>
<ul>
<li>只要有可能，在程序中尽量多使用
COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT
所释放的资源而减少。</li>
<li>COMMIT 所释放的资源：
<ul>
<li>回滚段上用于恢复数据的信息</li>
<li>被程序语句获得的锁</li>
<li>redo / undo log buffer 中的空间</li>
<li>管理上述 3 种资源中的内部花费</li>
</ul></li>
</ul>
<h3 id="二主键应当如何设计">二、主键应当如何设计？</h3>
<p>​
自增ID做主键，简单易懂，几乎所有数据库都支持自增类型，只是实现上各自有所不同而已。自增ID除了简单，其他都是缺点。</p>
<ol type="1">
<li>可靠性不高 存在自增ID回溯的问题，这个问题直到最新版本的MySQL
8.0才修复。</li>
<li>安全性不高
对外暴露的接口可以非常容易猜测对应的信息。比如：/User/1/这样的接口。</li>
<li>性能差 自增ID的性能较差，需要在数据库服务器端生成。</li>
<li>交互多 业务还需要额外执行一次类似last_insert_id()
的函数才能知道刚才插入的自增值，这需要多一次的网络交互。在海量并发的系统中，多1条SQL，就多一次性能上的开销。</li>
<li>局部唯一性
最重要的一点，自增ID是局部唯一，只在当前数据库实例中唯一，而不是全局唯一，在任意服务器间都是唯一的。对于目前分布式系统来说，这简直就是噩梦</li>
</ol>
<h4 id="使用业务字段做主键">1、使用业务字段做主键？</h4>
<p>​ 不可取！建议尽量不要用跟业务有关的字段做主键。</p>
<h4 id="推荐的主键设计">2、推荐的主键设计：</h4>
<ul>
<li>非核心业务：对应表的主键自增ID，如告警、日志、监控等信息。</li>
<li>核心业务：主键设计至少应该是全局唯一且是单调递增。全局唯一保证在各系统之间都是唯一的，单调递增是希望插入时不影响数据库性能</li>
</ul>
<p><strong>UUID</strong>：</p>
<p>​ UUID = 时间+UUID版本（16字节）- 时钟序列（4字节） -
MAC地址（12字节）</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221031152235559.png" /></p>
<p>​
在UUID中时间部分占用60位，存储的类似TIMESTAMP的时间戳，但表示的是从1582-10-15
00：00：00.00到现在的100ns的计数。可以看到UUID存储的时间精度比TIMESTAMPE更高</p>
<ul>
<li>为什么UUID是随机无序的呢？
<ul>
<li>因为UUID的设计中，<strong>将时间低位放在最前面，而这部分的数据是一直在变化的，并且是无序。</strong></li>
</ul></li>
</ul>
<p><strong>改造UUID，使其适配主键的要求</strong>：</p>
<p>​
若将时间高低位互换，则时间就是单调递增的了，也就变得单调递增了。MySQL
8.0可以更换时间低位和时间高位的存储方式，这样UUID就是有序的UUID了。</p>
<p>​
另外在真实的业务系统中，主键还可以加入业务和系统属性，如用户的尾号，机房的信息等。</p>
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>数据库精简笔记</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生快速入门系列Chap2——Kubernetes入门</title>
    <url>/2022/11/04/8e7c78160822/</url>
    <content><![CDATA[<h4 id="kubernetes基础概念">1、Kubernetes基础概念：</h4>
<ul>
<li><p>工程部署的演变：传统部署——虚拟机部署——容器化部署</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221104180722605.png" /></p></li>
<li><p>当容器化部署时代到来，微服务模块非常多的情境下，可能一台服务器上会有几十个容器，且不同的容器都部署在几十台服务器上，这个时候我们就需要一个<strong>大规模的容器编排管理系统</strong>。Kubernetes
为你提供了一个可弹性运行分布式系统的框架。 Kubernetes
会满足你的扩展要求、故障转移、部署模式等。</p></li>
<li><p>Kubernetes的特性如下：</p>
<ul>
<li><strong>服务发现和负载均衡</strong>：如果进入容器的流量很大，
Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。</li>
<li><strong>存储编排</strong>：Kubernetes
允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。</li>
<li><strong>自动部署和回滚</strong>：你可以自动化 Kubernetes
来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器</li>
<li><strong>自动完成装箱计算</strong>：Kubernetes 允许你指定每个容器所需
CPU 和内存（RAM）。 当容器指定了资源请求时，Kubernetes
可以做出更好的决策来管理容器的资源。</li>
<li><strong>自我修复</strong>：Kubernetes
重新启动失败的容器、替换容器、杀死不响应用户定义的
运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。</li>
<li><strong>密钥与配置管理</strong>：Kubernetes
允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。
你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。</li>
</ul></li>
</ul>
<h4 id="kubernetes架构">2、Kubernetes架构：</h4>
<ul>
<li>K8s基于一个服务器集群进行安装：N个主节点+M个工作节点（N&gt;=1）</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221104181719685.png" /></p>
<ul>
<li><strong>Control Plane
控制平面【相当于集团中心，Master节点】</strong>：控制平面的组件对集群做出全局决策(比如调度)，以及检测和响应集群事件。控制平面组件可以在集群中的任何节点上运行。
<ul>
<li>apiserver【相当于集团秘书部，一切对外活动都交给她中转】:API 服务器是
Kubernetes 控制面的前端。它可通过部署多个实例进行伸缩。你可以运行
kube-apiserver 的多个实例，并在这些实例之间平衡流量。</li>
<li>scheduler【调度者】：责监视新创建的、未指定运行<a
href="https://kubernetes.io/zh/docs/concepts/architecture/nodes/">节点（node）</a>的
容器，选择节点让容器在上面运行。调度决策考虑的因素包括单个 Pod 和 Pod
集合的资源需求、硬件/软件/策略约束等等。</li>
<li>etcd【相当于集团资料中心】：etcd
是兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes
所有集群数据的后台数据库。</li>
<li>controller-manager(c-m)【集团决策者】：在主节点上运行 <a
href="https://kubernetes.io/zh/docs/concepts/architecture/controller/">控制器</a>
的组件。从逻辑上讲，每个<a
href="https://kubernetes.io/zh/docs/concepts/architecture/controller/">控制器</a>都是一个单独的进程，
但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。</li>
<li>cloud-controller-manager(c-c-m)【外联部，可选】：仅运行特定于云平台的控制回路。
如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境，
所部署的环境中不需要云控制器管理器。</li>
</ul></li>
<li><strong>Node组件【相当于分工厂，Worker节点】</strong>：节点组件在每个节点上运行，维护运行的
Pod 并提供 Kubernetes 运行环境
<ul>
<li><p>kubelet【厂长，监工】：一个在集群中每个<a
href="https://kubernetes.io/zh/docs/concepts/architecture/nodes/">节点（node）</a>上运行的代理。
它保证<a
href="https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/#why-containers">容器（containers）</a>都
运行在 <a
href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pod</a>
中。kubelet 接收一组通过各类机制提供给它的 PodSpecs，确保这些 PodSpecs
中描述的容器处于运行状态且健康。负责该节点中应用的启停以及销毁，能够探测到不同应用的状态，然后汇报给api-server。</p></li>
<li><p>kube-proxy【门卫导航，网络访问入口】：是集群中每个节点上运行的网络代理，
实现 Kubernetes <a
href="https://kubernetes.io/zh/docs/concepts/services-networking/service/">服务（Service）</a>
概念的一部分。可以告知想要访问谁怎么访问，kube-proxy
维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod
进行网络通信。</p></li>
</ul></li>
<li>交互形式：</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221104230011339.png" /></p>
<h4 id="集群搭建与部署">3、集群搭建与部署</h4>
<p>每台服务器需要首先安装</p>
<ul>
<li>Docker 容器运行化环境</li>
<li>kubelet 节点厂长</li>
<li>kubectl 控制命令行</li>
<li>kubeadm 控制管理器</li>
</ul>
<p>​
随后，在某一台主节点处执行<code>kubeadm init</code>，初始化该节点为主节点，随后kubelet会自动下载主节点需要的如scheduler、api-server等等服务的镜像。</p>
<p>​
再随后，在其他节点处执行<code>kubeadm join</code>即可加入主节点创建的k8s集群。</p>
<h5 id="需要三台服务器">1）需要三台服务器</h5>
<ul>
<li>集群中的所有机器的网络彼此均能相互连接(公网和内网都可以)</li>
<li>节点之中不可以有重复的主机名、MAC 地址或
product_uuid。<strong>设置不同hostname</strong></li>
<li><strong>内网互信</strong></li>
<li>禁用交换分区。为了保证 kubelet 正常工作，你 <strong>必须</strong>
禁用交换分区。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装每台服务器的预安装环境（Docker、kubelet、kebectl、kubeadm）</span></span><br><span class="line"><span class="comment"># 更新镜像源</span></span><br><span class="line">sudo yum install -y yum-utils</span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装docker</span></span><br><span class="line">yum install -y docker-ce-20.10.7 docker-ce-cli-20.10.7  containerd.io-1.4.6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动docker</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker --now</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker的生产环境核心配置cgroup</span></span><br><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line">sudo <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://82m9ar63.mirror.aliyuncs.com&quot;</span>],</span><br><span class="line">  <span class="string">&quot;exec-opts&quot;</span>: [<span class="string">&quot;native.cgroupdriver=systemd&quot;</span>],</span><br><span class="line">  <span class="string">&quot;log-driver&quot;</span>: <span class="string">&quot;json-file&quot;</span>,</span><br><span class="line">  <span class="string">&quot;log-opts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;max-size&quot;</span>: <span class="string">&quot;100m&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;storage-driver&quot;</span>: <span class="string">&quot;overlay2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务器1、2、3分别执行以重命名hostname</span></span><br><span class="line">hostnamectl set-hostname k8s-master</span><br><span class="line">hostnamectl set-hostname k8s-node1</span><br><span class="line">hostnamectl set-hostname k8s-node2</span><br><span class="line"><span class="comment"># 下述命令全部服务器需要执行：k8s官方文档要求</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 SELinux 设置为 permissive 模式（相当于将其禁用）</span></span><br><span class="line">sudo sed -i <span class="string">&#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27;</span> /etc/selinux/config</span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭服务器交换分区</span></span><br><span class="line">sed -ri <span class="string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> /etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="comment">#允许 iptables 检查桥接流量</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/modules-load.d/k8s.conf</span></span><br><span class="line"><span class="string">br_netfilter</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/sysctl.d/k8s.conf</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装kubelet、kubeadm、kubectl</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置下载镜像源</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/yum.repos.d/kubernetes.repo</span></span><br><span class="line"><span class="string">[kubernetes]</span></span><br><span class="line"><span class="string">name=Kubernetes</span></span><br><span class="line"><span class="string">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=0</span></span><br><span class="line"><span class="string">repo_gpgcheck=0</span></span><br><span class="line"><span class="string">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span></span><br><span class="line"><span class="string">   http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span></span><br><span class="line"><span class="string">exclude=kubelet kubeadm kubectl</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用yum安装</span></span><br><span class="line">sudo yum install -y kubelet-1.20.9 kubeadm-1.20.9 kubectl-1.20.9 --disableexcludes=kubernetes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动kubelet</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> --now kubelet</span><br></pre></td></tr></table></figure>
<p>注意：kubelet 现在每隔几秒就会重启，因为它陷入了一个等待 kubeadm
指令的死循环</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用kubeadm引导启动集群</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载各个机器需要的镜像</span></span><br><span class="line">sudo <span class="built_in">tee</span> ./images.sh &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">images=(</span><br><span class="line">kube-apiserver:v1.20.9</span><br><span class="line">kube-proxy:v1.20.9</span><br><span class="line">kube-controller-manager:v1.20.9</span><br><span class="line">kube-scheduler:v1.20.9</span><br><span class="line">coredns:1.7.0</span><br><span class="line">etcd:3.4.13-0</span><br><span class="line">pause:3.2</span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> imageName <span class="keyword">in</span> <span class="variable">$&#123;images[@]&#125;</span> ; <span class="keyword">do</span></span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/<span class="variable">$imageName</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">EOF</span><br><span class="line">   </span><br><span class="line"><span class="built_in">chmod</span> +x ./images.sh &amp;&amp; ./images.sh</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化主节点：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有机器都需要执行如下：</span></span><br><span class="line"><span class="comment"># 即添加master域名映射，需要填写集群的内网的IP</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;172.31.0.4  cluster-endpoint&quot;</span> &gt;&gt; /etc/hosts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行完后，各个机器能够ping cluster-endpoint 能够ping通，说明配置正确了</span></span><br><span class="line"><span class="comment"># 主节点初始化，仅在主节点处理</span></span><br><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=<span class="variable">$&#123;master node ip&#125;</span> \</span><br><span class="line">--control-plane-endpoint=<span class="variable">$&#123;master node domain name&#125;</span> \</span><br><span class="line">--image-repository registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images \</span><br><span class="line">--kubernetes-version v1.20.9 \</span><br><span class="line">--service-cidr=10.96.0.0/16 \</span><br><span class="line">--pod-network-cidr=192.168.0.0/16</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意需要保证service-cidr和pod-netword-cidr不能重叠且和机器不能在一个网段</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 上述命令执行成功后，会显示如下页面：</span></span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  sudo <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  sudo <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, <span class="keyword">if</span> you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run <span class="string">&quot;kubectl apply -f [podnetwork].yaml&quot;</span> with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">You can now <span class="built_in">join</span> any number of control-plane nodes by copying certificate authorities</span><br><span class="line">and service account keys on each node and <span class="keyword">then</span> running the following as root:</span><br><span class="line"></span><br><span class="line">  kubeadm <span class="built_in">join</span> cluster-endpoint:6443 --token hums8f.vyx71prsg74ofce7 \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:a394d059dd51d68bb007a532a037d0a477131480ae95f75840c461e85e2c6ae3 \</span><br><span class="line">    --control-plane </span><br><span class="line"></span><br><span class="line">Then you can <span class="built_in">join</span> any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm <span class="built_in">join</span> cluster-endpoint:6443 --token hums8f.vyx71prsg74ofce7 \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:a394d059dd51d68bb007a532a037d0a477131480ae95f75840c461e85e2c6ae3</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据上述的提示信息，还需要在主节点上执行：</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"><span class="comment"># 观察是否正确</span></span><br><span class="line">kubectl get nodes</span><br><span class="line"><span class="comment"># 查看集群部署了哪些应用？</span></span><br><span class="line">kubectl get pods -A</span><br><span class="line"><span class="comment"># 运行中的应用在docker里面叫容器，在k8s里面叫Pod</span></span><br><span class="line">kubectl get pods -A</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在主节点上执行，下载网络组件</span></span><br><span class="line"></span><br><span class="line">curl https://docs.projectcalico.org/manifests/calico.yaml -O</span><br><span class="line"></span><br><span class="line">kubectl apply -f calico.yaml</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Worker节点准备，执行上面提示的信息即可</span></span><br><span class="line"></span><br><span class="line">kubeadm <span class="built_in">join</span> cluster-endpoint:6443 --token hums8f.vyx71prsg74ofce7 \</span><br><span class="line">    --discovery-token-ca-cert-hash</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 可以在Master节点上运行：</span></span><br><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>
<h5 id="部署dashboard">2）部署dashboard</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载dashboard配置文件</span></span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.3.1/aio/deploy/recommended.yaml</span><br><span class="line"><span class="comment"># 设置访问端口</span></span><br><span class="line">kubectl edit svc kubernetes-dashboard -n kubernetes-dashboard</span><br><span class="line"><span class="comment"># 把文件中的  type: ClusterIP 改为 type: NodePort</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行以下命令，查看端口映射关系</span></span><br><span class="line">kubectl get svc -A |grep kubernetes-dashboard</span><br><span class="line"><span class="comment">## 访问： https://集群任意IP:端口</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建访问账号，准备一个yaml文件； vi dash.yaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kubectl apply -f dash.yaml   <span class="comment"># 应用配置文件</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取k8s的访问令牌</span></span><br><span class="line">kubectl -n kubernetes-dashboard get secret $(kubectl -n kubernetes-dashboard get sa/admin-user -o jsonpath=<span class="string">&quot;&#123;.secrets[0].name&#125;&quot;</span>) -o go-template=<span class="string">&quot;&#123;&#123;.data.token | base64decode&#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="k8s命名空间容器工作负载">4、K8s——命名空间、容器、工作负载：</h4>
<h5 id="k8s的资源创建方法">1）K8s的资源创建方法：</h5>
<ul>
<li>使用命令行</li>
<li>使用YAML文件，书写YAML文件并使用<code>kubectl apply -f filename</code></li>
</ul>
<h5 id="namespace">2）Namespace：</h5>
<ul>
<li>名称空间，用来对集群资源进行隔离划分。默认只隔离资源，不隔离网络</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create ns hello</span><br><span class="line">kubectl delete ns hello</span><br></pre></td></tr></table></figure>
<p>或者使用YAML文件的形式</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello</span></span><br></pre></td></tr></table></figure>
<h5 id="pod">3）Pod：</h5>
<ul>
<li>运行中的一组容器，Pod是kubernetes中应用的最小单位。</li>
<li>在Container外层包了一层Pod，注意一个Pod里面允许存在多个容器</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221105220913167.png" /></p>
<ul>
<li>如下图所示：在一个Pod里，存在File Puller容器和Web
Server两个容器，一个用于内容管理下载，一个用于给客户提供访问服务。两个容器合起来完成了一个小的功能，封装在一个Pod里面。</li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221105221025280.png" style="zoom:50%;" /></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动一个Pod，指定一个镜像</span></span><br><span class="line">kubectl run mynginx --image=nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看default名称空间的Pod</span></span><br><span class="line">kubectl get pod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看这个pod的内部运行时描述</span></span><br><span class="line">kubectl describe pod Pod名字</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用YAML文件创建Pod</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">myapp</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">tomcat:8.5.68</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tomcat</span></span><br></pre></td></tr></table></figure>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221105221728766.png" style="zoom: 67%;" /></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除某个Pod</span></span><br><span class="line">kubectl delete pod Pod名字</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Pod的运行日志</span></span><br><span class="line">kubectl logs Pod名字</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个Pod - k8s都会分配一个ip</span></span><br><span class="line">kubectl get pod -owide</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Pod的ip+pod里面运行容器的端口</span></span><br><span class="line">curl 192.168.169.136</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集群中的任意一个机器以及任意的应用都能通过Pod分配的ip来访问这个Pod</span></span><br><span class="line"><span class="comment"># 但是目前，集群外的机器是没法访问的</span></span><br></pre></td></tr></table></figure>
<h5 id="deployment的多副本能力">4）Deployment的多副本能力</h5>
<p>​ Deployment用于控制Pod，使得Pod拥有多副本、自愈、扩缩容等能力。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个部署，可以创建多个Pod的副本</span></span><br><span class="line">kubectl create deployment my-dep --image=nginx --replicas=3</span><br></pre></td></tr></table></figure>
<h5 id="deployment的工作负载能力">5）Deployment的工作负载能力：</h5>
<ul>
<li>扩缩容：可以通过如下命令扩容或缩容部署副本数量</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl scale --replicas=5 deployment/my-dep</span><br></pre></td></tr></table></figure>
<ul>
<li><p>自愈&amp;故障转移：当Pod出现故障时，会自动重启该Pod。如果当某台服务器停机了，那么其会将该台服务器上运行的Pod在服务器的其他集群上拉取一份，并且运行，即故障转移</p></li>
<li><p>滚动更新：用于Pod的版本更新，全程无需停机维护，可以持续应对流量进入。对于服务器集群而言，每一台服务器先启动新版本的Pod，正确后杀死老版本的Pod，并把该台服务器上的流量转入新版本Pod中。当执行滚动更新的时候可以执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改my-dep这个deployment的nginx容器的镜像，是更新后的镜像</span></span><br><span class="line">kubectl <span class="built_in">set</span> image deployment/my-dep nginx=nginx:1.16.1 --record</span><br><span class="line"><span class="comment"># 使用此命令查看状态</span></span><br><span class="line">kubectl rollout status deployment/my-dep</span><br></pre></td></tr></table></figure></li>
<li><p>版本回退能力：</p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看版本改动的历史记录</span><br><span class="line">kubectl rollout history deployment/my-dep</span><br><span class="line"># 查看某个版本改动的历史详情</span><br><span class="line">kubectl rollout history deployment/my-dep --revision=2</span><br><span class="line"># 回滚(回到上次)</span><br><span class="line">kubectl rollout undo deployment/my-dep</span><br><span class="line"># 回滚(回到指定版本)</span><br><span class="line">kubectl rollout undo deployment/my-dep --to-revision=2</span><br></pre></td></tr></table></figure>
<h5 id="其他工作负载资源">6）其他工作负载资源：</h5>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221106130136601.png" /></p>
<h4 id="k8s服务网络service">5、K8s——服务网络Service：</h4>
<ul>
<li>Service：用于Pod的服务发现与负载均衡功能，是将一组Pods公开为网络服务的抽象方法</li>
<li>如此一来，这一组Pods的API地址就是Service暴露的公开地址，且Service能够对不同的Pod的运行状态进行监测，其实就有点像阿里云的负载均衡服务器。</li>
</ul>
<h5 id="cluster-ip模式集群内部访问">1）Cluster
IP模式（集群内部访问）</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 部署服务，其可以选择一组Pod然后将他们暴露为Service</span></span><br><span class="line">kubectl expose deployment my-dep --port=8000 --target-port=80</span><br><span class="line"><span class="comment"># 使用标签检索Pod</span></span><br><span class="line">kubectl get pod -l app=my-dep</span><br></pre></td></tr></table></figure>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221106130948476.png" /></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取service</span></span><br><span class="line">kubectl get service</span><br><span class="line"><span class="comment"># CLUSTER-IP即暴露给外层的服务地址</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221106131131834.png" /></p>
<ul>
<li>什么是服务发现机制？
<ul>
<li>如果原先Deployment对应部署的Pod是三份，此时缩容到了两份，即有一个Pod下线了，那么此时Service能够发现有一个Pod下线了，不会像该Pod转发流量。如果后续Pod重新上线，Service又会重新将流量分流给这个重新上线的Pod。</li>
</ul></li>
</ul>
<h5
id="nodeport模式集群外也可以访问">2）NodePort模式（集群外也可以访问）：</h5>
<p>​
此时，不仅可以通过内部Ip+端口可以访问，而且还会在每一台机器上随机暴露一个端口，使得外网可以通过访问机器的公网IP+端口也可以访问该服务。暴露的端口范围在
30000-32767 之间。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 部署服务，其可以选择一组Pod然后将他们暴露为Service</span></span><br><span class="line">kubectl expose deployment my-dep --port=8000 --target-port=80 --<span class="built_in">type</span>=NodePort</span><br></pre></td></tr></table></figure>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221106132238850.png" /></p>
<h4 id="k8s服务网络-ingress">6、K8s——服务网络 Ingress</h4>
<ul>
<li>Ingress是Service的统一网关入口</li>
<li>Service负责Pod的负载均衡，而Ingress负责将流量转发给Service。Ingress起到类似nginx的作用。</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-11-06%2021.00.40.png" /></p>
<h5
id="安装ingress通过yaml文件来进行安装">1）安装ingress，通过yaml文件来进行安装</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v0.47.0/deploy/static/provider/baremetal/deploy.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改镜像</span></span><br><span class="line">vi deploy.yaml</span><br><span class="line"><span class="comment"># 将image的值改为如下值：</span></span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/ingress-nginx-controller:v0.46.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查安装的结果</span></span><br><span class="line">kubectl get pod,svc -n ingress-nginx</span><br></pre></td></tr></table></figure>
<h5 id="使用ingress">2）使用ingress</h5>
<ul>
<li>安装ingress以后，会暴露两个端口，分别负责https和http的访问</li>
<li>应用如下yaml文件，进行测试：</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello-server</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">hello-server</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">hello-server</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hello-server</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/hello-server</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9000</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-demo</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-demo</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-demo</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-demo</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-demo</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">hello-server</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello-server</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">hello-server</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">9000</span></span><br></pre></td></tr></table></figure>
<ul>
<li>应用上述yaml部署deployment和service后，架构图如下所示：</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-11-06%2021.10.08.png" /></p>
<ul>
<li>此时，我们需要将打入ingress层的流量做一个分流：</li>
<li>配置生效后，访问hello.atguigu.com要将流量打到hello这个service</li>
<li>访问demo.atguigu.com就要将流量打到nginx-demo这个service</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress  </span><br><span class="line">metadata:</span><br><span class="line">  name: ingress-host-bar</span><br><span class="line">spec:</span><br><span class="line">  ingressClassName: nginx</span><br><span class="line">  rules:</span><br><span class="line">  - host: <span class="string">&quot;hello.atguigu.com&quot;</span></span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - pathType: Prefix</span><br><span class="line">        path: <span class="string">&quot;/&quot;</span></span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: hello-server</span><br><span class="line">            port:</span><br><span class="line">              number: 8000</span><br><span class="line">  - host: <span class="string">&quot;demo.atguigu.com&quot;</span></span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - pathType: Prefix</span><br><span class="line">        path: <span class="string">&quot;/nginx&quot;</span>  <span class="comment"># 把请求会转给下面的服务，下面的服务一定要能处理这个路径，不能处理就是404</span></span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: nginx-demo  <span class="comment">## java，比如使用路径重写，去掉前缀nginx</span></span><br><span class="line">            port:</span><br><span class="line">              number: 8000</span><br></pre></td></tr></table></figure>
<ul>
<li>path: "/nginx" 与 path: "/" 会有什么样不同的效果？
<ul>
<li>这里的path其实就是匹配根目录的一个规则。路径前缀是/nginx的话，网关就知道能够处理，不然网关会直接把这个流量拦下来。同时，后面的service服务也需要能够处理这个路径，不然网关将该请求转发给service以后，如果service不能处理的话就会返回404。</li>
</ul></li>
</ul>
<h5 id="ingress路径重写">3）Ingress路径重写：</h5>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span>  </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">	<span class="comment"># 新增内容，$2的意思就是$前的东西都舍弃，$后的东西就保留</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/rewrite-target:</span> <span class="string">/$2</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-host-bar</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ingressClassName:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">&quot;hello.atguigu.com&quot;</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&quot;/&quot;</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">hello-server</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">8000</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">&quot;demo.atguigu.com&quot;</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&quot;/nginx(/|$)(.*)&quot;</span>  <span class="comment"># 把请求会转给下面的服务，下面的服务一定要能处理这个路径，不能处理就是404</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">nginx-demo</span>  <span class="comment">## java，比如使用路径重写，去掉前缀nginx</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">8000</span></span><br></pre></td></tr></table></figure>
<p>如此重写路径后，外层再访问/nginx的地址时，当ingress转发给后台的service时，会先将/nginx前缀截掉，访问service的根目录/。</p>
<h5 id="流量限制">4）流量限制：</h5>
<p>应用如下配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-limit-rate</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">  <span class="comment"># 新增流量限制，每秒放行1个请求</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/limit-rps:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ingressClassName:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">&quot;haha.atguigu.com&quot;</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Exact</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&quot;/&quot;</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">nginx-demo</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">8000</span></span><br></pre></td></tr></table></figure>
<h4 id="k8s存储抽象">6、K8s——存储抽象：</h4>
<p>​
因为K8s具备故障转移的能力，所以如果某个Pod想在别的机器上拉起转移部署，但是数据却没有相应的跟过去的话，就会导致重新拉起的服务无效，故而我们要抽相处一层存储区域。</p>
<h5 id="nfs网络文件系统">1）NFS网络文件系统</h5>
<p>​
首先搭建NFS网络文件系统，它能够同步多台服务器之间的某一块空间，使得某块特定空间内的数据文件一致。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 所有节点</span></span><br><span class="line"><span class="comment"># 所有机器安装</span></span><br><span class="line">yum install -y nfs-utils</span><br><span class="line"><span class="comment"># 主节点：</span></span><br><span class="line"><span class="comment">#nfs主节点</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/nfs/data/ *(insecure,rw,sync,no_root_squash)&quot;</span> &gt; /etc/exports</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /nfs/data</span><br><span class="line">systemctl <span class="built_in">enable</span> rpcbind --now</span><br><span class="line">systemctl <span class="built_in">enable</span> nfs-server --now</span><br><span class="line"><span class="comment">#配置生效</span></span><br><span class="line">exportfs -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从节点：</span></span><br><span class="line">showmount -e 172.31.0.4 <span class="comment"># 主服务器IP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行以下命令挂载 nfs 服务器上的共享目录到本机路径 /root/nfsmount</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /nfs/data</span><br><span class="line"></span><br><span class="line">mount -t nfs 172.31.0.4:/nfs/data  /nfs/data</span><br><span class="line"><span class="comment"># 写入一个测试文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello nfs server&quot;</span> &gt; /nfs/data/test.txt</span><br></pre></td></tr></table></figure>
<h5
id="使用deployment进行nfs的挂载">2）使用Deployment进行NFS的挂载：</h5>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pv-demo</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-pv-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pv-demo</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pv-demo</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span>   <span class="comment"># 将哪个路径进行部署</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">          <span class="attr">nfs:</span></span><br><span class="line">            <span class="attr">server:</span> <span class="number">172.31</span><span class="number">.0</span><span class="number">.4</span>  <span class="comment"># 主节点IP</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/nfs/data/nginx-pv</span>   <span class="comment"># 进行挂载</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-11-06%2021.40.09.png" /></p>
<h4 id="存储抽象pv和pvc">7、存储抽象——PV和PVC</h4>
<p><em>PV：持久卷（Persistent
Volume），将应用需要持久化的数据保存到指定位置</em></p>
<p><em>PVC：持久卷申明（<strong>Persistent Volume
Claim</strong>），申明需要使用的持久卷规格</em></p>
<p>​
先前挂载数据的模式，挂载的文件目录不受控制，可能存在一些问题，故而我们提出了PV和PVC这样一个概念。先事先规划好所有的持久卷及地址。如下图所示，容器想要挂载空间时，需要先申请，申请1G的空间，那么就会从现有的空间中挑选出最合适的分配给这个Pod。这样的好处是：如果Pod被移除，则PVC被移除，PVC移除后，其对应的空间也会被移除。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-11-07%2014.45.32.png" /></p>
<h5 id="实践pv池静态供应模式">1）实践：PV池——静态供应模式</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nfs主节点</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /nfs/data/01</span><br><span class="line"><span class="built_in">mkdir</span> -p /nfs/data/02</span><br><span class="line"><span class="built_in">mkdir</span> -p /nfs/data/03</span><br></pre></td></tr></table></figure>
<ul>
<li>利用如下YAML文件，在PV池中，创建三个PV存储空间</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv01-10m</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">10M</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/nfs/data/01</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">172.31</span><span class="number">.0</span><span class="number">.4</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv02-1gi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/nfs/data/02</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">172.31</span><span class="number">.0</span><span class="number">.4</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv03-3gi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">3Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/nfs/data/03</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">172.31</span><span class="number">.0</span><span class="number">.4</span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建PVC，即写一份空间申请书，我需要申请的空间为200M，且访问模式需要支持读写。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">200Mi</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs</span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建Pod绑定PVC</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-deploy-pvc</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deploy-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-deploy-pvc</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-deploy-pvc</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">          <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">            <span class="attr">claimName:</span> <span class="string">nginx-pvc</span></span><br></pre></td></tr></table></figure>
<h5 id="实践pv池动态供应模式">2）实践：PV池——动态供应模式：</h5>
<p>​
就是PV池并不是提前分配好的，而是每收到一个PVC，就分配一个对应大小的PV空间。</p>
<h4 id="存储抽象configmap">8、存储抽象——ConfigMap</h4>
<p>作用：抽取应用配置，并且可以自动更新</p>
<ul>
<li>以Redis部署为例：</li>
</ul>
<h5
id="把之前的配置文件创建为配置集">1）把之前的配置文件创建为配置集</h5>
<figure class="highlight plaintext"><figcaption><span>s</span></figcaption><table><tr><td class="code"><pre><span class="line"># 创建配置，redis保存到k8s的etcd；</span><br><span class="line">kubectl create cm redis-conf --from-file=redis.conf</span><br></pre></td></tr></table></figure>
<h5 id="随后就可以根据配置集启动pod">2）随后就可以根据配置集启动Pod</h5>
<h4 id="存储抽象secret资源">9、存储抽象——Secret资源：</h4>
<p>​ Secret 对象类型用来保存敏感信息，例如密码、OAuth 令牌和 SSH 密钥。
将这些信息放在 secret 中比放在 <a
href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pod</a>
的定义或者 <a
href="https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-image">容器镜像</a>
中来说更加安全和灵活。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过一个私有的docker来创建一个secret资源，</span></span><br><span class="line">kubectl create secret docker-registry leifengyang-docker \</span><br><span class="line">--docker-username=leifengyang \</span><br><span class="line">--docker-password=Lfy123456 \</span><br><span class="line">--docker-email=534096094@qq.com</span><br><span class="line"></span><br><span class="line"><span class="comment">## 命令格式</span></span><br><span class="line">kubectl create secret docker-registry regcred \</span><br><span class="line">  --docker-server=&lt;你的镜像仓库服务器&gt; \</span><br><span class="line">  --docker-username=&lt;你的用户名&gt; \</span><br><span class="line">  --docker-password=&lt;你的密码&gt; \</span><br><span class="line">  --docker-email=&lt;你的邮箱地址&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过secret资源来创建docker</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">private-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">private-nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">leifengyang/guignginx:v1.0</span></span><br><span class="line">  <span class="attr">imagePullSecrets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">leifengyang-docker</span></span><br></pre></td></tr></table></figure>
<h5 id="section"></h5>
]]></content>
      <categories>
        <category>⑨ 工程类笔记</category>
        <category>云原生入门</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生快速入门系列Chap1——云平台+容器化</title>
    <url>/2022/11/03/a1fb45edd54f/</url>
    <content><![CDATA[<h4 id="公有云和私有云">1、公有云和私有云：</h4>
<ul>
<li><p>公有云：</p>
<ul>
<li>公有云资源（例如服务器和存储空间）由第三方云服务提供商拥有和运营，这些资源通过
Internet 提供</li>
<li><strong>成本更低</strong>：无需购买硬件或软件，仅对使用的服务付费。</li>
<li><strong>无需维护</strong>：维护由服务提供商提供。</li>
<li><strong>近乎无限制的缩放性</strong>：提供按需资源，可满足业务需求。</li>
<li><strong>高可靠性</strong>：具备众多服务器，确保免受故障影响。</li>
<li>可用性： N个9 全年的故障时间： 365<em>24</em>3600*(1-99.9999%)</li>
</ul></li>
<li><p>私有云：</p>
<ul>
<li><p>私有云由专供一个企业或组织使用的云计算资源构成。在私有云中，<strong>服务和基础结构始终在私有网络上进行维护，硬件和软件专供组织使用。</strong>私有云的使用对象通常为政府机构、金融机构以及其他具备业务关键性运营且希望对环境拥有更大控制权的中型到大型组织。</p></li>
<li><p><strong>灵活性更强</strong>：组织可自定义云环境以满足特定业务需求。</p></li>
<li><p><strong>控制力更强</strong>：资源不与其他组织共享，因此能获得更高的控制力以及<strong>更高的隐私级别。</strong></p></li>
<li><p><strong>可伸缩性更强</strong>：与本地基础结构相比，私有云通常具有更强的可伸缩性。</p></li>
</ul></li>
<li><p>没有一种云计算类型适用于所有人。多种不同的云计算模型、类型和服务已得到发展，可以满足组织快速变化的技术需求。</p></li>
</ul>
<h4 id="私有网络vpc">2、私有网络VPC</h4>
<p>​ 集群内服务器之间互相访问，一般都是用私有IP进行访问，速度更快.</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221031170245325.png" /></p>
<p>​
在实际的服务器集群中,可以自己先新建一个专有网络(其实就是可以在内部创建局域网,然后再通过交换机创建子网等),划分相应的网段.比如说192.168.o.0/16.</p>
<p>​ 不同VPC之间的主机不能直接通信,VPC提供了一个隔离域.</p>
<h4 id="docker容器化概念">3、Docker容器化概念</h4>
<ul>
<li>统一标准，应用构建、分享和运行。</li>
<li>资源隔离：cpu内存资源隔离与限制，访问设备隔离与限制，网络隔离与限制等</li>
<li>虚拟化技术：
<ul>
<li>在Docker容器化技术还没有出现的时候，人们使用的是虚拟化技术。基于虚拟机的部署方式，基础镜像非常大，创建使用稍微复杂，启动速度较慢，移植与分享不方便，虽然其隔离性非常的好。</li>
<li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221101161243475.png" style="zoom:67%;" /></li>
</ul></li>
<li>基于虚拟化的Docker容器化技术：
<ul>
<li>基础镜像MB级别，创建简单，启动速度快，移植与分享方便</li>
<li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221101161359831.png" style="zoom:67%;" /></li>
<li>架构如图所示：Registry镜像仓库，Containers容器，Images镜像</li>
<li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221101161524606.png" style="zoom:67%;" /></li>
</ul></li>
</ul>
<h4 id="docker容器化常用命令">4、Docker容器化常用命令</h4>
<h5 id="镜像相关">1）镜像相关</h5>
<p>​ Docker Hub常用的镜像网站</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull nginx  <span class="comment">#下载最新版</span></span><br><span class="line">docker pull nginx:1.20.1 <span class="comment">#下载指定版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 下载来的镜像都在本地</span></span><br><span class="line">docker images  <span class="comment">#查看所有镜像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除镜像</span></span><br><span class="line">docker rmi 镜像名:版本号 / 镜像<span class="built_in">id</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="容器启动停止相关">2）容器启动停止相关：</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># -d：后台运行</span></span><br><span class="line"><span class="comment"># --restart=always   该容器开机自启，应用开机自启</span></span><br><span class="line"><span class="comment"># -p 外部端口:内部端口  端口映射 </span></span><br><span class="line">docker run --name=mynginx -d --restart=always -p 88:80 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看正在运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="comment"># 查看所有容器</span></span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除停止的容器</span></span><br><span class="line">docker <span class="built_in">rm</span>  容器<span class="built_in">id</span>/名字</span><br><span class="line">docker <span class="built_in">rm</span> -f mynginx   <span class="comment"># 强制删除正在运行中的容器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#停止容器</span></span><br><span class="line">docker stop 容器<span class="built_in">id</span>/名字</span><br><span class="line"><span class="comment">#再次启动</span></span><br><span class="line">docker start 容器<span class="built_in">id</span>/名字</span><br></pre></td></tr></table></figure>
<h5 id="修改容器内容">3）修改容器内容：</h5>
<ul>
<li>法1：进入容器内部，然后修改</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入容器内部的系统，修改容器内容</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 容器<span class="built_in">id</span> /bin/bash</span><br></pre></td></tr></table></figure>
<ul>
<li>法2：挂载数据到外部修改：(请注意：挂载在外部的数据是没法提交改变的)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name=mynginx </span><br><span class="line">-d  --restart=always </span><br><span class="line">-p  88:80 </span><br><span class="line">-v /data/html:/usr/share/nginx/html:ro  <span class="comment"># 外部数据地址:内部数据地址 :ro代表只读模式，容器内不能修改</span></span><br><span class="line">nginx</span><br></pre></td></tr></table></figure>
<h5 id="提交改变">4）提交改变：</h5>
<ul>
<li>将自己修改好的自定义镜像提交,这样会在本地产生一个新的镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># -a author -m message</span></span><br><span class="line">docker commit -a <span class="string">&quot;fantast&quot;</span> -m <span class="string">&quot;首页变化&quot;</span> 341d81f7504f slksnginx:v1.0</span><br></pre></td></tr></table></figure>
<ul>
<li>将镜像文件打包存储，然后传输给另一台主机：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打包镜像至压缩包</span></span><br><span class="line">docker save -o abc.tar fantastnginx:v1.0</span><br><span class="line"><span class="comment"># 远程传输</span></span><br><span class="line">scp abc.tar root@128.12.33.12:/root/</span><br><span class="line"><span class="comment"># 加载docker镜像压缩包</span></span><br><span class="line">docker load abc.tar</span><br></pre></td></tr></table></figure>
<ul>
<li>推送至远程仓库docker hub</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把旧镜像的名字，改成仓库要求的新版名字</span></span><br><span class="line">docker tag fantastnginx:v1.0 fantast616/fantastnginx:v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录到docker hub</span></span><br><span class="line">docker login       </span><br><span class="line"></span><br><span class="line">docker <span class="built_in">logout</span>（推送完成镜像后退出）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送</span></span><br><span class="line">docker push fantast616/fantastnginx:v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 别的机器下载</span></span><br><span class="line">docker pull fantast616/fantastnginx:v1.0</span><br></pre></td></tr></table></figure>
<h5 id="其他命令">5）其他命令：</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker 运行日志</span></span><br><span class="line">docker logs 容器名/id</span><br><span class="line"><span class="comment"># docker 进入内部BASH控制台</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 容器<span class="built_in">id</span> /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker 经常修改nginx配置文件</span></span><br><span class="line">docker run -d -p 80:80 \</span><br><span class="line">-v /data/html:/usr/share/nginx/html:ro \</span><br><span class="line">-v /data/conf/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">--name mynginx-02 \</span><br><span class="line">nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#把容器指定位置的东西复制出来 </span></span><br><span class="line">docker <span class="built_in">cp</span> 5eff66eec7e1:/etc/nginx/nginx.conf  /data/conf/nginx.conf  </span><br><span class="line"><span class="comment">#把外面的内容复制到容器里面</span></span><br><span class="line">docker <span class="built_in">cp</span>  /data/conf/nginx.conf  5eff66eec7e1:/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>
<h4
id="编写一个简单的springboot应用并部署">5、编写一个简单的SpringBoot应用并部署：</h4>
<h5 id="docker部署redis">1）Docker部署Redis</h5>
<p>首先下载redis镜像，并在外部配置文件，最后启动redis镜像完成映射</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">#redis使用自定义配置文件启动</span><br><span class="line"></span><br><span class="line">docker run -v /data/redis/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-v /data/redis/data:/data \</span><br><span class="line">-d --name myredis \</span><br><span class="line">-p 6379:6379 \</span><br><span class="line">redis:latest  redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure>
<h5 id="非docker部署步骤">2）非Docker部署步骤：</h5>
<ul>
<li>SpringBoot打包为可执行的jar包，并上传至服务器</li>
<li>服务器运行java -jar</li>
</ul>
<h5
id="docker部署步骤编写dockerfile">3）Docker部署步骤：编写DockerFile</h5>
<ul>
<li>Dockerfile如下：</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-slim  <span class="comment"># 基础镜像环境，比如说运行环境java</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=fantast</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> target/*.jar /app.jar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>还有一个Jar目录叫做 target</p></li>
<li><p>将Dockerfile和target上传到服务器的一个目录下，然后执行以下命令构建镜像</p></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t java-demo:v1.0 .</span><br></pre></td></tr></table></figure>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221104142249625.png" /></p>
<h5 id="分享docker">4）分享docker</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 登录docker hub</span></span><br><span class="line">docker login</span><br><span class="line"></span><br><span class="line"><span class="comment">#给旧镜像起名</span></span><br><span class="line">docker tag java-demo:v1.0  fantast/java-demo:v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送到docker hub</span></span><br><span class="line">docker push fantast/java-demo:v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 别的机器</span></span><br><span class="line">docker pull fantast/java-demo:v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 别的机器运行</span></span><br><span class="line">docker run -d -p 8080:8080 --name myjava-app java-demo:v1.0</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>⑨ 工程类笔记</category>
        <category>云原生入门</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap12 Mysql数据库调优工具</title>
    <url>/2022/10/28/a30af89db2dc/</url>
    <content><![CDATA[<h3 id="一数据库优化步骤及优化工具">一、数据库优化步骤及优化工具</h3>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221028165505532.png" style="zoom:67%;" /></p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221028165600066.png" style="zoom:67%;" /></p>
<h4 id="统计sql的查询成本">1、统计SQL的查询成本：</h4>
<p>​ 这个Value代表的是进行了多少个页的查询</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221028170212104.png" /></p>
<p>​
使用场景：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。SQL查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：</p>
<ul>
<li>位置决定效率。如果页就在数据库缓冲池中，那么效率是最高的，否则还需要从内存或者磁盘中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。</li>
<li>批量决定效率。如果我们从磁盘中对单一页进行随机读，那么效率是很低的（差不多10ms），而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。</li>
<li>考虑数据存放的位置，如果是经常使用的数据就要尽量放到缓冲池中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。</li>
</ul>
<h4 id="开启慢查询日志">2、开启慢查询日志：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global slow_query_log=&#x27;ON&#x27;;</span><br></pre></td></tr></table></figure>
<p>​
MySQL的慢查询日志，用来记录在MySQL中响应时间超过阈值的语句，具体指运行时间超过long_query_time值的SQL，会被记录到慢查询日志中，默认值为10s。</p>
<p>​ 如果不是调优需要的话，一般不会开启该参数。</p>
<p>​ 设置时间阈值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; set global long_query_time = 1;</span><br><span class="line">mysql&gt; show global variables like &#x27;%long_query_time%&#x27;;</span><br><span class="line">mysql&gt; set long_query_time=1;</span><br><span class="line">mysql&gt; show variables like &#x27;%long_query_time%&#x27;;</span><br></pre></td></tr></table></figure>
<p>​ 查看慢查询记录条数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW GLOBAL STATUS LIKE &#x27;%Slow_queries%&#x27;;</span><br></pre></td></tr></table></figure>
<p>​ 慢查询日志分析工具：mysqldumpslow</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#得到返回记录集最多的10个SQL</span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log</span><br><span class="line">#得到访问次数最多的10个SQL</span><br><span class="line">mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log</span><br><span class="line">#得到按照时间排序的前10条里面含有左连接的查询语句</span><br><span class="line">mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/atguigu-slow.log</span><br><span class="line">#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more</span><br></pre></td></tr></table></figure>
<p>​ 查看SQL执行成本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql &gt; set profiling = &#x27;ON&#x27;;</span><br><span class="line">mysql &gt; show profiles;</span><br><span class="line">mysql &gt; show profile;</span><br><span class="line">mysql&gt; show profile cpu,block io for query 2;</span><br></pre></td></tr></table></figure>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/image-20221029131535493.png" /></p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29 13.17.28.png" style="zoom:67%;" /></p>
<h4 id="分析查询语句explain">3、分析查询语句EXPLAIN：</h4>
<p>​
<strong>定位了查询慢的SQL之后，我们就可以使用EXPLAIN或DESCRIBE工具做针对性的分析查询语句。</strong></p>
<ul>
<li><p>能显示哪些信息？</p>
<ul>
<li><p>表的读取顺序，数据读取操作的操作类型、哪些索引可以使用，哪些索引实际被使用、表之间的引用、每张表有多少行被优化器查询。</p></li>
<li><p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29%2013.32.18.png" /></p></li>
<li><table>
<colgroup>
<col style="width: 19%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="header">
<th>id</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>select_type</td>
<td>SELECT关键字对应的那个查询的类型</td>
</tr>
<tr class="even">
<td>table</td>
<td>表名</td>
</tr>
<tr class="odd">
<td>Partitions</td>
<td>匹配的分区信息</td>
</tr>
<tr class="even">
<td>type</td>
<td>针对单表的访问方法</td>
</tr>
<tr class="odd">
<td>Possible_keys</td>
<td>可能用到的索引</td>
</tr>
<tr class="even">
<td>key</td>
<td>实际上使用的索引</td>
</tr>
<tr class="odd">
<td>key_len</td>
<td>实际使用到的索引长度</td>
</tr>
<tr class="even">
<td>ref</td>
<td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td>
</tr>
<tr class="odd">
<td>rows</td>
<td>预估的需要读取的记录条数</td>
</tr>
<tr class="even">
<td>filtered</td>
<td>某个表经过搜索条件过滤后剩余记录条数的百分比</td>
</tr>
<tr class="odd">
<td>Extra</td>
<td>一些额外的信息</td>
</tr>
</tbody>
</table></li>
</ul></li>
</ul>
<h5 id="id-和-table关键词">1）id 和 table关键词</h5>
<ul>
<li>Case1:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 INNER JOIN s2</span><br><span class="line">ON s1.key1 = s2.key1</span><br><span class="line">WHERE s1.common_field = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29%2013.57.41.png" /></p>
<ul>
<li><p>每一条查询记录，都对应一张单表。比如说上述inner
join，用到两个单表，所以会显示有两条记录</p></li>
<li><p>但是在一个大的查询中，一个SELECT关键词对应着一个id</p></li>
</ul></li>
<li><p>Case2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure></li>
<li><p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29%2014.03.11.png" /></p>
<ul>
<li>有两个SELECT语句，所以对应两个id</li>
</ul></li>
<li><p>Case3:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key2 FROM s2 WHERE common_field = &#x27;a&#x27;);</span><br></pre></td></tr></table></figure>
<ul>
<li><p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29%2014.07.15.png" /></p></li>
<li><p>虽然有两个SELECT语句，为啥同一个ID呢？因为查询优化器可能对涉及子查询的查询语句进行重写，转换为多表查询的形式。</p></li>
</ul></li>
<li><p>Case4:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29%2014.09.41.png" /></p></li>
<li><p>UNION操作因为需要中间表进行去重操作，所以涉及到第三个记录。</p></li>
</ul></li>
<li><p>Case5:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;</span><br></pre></td></tr></table></figure></li>
<li><p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29%2014.10.39.png" /></p></li>
<li><p>因为UNION ALL不用去重，所以不会有第三条记录</p></li>
<li><p><strong>总结相关内容：</strong></p>
<ul>
<li>id如果相同，可以认为是一组，从上往下顺序执行</li>
<li>在所有组中，id值越大，优先级越高，越先执行</li>
<li>关注点：id号每个号码，表示一趟独立的查询,
一个sql的查询趟数越少越好</li>
</ul></li>
</ul>
<h5 id="select_type">2）select_type</h5>
<p>​
SELECT关键字对应的那个查询的类型，确认了小查询在大的查询中扮演了怎样的一个角色。</p>
<ul>
<li><p>查询语句中不包含UNION和子查询的都是SIMPLE</p></li>
<li><p>连接查询都是SIMPLE</p></li>
<li><p>Case1: 相关子查询 DEPENDENT SUBQUERY</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE s1.key2 =</span><br><span class="line">s2.key2) OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29%2014.18.01.png" /></p></li>
<li><p>Case2: 查询优化器优化了的情况</p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 IN </span><br><span class="line">	(</span><br><span class="line">    SELECT key1 FROM s2 WHERE key1 = &#x27;a&#x27; </span><br><span class="line">   	UNION </span><br><span class="line">   	SELECT key1 FROM s1 WHERE key1 = &#x27;b&#x27;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29%2014.23.09.png" /></p>
<h5
id="type对某张表的查询类型查询方法">3）type：对某张表的查询类型，查询方法</h5>
<ul>
<li>所有访问类型，越靠前是我们最希望看到的（效果越好）：system ， const
， eq_ref ， ref ， fulltext ， ref_or_null ，index_merge ，
unique_subquery ， index_subquery ， range ， index ， ALL</li>
<li>system</li>
</ul>
<p>示例：表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE s1 (</span><br><span class="line">    id INT AUTO_INCREMENT,</span><br><span class="line">    key1 VARCHAR(100),</span><br><span class="line">    key2 INT,</span><br><span class="line">    key3 VARCHAR(100),</span><br><span class="line">    key_part1 VARCHAR(100),</span><br><span class="line">    key_part2 VARCHAR(100),</span><br><span class="line">    key_part3 VARCHAR(100),</span><br><span class="line">    common_field VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    INDEX idx_key1 (key1),</span><br><span class="line">    UNIQUE INDEX idx_key2 (key2),</span><br><span class="line">    INDEX idx_key3 (key3),	</span><br><span class="line">    INDEX idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE=INNODB CHARSET=utf8;</span><br></pre></td></tr></table></figure>
<ul>
<li>const：根据主键或唯一二级索引与常数进行匹配</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE id = 10005;</span><br></pre></td></tr></table></figure>
<ul>
<li>eq_ref：连接查询时，被驱动表根据主键或唯一二级索引与常数进行匹配</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;</span><br></pre></td></tr></table></figure>
<p>​
从执行计划的结果中可以看出，MySQL打算将s2作为驱动表，s1作为被驱动表，重点关注s1的访问方法是eq_ref
，表明在访问s1表的时候可以通过主键的等值匹配来进行访问</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29%2014.29.09.png" /></p>
<ul>
<li>ref：普通二级索引与常数进行匹配</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29%2014.33.58.png" /></p>
<ul>
<li>ref_or_null 普通二级索引与常数进行匹配，且索引值可能为null</li>
<li>index_merge MySQL 打算使用索引合并的方式来执行对 s1 表的查询。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27; OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<ul>
<li>unique_subquery</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key2 IN (SELECT id FROM s2 where s1.key1 = s2.key1) OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<ul>
<li>index_subquery</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE common_field IN (SELECT key3 FROM s2 where s1.key1 = s2.key1) OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<ul>
<li>range
使用索引获取某些范围区间的记录，那么就可能使用到range访问方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;a&#x27; AND key1 &lt; &#x27;b&#x27;;</span><br></pre></td></tr></table></figure>
<ul>
<li>index
当我们可以使用素引覆盖（不用回表就可以查到数据），但需要扫描全部的索引记录时，该表的访问方法就是index
【因为此处，联合索引的字段最优先的是key_part1,key_part2然后才是key_part3】</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3=&#x27;a&#x27;；</span><br></pre></td></tr></table></figure>
<p>​ 即如果语句如下，则type就是ref而非index</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT key_part2 FROM s1 WHERE key_part1=&#x27;a&#x27; and key_part3 = &#x27;b&#x27;;</span><br></pre></td></tr></table></figure>
<ul>
<li>all</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1;</span><br></pre></td></tr></table></figure>
<p>​ <strong>SQL</strong> <strong>性能优化的目标：至少要达到</strong>
<strong>range</strong> <strong>级别，要求是</strong>
<strong>ref</strong> <strong>级别，最好是</strong>
<strong>consts</strong>级别。</p>
<h5 id="possible_keys-和-key">4）possible_keys 和 key</h5>
<p>​
在EXPLAIN语句输出的执行计划中，possible_keys列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些。一般查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。key列表示实际用到的索引有哪些，如果为NULL，则没有使用索引。</p>
<h5 id="key_len">5）key_len</h5>
<p>​
实际使用到的索引长度（字节数），帮你检查是否充分的利用上了索引，值越大越好，主要针对于联合索引。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE id = 10005;</span><br></pre></td></tr></table></figure>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221029221248821.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key2 = 10126;</span><br></pre></td></tr></table></figure>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221029221254958.png" /></p>
<p>4+1 =5, 因为key2字段不是非空的，所以记录NULL需要一个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key_part1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221029221407032.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key_part1 = &#x27;a&#x27; AND key_part2 = &#x27;b&#x27;;</span><br></pre></td></tr></table></figure>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221029221412049.png" /></p>
<p><strong>key_len</strong>如何计算:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># varchar(10)变长字段且允许NULL = 10 * ( character set：</span><br><span class="line"># utf8=3,gbk=2,latin1=1)+1(NULL)+2(变长字段)</span><br><span class="line"></span><br><span class="line"># varchar(10)变长字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+2(变长字段)</span><br><span class="line"></span><br><span class="line"># char(10)固定字段且允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL)</span><br><span class="line"></span><br><span class="line"># char(10)固定字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)</span><br></pre></td></tr></table></figure>
<h5 id="ref">6）ref</h5>
<p>​ 当使用索引列等值查询的时候，与索引列进行等值匹配的对象信息。</p>
<h5 id="rows">7）rows</h5>
<p>​ 预估的需要读取的记录条数</p>
<h5 id="filtered">8）filtered</h5>
<p>​
某个表经过搜索条件过滤后，剩余记录条数的百分比。对于单表查询没有什么大的意义。</p>
<ul>
<li>Case1:代表，单表查询时，经过key1 &gt; 'z' 和 common_filed='a'
条件筛选后，还剩下的记录是10%</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27; AND common_field = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221030202016814.png" /></p>
<ul>
<li>Case2:连表查询时，s1驱动表，s2被驱动表,此时filtered的值决定了被驱动表s2需要执行的次数，即rows*filtered。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key1 WHERE s1.common_field = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221030202138448.png" /></p>
<h5 id="extra">9） Extra</h5>
<p>​ 更准确的理解MySQL到底将如何执行给定的查询语句</p>
<h5 id="小结">10）小结：</h5>
<ul>
<li>EXPLAIN不考虑各种Cache</li>
<li>EXPLAIN不能显示MySQL在执行查询时所作的优化工作</li>
<li>EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况</li>
<li>部分统计信息是估算的，并非精确值</li>
</ul>
<h4 id="explain语句的输出格式">4、EXPLAIN语句的输出格式</h4>
<h5 id="传统格式表格形式">1）传统格式，表格形式</h5>
<p>​ 即上述内容</p>
<h5 id="json格式会显示成本">2）JSON格式，会显示成本</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN FORMAT=JSON SELECT ....</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query_block&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;select_id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cost_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;4445.50&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;nested_loop&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;table_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s1&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;access_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ALL&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;possible_keys&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;idx_key1&quot;</span></span><br><span class="line">          <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;rows_examined_per_scan&quot;</span><span class="punctuation">:</span> <span class="number">9825</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;rows_produced_per_join&quot;</span><span class="punctuation">:</span> <span class="number">9825</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;filtered&quot;</span><span class="punctuation">:</span> <span class="string">&quot;100.00&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;cost_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;read_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;24.25&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;eval_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;982.50&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;prefix_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1006.75&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;data_read_per_join&quot;</span><span class="punctuation">:</span> <span class="string">&quot;17M&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;used_columns&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;id&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key3&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key_part1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key_part2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key_part3&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;common_field&quot;</span></span><br><span class="line">          <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;attached_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`experiment`.`s1`.`key1` is not null)&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;table_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s2&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;access_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eq_ref&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;possible_keys&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;idx_key2&quot;</span></span><br><span class="line">          <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;idx_key2&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;used_key_parts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;key2&quot;</span></span><br><span class="line">          <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;key_length&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;ref&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;experiment.s1.key1&quot;</span></span><br><span class="line">          <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;rows_examined_per_scan&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;rows_produced_per_join&quot;</span><span class="punctuation">:</span> <span class="number">9825</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;filtered&quot;</span><span class="punctuation">:</span> <span class="string">&quot;100.00&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;index_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(cast(`experiment`.`s1`.`key1` as double) = cast(`experiment`.`s2`.`key2` as double))&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;cost_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;read_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2456.25&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;eval_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;982.50&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;prefix_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;4445.50&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;data_read_per_join&quot;</span><span class="punctuation">:</span> <span class="string">&quot;17M&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;used_columns&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;id&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key3&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key_part1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key_part2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key_part3&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;common_field&quot;</span></span><br><span class="line">          <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>由于 s2 表是被驱动表，所以可能被读取多次，这里的 read_cost 和
eval_cost 是访问多次 s2 表后累</p>
<p>加起来的值，大家主要关注里边儿的 prefix_cost
的值代表的是整个连接查询预计的成本，也就是单</p>
<p>次查询 s1 表和多次查询 s2 表后的成本的和.</p></li>
<li><p>read_cost</p>
<ul>
<li>IO 成本</li>
<li>检测 rows × (1 - filter) 条记录的 CPU 成本</li>
</ul></li>
<li><p>eval_cost</p>
<ul>
<li>检测rows × filter 条记录的成本</li>
</ul></li>
<li><p>prefix_cost</p>
<ul>
<li>单独查询s1表的成本</li>
</ul></li>
<li><p>data_read_per_join</p>
<ul>
<li>在此次查询中需要读取的数据量</li>
</ul></li>
</ul>
<h5 id="tree形式">3）TREE形式</h5>
<h5 id="可视化形式">4）可视化形式</h5>
<h4
id="分析优化器执行计划trace工具">5、分析优化器执行计划：trace工具</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET optimizer_trace=&quot;enabled=on&quot;,end_markers_in_json=on;</span><br><span class="line">SET optimizer_trace_max_mem_size=1000000;</span><br></pre></td></tr></table></figure>
<p>开启以后可以分析常见的许多SQL语句,通过如下语句进行查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from information_schema.optimizer_trace\G</span><br></pre></td></tr></table></figure>
<h4 id="mysql监控分析视图-sys-schema">6、MySQL监控分析视图-sys
schema</h4>
<p>​
关于MySQL的性能监控和问题诊断，我们一般都从performance_schema中去获取想要的数据，在MySQL5.7.7版本中新增sys
schema，它将prformance_schema和information_schema中的数据以更容易理解的方式总结归纳为”视图”，其目的就是为了降低查询performance_schema的复杂度，让DBA能够快速的定位问题。</p>
<p>​
下面看看这些库中都有哪些监控表和视图，掌握了这些，在我们开发和运维的过程中就起到了事半功倍的效果。</p>
<ul>
<li>索引相关</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1. 查询冗余索引</span><br><span class="line">select * from sys.schema_redundant_indexes;</span><br><span class="line">#2. 查询未使用过的索引</span><br><span class="line">select * from sys.schema_unused_indexes;</span><br><span class="line">#3. 查询索引的使用情况</span><br><span class="line">select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted</span><br><span class="line">from sys.schema_index_statistics where table_schema=&#x27;dbname&#x27; ;</span><br></pre></td></tr></table></figure>
<ul>
<li>表相关</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1. 查询表的访问量</span><br><span class="line">select table_schema,table_name,sum(io_read_requests+io_write_requests) as io from</span><br><span class="line">sys.schema_table_statistics group by table_schema,table_name order by io desc;</span><br><span class="line"># 2. 查询占用bufferpool较多的表</span><br><span class="line">select object_schema,object_name,allocated,data</span><br><span class="line">from sys.innodb_buffer_stats_by_table order by allocated limit 10;</span><br><span class="line"># 3. 查看表的全表扫描情况</span><br><span class="line">select * from sys.statements_with_full_table_scans where db=&#x27;dbname&#x27;;</span><br></pre></td></tr></table></figure>
<ul>
<li>语句相关</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1. 监控SQL执行的频率</span><br><span class="line">select db,exec_count,query from sys.statement_analysis</span><br><span class="line">order by exec_count desc;</span><br><span class="line">#2. 监控使用了排序的SQL</span><br><span class="line">select db,exec_count,first_seen,last_seen,query</span><br><span class="line">from sys.statements_with_sorting limit 1;</span><br><span class="line">#3. 监控使用了临时表或者磁盘临时表的SQL</span><br><span class="line">select db,exec_count,tmp_tables,tmp_disk_tables,query</span><br><span class="line">from sys.statement_analysis where tmp_tables&gt;0 or tmp_disk_tables &gt;0</span><br><span class="line">order by (tmp_tables+tmp_disk_tables) desc;</span><br></pre></td></tr></table></figure>
<ul>
<li>IO相关</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1. 查看消耗磁盘IO的文件</span><br><span class="line">select file,avg_read,avg_write,avg_read+avg_write as avg_io</span><br><span class="line">from sys.io_global_by_file_by_bytes order by avg_read limit 10;</span><br></pre></td></tr></table></figure>
<ul>
<li>Innodb相关</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1. 行锁阻塞情况</span><br><span class="line">select * from sys.innodb_lock_waits;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>数据库精简笔记</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap11 Mysql索引与创建原则</title>
    <url>/2022/10/27/5b0755a55834/</url>
    <content><![CDATA[<h3 id="一索引的创建与删除">一、索引的创建与删除</h3>
<ul>
<li>分类之<strong>全文索引</strong>：搜索引擎使用的一种关键技术。它能够利用【分词技术】等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。<strong>全文索引非常适合大型数据集，对于小的数据集，它的用处比较小。</strong>
<ul>
<li>使用参数FULLTEXT可以设置索引为全文索引。</li>
<li>在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。查询数据量较大的字符串类型的字段时，使用全文索引可以提高查询速度。例如，表student的字段information是TEXT类型，该字段包含了很多文字信息。在字段information上建立全文索引后，可以提高查询字段information的速度。</li>
</ul></li>
</ul>
<h4 id="创建删除索引">1、创建删除索引：</h4>
<h5 id="创建表时新增">1）创建表时新增</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE table_name [col_name data_type]</span><br><span class="line">[UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC | DESC]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>UNIQUE 、FULLTEXT 和SPATIAL
为可选参数，分别表示唯一索引、全文索引和空间索引；</p></li>
<li><p>INDEX 与KEY 为同义词，两者的作用相同，用来指定创建索引；</p></li>
<li><p>index_name
指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名；</p></li>
<li><p>col_name
为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；</p></li>
<li><p>length
为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；</p></li>
<li><p>ASC 或DESC 指定升序或者降序的索引值存</p></li>
<li><p>多列索引：</p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INDEX multi_idx(id,name,age)</span><br></pre></td></tr></table></figure>
<ul>
<li>全文索引：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `papers` (</span><br><span class="line">`id` int(10) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">`title` varchar(200) DEFAULT NULL,</span><br><span class="line">`content` text,</span><br><span class="line">PRIMARY KEY (`id`),</span><br><span class="line">FULLTEXT KEY `title` (`title`,`content`)</span><br><span class="line">) ENGINE=MyISAM DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>
<p>全文检索如何查询？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM papers WHERE content LIKE ‘%查询字符串%’; # 普通查询</span><br><span class="line">SELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’); # 全文检索，非常快</span><br></pre></td></tr></table></figure>
<h5 id="创建表后新增">2）创建表后新增</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name</span><br><span class="line">ON table_name (col_name[length],...) [ASC | DESC]</span><br></pre></td></tr></table></figure>
<h5 id="删除索引">3）删除索引：</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX index_name ON table_name;</span><br></pre></td></tr></table></figure>
<h3 id="二mysql8.0索引新特性">二、Mysql8.0索引新特性：</h3>
<h4 id="降序索引">1、降序索引：</h4>
<p>​ 即DESC关键字被支持，其在某种场景下意义重大，如下：</p>
<p>先创建索引如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE ts1(a int,b int,index idx_a_b(a ASC,b desc));</span><br></pre></td></tr></table></figure>
<p>​ 在执行如下语句时，执行计划中扫描数为799，而且提示使用了Using
filesort，这是MySQL中一种速度比较慢的外部排序，能避免是最好的。多数情况下，管理员可以通过优化索引来尽量避免出现Using
filesort，从而提高数据库执行速度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM ts1 ORDER BY a,b DESC LIMIT 5;</span><br></pre></td></tr></table></figure>
<p>​ 但是在执行如下语句时，就会快很多且不会使用Using filesort：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM ts1 ORDER BY a ASC,b DESC LIMIT 5;</span><br></pre></td></tr></table></figure>
<h4 id="隐藏索引">2、隐藏索引：</h4>
<p>​
只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引（即使使用force
index（强制使用索引），优化器也不会使用该索引），确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。</p>
<p>​ 这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除。</p>
<p>​
同时，如果你想验证某个索引删除之后的查询性能影响，就可以暂时先隐藏该索引。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX indexname</span><br><span class="line">ON tablename(propname[(length)]) INVISIBLE;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引</span><br><span class="line">ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引</span><br></pre></td></tr></table></figure>
<h3 id="三索引的设计原则">三、索引的设计原则</h3>
<h4 id="哪些情况适合创建索引">1、哪些情况适合创建索引？</h4>
<h5
id="字段的数值有唯一性的限制但是没有加唯一性约束的字段">1）字段的数值有唯一性的限制，但是没有加唯一性约束的字段</h5>
<h5 id="频繁作为where查询条件的字段">2）频繁作为WHERE查询条件的字段</h5>
<h5 id="经常group-by和order-by的列">3）经常GROUP BY和ORDER BY的列</h5>
<p>​
需要对分组或者排序的字段进行索引。如果待排序的列有多个，那么可以在这些列上建立联合索引。既有GROUP
BY 又有 ORDER BY，可以考虑建立联合索引，但联合索引要先写GROUP BY 再写
ORDER BY。</p>
<h5 id="updatedelete-的-where-条件列">4）UPDATE、DELETE 的 WHERE
条件列</h5>
<p>​
如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</p>
<h5 id="distinct-操作的字段需要创建索引">5）DISTINCT
操作的字段需要创建索引</h5>
<p>​
有时候我们需要对某个字段进行去重，使用DISTINCT，那么对这个字段创建索引，也会提升查询效率。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT(student_id) FROM `student_info`;</span><br></pre></td></tr></table></figure>
<h5
id="多表join连接操作时创建索引的注意事项">6）多表JOIN连接操作时，创建索引的注意事项:</h5>
<ul>
<li>连接的表数量不要超过3张</li>
<li>对WHERE条件创建索引</li>
<li><strong>对用于连接的字段创建索引</strong>，并且该字段在多张表中的类型必须一致。</li>
</ul>
<h5 id="使用列的类型小的创建索引">7）使用列的类型小的创建索引</h5>
<ul>
<li><p>类型大小指该类型表示的数据范围的大小。</p></li>
<li><p>如果要对某个列建立索引，尽量让这个列使用较小的数据类型。原因：</p>
<ul>
<li>数据类型越小，在查询时进行的比较操作越快</li>
<li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘I/0带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li>
</ul></li>
</ul>
<h5
id="创建字符串列的索引时注意事项">8）创建字符串列的索引时注意事项：</h5>
<p>​
假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的B+树中有这么两个问题：</p>
<ul>
<li>B+树索引中的记录需要把该列的完整字符串存储起来，更费时。而且字符串越长，在索引中占用的存储空间越大。</li>
<li>如果B+树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间。</li>
</ul>
<p>​
<strong>通过截取字段的前面一部分内容建立索引，这个就叫前缀索引。</strong></p>
<p>​
这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后<strong>根据前缀相同的记录的主键值回表查询完整的字符串值。</strong>既节约空间，又减少了字符串的比较时间，还大体能解决排序的问题。</p>
<ul>
<li><p><strong>关键问题</strong>：截取多少比较合适？</p></li>
<li><p>先看一下字段在全部数据中的选择度</p>
<ul>
<li>```mysql select count(distinct address) / count(<em>) from shop;
count(distinct left(列名, 索引长度))/count(</em>) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```mysql</span><br><span class="line">  select count(distinct left(address,10)) / count(*) as sub10, -- 截取前10个字符的选择度</span><br><span class="line">  count(distinct left(address,15)) / count(*) as sub11, -- 截取前15个字符的选择度</span><br><span class="line">  count(distinct left(address,20)) / count(*) as sub12, -- 截取前20个字符的选择度</span><br><span class="line">  count(distinct left(address,25)) / count(*) as sub13 -- 截取前25个字符的选择度</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h5 id="区分度高的列适合作为索引">9）区分度高的列适合作为索引：</h5>
<p>​
列的基数指的是某一列中不重复数据的个数，比方说某个列包含值2，5，8，2，5，8，2，5，8，虽然有9条记录，但该列的基数却是3。</p>
<p>​ 可以使用公式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(distinct a)/count(*) from t1 </span><br></pre></td></tr></table></figure>
<p>​ 计算区分度，越接近1越好，一般超过33%就算是比较高效的索引了。</p>
<h5
id="使用最频繁的列放到联合索引的左侧">10）使用最频繁的列放到联合索引的左侧</h5>
<h5
id="在多个字段都要创建索引时联合索引优于单值索引">11）在多个字段都要创建索引时，联合索引优于单值索引</h5>
<h4 id="索引数目的限制">2、索引数目的限制：</h4>
<ul>
<li><p>单张表不超过6个索引</p></li>
<li><p>索引占用磁盘空间、会影响insert，update的效率。同时，因为优化器在执行查询前，如果索引太多，会导致其生成执行计划的时间降低。</p></li>
</ul>
<h4 id="哪些情况不适合创建索引">3、哪些情况不适合创建索引？</h4>
<h5
id="在where中使用不到的字段不要设置索引">1）在where中使用不到的字段，不要设置索引</h5>
<h5
id="数据量小的表最好不要使用索引">2）数据量小的表最好不要使用索引</h5>
<h5
id="有大量重复数据的列上不要建立索引10">3）有大量重复数据的列上不要建立索引（10%）</h5>
<p>​ 要在 100 万行数据中查找其中的 50
万行（比如性别为男的数据），一旦创建了索引，你需要先访问 50
万次索引，然后再访问 50
万次数据表，这样加起来的开销比不使用索引可能还要大.</p>
<h5
id="避免对经常更新的表创建过多的索引">4）避免对经常更新的表创建过多的索引</h5>
<h5 id="不建议用无序的值作为索引">5）不建议用无序的值作为索引</h5>
<p>​
例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。</p>
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>数据库精简笔记</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap10 InnoDB数据存储结构分析</title>
    <url>/2022/10/25/df494e08f4d8/</url>
    <content><![CDATA[<h3 id="一数据库的存储结构页">一、数据库的存储结构：页</h3>
<h4
id="磁盘与内存交互的基本单位页">1、磁盘与内存交互的基本单位——页：</h4>
<ul>
<li><p>InnoDB将数据划分为若干个页，页的大小默认为16KB。</p></li>
<li><p><strong>将页作为磁盘和内存之间交互的基本单位。</strong>即，在数据库中，不论读多少行，都是将这些行所在的页进行加载。即I/O操作的最小单位就是页。</p></li>
<li><p>连续的页之间，不在物理结构上相连接，期间通过双向链表连接。每个数据页中的记录会按照主键的值从小到大的顺序组成一个单向链表，<strong>每个数据也都会为存储在它里面的记录生成一个页目录，</strong>这样可以在页目录中是用二分法定位到对应的槽，再遍历槽对应分组中的记录找到指定记录就行。</p></li>
<li><p>页的上层结构：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221023094039939.png" /></p>
<ul>
<li>区：一个区会分配64个连续的页</li>
<li>段：段是数据库中的分配单位。段中不要求区和区之间连续。比如说创建一张表时，会创建一个表段，创建一个索引时，会创建一个索引段。</li>
<li>表空间：逻辑容器，可以有1个或多个段。表空间从管理上可以划分为：系统表空间、用户表空间等。</li>
</ul></li>
</ul>
<h4 id="页的内部结构">2、页的内部结构：</h4>
<h5 id="数据页的存储空间被划分为7个部分">1)
数据页的存储空间被划分为7个部分：</h5>
<ul>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221023094541084.png" /></li>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221023094558222.png" /></li>
</ul>
<h5 id="file-header-和-file-trailer-文件头部和文件尾部">2) File Header
和 File Trailer 文件头部和文件尾部：</h5>
<ul>
<li>File Header 描述各种页的通用信息——页的编号，上一页下一页等
<ul>
<li>FIL_PAGE_OFFSET 页的单独页号</li>
<li>FIL_PAGE_TYPE 页的类型，比如索引页、日志页等等</li>
<li>FIL_PAGE_PREV（4字节）和FIL_PAGE_NEXT（4字节）本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，保证这些页之间不需要是物理上的连续，而是逻辑上的连续。</li>
<li>FIL_PAGE_SPACE_OR_CHKSUM（4字节）当前页面的校验和，<strong>文件头部和尾部都有这个校验和</strong>
<ul>
<li>作用 :
InnoDB存储引擎以页为单位把数据加载到内存中处理，<strong>如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候断电了，造成了该页传输的不完整。</strong>为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），<strong>这时可以通过文件尾的校验和（checksum
值）与文件头的校验和做比对，如果两个值不相等则证明页的传输有问题，需要重新进行传输，</strong>否则认为页的传输已经完成。</li>
<li>具体操作方法：每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为File
Header在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在File
Header中的校验和就代表着已经修改过的页，而在File
Trailer中的校验和代表着原先的页，二者不同则意味着同步中间出了错。</li>
</ul></li>
<li>FIL_PAGE_LSN 页面被最后修改时对应的日志序列位置（Log Sequence
Number）</li>
</ul></li>
<li>文件尾部：共8字节
<ul>
<li>前4个字节代表页的校验和：这个部分是和File Header中的校验和相对应的。
后4个字节代表页面被最后修改时对应的日志序列位置（LSN）：这个部分也是为了校验页的完整性的，如果首部和尾部的LSN值校验不成功的话，就说明同步过程出现了问题</li>
</ul></li>
</ul>
<h5 id="free-space-user-records-infimum-supremum">3) Free Space &amp;
User Records &amp; Infimum Supremum</h5>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-23%2016.31.02.png" /></p>
<ul>
<li><p>每插入一条记录，从Free Space部分申请一个记录大小的空间分给User
Records空间</p></li>
<li><p>我们自己存储的记录会按照指定的行格式存储到User
Records部分</p></li>
<li><p>记录按照指定的行格式一条一条摆在User
Records部分，相互之间形成单链表。
用户记录里的一条条数据如何记录和形成呢？详见InnoDB行格式中的记录头信息。</p></li>
<li><p>Infimum Supremum 最小最大记录：</p>
<ul>
<li><p>对于一条完整的记录来说，比较记录的大小就是比较主键的大小。</p></li>
<li><p>InnoDB规定的最小记录与最大记录这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-23%2016.40.36.png" /></p></li>
<li><p>这两条记录不是我们自己定义的记录，所以它们并不存放在页的User
Records部分，他们被单独放在一个称为Infimum +
Supremum的部分，如图所示：</p></li>
</ul></li>
</ul>
<h5 id="page-directory-page-header-页目录和页头">4) Page Directory &amp;
Page Header 页目录和页头</h5>
<ul>
<li><p>1、为什么需要页目录？</p>
<ul>
<li>在页中，记录是以单向链表的形式进行存储的。查找性能差，因此在页结构中专门设计了页目录这个模块，专门给记录做一个目录，通过二分查找法的方式进行检索，提升效率。</li>
<li>具体做法：将所有的记录分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录。
<ul>
<li>第 1 组，也就是最小记录所在的分组只有 1 个记录；
最后一组，就是最大记录所在的分组，会有 1-8 条记录； 其余的组记录数量在
4-8 条之间。</li>
<li>在每个组中<strong>最后一条记录的头信息中会存储该组一共有多少条记录</strong>，作为
n_owned 字段。</li>
<li>页目录用来存储<strong>每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，</strong>每组的地址偏移量也被称之为槽（slot），每个槽相当于指针指向了不同组的最后一个记录。</li>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-23%2016.50.25.png" /></li>
</ul></li>
</ul></li>
<li><p>2、页目录结构下如何快速查找记录？</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-23%2016.53.45.png" /></p></li>
</ul>
<p>Page Header 页头</p>
<ul>
<li><p>为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫Page
Header的部分，这个部分占用固定的56个字节，专门存储各种状态信息。</p></li>
<li><p>PAGE_DIRECTION 记录插入方向</p></li>
<li><p>PAGE_N_DIRECTION</p>
<ul>
<li>假设连续几次插入新记录的方向都是一致的，InnoDB会把沿着同一个方向插入记录的条数记下来，这个条数就用PAGE_N_DIRECTION这个状态表示。当然，如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计。</li>
</ul></li>
</ul>
<h4
id="从数据页的角度看b树如何查询">3、从数据页的角度看B+树如何查询：</h4>
<h5 id="如何查询">1）如何查询？</h5>
<p>​
先从B+树的根开始，逐层检索。然后将数据页加载到内存中，页目录中的槽使用二分查找的方式先找到一个粗略的记录分组，然后再在分组中通过链表遍历的方式查找记录。</p>
<h5
id="普通索引和唯一索引在查询中的区别">2）普通索引和唯一索引在查询中的区别？</h5>
<p>​
唯一索引找到了关键字就可以停止检索。而普通索引找到关键字以后，还需要在内存中多看下X条记录。</p>
<h4 id="innodb行格式compact行格式">4、InnoDB行格式：COMPACT行格式</h4>
<p>一条记录的数据可以分为记录的额外信息和真实数据</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-23%2016.34.37.png" /></p>
<h5 id="变长字段长度列表">1）变长字段长度列表</h5>
<p>​
变长字段中存储多少字节的数据不是固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。</p>
<p>​
在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表。
注意：这里面存储的变长长度和字段顺序是反过来的。比如两个varchar字段在表结构的顺序是a(10)，b(15)。那么在变长字段长度列表中存储的长度顺序就是15，10，是反过来的。</p>
<h5 id="null值列表">2）NULL值列表</h5>
<p>​
Compact行格式会把可以为NULL的列统一管理起来，存在一个标记为NULL值列表中。如果表中没有允许存储
NULL 的列，则 NULL值列表也不存在了。</p>
<ul>
<li>为什么定义NULL值列表？
<ul>
<li>之所以要存储NULL是因为数据都是需要对齐的，如果没有标注出来NULL值的位置，就有可能在查询数据的时候出现混乱。如果使用一个特定的符号放到相应的数据位表示空置的话，虽然能达到效果，但是这样很浪费空间，所以直接就在行数据得头部开辟出一块空间专门用来记录该行数据哪些是非空数据，哪些是空数据，</li>
</ul></li>
<li>格式如下：
<ul>
<li>二进制位的值为1时，代表该列的值为NULL。</li>
<li>二进制位的值为0时，代表该列的值不为NULL。</li>
</ul></li>
<li>例如：字段 a、b、c，其中a是主键，在某一行中存储的数依次是
a=1、b=null、c=2。那么Compact行格式中的NULL值列表中存储：01。第一个0表示c不为null，第二个1表示b是null。这里之所以没有a是因为数据库会自动跳过主键，因为主键肯定是非NULL且唯一的，在NULL值列表的数据中就会自动跳过主键。</li>
</ul>
<h5 id="记录头信息总共就5个字节">3）记录头信息（总共就5个字节）</h5>
<ul>
<li><p>delete_mask</p>
<ul>
<li>这个属性标记着当前记录是否被删除，占用1个二进制位。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后其他的记录在磁盘上需要重新排列，导致性能消耗。所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的垃圾链表。<br />
</li>
</ul></li>
<li><p>min_rec_mask</p>
<ul>
<li>B+树的每层非叶子节点中的最小记录都会添加该标记，min_rec_mask值为1。</li>
</ul></li>
<li><p>record_type</p>
<ul>
<li>这个属性表示当前记录的类型，一共有4种类型的记录：
<ul>
<li>0：表示普通记录<br />
</li>
<li>1：表示B+树非叶节点记录</li>
<li>2：表示最小记录<br />
</li>
<li>3：表示最大记录</li>
</ul></li>
</ul></li>
<li><p>heap_no</p>
<ul>
<li>这个属性表示当前记录在本页中的位置。比如说2，3，4，5等</li>
<li><strong>MySQL会自动给每个页里加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为伪记录或者虚拟记录。</strong>这两个伪记录一个代表最小记录，一个代表最大记录。最小记录和最大记录的heap_no值分别是0和1，也就是说它们的位置最靠前。<br />
</li>
</ul></li>
<li><p>n_owned</p>
<ul>
<li><strong>页目录</strong>中每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为
n_owned 字段。详情见page directory。</li>
</ul></li>
<li><p>next_record</p>
<ul>
<li>它表示从当前记录的真实数据到下一条记录的真实数据的<strong>地址偏移量。</strong></li>
<li>比如：第一条记录的next_record值为32，意味着从第一条记录的真实数据的地址处向后找32个字节便是下一条记录的真实数据。注意，下一条记录指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。</li>
<li>规定Infimum记录（也就是最小记录）的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是
Supremum记录（也就是最大记录）。</li>
</ul></li>
<li><p><strong>不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的。
</strong></p></li>
<li><p>主键值为2的记录被删掉了以后，存储空间不会回收，如果我们再次把这条记录插入到表中，会发生什么事呢？——
直接复用了原来被删除记录的存储空间。</p></li>
<li><p><strong>说明：当数据页中存在多条被删除掉的记录时，这些记录的next_record属性将会把这些被删除掉的记录组成一个垃圾链表，以备之后重用这部分存储空间。
</strong></p></li>
</ul>
<h5 id="记录的真实数据">4）记录的真实数据</h5>
<p>​ 除了我们自己定义的列数据以外，还会有三个隐藏列。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221023222958606.png" /></p>
<p>​
实际上这几个列的真正名称其实是：DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR</p>
<ul>
<li>一个表没有手动定义主键，则会选取一个Unique键作为主键，如果连Unique键都没有定义的话，则会为表默认添加一个名为row_id的隐藏列作为主键。所以row_id是在没有自定义主键以及Unique键的情况下才会存在的。</li>
<li>事务ID和回滚指针涉及到事务相关的内容，具体见事务</li>
</ul>
<h4 id="dynamic和compressed行格式">5、Dynamic和Compressed行格式</h4>
<h5 id="什么是行溢出">1）什么是行溢出？</h5>
<p>​ InnoDB存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。
很多DBA喜欢MySQL数据库提供的VARCHAR(M)类型，认为可以存放65535字节。这是真的吗？如果我们使用
ascii字符集的话，一个字符就代表一个字节，我们看看VARCHAR(65535)是否可用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE varchar_size_demo( c VARCHAR(65535) ) CHARSET=ascii ROW_FORMAT=Compact;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have to change some columns to TEXT or BLOBs </span><br></pre></td></tr></table></figure>
<p>​
报错信息表达的意思是：MySQL对一条记录占用的最大存储空间是有限制的，除BLOB或者TEXT类型的列之外，
其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节。
这个65535个字节除了列本身的数据之外，还包括一些其他的数据，</p>
<p>​
<strong>以Compact行格式为例，比如说我们为了存储一个VARCHAR(M)类型的列，除了真实数据占有空间以外，还需要记录的额外信息。
如果该VARCHAR类型的列没有NOT
NULL属性，那最多只能存储65532个字节的数据，因为变长字段的长度占用
2个字节，NULL值标识需要占用1个字节。</strong></p>
<ul>
<li><p>通过上面的案例，我们可以知道一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65533个字节，<strong>这样就可能出现一个页存放不了一条记录，这种现象称为行溢出。</strong></p></li>
<li><p>在Compact和Reduntant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中进行分页存储，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。这称为页的扩展，：</p></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221023224141758.png" /></p>
<h5 id="dynamic和compressed如何处理行溢出">2)
Dynamic和Compressed如何处理行溢出？</h5>
<p>​ 在MySQL
8.0中，默认行格式就是Dynamic。Dynamic、Compressed行格式和Compact行格式挺像，只不过在处理行溢出数据时有分歧：</p>
<ul>
<li><p>Compressed和Dynamic两种记录格式对于存放在BLOB中的数据采用了完全的行溢出的方式。</p></li>
<li><p>如图，在数据页中只存放20个字节的指针（溢出页的地址），实际的数据都存放在Off
Page（溢出页）中。Compact和Redundant两种格式会在记录的真实数据处存储一部分数据（存放768个前缀字节）。<strong>Compressed行记录格式的另一个功能就是，存储在其中的行数据会以zlib的算法进行压缩，因此对于BLOB、TEXT、VARCHAR这类大长度类型的数据能够进行非常有效的存储。</strong></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221023224238085.png" /></p></li>
</ul>
<h4 id="区段与碎片区与表空间结构">5、区、段与碎片区与表空间结构：</h4>
<h5 id="为什么要有区">1）为什么要有区？</h5>
<p>​
如果以页为单位来分配存储空间的话，双向链表相邻的两个页之间的物理位置可能离得比较远。当进行范围查询时，我们一般只需要定位到最左侧和最右侧的记录，然后沿着双向链表一直扫描即可。那么如果相邻的两个页之间的物理位置可能离得比较远的话，其实是在做<strong>随机IO</strong>，对于磁盘而言读写速度是很慢的。</p>
<p>​
所以，引入区的概念，使得1个区中含物理位置上连续的64个页，这样就会把上述过程变成<strong>顺序IO</strong>，减少了磁盘寻道和半圈旋转时间。</p>
<p>​
在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，<strong>而是按照区为单位分配，</strong>甚至在表中的数据特别多的时候，可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费（数据不足以填充满整个区），<strong>但是从性能角度看，可以消除很多的随机I/0</strong>，功大于过！</p>
<h5 id="为什么要有段">2）为什么要有段？</h5>
<p>​
对于范围查询，其实是对B+树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。</p>
<p>​
所以InnoDB对B+树的叶子节点和非叶子节点进行了区别对待，<strong>也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。</strong></p>
<p>​
存放叶子节点的区的集合就算是一个段（segment），存放非叶子节点的区的集合也算是一个段。<strong>也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。</strong></p>
<p>​
<strong>段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。</strong></p>
<h5 id="为什么要有碎片区">3）为什么要有碎片区？</h5>
<p>​
默认情况下，一个使用InnoDB存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用1M（64*16Kb=1024Kb）存储空间，所以默认情况下一个只存了几条记录的小表也需要2M的存储空间么？以后每次添加一个索引都要多申请2M的存储空间么？这对于存储记录比较少的表简直是天大的浪费。</p>
<p>​
这个问题的症结在于到现在为止我们介绍的区都是非常纯粹的，<strong>也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。</strong></p>
<p>​
为了考虑以完整的区为单位分配给某个段对于数据量较小的表太浪费存储空间的这种情况，InnoDB提出了一个<strong>碎片（fragment）区的概念</strong>。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是<strong>碎片区中的页可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。</strong></p>
<p>​ 碎片区直属于表空间，并不属于任何一个段。</p>
<h5 id="为某个段分配存储空间的策略">4）为某个段分配存储空间的策略：</h5>
<ul>
<li>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。</li>
<li>当某个段已经占用了32个碎片区页面之后，就会申请以完整的区为单位来分配存储间。</li>
</ul>
<p>​
所以现在段不能仅定义为是某些区的集合，更精确的应该是某些零散的页面以及一些完整的区的集合。</p>
<h5 id="区的分类">5）区的分类</h5>
<ul>
<li><p>碎片区</p>
<ul>
<li><p>空闲的区</p></li>
<li><p>有剩余空间的碎片区</p></li>
<li><p>没有剩余空间的碎片区</p></li>
</ul></li>
<li><p>附属于某个段的区</p></li>
</ul>
<h5 id="表空间">6）表空间：</h5>
<p>​
表空间可以看做是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。表空间是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。</p>
<ul>
<li>独立表空间：
<ul>
<li>每张表都有一个独立的表空间，即数据和索引信息都会保存在自己的表空间中。空间可以回收</li>
</ul></li>
<li>系统表空间：
<ul>
<li>整个MySQL进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面，这部分是独立表空间中没有的。</li>
<li>InnoDB数据字典：（内部系统表）
<ul>
<li>每当我们向一个表中插入一条记录的时候，MySOL校验过程如下
<ul>
<li>先要校验一下插入语句对应的表存不存在，插入的列和表中的列是否符合，</li>
<li>如果语法没有问题的话，还需要知道该表的聚簇索引和所有二级索引对应的根页面是哪个表空间的哪个页面，然后把记录插入对应索引的B+树中。</li>
<li>所以说，MySQL除了保存着我们插入的用户数据之外，还需要保存许多额外的信息（元数据）</li>
</ul></li>
<li>注意：用户是不能直接访问InnoDB的这些内部系统表，除非你直接去解析系统表空间对应文件系统上的文件。</li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>数据库精简笔记</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap8 Mysql逻辑架构和存储引擎</title>
    <url>/2022/10/23/9dff215cdc98/</url>
    <content><![CDATA[<h3 id="一逻辑架构">一、逻辑架构：</h3>
<p>​ 使用经典的C/S架构，服务端程序使用的是
mysqld服务，服务端大致分为三个步骤：</p>
<ul>
<li>连接管理（连接池）</li>
<li>解析和优化（SQL接口、解析器、优化器）</li>
<li>存储引擎（存储引擎和文件系统、日志文件）</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017154005406.png" /></p>
<h4 id="connectors">1、Connectors:</h4>
<p>​
MySQL是一个网络i程序，本质上就是在TCP连接上，通过MySql协议跟Mysql服务器进行数据的交互</p>
<h4 id="连接管理">2、连接管理：</h4>
<p>​
用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，<strong>都将依赖于此时读到的权限。</strong></p>
<p>​
<strong>TCP连接池</strong>：用于限制连接数，可以采用长连接模式来复用TCP连接，解决上述问题</p>
<p>​
<strong>线程池</strong>：TCP连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017161445894.png" style="zoom:50%;" /></p>
<h4 id="服务层">3、服务层：</h4>
<ul>
<li><p>SQL接口：</p>
<ul>
<li>接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT ...
FROM就是调用SQL Interface</li>
</ul></li>
<li><p>Parser解析器：</p>
<ul>
<li>在解析器中对 SQL
语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。</li>
<li><strong>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建语法树，并根据数据字典丰富查询语法树，会验证该客户端是否具有执行该查询的权限</strong></li>
</ul></li>
<li><p>Optimizer优化器：</p>
<ul>
<li><p>SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL
语句的执行路径，生成一个执行计划。这个执行计划表明应该使用哪些索引进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。</p></li>
<li><p>它使用“ 选取-投影-连接”策略进行查询</p></li>
<li><pre><code>  SELECT id,name FROM student WHERE gender = &#39;女&#39;;</code></pre></li>
<li><p>这个SELECT查询先根据WHERE语句进行选取，而不是将表全部查询出来以后再进行gender过滤。
这个SELECT查询先根据id和name进行属性投影，而不是将属性全部取出以后再进行过滤，将这两个查询条件连接起来生成最终查询结果。</p></li>
</ul></li>
<li><p>Caches &amp; Buffers： 查询缓存组件</p>
<ul>
<li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等
。这个查询缓存可以在不同客户端之间共享</li>
</ul></li>
</ul>
<h4 id="引擎层">4、引擎层</h4>
<p>​ 插件式存储引擎层（ Storage
Engines），真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作</p>
<h4 id="存储层">5、存储层：</h4>
<p>​
所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在文件系统上，以文件的方式存在的，并完成与存储引擎的交互</p>
<h3 id="二sql执行流程">二、SQL执行流程：</h3>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017163209630.png" /></p>
<h4 id="查询缓存">1、查询缓存：</h4>
<p>​ 因为查询缓存往往效率不高，所以在 MySQL8.0
之后就抛弃了这个功能。三大场景原因如下：</p>
<ul>
<li>在MySQL
中的查询缓存，不是缓存查询计划，而是查询对应的结果。这就意味着查询匹配的鲁棒性大大降低，<strong>只有相同的查询操作才会命中查询缓存。</strong>两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。因此
MySQL 的查询缓存命中率不高。</li>
<li>如果<strong>查询请求中包含某些系统函数、用户自定义变量和函数</strong>、一些系统表，如
mysql 、 information_schema、 performance_schema
数据库中的表，那这个请求就不会被缓存。</li>
<li>此外，既然是缓存，那就有它缓存失效的时候。<strong>MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，</strong>如对该表使用了INSERT
、 UPDATE 、DELETE 、TRUNCATE TABLE 、ALTER TABLE 、DROP TABLE 或 DROP
DATABASE
语句，那<strong>使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！</strong>对于更新压力大的数据库来说，查询缓存的命中率会非常低。</li>
</ul>
<h4 id="解析器">2、解析器：</h4>
<ul>
<li><p>词法分析</p>
<ul>
<li>MySQL
需要识别出SQL语句里面的字符串分别是什么，代表什么。是代表关键字还是表名</li>
</ul></li>
<li><p>语法分析</p>
<ul>
<li>根据词法分析的结果，语法分析器（比如：Bison）会根据语法规则，判断你输
入的这个 SQL 语句是否满足 MySQL 语法。</li>
</ul></li>
<li><p>如果SQL语句正确，会生成一个语法树：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017165049678.png" /></p></li>
</ul>
<h4 id="优化器">3、优化器：</h4>
<p>​ 在优化器中会确定 SQL
语句的执行路径，优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序，还有表达式简化、子查询转为连接、外连接转为内连接等。</p>
<p>​
在查询优化器中，可以分为<strong>逻辑查询优化阶段</strong>和<strong>物理查询优化阶段</strong>。</p>
<ul>
<li>逻辑查询优化就是通过改变SQL
语句的内容来使得SQL查询更高效，同时为物理查询优化提供更多的候选执行计划。通常采用的方式是对SQL语句进行等价变换，对查询进行重写，而查询重写的数学基础就是关系代数。<strong>对条件表达式进行等价谓词重写、条件简化，对视图进行重写，对子查询进行优化，对连接语义进行了外连接消除、嵌套连接消除等</strong></li>
<li>物理查询优化是基于关系代数进行的查询重写，而关系代数的每一步都对应着物理计算，这些物理计算往往存在多种算法，因此需要计算各种物理路径的代价，从中选择代价最小的作为执行计划。在这个阶段里，对于单表和多表连接的操作，需要高效地使用索引，提升查询效率。</li>
</ul>
<h4 id="执行器">4、执行器：</h4>
<p>​
在执行之前需要判断该用户是否具备权限。如果没有，就会返回权限错误。如果具备权限，就执行
SQL查询并返回结果。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017165434638.png" /></p>
<h4 id="语法顺序">5、语法顺序：</h4>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017170108824.png" /></p>
<h3 id="三数据库缓冲池">三、数据库缓冲池：</h3>
<p>​
InnoDB存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘I/0需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS会申请占用内存来作为数据缓冲池，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的Buffer
Poo1之后才可以访问。</p>
<p>​ <strong>目的</strong>：减少与磁盘直接进行I/O的时间</p>
<h4 id="缓冲池">1、缓冲池：</h4>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017171714267.png" /></p>
<p>​
缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟。所以InnoDB存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中，<strong>也就是说即使我们只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中。</strong>将整个页加载到内存中后就可以进行读写访问了，<strong>在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其缓存起来，这样将来有请求再次访问该页面时，就可以省去磁盘IO的开销了。</strong></p>
<p><strong>缓存原则：</strong></p>
<p>​ 优先对使用频次高的数据进行加载</p>
<p><strong>缓冲池的预读特性：</strong></p>
<p>​
缓冲池的作用就是提升I/0效率，而我们进行读取数据的时候存在一个“局部性原理”，也就是说我们使用了一些数据，大概率还会使用它周围的一些数据，因此采用“预读”的机制提前加载，可以减少未来可能的磁盘I/O操作。</p>
<h4 id="缓冲池如何读取数据">2、缓冲池如何读取数据：</h4>
<p>​
缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017172013707.png" /></p>
<p>​ 如果我们执行 SQL
语句的时候更新了缓存池中的数据，那么这些数据会马上同步到磁盘上吗？</p>
<p>​
实际上，当我们对数据库中的记录进行修改的时候，<strong>首先会修改缓冲池中页里面的记录信息，然后数据库会以一定的频率刷新到磁盘上。</strong></p>
<p>​
注意并不是每次发生更新操作，都会立刻进行磁盘回写。缓冲池会采用一种叫做checkpoint的机制将数据回写到磁盘上，这样做的好处就是提升了数据库的整体性能。比如，当缓冲池不够用时，需要释放掉一些不常用的页，此时就可以强行采用checkpoint的方式，<strong>将不常用的脏页回写到磁盘上，然后再从缓冲池中将这些页释放掉。这里脏页（dirty
page）指的是缓冲池中被修改过的页，与磁盘上的数据页不一致。</strong></p>
<h4 id="多个buffer-pool实例">3、多个Buffer Pool实例：</h4>
<p>​ Buffer
Pool本质是InnoDB向操作系统申请的一块连续的内存空间，在多线程环境下，访问Buffer
Pool中的数据都需要加锁处理。<strong>在Buffer
Pool特别大而且多线程并发访问特别高的情况下，单一的Buffer
Pool可能会影响请求的处理速度。</strong>所以在Buffer
Pool特别大的时候，我们可以把它们拆分成若干个小的Buffer
Pool，<strong>每个Buffer
Pool都称为一个实例，它们都是独立的，独立的去申请内存空间，独立的管理各种链表。所以在多线程并发访问时并不会相互影响，从而提高并发处理能力。</strong></p>
<h4 id="一些数据一致性问题">4、一些数据一致性问题</h4>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017172737298.png"
alt="image-20221017172737298" />
<figcaption aria-hidden="true">image-20221017172737298</figcaption>
</figure>
<p>​ 假设我们修改Buffer
Pool中的数据成功，但是还没来得及将数据刷入磁盘MySQL就挂了怎么办？按照上图的逻辑，此时更新之后的数据只存在于Buffer
Pool中，如果此时MySQL宕机了，这部分数据将会永久地丢失；怎么办呢？</p>
<p>​ 使用Redo Log和Undo Log来解决</p>
<h3 id="四存储引擎">四、存储引擎：</h3>
<h4
id="innodb引擎具备外键支持功能的事务存储引擎">1、InnoDB引擎：具备外键支持功能的事务存储引擎</h4>
<ul>
<li>默认事务型引擎，设计用于处理大量的短期事务，确保事务的完整提交和回滚</li>
<li>其为处理巨大数据量的最大性能设计</li>
<li>InnoDB写的处理效率会差一些，其会占用更多的磁盘空间来保存数据和索引</li>
<li>MyISAM只缓存索引，不缓存真实数据。InnoDB不仅缓存索引，还缓存真实数据，对内存要求较高，内存大小对性能有决定性的影响。</li>
</ul>
<h4
id="myisam引擎主要的非事务处理存储引擎">2、MyISAM引擎：主要的非事务处理存储引擎</h4>
<ul>
<li>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM
不支持事务、行级锁、外键，有一个毫无疑问的缺陷就是崩溃后无法安全恢复。</li>
<li>优势是访问的速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应用</li>
<li>应用场景：只读应用或者以读为主的业务</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221018172423185.png" /></p>
<h4 id="archive引擎用于数据归档">3、Archive引擎：用于数据归档</h4>
<h4
id="csv引擎可以快速便捷和外界进行数据交换">4、CSV引擎：可以快速便捷和外界进行数据交换</h4>
<h4 id="memory引擎置于内存的表">5、Memory引擎：置于内存的表</h4>
<p>​ Memory采用的逻辑介质是内存，
响应速度很快，但是当mysqld守护进程崩溃的时候数据会丢失。如下应用场景：</p>
<ol type="1">
<li>目标数据比较小，而且非常频繁的进行访问，在内存中存放数据，如果太大的数据会造成内存溢出。</li>
<li>如果数据是临时的，而且必须立即可用得到，那么就可以放在内存中。</li>
<li>存储在Memory表中的数据如果突然间丢失的话也没有太大的关系。</li>
</ol>
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>数据库精简笔记</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap9 Mysql索引优缺点与底层原理</title>
    <url>/2022/10/23/abee3bd85d4a/</url>
    <content><![CDATA[<h3 id="一为什么使用索引优缺点">一、为什么使用索引&amp;优缺点：</h3>
<p>​
避免全表扫描，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据。</p>
<p>​
如上图所示，数据库没有索引的情况下，数据分布在硬盘不同的位置上面，<strong>读取数据时，摆臂需要前后摆动查找数据，这样操作非常消耗时间。</strong></p>
<p>​
索引是一种数据结构，每个节点缓存的是一个Key-Value结构，Key是列的值，Value是该Key所在行对应的指针（文件位置）。</p>
<h4 id="优点">优点：</h4>
<ul>
<li>降低数据库的IO成本，提高数据检索的效率</li>
<li>加速表和表之间的连接。对于有依赖关系的子表和父表联合查询时，提高速度</li>
<li>显著减少查询中分组和排序的时间，降低CPU消耗</li>
</ul>
<h4 id="缺点">缺点：</h4>
<ul>
<li>创建和维护需要耗费时间</li>
<li>索引需要占据磁盘空间。</li>
<li>索引提高查询速度的同时，会降低更新表的速度。</li>
</ul>
<h3 id="二没有索引时的查找">二、没有索引时的查找：</h3>
<h4 id="case1-在单页中的查找">Case1: 在单页中的查找</h4>
<p>​ 如果数据较少，则所有记录都可以被存放到一个页里面</p>
<ul>
<li>以主键为搜索条件：可以以O（logN)复杂度查询到</li>
<li>以其他键为搜索条件：只能遍历.从最小记录开始以此遍历单链表中的每条记录。</li>
</ul>
<h4 id="case2在多页中的查找">Case2：在多页中的查找</h4>
<p>​ 如果记录非常多，需要很多数据页来存储这些记录，主要步骤分为：</p>
<ul>
<li>定位到记录所在的页</li>
<li>从所在的页内查找相应的记录</li>
</ul>
<p>​
在没有索引的情况下，由于不能快速定位到记录所在的页，只能从第一个页沿着双向链表一直往下找。在每个页中进行匹配。因为要遍历所有的数据页(以及加载)，所以非常耗时.</p>
<h3 id="三索引的设计">三、索引的设计:</h3>
<p>首先，简化假设某一条记录在磁盘上的记录形式如下：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221021092747727.png" /></p>
<p>那</p>
<p>1么，将一些记录放到页中的示意图就是如下所示：一个数据页的默认大小为16KB，其中会存有一定数量的记录。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221021105655165.png" /></p>
<p>​
我们现在的问题就是：想要快速的定位到需要查找的记录在哪些数据页中。我们可以采用B+树的形式进行架构，如下图所示：最底层的数据页存放的是普通的记录，record_type=0，页与页直接以双向链表的形式链接。再上层的数据页中存储的是普通记录的目录项记录，它们的record_type=1，再往上走就是层级更高的目录项，至此构成一颗B+树。需要值得注意的是，相邻的页之间页编号不一定连续，是通过指针指向链接的。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221021105859291.png" /></p>
<p>​
我们可以利用B+树定位到某条记录在哪个数据页的形式，可以大大节省内存和硬盘的IO次数，定位到具体的数据页以后，在每个页面内也有页目录，可以通过二分法来实现快速的定位记录。</p>
<h3 id="四常见索引的概念">四、常见索引的概念:</h3>
<h4 id="聚簇索引">1、聚簇索引：</h4>
<p>​
是一种数据存储方式，所有的用户记录都存储在了叶子节点，即<strong>数据即索引</strong>，<strong>索引即数据</strong>。</p>
<h5 id="特点">特点：</h5>
<ul>
<li>使用记录本身的 主键值的大小 进行记录和页的排序
<ul>
<li>页内的记录——按照主键的大小顺序排成单向链表。</li>
<li>各个存放用户记录的页——根据主键大小顺序排成一个双向链表</li>
<li>存放目录项记录的页——分为不同的层次，同一层次中的页之间按逐渐大小顺序排成双向链表</li>
</ul></li>
<li>B+树的叶子节点存储的是完整的用户记录</li>
<li>这种索引不需要我们在mysql中显式创建，InnoDB会自动创建聚簇索引。</li>
</ul>
<h5 id="优点-1">优点：</h5>
<ul>
<li>访问速度更快，对于主键的排序查找和范围查找非常快</li>
<li>查询显示一定范围数据的时候，由于数据都紧密相连，数据库不用从多个数据块中提取数据，节省了大量的io操作。</li>
</ul>
<h5 id="缺点-1">缺点：</h5>
<ul>
<li>插入速度严重依赖于插入顺序</li>
<li>更新主键代价很高，所以一般定义主键不可更新</li>
<li>二级索引访问需要两次查找</li>
</ul>
<h5 id="限制">限制：</h5>
<ul>
<li>仅有InnoDB数据引擎支持，MyISAM不支持聚簇索引</li>
<li>每个Mysql的表只能有一个聚簇索引，一般情况下是表的主键</li>
</ul>
<h4
id="二级索引辅助索引非聚簇索引">2、二级索引（辅助索引、非聚簇索引）</h4>
<p>​
如果想以非主键进行查找怎么办呢？多建几颗B+树即可。使用该列的大小作为数据页、页中记录的排序规则。对于这些B+树中，其叶子节点中并不存储完整的用户记录，而是仅存储<strong>该列
+ 主键的值</strong></p>
<h5 id="特点-1">特点：</h5>
<ul>
<li>使用记录本身的 该列（建B+树索引的列）值的大小 进行记录和页的排序
<ul>
<li>页内的记录——按照该列的大小顺序排成单向链表。</li>
<li>各个存放用户记录的页——根据该列大小顺序排成一个双向链表</li>
<li>存放目录项记录的页——分为不同的层次，同一层次中的页之间按逐渐大小顺序排成双向链表</li>
</ul></li>
<li>B+树的叶子节点存储的是 <strong>该列的值 + 主键的值</strong></li>
<li>这种索引需要我们在mysql中显式创建。</li>
<li><strong>在以该列为条件搜索的时候，需要进行回表操作</strong>，就是说先查找到记录的主键的值，再利用主键的值去聚簇索引中查找整条记录的值。</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221021212458365.png" /></p>
<h4 id="联合索引">3、联合索引：</h4>
<p>​
同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照
c2和c3列 的大小进行排序，这个包含两层含义：</p>
<ul>
<li><p>先把各个记录和页按照c2列进行排序。</p></li>
<li><p>在记录的c2列相同的情况下，采用c3列进行排序</p></li>
<li><p>以c2和c3列的大小为排序规则建立的B+树称为 联合索引
，<strong>本质上也是一个二级索引。</strong>它的意思与分别为c2和c3列分别建立索引的表述是不同的，主要表现为：</p>
<ul>
<li>建立 联合索引 只会建立如上图一样的1棵B+树。</li>
</ul></li>
</ul>
<h4 id="innodb的b树索引的注意事项">4、InnoDB的B+树索引的注意事项：</h4>
<ul>
<li><strong>根页面位置不变</strong>，实际上B+树的形成过程如下：
<ul>
<li>每当为某个表创建一个B+树索引的时候，<strong>都会为这个索引创建一个根节点页面。</strong></li>
<li>最开始表中没有数据的时候，每个B+树索引对应的根节点中既没有用户记录，也没有目录项记录。</li>
</ul></li>
<li>非叶节点中目录项记录的唯一性：即如果建立的非聚簇索引的那一列值不唯一怎么办？容易导致非叶节点的目录项不唯一。
<ul>
<li>为了让新插入记录能找到自己在哪个页里，<strong>我们需要保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的。</strong>所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：
<ul>
<li>索引列的值</li>
<li>主键值</li>
<li>页号</li>
</ul></li>
</ul></li>
</ul>
<figure>
<img
src="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221021223514710.png"
alt="蓝色即为主键值，橙色为建立索引列的值" />
<figcaption
aria-hidden="true">蓝色即为主键值，橙色为建立索引列的值</figcaption>
</figure>
<ul>
<li>一个页面最少存储2条记录（其实就是B+树本身的限制）</li>
</ul>
<h4 id="myisam中的索引方案">5、MyISAM中的索引方案：</h4>
<p>​
在MyISAM中，其使用的B+树索引的，叶子结点存储的是数据记录的地址，而不是数据本身。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/image-20221022120251019.png" /></p>
<h4 id="innodb和myisam引擎的区别">6、InnoDB和MyISAM引擎的区别</h4>
<p><strong>MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。</strong></p>
<ul>
<li><p>①
在InnoDB存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在MyISAM
中却需要进行一次回表操作，意味着MyISAM中建立的索引相当于全部都是二级索引。</p></li>
<li><p>②
InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。</p></li>
<li><p>③
InnoDB的非聚簇索引data域存储相应记录主键的值，而MyISAM索引记录的是地址。</p></li>
<li><p>④
MyISAM的回表操作是十分快速的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</p></li>
<li><p>⑤ InnoDB要求表必须有主键（
MyISAM可以没有）。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。</p></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-22%2012.06.40.png" /></p>
<h4 id="索引的数据结构选取">7、索引的数据结构选取</h4>
<p>​
为了减少索引在内存中的占用，其都是存储在磁盘上的。当我们使用索引查询的时候，不可能把索引全都一次性加载到内存中，所以要尽可能的设计索引的数据结构，使得<strong>磁盘IO次数较少</strong></p>
<ul>
<li>Hash索引从速度上来讲比树型索引要快很多，那么为什么索引还是设计成树的样子呢？
<ul>
<li>因为Hash索引仅能支持 等于、不等于 操作，无法支持范围查询</li>
<li>数据的存储没有顺序，如果需要ORDER BY的情况下，还要重新排序</li>
<li>如果重复值多，Hash冲突多的话，效率也会下降</li>
<li>不能支持联合索引</li>
<li>InnoDB不支持Hash索引</li>
</ul></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/image-20221022121840709.png" /></p>
<ul>
<li>InnoDB本身不支持Hash索引，但提供自适应Hash索引：
<ul>
<li>如果某个数据经常被访问，且满足一定条件，该数据页的地址就会放入Hash表中。下次查询的时候，直接通过自适应Hash就可以访问到这个数据页。</li>
</ul></li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/image-20221022122100058.png" style="zoom: 33%;" /></p>
<h4 id="b树和b树的选取">8、B树和B+树的选取：</h4>
<ul>
<li><p>B树：多路平衡查找树：</p>
<ul>
<li>（叶子结点和非叶子结点都会存储数据，搜索有可能终止于非叶子结点）</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/image-20221022122415040.png" /></p></li>
<li><p>B+树：</p>
<p>B+树更适合文件索引，两者区别如下：</p>
<ul>
<li>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 = 关键字数，而 B
树中，孩子数量 = 关键字数+1。</li>
<li>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）。</li>
<li>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而
B 树中， 非叶子节点既保存索引，也保存数据记录。</li>
<li>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接</li>
</ul></li>
<li><p>B+树相比于B树的区别和好处？</p>
<ul>
<li>查找效率更稳定（数据都在叶子节点），且更高（更矮胖）</li>
<li>范围查找中，效率也更高。因为数据都在叶子节点中，可以通过指针链接查找。</li>
</ul></li>
</ul>
<h4 id="r树">9、R树</h4>
<p>​
其仅支持geometry数据类型。比如查找20km以内所有的餐厅，岂能解决高维空间的搜索问题。其实质上就是一颗用来存储高维数据的平衡树。</p>
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>数据库精简笔记</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap16 Mysql日志与备份</title>
    <url>/2022/10/17/a810e83d8611/</url>
    <content><![CDATA[<h3 id="一暂无">一、暂无</h3>
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>数据库精简笔记</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>电子信息工程中数学模型与方法——单元2 系统辨识</title>
    <url>/2022/10/12/f71a1b069441/</url>
    <content><![CDATA[<h2 id="一模型智能">一、模型智能</h2>
<h3 id="什么是智能">1、什么是智能？</h3>
<p>​ 智能有三个层次（某IBM科学家）：感知智能，执行智能，认知智能</p>
<ul>
<li>感知智能：感知环境状态</li>
<li>执行智能：采取行动</li>
<li>认知智能：建模、分析与决策，认知智能是最高级智能</li>
</ul>
<p>认知智能是动物和人建立/改进环境模型（规律的表述），使用模型处理信息并做出预测和决策的能力</p>
<ul>
<li><p>理想人工智能:
人工智能是研究模拟和扩展动物和人的智能的理论和方法，包含感知智能、执行智能和认知智能。</p></li>
<li><p>当前人工智能：现在的所谓人工智能大都是开发基于图像和声音的感知技术。所以当前的人工智能还在感知智能的层次</p></li>
</ul>
<p>下图为自动控制流程：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220923163300371.png" style="zoom:67%;" /></p>
<ul>
<li><strong>一个系统的最优控制器一定是该系统的数学模型!</strong></li>
</ul>
<h3 id="基于智能建模的智能建造技术">2、基于智能建模的智能建造技术：</h3>
<ul>
<li><p>流程工业包括石化、化工、发电、钢铁、水泥、造纸、采矿等，是国民经济的基础</p></li>
<li><p>催生一个巨大的流程工业智能制造市场，在流程工业实现全面自动化生产，即智能制造，可以节能1%
-10%，提高收益0.1% - 2%，减少污染物生成5% - 50%</p></li>
</ul>
<p>计划调度、诊断监控、实时优化、模型预测控制、常规PID控制、设备仪表及DCS系统</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220923163633152.png" /></p>
<p><strong>过程模型的建立/维护，是实现每一层自动/闭环的关键</strong></p>
<p><strong>模型智能：</strong>模型智能是一个计算机算法（软件），对于一类给定过程，可以对其自动建模、自动维护模型、并自动使用模型进行预测、控制、优化及诊断</p>
<h4 id="系统辨识的渐进法">1）系统辨识的渐进法：</h4>
<ul>
<li>多变量、闭环、自动系统辨识（建模）技术
<ul>
<li>• 自动最优激励信号设计，多变量、闭环、自动测试</li>
<li>• 自动确定模型阶次</li>
<li>• 自动模型参数估计（计算）</li>
<li>• 自动模型检验，给出每个模型A, B, C, D评级</li>
</ul></li>
</ul>
<h4 id="pid闭环参数整定">2）PID闭环参数整定</h4>
<p>​
PID控制器以其结构简单、稳定性好、调整方便而成为应用最广泛的一类工业控制器。</p>
<ul>
<li>问题核心：PID控制器参数整定困难</li>
<li>参数整定方法：</li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220923164457568.png" style="zoom:67%;" /></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220923164619424.png" /></p>
<h4 id="模型预测控制">3）模型预测控制：</h4>
<p>​
模型预测控制：是指利用对象的历史信息和模型信息，通过在未来时段上优化过程输出来计算最佳输入序列的一类算法。</p>
<p>​ <strong>关键环节：</strong>预测模型、滚动优化、反馈校正</p>
<p>​ 减少波动以后就可以卡边操作</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220923164911006.png" style="zoom:67%;" /></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220923165006259.png" /></p>
<h4 id="总结">3、总结：</h4>
<ul>
<li>动态模型是智能制造的关键，模型才是智能</li>
<li>团队经过多年研发，流程工业系统的智能建模、控制及优化技术已成熟，包括:
(1) 基础控制层; (2) 先进控制层; (3) 实时优化层</li>
<li>可在各流程工业普及应用，节能减排、提高收益</li>
</ul>
<h2
id="二系统辨识动态数据建模的理论和方法">二、系统辨识——动态数据建模的理论和方法：</h2>
<h3
id="系统辨识介绍系统辨识的关键步骤">1、系统辨识介绍（系统辨识的关键步骤）</h3>
<ul>
<li><p>系统 System：
系统是以有序形式排列的对象的集合，用于某种目的</p></li>
<li><p>过程 Process:
过程是用于在流程工业中制造均质材料或能源产品的加工厂。
加工工业包括：石油、化工、电力、造纸、玻璃、采矿、金属、水泥、药品、食品</p></li>
<li><p>模型 Model:
模型是一个系统（过程）基本方面的表示，表示该系统的知识</p></li>
<li><p>数学模型 Mathematical Models:
用微分方程和代数方程描述系统变量之间的关系。工程领域的主要部分涉及使用数学模型进行设计、模拟、预测和控制/优化。</p></li>
<li><p>系统辨识：系统或过程识别是使用测试数据对系统（过程）进行数学建模的领域。从技术上讲，Zadeh（1962）将系统识别定义为：在输入和输出的基础上，确定特定类别系统（模型）内的系统模型。</p></li>
<li><p><strong>系统辨识的过程</strong></p></li>
</ul>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220923173506705.png"
alt="image-20220923173506705" />
<figcaption aria-hidden="true">image-20220923173506705</figcaption>
</figure>
<p><strong>系统辨识的关键步骤</strong>：</p>
<p>1）识别测试，辨识实验的设计 Identification tests/experiments
：生成信息，输入输出数据</p>
<p>2）模型结构选择 Model order/structure selection
：线性或非线性，什么结构（MIMO），什么顺序？</p>
<p>3）参数估计Parameter estimation ：使用一些优化技术确定模型参数。</p>
<p>4） 模型验证Model validation:
：检查获得的模型是否足够好，是否能够使用（目的），如果不够，给出补救方法。</p>
<h3 id="动态系统和信号的模型">2、动态系统和信号的模型：</h3>
<h4
id="单输入单输出连续时间模型siso-continuous-time-models">1）单输入单输出连续时间模型：SISO
Continuous-Time Models</h4>
<p>​ 最常用的是<strong>微分方程</strong>和<strong>传递函数</strong>：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927194052145.png" /></p>
<p>​ <img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927194102312.png" /></p>
<p>还可以用<strong>脉冲响应模型</strong>进行描述：<strong>引入延迟算子</strong></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927194118895.png" /></p>
<h4 id="单输入单输出离散时间模型">2）单输入单输出离散时间模型：</h4>
<p>一个使用保持电路的计算机控制系统采样过程</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927194329943.png" /></p>
<ul>
<li><p>Zero-Order Hold 即零阶保持器，只有一个设置<a
href="https://so.csdn.net/so/search?q=采样&amp;spm=1001.2101.3001.7020">采样</a>时间的参数，表示的是以采样时间间隔进行数据的采集；</p></li>
<li><p>Unit Delay即单位延迟模块，有两个输入参数，类似于<a
href="https://so.csdn.net/so/search?q=寄存器&amp;spm=1001.2101.3001.7020">寄存器</a>，第一个是设置初始值，第二个是采样时间。</p></li>
<li><p>Zero-Order Hold模块是以当前时间点以后的值为准，而Unit
Delay是以当前时间之前的值为准。</p></li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927221208577.png" style="zoom:67%;" /></p>
<ul>
<li>在<strong>离散时间模型中</strong>引入延迟算子就能得到相应的离散传递函数：</li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927221358771.png" style="zoom:50%;" /></p>
<ul>
<li><p>对一个n阶的差分方程使用0阶保持器：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927221507779.png" style="zoom:67%;" /></p></li>
</ul>
<h4 id="信号的几种模型描述方式">3）信号的几种模型描述方式</h4>
<h5 id="频域框架有限序列的信号的周期图">-
频域框架：有限序列的信号的周期图：</h5>
<ul>
<li>通过傅里叶变化：可以得到信号的周期图</li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927221626122.png" style="zoom:50%;" /></p>
<ul>
<li><p><strong>信号的周期图：periodogram</strong> ——
反映了信号在各个频域点上能量贡献的大小</p></li>
<li><p>Parsevals恒等式： 左侧是时间域，右侧是频域</p></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927221815400.png" /></p>
<p>​ 信号在时间域内拥有的总能量等于其在频域内各个频率的能量的总和</p>
<h5 id="概率框架信号功率谱-signal-spectra">- 概率框架：信号功率谱 signal
spectra</h5>
<ul>
<li><p>随机过程：一组信号，在每个时刻都是一个随机变量。</p></li>
<li><p>平稳随机过程：这个随机过程，其均值属性不随时间变化</p></li>
<li><p>自相关函数和功率谱</p></li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927222142483.png" style="zoom:50%;" /></p>
<ul>
<li>给定两个平稳随机过程v(t)
s(t)：互相关函数，和互功率谱（是互相关函数的傅里叶变换）：</li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927222301599.png" style="zoom: 50%;" /></p>
<ul>
<li>如果给定一个随机过程的实现v(t),可以用时间算子代替数学期望可以估计自相关函数，从而估计功率谱</li>
</ul>
<p>但这样一个过程是有一个假设的，这个假设就是 Ergodic
process（个态遍历）也就是：当N趋于正无穷，时间平均值趋于整体平均</p>
<h5 id="白噪声信号white-noise-process">- 白噪声信号White noise
process:</h5>
<p>​ 零均值和方差 R 的独立同分布随机变量序列。</p>
<p>​
<strong>特点</strong>：白噪声没有记忆，t时间的信号值和t时间前的值完全无关，也就是可以导出下图中说的重要规则：</p>
<p><strong>每个平稳随机过程 {v(t)}
都可以通过稳定的最小相位滤波器对白噪声滤波来生成</strong></p>
<p>​ <img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927222909082.png" /></p>
<h3 id="有扰动情况下的线性过程描述">3、有扰动情况下的线性过程描述：</h3>
<p>​
假设v(t)是稳定随即过程，利用上述的结论，我们可以使用下述这个形式来表示有扰动情况下的线性过程的描述。之后关键就是在这个模型下进行利用实验数据估计G(q)和H(q)</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927223152305.png" style="zoom:50%;" /></p>
<h2 id="三系统辨识辨识实验设计">三、系统辨识——辨识实验设计</h2>
<h3 id="辨识实验identification-test的必要性">1、辨识实验Identification
Test的必要性</h3>
<ul>
<li>辨识实验（控制）的目的是激发和收集（控制）相关信息。</li>
<li>测试期间使用测试信号/激励。</li>
<li>辨识实验是一种成本，但不要干扰正常生产。</li>
<li>良好的辨识实验是成功识别/控制的关键。</li>
<li>没有良好的辨识实验就是数据输入垃圾输出。</li>
</ul>
<p><strong>辨识实验是有代价的</strong>：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927223723009.png" style="zoom:50%;" /></p>
<h3 id="preliminary-tests-预测试">2、Preliminary Tests 预测试</h3>
<p>目的是为了获得先验知识</p>
<h4 id="收集历史数据collect-historic-data-p3">1）收集历史数据Collect
historic data P3</h4>
<p><strong>一般来说，历史数据对于模型来说不够丰富，或者换句话说，信噪比太低（例如90％的噪声，10％的信号）</strong></p>
<ul>
<li>获得过程的第一印象。</li>
<li>过程的输出 (CV) 代表未测量的干扰。</li>
<li>MV 的动作代表操作员的控制。</li>
<li>简单又便宜。 数据库可用于大多数流程。</li>
<li>与操作者交谈并向他们学习。</li>
</ul>
<h4 id="阶跃实验short-step-test-p4">2）阶跃实验Short step test P4</h4>
<ul>
<li>将每个操作变量上下操作一些次数</li>
<li>检查主要时间常数、增益和延迟</li>
<li>检查并调整 MV PID 回路。</li>
<li>控制工程师可以通过观察过程阶跃响应直观地了解过程动态。</li>
<li>低成本测试。</li>
</ul>
<h4
id="阶梯实验了解对象的非线性程度">3）阶梯实验：了解对象的非线性程度</h4>
<ul>
<li>将阶梯信号应用于某些 MV。</li>
<li>目的是检查非线性。</li>
<li>高成本测试，通常不允许</li>
</ul>
<h3 id="系统辨识中常见的实验信号">3、系统辨识中常见的实验信号</h3>
<p>实验信号有两个方面的因素需要考虑：信号波形和频谱的要求 wave form and
frequency content</p>
<ul>
<li>信号波形（时域）要求： -
<ul>
<li>在正常操作中不会引起干扰（比较脉冲和阶跃）。</li>
<li>不激发过程非线性（比较脉冲和步骤）。</li>
<li>操作员友好（比较脉冲和阶跃）。</li>
</ul></li>
<li>信号频率成分（功率谱）设计：
<ul>
<li>测试信号的功率谱会影响控制性能。</li>
<li>用于控制目的的最佳频谱设计。</li>
</ul></li>
</ul>
<h4 id="prbs-二进制伪随机信号">1）PRBS 二进制伪随机信号：</h4>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927224849434.png" /></p>
<ul>
<li><p>Clock是时钟脉冲</p></li>
<li><p>State是移位寄存器</p></li>
<li><p>移位寄存器产生的序列，最大的周期为 M 即 2^n-1 称为M序列</p></li>
<li><p>统计特性：（均值、自相关函数、频谱图）</p></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927225042867.png" /></p>
<p>​
该实验信号模型可以很好的模拟一个白噪声信号，但是这种信号切换频率太快，对工业的装置影响太大。同时其对于中低频信号不友好，比较偏重于高频。而系统辨识需要中低频信号</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927225345044.png" style="zoom:67%;" /></p>
<p>​ 所以需要调整我们的PRBS来产生低通特性的PRBS信号：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927225321648.png" style="zoom:67%;" /></p>
<h4 id="gbngeneralized-binary-noise-广义二值化信号">2）GBN(generalized
binary noise) 广义二值化信号</h4>
<p>​ 信号翻转的概率，按照如下图：Generation rule进行信号的生成：</p>
<p>​ psw为切换概率</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927225457178.png" /></p>
<p>​
<strong>通过降低切换概率，增加切换时间来获得低通的信号，来进行辨识信号实验。</strong></p>
<h4 id="pbrs和gbn对比">3）PBRS和GBN对比：</h4>
<ul>
<li>相比于PRBS来说，PRBS在一些特殊的2pi的点等于0，不接近实际，而GBN不会。同时，PRBS有最长周期，而GBN没有，可以随意选择</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927225706274.png" /></p>
<h4
id="持续激励的测试信号persistent-excitation-of-a-test-signal">4）持续激励的测试信号：Persistent
excitation of a test signal</h4>
<ul>
<li>N阶的持续激励信号：需要满足以下条件：</li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927225916291.png" style="zoom:50%;" /></p>
<ul>
<li>N阶持续激励的频域解释：n阶持续激励的频域解释是信号的频谱在区间（-pi,pi）内至少n个频率中不为零</li>
<li>PRBS和GBN信号的区别：</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927230015132.png" /></p>
<h3 id="模型辨识的测试最终测试">4、模型辨识的测试，最终测试</h3>
<h4 id="mpc控制的测试设计">1） MPC控制的测试设计</h4>
<ul>
<li>测试时间：
<ul>
<li>小系统或低噪音：（6~10）*（稳定时间 settling time）</li>
<li>大型系统或高噪音：(12 ~ 20) *(稳定时间 settling time)</li>
</ul></li>
<li>信号类型：GBN -</li>
<li>信号步长：根据预先测试和与操作员的讨论确定。
从小开始，可以在测试过程中进行调整-</li>
<li>信号平均切换时间（功率谱）：</li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927230237868.png" style="zoom:50%;" /></p>
<ul>
<li><p>GBN信号可以同时做若干个实验，不同实验互不相关。</p></li>
<li><p>每个测试的MV个数，以及测试信号的相关性：</p>
<ul>
<li>每次测试的 MV 数量：开环测试最多 10 个 MV； 在闭环测试中所有
MV。</li>
<li>测试信号之间的相关性：通常独立；
对于条件不佳的过程（例如高纯度蒸馏塔），某些 MV
之间的强相关性可能会有所帮助。</li>
</ul></li>
</ul>
<h4 id="闭环实验测试">2）闭环实验测试：</h4>
<ul>
<li>大多数工业应用使用开环测试。</li>
<li>20年前，业界不相信的过程是 可使用闭环数据识别。</li>
<li>可以在设定点或 MV 处应用测试信号</li>
<li><strong>闭环测试对过程操作的干扰较小</strong></li>
<li>闭环测试易于进行。</li>
<li>来自闭环测试数据的模型更适合控制。</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927230553891.png" /></p>
<h2
id="四系统辨识最小二乘的系统辨识方法">四、系统辨识——最小二乘的系统辨识方法</h2>
<h3 id="最小二乘的原则p20页-由高斯提出">1、最小二乘的原则：P20页
由高斯提出</h3>
<h3
id="基于最小二乘估计线性过程的模型arx模型">2、基于最小二乘，估计线性过程的模型——ARX模型</h3>
<p>用n阶差分方程描述：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927230958268.png" /></p>
<p>引入误差项：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927231012557.png" /></p>
<p>首先进行等式重组：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927231103308.png" style="zoom: 50%;" /></p>
<p>在系统辨识实验测试后，我们可以得到数据集，并且使用数据来填充等式：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927231138550.png" style="zoom:50%;" /></p>
<p>最后，通过最小化如下的目标函数来估计模型参数：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927231216488.png" style="zoom:50%;" /></p>
<p>如下为解：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927231234423.png" style="zoom:50%;" /></p>
<h3 id="工业实例">3、工业实例：</h3>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927231336491.png"
alt="image-20220927231336491" />
<figcaption aria-hidden="true">image-20220927231336491</figcaption>
</figure>
<h3 id="最小二乘估计的属性">4、最小二乘估计的属性：</h3>
<p><strong>估计器的理想（良好）属性：</strong></p>
<ul>
<li>无偏估计 Unbiased estimator</li>
<li>一致的估计器 Consistent estimator</li>
<li>有效或最小方差估计器 Efficient or minimum variance estimator:</li>
</ul>
<p><strong>原始的最小二乘估计器是无偏的</strong></p>
<p><strong>ARX模型是有偏的，因为A2不保持</strong></p>
<h2 id="五最小二乘模型的扩展">五、最小二乘模型的扩展：</h2>
<h3 id="输出误差方法-output-error-method">1、输出误差方法 Output-error
method</h3>
<p>​ 其存在一个大的数值问题：输出误差在 A(q) 参数中是非线性的。
不存在解析（封闭形式）解决方案，也无法保证全局最小值。</p>
<h4 id="关于一致性的证明">1）关于一致性的证明：</h4>
<ul>
<li>真实过程由 (5.1.4) 给出，其中 v(t) 是零均值的平稳随机过程。</li>
<li>模型阶数 n 正确。</li>
<li>输入持续兴奋，阶数高于 2n。</li>
<li><strong>测试是开环的。</strong></li>
<li>最小化收敛到所有 N 的全局最小值。</li>
<li>A(q) 和 B(q) 没有公因数。</li>
</ul>
<h3 id="预测误差方法-prediction-error-methods">2、预测误差方法
Prediction error methods</h3>
<p>该方法实现：1）闭环测试的一致性（无偏性） 2)
开环和闭环的效率（最小方差）。</p>
<p>ARMAX 模型：</p>
<ul>
<li>一些控制设计方法的良好模型结构。、</li>
<li>数值优化是必要的，不能保证全局最小值</li>
</ul>
<p>BOX-Jenkins模型：</p>
<h4 id="预测误差方法的属性">预测误差方法的属性：</h4>
<ul>
<li>假设：（1）过程稳定； (2)模型结构正确； (3) 测试信号持续激励； (4)
最小化收敛到其全局最小值</li>
</ul>
<h3 id="阶次选择-order-selection">3、阶次选择 Order Selection</h3>
<ul>
<li>目的：找到模型阶次，以便模型对其使用最准确（在控制中）。
<ul>
<li>粗阶选择方法：检查协方差矩阵的秩，绘制 Hankel 矩阵的奇异值。
对于嘈杂的数据不准确。</li>
<li>准确的方法：首先估计具有递增阶数的模型，然后使用错误准则选择最佳阶数。</li>
</ul></li>
<li>主要议题：什么策略？什么数据集？
<ul>
<li>在识别文献中，预测误差准则常用于模型阶数选择。 -</li>
<li>交叉验证的缺点是成本高。 使用估计数据进行模型阶数选择更经济。</li>
<li>使用估计数据的错误标准是使用验证数据的错误标准的有偏估计。</li>
</ul></li>
</ul>
<p><strong>输出误差小并不能保证仿真误差小</strong></p>
<ul>
<li><p>仍然需要证明 FOE 是对验证数据的 OE 标准的无偏估计。</p></li>
<li><p>我们可以将这种使用不同标准进行模型估计和订单选择的交叉标准方法称为方法。</p></li>
</ul>
<h3 id="模型验证-model-validation">4、模型验证 Model Validation</h3>
<p>检查获得的模型是否足以使用（控制），如果没有，提供补救措施（做什么</p>
<p>将模型属性与过程知识进行比较。 粗略估计过程增益，主要时间常数。</p>
<p>使用模型阶跃响应图。 检查不同方法的一致性。 估计 FIR、ARX、ARMAX 和
Box-Jenkins 模型并比较它们的阶跃响应和频率响应</p>
<h4 id="残差分析">1) 残差分析：</h4>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220928090759861.png" style="zoom:50%;" /></p>
<ul>
<li>一个批评意见：控制的识别没有解决。 （这类模型是否适用于控制）
<ul>
<li>前三种方法或多或少是定性测试。</li>
<li>残差分析是检查模型是否与测试数据充分吻合。</li>
<li>没有一种方法可以判断模型是否适合控制。</li>
<li>如果一个模型通过了残差分析，它只告诉给定数据获得了好的模型。
但是数据是否足够好（用于控制）？</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>⓾ 课程笔记</category>
        <category>电子信息工程数学模型与方法</category>
      </categories>
      <tags>
        <tag>course</tag>
      </tags>
  </entry>
  <entry>
    <title>电子信息工程中数学模型与方法——单元3 电磁系统</title>
    <url>/2022/09/30/2742f0d23b8a/</url>
    <content><![CDATA[<h2 id="一概述和基本理论">一、概述和基本理论</h2>
<h3 id="麦克斯韦方程组">1、麦克斯韦方程组：</h3>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221002113642895.png" /></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221002113659170.png" /></p>
<h3 id="平面电磁波">2、平面电磁波：</h3>
<ul>
<li><p>波 : 扰动、能量、或物理信息在空间上传播的一种物理现象；</p></li>
<li><p>电磁波 : 传播电磁能量的波；</p></li>
<li><p>平面电磁波 :
波前（等相位面）是平行面且与传播方向垂直的固定频率电磁波；</p></li>
<li><p>亥姆亥兹方程（Helmholtz’s equation）</p></li>
</ul>
<p><img
src="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150037334.png" /></p>
<ul>
<li>电场强度表达式：</li>
</ul>
<p><img
src="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150210202.png" /></p>
<p><img
src="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150222274.png" /></p>
<ul>
<li><p>磁场强度表达式：</p>
<figure>
<img
src="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150256704.png"
alt="image-20221002150256704" />
<figcaption aria-hidden="true">image-20221002150256704</figcaption>
</figure></li>
</ul>
<h3 id="特征阻抗">3、特征阻抗：</h3>
<p>电场强度和磁场强度的幅值比值定义为某种材料的特征阻抗</p>
<p><img
src="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150355839.png" /></p>
<h3 id="电磁辐射天线辐射">4、电磁辐射—天线辐射</h3>
<p>​ 分为近场和远场，近场又分为两个</p>
<p><img
src="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150510352.png" /></p>
<p>​ 在比较远的地方可以等价于一个平面波的形式</p>
<p><img
src="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150516797.png" /></p>
<h3 id="电磁辐射赫兹偶极子">5、电磁辐射—赫兹偶极子：</h3>
<h3 id="电磁辐射半波长偶极子">6、电磁辐射—半波长偶极子</h3>
<h3 id="电磁辐射天线应用-p24-26">7、电磁辐射—天线应用 P24-26</h3>
<figure>
<img
src="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150915273.png"
alt="image-20221002150915273" />
<figcaption aria-hidden="true">image-20221002150915273</figcaption>
</figure>
<ul>
<li>移动手机 P26-27</li>
<li>笔记本电脑 P28-29</li>
<li>无线可穿戴设备 P30-31</li>
<li>无线电识别天线 P32-33
<ul>
<li>无线电识别：一种用来在一定距离无线识别的电子贴片技术。</li>
</ul></li>
<li>工作范围：P３４　　近场和远场</li>
<li>工作模式：被动（Passive Tag 主动（ Active Tag 半被动（ Semi passive
Tag)
<ul>
<li>被动：
<ul>
<li>没有电源，使用从读卡器上的能量来充能并且传输数据到读卡器</li>
<li>更小，更廉价</li>
<li>往往只有很短的读取距离</li>
</ul></li>
<li>主动：
<ul>
<li>有电源，tag先传输，然后是reader</li>
<li>更长的读取距离，100m或以上</li>
<li>昂贵，使用时间较有限</li>
</ul></li>
</ul></li>
</ul>
<h3 id="电磁感应无线传能">8、电磁感应—无线传能</h3>
<h3 id="电磁感应全息成像">9、电磁感应—全息成像</h3>
<h3 id="电磁辐射穿透性-p39">10、电磁辐射—穿透性 P39</h3>
<h2 id="二电磁散射系统建模和可视化">二、电磁散射系统建模和可视化</h2>
<h3 id="电磁散射基本理论-狄拉克格林函数">1、电磁散射基本理论
狄拉克格林函数</h3>
<h3 id="瑞利散射">2、瑞利散射</h3>
<p>​ 半径比光或其他电磁辐射的波长小很多（ （&lt;0.1 𝜆）的 微小颗粒
（例如单个原子或分子）对入射光束的散射。</p>
<p>​
瑞利散射在光通过<strong>透明的固体和液体时都会发生，但以气体最为显著。</strong></p>
<figure>
<img
src="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002152515412.png"
alt="image-20221002152515412" />
<figcaption aria-hidden="true">image-20221002152515412</figcaption>
</figure>
<ul>
<li>总的辐射能量与波数的四次方成正相关，与波长的四次方成反相关。频率越高，瑞利散射越强</li>
<li>公式见P7</li>
</ul>
<h3 id="米氏散射">3、米氏散射：</h3>
<p>​ <strong>当 微粒半径的大小接近于或大于入射光线的波长 λ
的时候</strong>，大部分的入射光线会沿着前进的方向进行散射，这种现象被称为米氏散射。
​<strong>散射场几乎与波长无关；前向波比较大 ;
物体大小越大，前向波越大</strong></p>
<p>​
这种大微粒包括灰尘，水滴，来自污染物的颗粒物质，如烟雾等。即s是形成所谓的丁达尔效应</p>
<p><img
src="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002152726428.png" /></p>
<ul>
<li>为什么天空是蓝色、红色（傍晚）、白色（云）？</li>
</ul>
<p>​ 瑞利散射：波长的四次方成反相关，即频率越高，瑞利散射越强</p>
<p><img
src="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002152752906.png" /></p>
<h3 id="应用微波近场扫描显微成像">4、应用：微波近场扫描显微成像：</h3>
<p><img
src="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002152904823.png" /></p>
]]></content>
      <categories>
        <category>⓾ 课程笔记</category>
        <category>电子信息工程数学模型与方法</category>
      </categories>
      <tags>
        <tag>course</tag>
      </tags>
  </entry>
  <entry>
    <title>电子信息工程中数学模型与方法——单元1 工业智能</title>
    <url>/2022/09/19/e947a7cc4335/</url>
    <content><![CDATA[<h2
id="一以模型为核心的工业智能工信融合与工业智能">一、以模型为核心的工业智能——工信融合与工业智能</h2>
<h3 id="工业文明发展和工信融合-p9">1、工业文明发展和工信融合 P9</h3>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220919140907698.png" alt="image-20220919140907698" style="zoom:33%;" /></p>
<ul>
<li>我国工业面临的形式和发展目标 P13</li>
<li>什么是两者领域的深度融合？ P14</li>
</ul>
<h3 id="智能人类智能和工业智能">2、智能：人类智能和工业智能</h3>
<ul>
<li>人类心智的八个范畴 P19</li>
<li>什么是智能？什么是智慧？智能的进化属性？理解工程科学的智能 P20</li>
<li>工业智能的八个范畴 P24</li>
<li>人擅长做的：感知、决策和执行</li>
</ul>
<h3 id="控制视角和控制前沿">3、控制视角和控制前沿</h3>
<ul>
<li>工业系统信息物理深度融合面临的主要挑战 P28
<ul>
<li>综合认知难、融合表达难、协同调控难、安全防护难</li>
</ul></li>
<li>实时、精准的综合信息感知 P29</li>
<li>工业大数据的综合表达与认知 P30</li>
<li>人-机-物协同的智能控制与优化 P31</li>
<li>三元空间的一体化安全防护 P32</li>
<li>智能工厂的内涵 P41</li>
<li>无人驾驶和无人工厂 共性和区别 P42</li>
<li>工厂智能化的技术分级：范围、能力、效益 L0-L5 P43</li>
</ul>
<h3 id="流程工业的智能化之路">4、流程工业的智能化之路</h3>
<ul>
<li>工业运行方式的变迁 P46 47
<ul>
<li>流程工业是形成人类物质文明的基础工业</li>
<li>流程工业的行业特点、新需求等</li>
<li>人工控制——少量仪表——中控系统——现代化大型控制室</li>
</ul></li>
<li>设计型技术和运行型技术：P48
<ul>
<li>设计型技术：产品和工艺设计-&gt;高附加值产品、新工艺</li>
<li>运行型技术：生产和制造
-&gt;高效、高适应性生产。不增加太多投资的情况下取得显著的经济效益，投资小见效快是最集中体现流程企业操作运行“智能”的技术关键</li>
<li>流程工业生产运行的新需求：高效、柔性。</li>
</ul></li>
<li>什么是智能？工厂的指挥、智慧工厂的工作流 P52</li>
<li>无人化工厂的技术核心：P53
<ul>
<li>人工智能：算力、数据、算法</li>
<li>工业智能：建模、控制、优化</li>
<li>大工业：工艺、流程、设备</li>
</ul></li>
<li>无人化工厂的新目标：P54</li>
</ul>
<h2
id="二以模型为核心的工业智能过程系统建模与分析运行">二、以模型为核心的工业智能——过程系统建模与分析运行：</h2>
<h3 id="引言">1、引言</h3>
<ul>
<li>机理模型（白箱）：P59</li>
<li>数据模型（黑箱）：P59</li>
</ul>
<h3 id="过程系统简介">2、过程系统简介</h3>
<ul>
<li>过程系统的结构</li>
<li>流程工业的典型生产过程：（反应 + 分离 很重要）
<ul>
<li>化工过程是由一个个加工过程组成的，可以分为两类：化学反应过程，物理加
工过程。</li>
<li>化学反应过程对应的设备为反应器，物理加工过程对应的设备为单元操作。</li>
<li>所有单元操作都属于动量、热量、质量的传递速率控制过程</li>
<li>单元操作的种类：P68</li>
<li>过程系统工程：以数学模型、计算机辅助为基础的效能分析、设计放大、操作调整</li>
</ul></li>
<li>田纳西过程：P69
<ul>
<li>操作变量：用于调节生产运行状态的手段。通常是阀门开度或者电机转速。</li>
<li>测量变量（生产装置的眼睛）：现场仪表或实验室分析手段所能测量的流量、
温度、压力、液位、组分等变量。通过测量变量可以了解生产过程的工作状</li>
<li>运行约束：运行约束一般包括设备操作范围的约束，产品约束，安全约束等。</li>
<li>优化目标：常见的优化目标包括提高产品收率、降低生产能耗等。</li>
</ul></li>
</ul>
<h3 id="模型描述和求解">3、模型描述和求解</h3>
<ul>
<li><p>装置与流股： P77</p>
<ul>
<li>全流程的机理模型是由单个装置的机理模型+连接关系组合而成的</li>
<li>装置与装置之间的连接称为流股Stream（包括物质流股和能量流股）</li>
<li>物质流股S由流量、组分、温度、压力来描述。能量流股H由热量和温度来描述。</li>
</ul></li>
<li><p>连接关系与全流程模型 P78</p></li>
<li><p>仿真问题与反问题：</p>
<ul>
<li><p>仿真问题：可用于回溯分析，what-if分析（就是如果输入调整，输出会如何改变）</p></li>
<li><p>仿真问题反问题：</p>
<ul>
<li><p>要求输出流股(产品)的状态为Y，相应的输入流股(进料)条件是怎样的？(操作问题)</p></li>
<li><p>设备参数应该如何选择？(设计问题)</p></li>
<li><p>获得了输入流股、输出流股等数据，如何反推设备参数？(参数估计问题)</p></li>
</ul></li>
</ul></li>
<li><p>序贯求解</p>
<ul>
<li>当进料条件为X时，产品的状态是怎样的？</li>
<li>当流程中存在回路Recycle时，需要先断开某个流股（割裂流股），才能够序贯求解。
回路的存在使得求解过程更加复杂</li>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220919154605965.png" /></li>
<li>优化问题：怎样的进料条件，使得A产品产量最高/生产能耗最低/有害物质产出最少？</li>
</ul></li>
<li><p>物质流 &amp; 能量流 &amp; 信息流：P83</p></li>
<li><p>单个装置的建模：装置的方程 P84</p></li>
<li><p>全流程机理模型的层次化特征：</p>
<ul>
<li>上述两类方程及流程单元的连接构成层次化特征，多层次的模型造成了机理模型的复杂性。</li>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220919155241488.png" /></li>
</ul></li>
<li><p>完整模型的序贯求解：P91</p>
<ul>
<li>上述多层次结构中的每个层次的模型通常都没有closed
form的解。也就是说序贯求解的思路需要在每个层次上，需要迭代求解那个层次的方程组。因此，完整模型序贯求解的工作流呈现出一种“洋葱结构”。</li>
</ul></li>
<li><p>机理模型联立求解：</p>
<ul>
<li>对于复杂耦合流程的优化问题，采用序贯法求解时迭代过程嵌套层数多，内外
层信息传递复杂、收敛难度大。采用联立方程法求解可以避免这一问题</li>
<li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220919155604175.png" style="zoom:50%;" /></li>
</ul></li>
</ul>
<h3 id="不同类型的命题">4、不同类型的命题</h3>
<ul>
<li>仿真或WHAT-IF分析 P95</li>
<li>灵敏度分析：灵敏度分析一般是各种优化问题求解的前置步骤</li>
<li>设计优化、操作优化：包括设备操作范围的约束、产品约束、安全约束</li>
<li>参数估计：参数估计需要使用实际装置的测量数据𝑦0
。实际的测量数据存在噪声、静差等，
需要先进行校正和滤波，然后再用于参数估计</li>
<li>稳态与动态：稳态是指各生产变量基本保持不变的平稳的运行状态动态是指两个稳态之间的过渡过程</li>
<li>动态优化问题：动态优化的结果不再是一个数值，而是一个时间序列𝑢(𝑡)</li>
</ul>
<h3 id="数学建模的步骤">5、数学建模的步骤</h3>
<ul>
<li>模型建立：工艺分析和简化装置数学模型的建立 P103
<ul>
<li>（建模假设、模型变量建立、机理方程的建立）</li>
</ul></li>
<li>命题求解：数学模型的变换和化简，模型的编程实现，数学规划命题的求解
P103</li>
<li>结果分析：求解结果是否正确，是否符合预期目标 P103</li>
</ul>
<p>​ 代数建模语言(Algebraic modeling language,
AML)：用于大规模数学计算(一般是数
学规划)中的数学元素进行描述，并提供求解器接口的一类高级脚本语言。</p>
<p>​ 非线性方程组求解和优化：迭代法数值计算</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220919160136072.png" style="zoom:50%;" /></p>
<p>​
初值（初始迭代点）对非线性规划问题的求解影响很大，考虑以下的优化命题：</p>
<h3 id="模型降阶和融合">6、模型降阶和融合：</h3>
<p>​ 高保真度模型，低保真度模型</p>
<ul>
<li><p>模型复杂度和性能的关系：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220919160736180.png" style="zoom:67%;" /></p></li>
<li><p>模型简化思路 P119</p></li>
<li><p>代理模型的建立 P121</p></li>
<li><p>机理数据融合模型 —— 灰箱模型 P122</p>
<ul>
<li>不同的融合思路 —— P123</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>⓾ 课程笔记</category>
        <category>电子信息工程数学模型与方法</category>
      </categories>
      <tags>
        <tag>course</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap7 Mysql 字符集底层原理，用户与权限管理</title>
    <url>/2022/09/13/50a88c64ec31/</url>
    <content><![CDATA[<h3 id="一字符集与底层原理">一、字符集与底层原理</h3>
<p>mysql5.7默认server字符集为 latin，不支持中文</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%character%&#x27;;</span><br></pre></td></tr></table></figure>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220913152542290.png" /></p>
<ul>
<li>当创建数据库时不显示地指定字符集，则继承mysql服务器的默认字符集</li>
<li>当创建数据表时不显示地指定字符集，则继承所在数据库的默认字符集</li>
</ul>
<h4 id="已有库表的字符集修改">已有库表的字符集修改：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table emp1 convert to character set &#x27;utf8&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="各级别的字符集">各级别的字符集：</h4>
<ul>
<li>服务器级别 character_set_server</li>
<li>数据库级别 character_set_database</li>
<li>表级别</li>
<li>列级别</li>
</ul>
<h4 id="字符集和比较规则">字符集和比较规则</h4>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220913221630290.png" /></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220913221612265.png" /></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220913221723119.png" /></p>
<h4
id="请求到响应过程中字符集的变化">请求到响应过程中字符集的变化：</h4>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220914222210985.png" /></p>
<p><strong>这个过程中涉及到三个变量：</strong></p>
<p>character_set_client 和 character_set_connection 和
character_set_results</p>
<p><strong>一般来说客户端：类unix操作系统使用utf8编码，windows使用gbk编码</strong></p>
<p><strong>开发中通常把上述三个系统变量设置成和客户端使用的字符集一致的情况，这样就减少了很多无谓的字符集转换</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET NAMES utf8mb4</span><br></pre></td></tr></table></figure>
<h3 id="二sql大小写规范">二、SQL大小写规范</h3>
<ul>
<li>MySQL在windows下是大小写不敏感的</li>
<li>MySQL在Linux下数据库名、表名、列名、别名大小写规则是这样的：
<ul>
<li>1、数据库名、表名、表的别名、变量名是严格区分大小写的；</li>
<li>2、关键字、函数名称在SQL中不区分大小写；</li>
<li>3、列名（或字段名）与列的别名（或字段别名）在所有的情况下均是忽略大小写的；</li>
</ul></li>
</ul>
<h3 id="三sql编写建议">三、SQL编写建议：</h3>
<ul>
<li>关键字和函数名称<strong>全部大写</strong></li>
<li>数据库名、表名、表别名、字段名、字段别名等<strong>全部小写</strong></li>
<li>SQL语句必须以分号结尾</li>
</ul>
<h3 id="四sql_mode的合理设置">四、SQL_MODE的合理设置：</h3>
<p>​ 其会影响支持的SQL语法以及它执行的数据验证检查。</p>
<h4 id="宽松模式-严格模式">1、宽松模式 &amp; 严格模式</h4>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-06%2009.25.12.png" /></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-06%2009.25.57.png" /></p>
<p><strong>虽然MYSQL等数据库总想把关于数据库的所有操作都自己包揽下来，包括数据的校验等等，但是其实有些校验最好在开发层完成</strong></p>
<h3 id="五数据库在文件系统中的表示">五、数据库在文件系统中的表示：</h3>
<h4 id="innodb存储引擎模式">1、Innodb存储引擎模式</h4>
<h5 id="表结构">1） 表结构：</h5>
<p>​ 为了保存表结构， InnoDB
在数据目录下对应的数据库子目录下创建了一个专门<strong>用于描述表结构的文件</strong>，文件名是这样，该文件以二进制格式存储</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">表名.frm</span><br></pre></td></tr></table></figure>
<h5 id="表中数据和索引">2）表中数据和索引：</h5>
<ul>
<li>系统表空间：
<ul>
<li>默认情况下，InnoDB会在数据目录下创建一个名为ibdata1 、大小为12M
的文件，这个文件就是对应的系统表空间在文件系统上的表示。注意这个文件是自扩展文件，当不够用的时候它会自己增加文件大小。</li>
</ul></li>
<li>独立表空间：
<ul>
<li>在mysql5.6以后，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是<strong>为每一个表建立一个独立表空间</strong>，也就是说我们创建了多少个表，就有多少个独立表空间。使用独立表空间来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同，只不过添加了一个.ibd
的扩展名而已，所以完整的文件名称长这样：</li>
</ul></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">表名.ibd</span><br></pre></td></tr></table></figure>
<h4 id="myisam存储引擎模式">2、MyISAM存储引擎模式：</h4>
<h5 id="表结构与innodb一致">1）表结构：与Innodb一致</h5>
<h5 id="表中数据和索引-1">2）表中数据和索引：</h5>
<p>​
在MyISAM中的索引全部都是二级索引，该<strong>存储引擎的数据和索引是分开存放的</strong>。假如test表使用MyISAM存储引擎的话，那么在它所在数据库对应的atguigu
目录下会为test 表创建这三个文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test.frm 存储表结构</span><br><span class="line">test.MYD 存储数据 (MYData)</span><br><span class="line">test.MYI 存储索引 (MYIndex)</span><br></pre></td></tr></table></figure>
<h3 id="六用户和权限管理">六、用户和权限管理：</h3>
<h4 id="创建修改与删除用户">1、创建、修改与删除用户</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE USER &#x27;kangshifu&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE mysql.user SET USER=&#x27;li4&#x27; WHERE USER=&#x27;wang5&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP USER &#x27;kangshifu&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure>
<h4 id="密码相关策略内容">2、密码相关策略内容</h4>
<ul>
<li>使用root用户登录Mysql后，可以这样修改自己的密码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET PASSWORD=&#x27;new_password&#x27;;</span><br></pre></td></tr></table></figure>
<ul>
<li>修改其他用户密码：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET PASSWORD FOR &#x27;username&#x27;@&#x27;hostname&#x27;=&#x27;new_password&#x27;;</span><br></pre></td></tr></table></figure>
<ul>
<li>密码过期策略：</li>
</ul>
<p>​
在MySQL中，数据库管理员可以手动设置账号密码过期，也可以建立一个自动密码过期策略。过期策略可以是全局的，也可以为每个账号设置单独的过期策</p>
<ul>
<li>密码重用策略：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET PERSIST password_history = 6; #设置不能选择最近使用过的6个密码</span><br><span class="line">SET PERSIST password_reuse_interval = 365; #设置不能选择最近一年内的密码</span><br></pre></td></tr></table></figure>
<h4 id="权限列表种类">3、权限列表种类：</h4>
<ul>
<li>Mysql的权限种类：
<ul>
<li>CREATE和DROP 创建删除数据库和表</li>
<li>SELECT、INSERT、UPDATE和DELETE 在数据库现有表上操作</li>
<li>SELECT 检索权限</li>
<li>INDEX 允许创建或删除索引</li>
<li>ALTER 更改表结构和重命名</li>
<li>GRANT 允许授权给其他用户</li>
</ul></li>
<li>授予权限的原则：
<ul>
<li>只授予满足需要的最小权限</li>
<li>创建用户时限制登陆主机IP</li>
</ul></li>
<li>授予权限方式有两种
<ul>
<li>把角色赋予给用户授权</li>
<li>直接给用户授权</li>
</ul></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT 权限1,权限2,…权限n ON 数据库名称.表名称 TO 用户名@用户地址 [IDENTIFIED BY ‘密码口令’];</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW GRANTS FOR &#x27;user&#x27;@&#x27;主机地址&#x27;;</span><br></pre></td></tr></table></figure>
<ul>
<li>收回权限</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REVOKE 权限1,权限2,…权限n ON 数据库名称.表名称 FROM 用户名@用户地址;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#收回全库全表的所有权限</span><br><span class="line">REVOKE ALL PRIVILEGES ON *.* FROM joe@&#x27;%&#x27;;</span><br><span class="line">#收回mysql库下的所有表的插删改查权限</span><br><span class="line">REVOKE SELECT,INSERT,UPDATE,DELETE ON mysql.* FROM joe@localhost;</span><br></pre></td></tr></table></figure>
<h4 id="权限表">4、权限表</h4>
<h5 id="user表">1）User表</h5>
<p>​
记录用户账号和权限信息，分为用户列、权限列、安全列、资源控制列（限制用户使用的资源，比如每小时允许执行的查询操作次数等）</p>
<h5 id="db表">2）db表</h5>
<p>​
DB表中存储了用户对某个数据库的操作权限,决定用户能从哪个数据库中存取</p>
<h5
id="tables_priv表和columns_priv表">3）tables_priv表和columns_priv表</h5>
<p>​
tables_priv表用来对表设置操作权限，columns_priv表用来对表的某一列设置权限</p>
<h5 id="procs_priv表">4）procs_priv表：</h5>
<p>​ procs_priv表可以对存储过程和存储函数设置操作权限</p>
<h4 id="访问控制">5、访问控制：</h4>
<ul>
<li>连接核实阶段</li>
</ul>
<p>​
服务器<strong>只有在user表记录的Host和User字段匹配客户端主机名和用户名，并且提供正确的密码时才接受连接</strong>。如果连接核实没有通过，服务器就完全拒绝访问；否则，服务器接受连接，然后进入请求核实阶段等待用户请求。</p>
<ul>
<li>请求核实阶段</li>
</ul>
<p>​
对此连接上进来的每个请求，服务器检查该请求要执行什么操作、是否有足够的权限来执行它，这正是需要授权表中的权限列发挥作用的地方。这些权限可以来自user、db、table_priv和column_priv表。</p>
<p>​
确认权限时，MySQL<strong>首先检查user表</strong>，如果指定的权限没有在user表中被授予，那么MySQL就会<strong>继续检查db表</strong>，db表是下一安全层级，其中的权限限定于数据库层级，在该层级的SELECT权限允许用户查看指定数据库的所有表中的数据；如果在该层级没有找到限定的权限，则MySQL<strong>继续检查tables_priv表以及columns_priv表</strong>，如果所有权限表都检查完毕，但还是没有找到允许的权限操作，MySQL将返回错误信息，用户请求的操作不能执行，操作失败。</p>
<h4 id="角色管理">6、角色管理</h4>
<ul>
<li><p>创建角色、给角色赋予权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE ROLE &#x27;role_name&#x27;[@&#x27;host_name&#x27;] [,&#x27;role_name&#x27;[@&#x27;host_name&#x27;]]...</span><br><span class="line"># 创建角色之后，默认这个角色是没有任何权限的，我们需要给角色授权。给角色授权的语法结构是</span><br><span class="line">GRANT privileges ON table_name TO &#x27;role_name&#x27;[@&#x27;host_name&#x27;];</span><br><span class="line"># 上述语句中privileges代表权限的名称，多个权限以逗号隔开</span><br><span class="line"># 查看角色权限：</span><br><span class="line">SHOW GRANTS FOR &#x27;manager&#x27;;</span><br><span class="line"># 只要你创建了一个角色，系统就会自动给你一个“ USAGE ”权限，意思是连接登录数据库的权限。</span><br></pre></td></tr></table></figure></li>
<li><p>回收角色权限、删除角色</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 角色授权后，可以对角色的权限进行维护，对权限进行添加或撤销。添加权限使用GRANT语句，与角色授权相同。撤销角色或角色权限使用REVOKE语句。撤销角色</span><br><span class="line">REVOKE privileges ON tablename FROM &#x27;rolename&#x27;;</span><br><span class="line"># 删除角色</span><br><span class="line">DROP ROLE role [,role2]...</span><br></pre></td></tr></table></figure></li>
<li><p>给用户赋予角色</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 角色创建并授权后，要赋给用户并处于激活状态才能发挥作用</span><br><span class="line">GRANT role [,role2,...] TO user [,user2,...];</span><br></pre></td></tr></table></figure></li>
<li><p>激活角色</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET DEFAULT ROLE ALL TO user@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure></li>
<li><p>撤销角色</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REVOKE role FROM user</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>数据库精简笔记</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap5 Mysql 视图，存储过程与函数</title>
    <url>/2022/09/12/108274e25ef3/</url>
    <content><![CDATA[<h3 id="一视图">一、视图</h3>
<p>​
<strong>视图一方面可以帮我们使用表的一部分而不是所有的表，另一方面也可以针对不同的用户制定不同的查
询视图。比如，针对一个公司的销售人员，我们只想给他看部分数据，而某些特殊的数据，比如采购的
价格，则不会提供给他。再比如，人员薪酬是个敏感的字段，那么只给某个级别以上的人员开放，其他
人的查询视图中则不提供这个字段。</strong></p>
<ul>
<li><p>视图是一种虚拟表，本身是不具有数据的，占用很少的内存空间</p></li>
<li><p>视图建立在已有表的基础上, 视图赖以建立的这些表称为基表</p></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220912195718829.png" /></p>
<ul>
<li><p>视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和
修改操作时，数据表中的数据会相应地发生变化，反之亦然。</p></li>
<li><p>视图，是向用户提供基表数据的另一种表现形式。<strong>通常情况下，小型项目的数据库可以不使用视
图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，它可以帮助我
们把经常查询的结果集放到虚拟表中，提升使用效率。理解和使用起来都非常方便</strong></p></li>
</ul>
<h3 id="二创建视图">二、创建视图：</h3>
<ul>
<li>创建单表视图</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW empvu80</span><br><span class="line">AS</span><br><span class="line">SELECT employee_id, last_name, salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id = 80;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建多表联合视图：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW empview</span><br><span class="line">AS</span><br><span class="line">SELECT employee_id emp_id,last_name NAME,department_name</span><br><span class="line">FROM employees e,departments d</span><br><span class="line">WHERE e.department_id = d.department_id;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以利用视图来对数据进行格式化：</li>
</ul>
<p>​
比如我们想输出员工姓名和对应的部门名，对应格式为emp_name(department_name)，就可以使用视图来完成数据格式化的操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW emp_depart</span><br><span class="line">AS</span><br><span class="line">SELECT CONCAT(last_name,&#x27;(&#x27;,department_name,&#x27;)&#x27;) AS emp_dept</span><br><span class="line">FROM employees e JOIN departments d</span><br><span class="line">WHERE e.department_id = d.department_id</span><br></pre></td></tr></table></figure>
<h3 id="三更新视图的数据">三、更新视图的数据</h3>
<p>​
支持使用INSERT、UPDATE和DELETE语句对视图中的数据进行插入、更新和删除操作</p>
<h4 id="关于一些不可更新的视图">关于一些不可更新的视图</h4>
<p>​
要使视图可更新，视图中的行和底层基本表中的行之间必须存在一对一的关系。另外当视图定义出现如
下情况时，视图不支持更新操作：</p>
<ul>
<li>在定义视图的时候指定了“ALGORITHM =
TEMPTABLE”，视图将不支持INSERT和DELETE操作；</li>
<li>视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT操作；</li>
<li>在定义视图的SELECT语句中使用了JOIN联合查询，视图将不支持INSERT和DELETE操作；</li>
<li>在定义视图的SELECT语句后的字段列表中使用了数学表达式或子查询，视图将不支持INSERT，也</li>
<li>不支持UPDATE使用了数学表达式、子查询的字段值；</li>
<li>在定义视图的SELECT语句后的字段列表中使用DISTINCT 、聚合函数、GROUP
BY 、HAVING 、 UNION 等，视图将不支持INSERT、UPDATE、DELETE；</li>
<li>在定义视图的SELECT语句中包含了子查询，而子查询中引用了FROM后面的表，视图将不支持
INSERT、UPDATE、DELETE；</li>
<li>视图定义基于一个不可更新视图</li>
<li>常量视图</li>
</ul>
<h3 id="四视图的优缺点与总结">四、视图的优缺点与总结：</h3>
<ul>
<li>优点</li>
</ul>
<p>1、操作简单，<strong>将经常使用的查询操作定义为视图，开发人员不需要关心视图对应的数据表的结构、表与表之间的关联关系等</strong></p>
<p>2、减少数据冗余，其存储的是查询语句，本身不存储数据</p>
<p>3、数据安全，将用户对数据的访问限制在某些数据的结果集上，具有一定的隔离性。</p>
<p>4、适应多变的需求，分解复杂的查询逻辑。可以先将复杂的逻辑查询分解，创建多个视图，再将这多个视图结合起来，完成复杂的查询逻辑。</p>
<ul>
<li>缺点：</li>
</ul>
<p>1、如果实际数据表的结构变更了，我们就需要及时对相关的视图进行相应的维护。特别是嵌套的视图（就是在视图的基础上创建视图），维护会变得比较复杂，
可读性不好，容易变成系统的潜在隐患。因为创建视图的 SQL
查询可能会对字段重命名，也可能包含复杂的逻辑，这些都会增加维护的成本。</p>
<h3 id="五存储过程与函数">五、存储过程与函数：</h3>
<ul>
<li>存储过程就是一组经过预先编译的 SQL 语句的封装。</li>
<li>执行过程：存储过程预先存储在 MySQL
服务器上，需要执行的时候，客户端只需要向服务器端发出调用
存储过程的命令，服务器端就可以把预先存储好的这一系列 SQL
语句全部执行。</li>
</ul>
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>数据库精简笔记</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap6 Mysql 变量与游标.触发器</title>
    <url>/2022/09/12/2c85f3f81b49/</url>
    <content><![CDATA[<h3 id="一系统变量">一、系统变量：</h3>
<p>​
系统变量由系统定义，不是用户定义，属于服务器层面。启动MySQL服务，生成MySQL服务实例期间，
MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特
征。这些系统变量的值要么是编译MySQL时参数的默认值，要么是配置文件（例如my.ini等）中的参数
值。</p>
<h4
id="全局系统变量-global关键字-会话系统变量-session关键字">1、全局系统变量
global关键字 &amp; 会话系统变量 session关键字</h4>
<p>​
每一个MySQL客户机成功连接MySQL服务器后，都会产生与之对应的会话Session。会话期间，MySQL服务实例会在MySQL服务器内存中生成与该会话对应的<strong>会话系统变量</strong>，这些会话系统变量的初始值是全局系统变
量值的复制。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220912221138151.png" /></p>
<ul>
<li><p>全局系统变量针对于所有会话（连接）有效，<strong>但不能跨重启</strong></p></li>
<li><p>会话1对某个全局系统变量值的修改会导致会话2中同一个全局系统变量值的修改</p></li>
</ul>
<p>​ <strong>在MySQL中有些系统变量只能是全局的，例如 max_connections
用于限制服务器的最大连接数；有些系
统变量作用域既可以是全局又可以是会话，例如 character_set_client
用于设置客户端的字符集；有些系 统变量的作用域只能是当前会话，例如
pseudo_thread_id 用于标记当前会话的 MySQL 连接 ID</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看所有全局变量</span><br><span class="line">SHOW GLOBAL VARIABLES;</span><br><span class="line">#查看所有会话变量</span><br><span class="line">SHOW SESSION VARIABLES;</span><br><span class="line">或</span><br><span class="line">SHOW VARIABLES;</span><br></pre></td></tr></table></figure>
<p>​ MySQL 中的系统变量以两个“@” 开头，其中“@<span class="citation"
data-cites="global">@global</span>”仅用于标记全局系统变量，“@<span
class="citation"
data-cites="session">@session</span>”仅用于标记会话系统变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看指定的系统变量的值</span><br><span class="line">SELECT @@global.变量名;</span><br><span class="line">#查看指定的会话变量的值</span><br><span class="line">SELECT @@session.变量名;</span><br><span class="line">#或者</span><br><span class="line">SELECT @@变量名;</span><br><span class="line"></span><br><span class="line">#为某个全局变量赋值</span><br><span class="line">#方式1</span><br><span class="line">SET @@global.变量名=变量值;</span><br><span class="line">#方式2：</span><br><span class="line">SET GLOBAL 变量名=变量值;</span><br><span class="line">#为某个会话变量赋值</span><br><span class="line">#方式1：</span><br><span class="line">SET @@session.变量名=变量值;</span><br><span class="line">#方式2：</span><br><span class="line">SET SESSION 变量名=变量值;</span><br></pre></td></tr></table></figure>
<h4 id="会话用户变量与局部变量">2、会话用户变量与局部变量：</h4>
<ul>
<li>会话用户变量：作用域和会话变量一样，只对当前连接会话有效。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#方式1：“=”或“:=”</span><br><span class="line">SET @用户变量 = 值;</span><br><span class="line">SET @用户变量 := 值;</span><br><span class="line">#方式2：“:=” 或 INTO关键字</span><br><span class="line">SELECT @用户变量 := 表达式 [FROM 等子句];</span><br><span class="line">SELECT 表达式 INTO @用户变量 [FROM 等子句];</span><br></pre></td></tr></table></figure>
<ul>
<li>局部变量：只在 BEGIN 和 END
语句块中有效。局部变量只能在存储过程和函数中使用。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">#声明局部变量</span><br><span class="line">DECLARE 变量名1 变量数据类型 [DEFAULT 变量默认值];</span><br><span class="line">DECLARE 变量名2,变量名3,... 变量数据类型 [DEFAULT 变量默认值];</span><br><span class="line">#为局部变量赋值</span><br><span class="line">SET 变量名1 = 值;</span><br><span class="line">SELECT 值 INTO 变量名2 [FROM 子句];</span><br><span class="line">#查看局部变量的值</span><br><span class="line">SELECT 变量1,变量2,变量3;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<h3 id="二游标">二、游标</h3>
<p>​
游标，提供了一种灵活的操作方式，让我们能够对结果集中的每一条记录进行定位，并对指向的记录中的数据进行操作的数据结构。游标让
SQL 这种面向集合的语言有了面向过程开发的能力。</p>
<p>​
游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标充当了指针的作用，我们可以通过操作游标来对数据行进行操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE get_count_by_limit_total_salary(IN limit_total_salary DOUBLE,OUT</span><br><span class="line">total_count INT)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE sum_salary DOUBLE DEFAULT 0; #记录累加的总工资</span><br><span class="line">DECLARE cursor_salary DOUBLE DEFAULT 0; #记录某一个工资值</span><br><span class="line">DECLARE emp_count INT DEFAULT 0; #记录循环个数</span><br><span class="line">#定义游标</span><br><span class="line">DECLARE emp_cursor CURSOR FOR SELECT salary FROM employees ORDER BY salary DESC;</span><br><span class="line">#打开游标</span><br><span class="line">OPEN emp_cursor;</span><br><span class="line">REPEAT</span><br><span class="line">#使用游标（从游标中获取数据）</span><br><span class="line">FETCH emp_cursor INTO cursor_salary;</span><br><span class="line">SET sum_salary = sum_salary + cursor_salary;</span><br><span class="line">SET emp_count = emp_count + 1;</span><br><span class="line">UNTIL sum_salary &gt;= limit_total_salary</span><br><span class="line">END REPEAT;</span><br><span class="line">SET total_count = emp_count;</span><br><span class="line">#关闭游标</span><br><span class="line">CLOSE emp_cursor;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
<h3 id="三触发器">三、触发器</h3>
<p><strong>应用场景：</strong></p>
<p>​ 在实际开发中，我们经常会遇到这样的情况：有 2
个或者多个相互关联的表，如商品信息和库存信息分别存放在 2
个不同的数据表中，我们在添加一条新商品记录的时候，为了保证数据的完整性，必须同时在库存表中添加一条库存记录。
​
这样一来，我们就必须把这两个关联的操作步骤写到程序里面，而且要用事务包裹起来，确保这两个操作成为一个原子操作，要么全部执行，要么全部不执行。要是遇到特殊情况，可能还需要对数据进行手动维护，这样就很容易忘记其中的一步，导致数据缺失。
​
这个时候，咱们可以使用触发器。你可以创建一个触发器，让商品信息数据的插入操作自动触发库存数
据的插入操作。这样一来，就不用担心因为忘记添加库存数据而导致的数据缺失了。</p>
<p>​</p>
<p><strong>概述</strong>：</p>
<p>​ 触发器是由事件来触发某个操作，这些事件包括INSERT 、UPDATE 、DELETE
事件。所谓事件就是指
用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生
了，就会自动激发触发器执行相应的操作。</p>
<ul>
<li>优点：
<ul>
<li>触发器可以确保数据的完整性。</li>
<li>触发器可以帮助我们记录操作日志。</li>
<li>可以具体记录什么时间发生了什么。比如，记录修改会员储值金额的触发器，就是一个很
好的例子。这对我们还原操作执行时的具体场景，</li>
<li>触发器还可以用在操作数据前，对数据进行合法性检查。</li>
</ul></li>
<li>缺点：
<ul>
<li>着触发器有可能不受应用层的控制。这对系统维护是非常有挑战的。</li>
<li>相关数据的变更，可能会导致触发器出错。特别是数据表结构的变更，都可能会导致触发器出错，进而影响数据操作的正常运行。这些都会由于触发器本身的隐蔽性，影响到应用中错误原因排查的效率。</li>
</ul></li>
</ul>
<p><strong>注意</strong>：</p>
<p>​ 如果在子表中定义了外键约束，并且外键指定了ON UPDATE/DELETE
CASCADE/SET
NULL子句，此时修改父表被引用的键值或删除父表被引用的记录行时，也会引起子表的修改和删除操作，此时基于子表的UPDATE和DELETE语句定义的触发器并不会被激活。</p>
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>数据库精简笔记</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap4 Mysql 约束</title>
    <url>/2022/09/10/ee0ee8e192df/</url>
    <content><![CDATA[<h3 id="一约束">一、约束</h3>
<p>​ 约束是表级的强制规定,可以通过如下命令查看表的约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_schema.table_constraints</span><br><span class="line">WHERE table name=&#x27;’&#x27;表名称&#x27;；</span><br></pre></td></tr></table></figure>
<h3 id="二非空约束">二、非空约束</h3>
<p>​ 单列约束，不能组合非空值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test(</span><br><span class="line">	id INT NOT NULL,</span><br><span class="line">    email CHAR</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ALTER TABLE test</span><br><span class="line">MODIFY email CHAR NOT NULL;</span><br><span class="line"></span><br><span class="line">ALTER TABLE test</span><br><span class="line">MODIFY id INT NULL;</span><br></pre></td></tr></table></figure>
<h3 id="三唯一性约束">三、唯一性约束</h3>
<p>​ 单列约束，允许出现多个NULL值，可以多个列的组合唯一</p>
<ul>
<li>唯一性约束允许列值为空。</li>
<li>在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。</li>
<li><strong>MySQL会给唯一约束的列上默认创建一个唯一索引。</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE USER(</span><br><span class="line">    id INT NOT NULL,</span><br><span class="line">    CNAME VARCHAR(25) UNIQUE,  # 列级约束语法</span><br><span class="line">    NAME VARCHAR(25),</span><br><span class="line">    PASSWORD VARCHAR(16),</span><br><span class="line">    # 使用表级约束语法</span><br><span class="line">    CONSTRAINT uk_name_pwd UNIQUE(NAME,PASSWORD) # 用户名和密码组合不能重复</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>复合唯一约束</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table student_course(</span><br><span class="line">    id int,</span><br><span class="line">    sid int,</span><br><span class="line">    cid int,</span><br><span class="line">    score int,</span><br><span class="line">    unique key(sid,cid) #复合唯一</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="四主键约束">四、主键约束</h3>
<ul>
<li>主键约束相当于唯一约束+非空约束的组合，主键约束列不允许重复，也不允许出现空值。</li>
<li>主键约束对应着表中的一列或者多列（复合主键）</li>
<li>MySQL的主键名总是PRIMARY，就算自己命名了主键约束名也没用。</li>
<li>当创建主键约束时，系统默认会在所在的列或列组合上建立对应的主键索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE emp4(</span><br><span class="line">    id INT PRIMARY KEY AUTO_INCREMENT ,</span><br><span class="line">    NAME VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table student_course(</span><br><span class="line">    sid int,</span><br><span class="line">    cid int,</span><br><span class="line">    score int,</span><br><span class="line">    primary key(sid,cid) #复合主键</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">alter table 表名称 drop primary key;</span><br></pre></td></tr></table></figure>
<h3 id="五auto_increment">五、AUTO_INCREMENT</h3>
<ul>
<li>一个表最多只能有一个自增长列</li>
<li>当需要产生唯一标识符或顺序值时，可设置自增长</li>
<li>自增长列约束的列必须是键列（主键列，唯一键列）</li>
<li>自增约束的列的数据类型必须是整数类型</li>
<li>如果自增列指定了 0 和
null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接
赋值为具体值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名称(</span><br><span class="line">    字段名 数据类型 primary key auto_increment,</span><br><span class="line">    字段名 数据类型 unique key not null,</span><br><span class="line">    字段名 数据类型 unique key,</span><br><span class="line">    字段名 数据类型 not null default 默认值,</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注意：自增主键的持久化：</strong></p>
<p>​ 在MySQL 5.7系统中，对于自增主键的分配规则，是由InnoDB数据字典
内部一个 计数器 来决定的，而该计数器只在 内存中维护
，并不会持久化到磁盘中。当数据库重启时，该 计数器会被初始化。</p>
<p>​ MySQL 8.0将自增主键的计数器持久化到 重做日志
中。每次计数器发生改变，都会将其写入重做日志
中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值</p>
<h3 id="六外键约束">六、外键约束</h3>
<p><strong>从表的外键列，必须引用/参考主表的主键或唯一约束的列</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table dept( #主表</span><br><span class="line">    did int primary key, #部门编号</span><br><span class="line">    dname varchar(50) #部门名称</span><br><span class="line">);</span><br><span class="line">create table emp(#从表</span><br><span class="line">    eid int primary key, #员工编号</span><br><span class="line">    ename varchar(5), #员工姓名</span><br><span class="line">    deptid int, #员工所在的部门</span><br><span class="line">    foreign key (deptid) references dept(did) #在从表中指定外键约束</span><br><span class="line">    #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>约束等级</strong>：</p>
<ul>
<li>Cascade方式
：在父表上update/delete记录时，同步update/delete掉子表的匹配记录</li>
<li>Set null方式
：在父表上update/delete记录时，将子表上匹配记录的列设为null，但是要注意子
表的外键列不能为not null</li>
<li>No action方式
：如果子表中有匹配的记录，则不允许对父表对应候选键进行update/delete操作</li>
<li>Restrict方式 ：同no action， 都是立即检查外键约束</li>
<li>Set default方式
（在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置
成一个默认的值，但Innodb不能识别</li>
</ul>
<p><strong>对于外键约束，最好是采用: ON UPDATE CASCADE ON DELETE
RESTRICT 的方式。</strong></p>
<p><strong>在 MySQL
里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL
操作，有可能会不适 合。比如大型网站的中央数据库，可能会
因为外键约束的系统开销而变得非常慢 。所以， MySQL 允
许你不使用系统自带的外键约束，在 应用层面
完成检查数据一致性的逻辑。也就是说，即使你不
用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。</strong></p>
<p><strong>一些提示：【 强制
】不得使用外键与级联，一切外键概念必须在应用层解决。
说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的
student_id 则为外键。如果更新学 生表中的 student_id，同时触发成绩表中的
student_id 更新，即为级联更新。外键与级联更新适用于 单 机低并发 ，不适合
分布式 、 高并发集群 ；级联更新是强阻塞，存在数据库 更新风暴
的风险；外键影响 数据库的 插入速度 。</strong></p>
<h3 id="七检查约束与默认值约束">七、检查约束与默认值约束</h3>
<h4 id="check约束">1 CHECK约束</h4>
<p>​ 检查某个字段的值是否符合xx要求，一般指的是值的范围</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE temp(</span><br><span class="line">    id INT AUTO_INCREMENT,</span><br><span class="line">    NAME VARCHAR(20),</span><br><span class="line">    age INT CHECK(age &gt; 20),</span><br><span class="line">    PRIMARY KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="default-约束">2 DEFAULT 约束</h4>
<p>给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默
认值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名称(</span><br><span class="line">    字段名 数据类型 primary key,</span><br><span class="line">    字段名 数据类型 unique key not null,</span><br><span class="line">    字段名 数据类型 unique key,</span><br><span class="line">    字段名 数据类型 not null default 默认值,</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>一些问题</strong>：</p>
<ul>
<li>为什么不想要 null 的值
<ul>
<li>1）不好比较。null是一种特殊值，比较时只能用专门的is null 和 is not
null来比较。碰到运算符，通 常返回null。</li>
<li>2）效率不高。影响提高索引效果。因此，我们往往在建表时 not null
default '' 或 default 0</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>数据库精简笔记</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>2022-2023秋冬大计基答疑整理——沈睿班</title>
    <url>/2022/09/09/66d597ae86a9/</url>
    <content><![CDATA[<h2 id="使用指南">1、使用指南：</h2>
<h3
id="如何在本文档内搜索相关问题">1）如何在本文档内搜索相关问题？：</h3>
<ul>
<li><strong>方法1</strong>：使用博客上方内置的<strong>搜索功能</strong>，点击搜索后，输入相关关键词即可。<strong>需要注意的是，由于本文档是基于整个博客进行更新的，所以该搜索功能是在整个博客内进行搜索，请从中找到本篇文章，即《2022-2023秋冬大计基答疑整理—沈睿班》的搜索结果进入即可</strong>，如果没有本篇文章的搜索结果即代表没有相关内容。如果对其他博文感兴趣也可以随意浏览。</li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220908105925826.png" style="zoom:67%;" /></p>
<ul>
<li><strong>方法2</strong>：以firefox浏览器为例，在浏览器中打开本网页后，按<strong>CTRL+F</strong>键,会看到浏览器底部会出现如下搜索栏,在左侧"在此页面中查找"处输入你想要搜索的内容即可进行相关内容的搜索。其他不同浏览器的搜索框使用方法可以访问如下链接：https://www.163.com/dy/article/H6K7CURU0552EUN3.html</li>
</ul>
<h3
id="如果对本文档内容有所疑问如何提出">2）如果对本文档内容有所疑问如何提出？：</h3>
<p>​
如果你发现本文档内有问答有错误或不严谨的地方，你可以通过以下方法提出</p>
<ul>
<li><p><strong>方法1</strong>：你可以直接截图发至钉钉群内，<span
class="citation"
data-cites="助教提出你的疑问">@助教提出你的疑问</span>。</p></li>
<li><p><strong>方法2</strong>：使用博客页面下方内置的评论功能，此功能需要你先注册<a
href="https://github.com">github</a>账号，随后以github账号登录进行评论。评论后助教会进行更正或以同样形式回答。</p></li>
</ul>
<h3 id="其他便捷功能">3）其他便捷功能：</h3>
<ul>
<li>1、你可以使用左侧的导航栏帮助你快速定位你所在的问题目录</li>
<li>2、你可以通过点击左侧导航栏下方的"叉叉"图标，来关闭左侧导航栏。</li>
<li>3、你可以通过点击左侧导航栏下方的"箭头"图标，来快速返回至该文档的最上方。箭头图标旁的百分比代表你目前正在浏览的部分是整份文档的何处位置。</li>
</ul>
<h2 id="正文">2、正文：</h2>
<h3
id="问1vmware官网哪里点进去有软件下载">问1：vmware官网哪里点进去有软件下载？</h3>
<ul>
<li>https://customerconnect.vmware.com/downloads/#all_products</li>
</ul>
<hr />
<h3
id="问2window10的iso镜像文件哪里可以下载">问2：window10的iso镜像文件哪里可以下载？</h3>
<ul>
<li><p>需要校园网内网访问，是学校的官方软件平台</p></li>
<li><p>http://download.ms.zju.edu.cn/SW_DVD9_Win_Pro_10_21H1_64BIT_ChnSimp_Pro_Ent_EDU_N_MLF_X22-55090.ISO</p></li>
</ul>
<hr />
<h3
id="问3安装vmware时出现如下错误">问3：安装VMWare时出现如下错误：</h3>
<p>写入文件时 DIFXAPI.dll时出错，请确认您有访问该目录的权限</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220918171424902.png" /></p>
<ul>
<li>一般这种情况是因为你电脑上开着一些杀毒软件导致的，比如说360安全卫士，电脑管家这种，可以先关闭杀毒软件后尝试安装。</li>
</ul>
<hr />
<h3
id="问4绑定pta账号时绑定码是多少">问4：绑定PTA账号时，绑定码是多少？</h3>
<ul>
<li>不同时间的班不一样，见下：
<ul>
<li>周四1、2节：248374</li>
<li>周四3、4节：717242</li>
<li>周四7、8节：834958</li>
</ul></li>
</ul>
<hr />
<h3
id="问5判断题计算机存储模式规定存储单元以位bit为单位8个二进制位构成1个字节byte">问5：判断题：计算机存储模式规定，存储单元以位（bit）为单位，8个二进制位构成1个字节（Byte）。</h3>
<ul>
<li>答案：错误。存储单元以字节为单位，即Byte</li>
</ul>
<hr />
<h3
id="问6判断题高速缓存器cache介于cpu与主存之间用于解决内存与外存的速度匹配问题以提高存储速度">问6：判断题：高速缓存器Cache介于CPU与主存之间，用于解决内存与外存的速度匹配问题，以提高存储速度。</h3>
<ul>
<li>答案：错误。不是为了解决内存与外存的速度匹配问题，而是为了解决内存和CPU的速度匹配问题。因为现代CPU频率比较高，内存的发展跟不上CPU访问主存的速度，这样的话把CPU最有可能访问的数据放在cache中，CPU可以在很短的时间内得到数据</li>
</ul>
<hr />
<h3
id="问7如果某一计算机的内存单元总共可存储256个字节的容量则这些内存单元的地址编号可以从1000hh表示16进制到h">问7：如果某一计算机的内存单元总共可存储256个字节的容量，则这些内存单元的地址编号可以从1000H（H表示16进制）到（）H。</h3>
<ul>
<li>答案：10FFH。这一类题目涉及到十六进制运算，搞清楚这块的计算就可以应付许多题目。首先你需要学会16进制和10进制的转换。即
十进制的256，在16进制中是多少？答案是100H.所以，内存的地址编号应该就是从1000H
+ 100H - 1 = 10FFH.</li>
<li>题外话：在一些其他题目中，注意区分字节和位，字节是Byte，位是bit，简写一个是B，一个是b。1Byte
= 8bit</li>
</ul>
<hr />
<h3
id="问8某系统的进程状态如下图所示其中3表示等待某个事件1表示进程被选中问a是_状态2表示____________c表示___________">问8：某系统的进程状态如下图所示，其中3表示等待某个事件，1表示进程被选中，问：a是_<strong><em>状态，2表示</em></strong>____________，c表示___________。</h3>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221019185521467.png" /></p>
<ul>
<li>答案：运行，时间片到，等待I/O</li>
<li>分析：这个是考察进程的状态转移的一道题目，大家可以通过熟悉下图来完成相关的题目。下图是详细版的一个进程状态转移的说明。值得注意的是：</li>
<li>运行态→阻塞态是一种进程自身做出的<strong>主动行为</strong></li>
<li>阻塞态→就绪态是不是进程自身能控制的，是一种<strong>被动行为</strong>。</li>
<li>注意：<strong>不能由阻塞态直接转换为运行态</strong>，<strong>也不能由就绪态直接转换为阻塞态</strong>（因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221019185634225.png" /></p>
<hr />
<h3
id="问9在windows中用户使用______管理硬件资源设置">问9：在Windows中，用户使用（______）管理硬件资源设置。</h3>
<ul>
<li>答案：控制面板.</li>
</ul>
<hr />
<h3
id="问10以下关于浮点数的描述_____________是正确的">问10：以下关于浮点数的描述，_____________是正确的</h3>
<p>A. 符号位用来决定阶码是正的还是负的</p>
<p>B.小数点是以二进制1的形式保存在尾数中的</p>
<p>C.对于一个32位的浮点数来说,阶码的位数与尾数的位数并不是固定的</p>
<p>D.若阶码的值=n,则尾数乘以2的n次方就是该浮点数的大小</p>
<ul>
<li>答案：D.</li>
<li>解析：A 符号位决定的是浮点数本身是正还是负，而不是决定阶码的政府。B.
明显错误 C.
单精度（32位）浮点数。占用4个字节（32位）存储空间，包括符号位1位，阶码8位，尾数23位，都是固定的位数。D.
正确的</li>
</ul>
<hr />
<h3
id="问11实现汉字字形表示的方法一般可分为______两大类">问11：实现汉字字形表示的方法，一般可分为______两大类。</h3>
<ul>
<li>答案：点阵与曲线（轮廓），曲线（轮廓）
实际上就是矢量的表现形式，所以实现汉字字形表示的方法可以分为点阵与矢量
或者说 点阵与曲线轮廓 都可以<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221103145458857.png" /></li>
</ul>
<hr />
<h3
id="问12以下哪种存储介质具有较大的存储容量">问12：以下哪种存储介质具有较大的存储容量?</h3>
<p>A.floppy diskette</p>
<p>B.cd(compact disc)</p>
<p>C.dvd(digital video disc)</p>
<p>D.blu-ray disc</p>
<p>答案：D.</p>
<p>A为<strong>软盘</strong>（Floppy Disk)，是一种<a
href="https://zh.wikipedia.org/wiki/碟盤存儲">碟盘存储</a>，主要部分是一张薄软的<a
href="https://zh.wikipedia.org/wiki/磁儲存">磁存储</a><a
href="https://zh.wikipedia.org/wiki/介质">介质</a>盘片，盘片封装在矩形塑料壳中，内衬有用于清理灰尘的纤维织物。读写软盘需要借助软盘驱动器（英语：floppy
disk drive，简称 <strong>FDD</strong>）。</p>
<p>第一个软盘是由<a
href="https://zh.wikipedia.org/wiki/IBM">IBM</a>于1971年开发出的，直径8<a
href="https://zh.wikipedia.org/wiki/吋">吋</a>。随着硬件技术的发展与使用的需要，又派生出5.25吋的软盘，并广泛使用在<a
href="https://zh.wikipedia.org/wiki/Apple_II">Apple II</a>、<a
href="https://zh.wikipedia.org/wiki/IBM_PC">IBM
PC</a>及其他兼容电脑上。苹果1984年在Mac机开始采用3.5吋软盘，此时容量还不到1MB，后来，由日本<a
href="https://zh.wikipedia.org/wiki/索尼">索尼</a>的3.5吋软盘片容量有1.44MB所取代，这种软盘片80至90年代盛行，在20世纪后期3.5吋软盘驱动器仍是电脑普及设备之一，但是在进入21世纪后后逐渐过时并被淘汰</p>
<p>B为<strong>激光唱片</strong>（英语：<strong>C</strong>ompact
<strong>D</strong>isc，缩写：<strong>CD</strong>）是一种用以存储数字资料的<a
href="https://zh.wikipedia.org/wiki/光學碟片">光学盘片</a>，原被开发用作存储<a
href="https://zh.wikipedia.org/wiki/數位音訊">数字音频</a>。CD在1982年面世，至今仍然是商业录音的标准<a
href="https://zh.wikipedia.org/wiki/儲存裝置">存储设备</a>。</p>
<p>CD的基本规格（根据1983年9月的Audio-CD 标准红皮书）：</p>
<ul>
<li>扫描速度：1.2–1.4 m/s，固定线速度/<a
href="https://zh.wikipedia.org/wiki/CLV">CLV</a>（Constant Linear
Velocity）- 约相等于碟内环每分钟500转，碟外环每分钟200转。</li>
<li>读写速度：1X = 150 KiB/s = 153,600 Bytes/s</li>
<li>容量：700MB</li>
</ul>
<p>C为<strong>数字多功能光盘</strong>（英语：<strong>D</strong>igital
<strong>V</strong>ersatile
<strong>D</strong>isc，缩写：<strong>DVD</strong>）是一种<a
href="https://zh.wikipedia.org/wiki/光碟">光盘</a>存储媒体，通常用来播放<a
href="https://zh.wikipedia.org/wiki/標清">标清</a>（标准解晰度）的<a
href="https://zh.wikipedia.org/wiki/電影">电影</a>，高清音质的<a
href="https://zh.wikipedia.org/wiki/音樂">音乐</a>与大容量存储资料用途。DVD与<a
href="https://zh.wikipedia.org/wiki/CD">CD</a>或<a
href="https://zh.wikipedia.org/wiki/藍光光碟">蓝光光盘</a>（Blu-ray
Disc）的外观极为相似，直径有80mm、120mm规格等。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221121142748993.png" /></p>
<p>D为<strong>蓝光光盘</strong>（英语：<strong>B</strong>lu-ray
<strong>D</strong>isc，缩写：<strong>BD</strong>）是<a
href="https://zh.wikipedia.org/wiki/DVD">DVD</a>之后的下一代<a
href="https://zh.wikipedia.org/wiki/光碟">光盘</a>格式之一，用以存储高质量的影音以及高容量的资料。</p>
<p>最终：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221121142841827.png" /></p>
<hr />
<h3
id="问13要查看设置修改显示器分辨率可以从___________进入谁">问13：要查看设置修改显示器分辨率，可以从___________进入谁。。</h3>
<ul>
<li>答案：windows桌面的空白地方右键弹出的菜单中点击“显示设置（D）”</li>
</ul>
<hr />
<h3
id="问14windows操作系统通过________管理接入的设备windows每一个设备都有一个________windows操作系统与设备之间的通信标准是________它用于规范电脑与外部设备的连接和通讯">问14：Windows操作系统通过________管理接入的设备，windows每一个设备都有一个________，windows操作系统与设备之间的通信标准是________，它用于规范电脑与外部设备的连接和通讯。。</h3>
<ul>
<li>答案：设备管理器、设备驱动、USB</li>
</ul>
]]></content>
      <categories>
        <category>⑩ 其他内容</category>
      </categories>
  </entry>
  <entry>
    <title>Chap3 Mysql DDL与DCL操作、增删改与数据类型</title>
    <url>/2022/09/07/60ff079d7c8c/</url>
    <content><![CDATA[<h3 id="一一些ddl与dcl操作">一、一些DDL与DCL操作：</h3>
<h4 id="数据库相关操作">1、数据库相关操作：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE mytest1 CHARACTER SET &#x27;utf8&#x27;;</span><br><span class="line">ALTER DATABASE mytest1 CHARACTER SET &#x27;utf8mb4&#x27;;</span><br><span class="line">DROP DATABASE IF EXISTS mytest1;  //删除数据库</span><br></pre></td></tr></table></figure>
<h4 id="数据表相关操作">2、数据表相关操作：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS myempl(</span><br><span class="line">id INT,</span><br><span class="line">emp_name VARCHAR(15),</span><br><span class="line">hire_date DATE); # 创建表</span><br><span class="line"></span><br><span class="line">DESC myempl;  # 查看表结构</span><br><span class="line"></span><br><span class="line"># 通过现有表建立新表，会导入现有表数据</span><br><span class="line">CREATE TABLE myemp3</span><br><span class="line">AS </span><br><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line"># 结合子查询，通过现有表执行</span><br><span class="line">CREATE TABLE myemp3</span><br><span class="line">AS </span><br><span class="line">SELECT e.employee_id emp_id,e.last_name lname,d.department name</span><br><span class="line">FROM employees e JOIN departments d</span><br><span class="line">ON e.department id = d. department id;</span><br><span class="line"></span><br><span class="line"># 修改表</span><br><span class="line"># ====== 添加一个字段 ====== </span><br><span class="line">ALTER TABLE myemp1</span><br><span class="line">ADD salary DOUBLE(10,2);  # 默认添加到表中的最后一个字段</span><br><span class="line"></span><br><span class="line">ALTER TABLE myemp1</span><br><span class="line">ADD salary DOUBLE(10,2) FIRST;  # 添加到表中的第一个字段</span><br><span class="line"></span><br><span class="line"># 修改一个字段</span><br><span class="line">ALTER TABLE myemp1</span><br><span class="line">MODIFY salary DOUBLE(10,2) DEFAULT &#x27;aaa&#x27;;  # 添加到表中的第一个字段</span><br><span class="line"></span><br><span class="line"># 重命名一个字段</span><br><span class="line">ALTER TABLE dept80</span><br><span class="line">CHANGE department_name dept_name varchar(15);</span><br><span class="line"></span><br><span class="line"># 删除一个字段</span><br><span class="line">ALTER TABLE myemp1 DROP salary</span><br><span class="line"></span><br><span class="line"># 重命名表</span><br><span class="line">RENAME TABLE myemp1</span><br><span class="line">TO myemp11</span><br><span class="line"></span><br><span class="line"># 删除表</span><br><span class="line">DROP TABLE myemp1 IF EXISTS</span><br><span class="line"></span><br><span class="line"># 清空表</span><br><span class="line">TRUNCATE TABLE myemp1;</span><br><span class="line">#【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 TRIGGER，有可能造成事故，故不建议在开发代码中使用此语句。</span><br></pre></td></tr></table></figure>
<h3 id="二ddl-和-dml的说明">二、DDL 和 DML的说明</h3>
<p>​ DDL的操作一旦执行，就不可回滚。</p>
<p>​
DML的操作默认情况，一旦执行，也是不可回滚的。但是，如果在执行DL之前，执行了SET
autocommit=FALSE，则执行的DML操作就可以实现回滚。</p>
<h3 id="三mysql8-ddl的原子化">三、MYSQL8 ——DDL的原子化：</h3>
<p>​
在MySQL8.0版本中，InnoDB表的DDL支持事务完整性，即DDL操作要么成功要么回滚。DDL操作回滚日志写入到data
dictionary数据字典表mysql.innodb_ddlIlog（该表是隐藏的表，通过show
tables无法看到）中，用于回滚操作。通过设置参数，可将DDL操作日志打印输出到MySQL错误日志中。</p>
<h3 id="四增删改">四、增删改</h3>
<h4 id="增">1、增</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO departments(department_id, department_name)</span><br><span class="line">VALUES (80, &#x27;IT&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO emp(emp_id,emp_name)</span><br><span class="line">VALUES (1001,&#x27;shkstart&#x27;),</span><br><span class="line">(1002,&#x27;atguigu&#x27;),</span><br><span class="line">(1003,&#x27;Tom&#x27;);</span><br><span class="line"></span><br><span class="line"># 通过SELECT来增加</span><br><span class="line">INSERT INTO sales_reps(id, name, salary, commission_pct)</span><br><span class="line">SELECT employee_id, last_name, salary, commission_pct</span><br><span class="line">FROM employees</span><br><span class="line">WHERE job_id LIKE &#x27;%REP%&#x27;;</span><br></pre></td></tr></table></figure>
<h4 id="删">2、删</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM departments</span><br><span class="line">WHERE department_name = &#x27;Finance&#x27;;</span><br></pre></td></tr></table></figure>
<h4 id="改">3、改</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE employees</span><br><span class="line">SET department_id = 70</span><br><span class="line">WHERE employee_id = 113;</span><br></pre></td></tr></table></figure>
<h4 id="mysql8-计算列">4、MYSQL8 计算列：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tb1(</span><br><span class="line">    id INT,</span><br><span class="line">    a INT,</span><br><span class="line">    b INT,</span><br><span class="line">    c INT GENERATED ALWAYS AS (a + b) VIRTUAL</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="五数据类型详解">五、数据类型详解：</h3>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220910112143456.png" style="zoom:67%;" /></p>
<h4 id="整型">1、整型</h4>
<ul>
<li><p>TINYINT 1字节
一般用于枚举数据，比如系统设定取值范围很小且固定的场景</p></li>
<li><p>SMALLINT 2字节
可以用于较小范围的统计数据，比如统计工厂的固定资产库存数量</p></li>
<li><p>MEDUIMINT 3字节 用于较大整数的计算，比如车站每日的客流量</p></li>
<li><p>INT4字节
取值范围足够大，一般情况下不用考虑超限问题，用得最多。比如商品编号</p></li>
<li><p>BIGINT 8字节
只有当你处理特别巨大的整数时才会用到。比如双十一的交易量、大型门户网站点击量、证
券公司衍生产品持仓等</p></li>
<li><p>可选属性</p>
<ul>
<li>UNSIGNED 无符号属性</li>
<li>ZEROFILL 零填充</li>
</ul></li>
</ul>
<h4 id="浮点类型">2、浮点类型</h4>
<ul>
<li>FLOAT</li>
<li>DOUBLE</li>
</ul>
<p>​
如果用到浮点数，要特别注意误差问题，因为浮点数是不准确的，所以我们要避免使用“=”来
​
判断两个数是否相等。同时，在一些对精确度要求较高的项目中，千万不要使用浮点数，不然会导致结
果错误，甚至是造成不可挽回的损失</p>
<h4 id="定点数类型">3、定点数类型：</h4>
<ul>
<li><p>DECIMAL(M,D)</p></li>
<li><p>表示高精度小数。其中，M被称为精度，D被称为标度。0&lt;=M&lt;=65，
0&lt;=D&lt;=30，D&lt;M。例如，定义DECIMAL（5,2）的类型，表示该列取值范围是-999.99~999.99。</p></li>
<li><p>DECIMAL
的存储空间并不是固定的，由精度值M决定，总共占用的存储空间为M+2个字节。也就是
说，在一些对精度要求不高的场景下，比起占用同样字节长度的定点数，浮点数表达的数值范围可
以更大一些。</p></li>
<li><p>定点数在MySQL内部是以字符串的形式进行存储，这就决定了<strong>它一定是精准的</strong>。</p></li>
</ul>
<h4 id="位类型">4、位类型</h4>
<ul>
<li>BIT(M)</li>
<li>如果没有指定(M)，默认是1位。这个1位，表示只能存1位的二进制值。这里(M)是表示二进制的
位数，位数最小值为1，最大值为64。</li>
</ul>
<h4 id="日期与时间类型">5、日期与时间类型</h4>
<ul>
<li><p>YEAR 类型通常用来表示年</p></li>
<li><p>DATE 类型通常用来表示年、月、日</p></li>
<li><p>TIME 类型通常用来表示时、分、秒</p></li>
<li><p>DATETIME 类型通常用来表示年、月、日、时、分、秒</p></li>
<li><p>TIMESTAMP 类型通常用来表示带时区的年、月、日、时、分、秒</p></li>
<li><p>DATETIME占用8个字节</p></li>
<li><p>TIMESTAMP占用4个字节，TIMESTAMP底层存储的是毫秒值</p></li>
<li><p>DATETIME 和 TIMESTAMP差别：</p>
<ul>
<li>TIMESTAMP存储的时间范围比DATETIME要小很多，只能存储“1970-01-01
00:00:01 UTC”到“2038-01-19 03:14:07
UTC”之间的时间。存储数据的时候需要对当前时间所在的时区进行转换，查询数据的时候再将时间转换回当前的时
区。因此，使用TIMESTAMP存储的同一个时间值，在不同的时区查询时会显示不同的时间</li>
<li>TIMESTAMP会根据用户的时区不同，显示不同的结果。而DATETIME则只能
反映出插入时当地的时区，其他时区的人查看数据必然会有误差的,需要额外做处理</li>
</ul></li>
</ul>
<h4 id="文本字符串类型">6、文本字符串类型</h4>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220910143332516.png" /></p>
<ul>
<li>何时使用CHAR？何时使用VARCHAR？
<ul>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220910143612992.png" /></li>
<li>情况1：存储很短的信息。比如门牌号码101，201....这样很短的信息应该用char，因为varchar还要占个byte用于
存储信息长度，本来打算节约存储的，结果得不偿失。</li>
<li>情况2：固定长度的。比如使用uuid作为主键，那用char应该更合适。因为他固定长度，varchar动态根据长度的特性就消失了，而且还要占个长度信息。</li>
<li>情况3：十分频繁改变的列，因为varchar的每次存储都需要有额外的计算，得到长度等工作。如果一个非常频繁改变的话，会又较多的小号用于计算。</li>
<li>情况4：具体存储引擎的情况：
<ul>
<li>InnoDB
存储引擎，建议使用VARCHAR类型。因为对于InnoDB数据表，内部的行存储格式并没有区
分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），而且主要影响性能的因素
是数据行使用的存储总量，由于char平均占用的空间多于varchar，所以除了简短并且固定长度的，
其他考虑varchar。这样节省空间，对磁盘I/O和数据存储总量比较好。</li>
</ul></li>
</ul></li>
<li>关于TEXT字段：
<ul>
<li>TEXT文本类型，可以存比较大的文本段，搜索速度稍慢，因此如果不是特别大的内容，建议使用CHAR，
VARCHAR来代替。还有TEXT类型不用加默认值，加了也没用。而且text和blob类型的数据删除后容易导致
“空洞”，使得文件碎片比较多，所以频繁使用的表不建议包含TEXT类型字段，建议单独分出去，单独用
一个表。</li>
</ul></li>
<li>关于ENUM和SET
<ul>
<li>设置字段值时，ENUM类型只允许从成员中选取单个值，不能一次选取多个值。</li>
<li>SET类型在选取成员时，可以一次选择多个成员，这一点与ENUM类型不同。</li>
</ul></li>
</ul>
<h4 id="二进制字符串">7、二进制字符串</h4>
<p>BINARY VARBINARY BLOB</p>
<ul>
<li>使用TEXT和BLOB时的注意事项：
<ul>
<li>BLOB和TEXT值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值
会在数据表中留下很大的"
空洞"，以后填入这些"空洞"的记录可能长度不同。为了提高性能，建议定期 使用
OPTIMIZE TABLE 功能对这类表进行碎片整理。</li>
<li>如果需要对大文本字段进行模糊查询，MySQL
提供了前缀索引。但是仍然要在不必要的时候避免检
索大型的BLOB或TEXT值。例如，SELECT *
查询就不是很好的想法，除非你能够确定作为约束条件的
WHERE子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的值。</li>
<li>把BLOB或TEXT列分离到单独的表中。在某些环境中，如果把这些数据列移动到第二张数据表中，可
以让你把原数据表中的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会减少主表中的
碎片，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行 SELECT
* 查询的时候不会通过 网络传输大量的BLOB或TEXT值。</li>
</ul></li>
</ul>
<h4 id="json类型">8、JSON类型：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_json (js)</span><br><span class="line">VALUES (&#x27;&#123;&quot;name&quot;:&quot;songhk&quot;, &quot;age&quot;:18, &quot;address&quot;:&#123;&quot;province&quot;:&quot;beijing&quot;,</span><br><span class="line">&quot;city&quot;:&quot;beijing&quot;&#125;&#125;&#x27;);</span><br></pre></td></tr></table></figure>
<h4 id="空间类型">9、空间类型：</h4>
<p>​ MySQL
空间类型扩展支持地理特征的生成、存储和分析。这里的地理特征表示世界上具有位置的任何东
西，可以是一个实体，例如一座山；可以是空间，例如一座办公楼；也可以是一个可定义的位置，例如
一个十字路口等等。MySQL中使用Geometry（几何）
来表示所有地理特征。Geometry指一个点或点的
集合，代表世界上任何具有位置的事物。</p>
<h4 id="总结">10、总结：</h4>
<ul>
<li>任何字段如果为非负数，必须是 UNSIGNED</li>
<li>【强制】小数类型为 DECIMAL，禁止使用 FLOAT 和
DOUBLE。说明：在存储的时候，FLOAT 和 DOUBLE
都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过
DECIMAL 的范围，建议将数据拆成整数和小数并分开存储。</li>
<li>【强制】如果存储的字符串长度几乎相等，使用 CHAR
定长字符串类型。</li>
<li>【强制】VARCHAR 是可变长字符串，不预先分配存储空间，长度不要超过
5000。如果存储长度大 于此值，定义字段类型为
TEXT，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</li>
</ul>
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>数据库精简笔记</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap2 Mysql各类函数与子查询</title>
    <url>/2022/09/05/22f2ef21dade/</url>
    <content><![CDATA[<h3 id="一函数">一、函数</h3>
<h4 id="流程控制函数">1、流程控制函数</h4>
<ul>
<li>CASE WHEN THEN</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id,salary, CASE WHEN salary&gt;=15000 THEN &#x27;高薪&#x27;</span><br><span class="line">WHEN salary&gt;=10000 THEN &#x27;潜力股&#x27;</span><br><span class="line">WHEN salary&gt;=8000 THEN &#x27;屌丝&#x27;</span><br><span class="line">ELSE &#x27;草根&#x27; END &quot;描述&quot;</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
<ul>
<li>IF &amp;&amp; IFNULL</li>
</ul>
<h4 id="加密与解密函数">2、加密与解密函数</h4>
<ul>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220905172002244.png" /></li>
</ul>
<h4 id="mysql信息函数">3、MYSQL信息函数</h4>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220905172039855.png" /></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220905172112542.png" /></p>
<h4 id="一些其他单行函数">4、一些其他单行函数：</h4>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220905172140390.png" /></p>
<h4 id="聚合函数">5、聚合函数：</h4>
<p>​ <strong>输入一组数据的集合，输出单个值</strong></p>
<ul>
<li>常用的聚合函数：AVG SUM MAX MIN</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT AVG(salary),SUM(salary),AVG(salary)*107</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT MAX(salary),MIN(salary)</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
<ul>
<li>COUNT</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(employee_id),COUNT(salary),COUNT(2* salary)</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>COUNT计算指定字段，是不计算该字段为空值的记录数目的</p></li>
<li><p>所以如果想要计算表中有多少条记录，可以使用COUNT(*)</p></li>
</ul>
<p><strong>需求：查询公司中平均奖金率</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 错误的做法，因为有可能commission_pct为null</span><br><span class="line">SELECT AVG(commission_pct)</span><br><span class="line">FROM employees;</span><br><span class="line"># 正确的做法：</span><br><span class="line">SELECT SUM(commission_pct) / COUNT(IFNULL(commission_pct,0))</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
<ul>
<li>GROUP BY 的使用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT department_id,AVG(salary)</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br></pre></td></tr></table></figure>
<ul>
<li>如果要使用多个列进行GROUP BY 分组操作：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT department_id,job_id,AVG(salary)</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id,job_id</span><br></pre></td></tr></table></figure>
<p><strong>提示结论</strong>：</p>
<ul>
<li><p>出现在SELECT中的非聚合函数字段，都必须出现在GROUP
BY里面。</p></li>
<li><p>GROUP BY 声明在FROM后面、WHERE后面，ORDER
BY前面、LIMIT前面</p></li>
<li><p>在GROUP BY中使用 WITH ROLLUP，使用WITH
ROLLUP关键字之后，在所有查询出的分组记录之后增加一条记录，该记录计算查询出的所有记录的总和，即统计记录数量。</p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT department_id,AVG(salary) AS avg_sal</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id WITH ROLLUP;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 当使用ROLLUP时，不能同时使用ORDER BY子句进行结果排那，即ROLLUP和ORDER BY是互相排斥的。</span><br><span class="line">SELECT department_id,AVG(salary) AS avg_sal</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">ORDER BY avg_sal ASC;</span><br></pre></td></tr></table></figure>
<ul>
<li>Having的使用（用于过滤数据）
<ul>
<li>如果过滤条件中使用了聚合函数，必须使用HAVING来替换WHERE</li>
<li>如果过滤条件中没有聚合函数，则过滤条件声明在HAVING或WHERE中都可以</li>
</ul></li>
</ul>
<p><strong>查询各个部门中最高工资比10000高的部门信息：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT department_id,MAX(salary)</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING MAX(salary) &gt; 10000</span><br></pre></td></tr></table></figure>
<h4 id="where-和-having的区别">6、WHERE 和 HAVING的区别：</h4>
<ul>
<li>区别1：WHERE可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件；HAVING必须要与GROUPBY配合使用，可以把分组计算的函数和分组字段作为筛选条件。</li>
<li>区别2：如果需要通过连接从关联表中获取需要的数据，WHERE是先筛选后连接，而
HAVING是先连接后筛选。这一点，就决定了在关联查询中，WHERE比HAVING更高效。因为WHERE可以先筛选，用一个筛选后的较小数据集和关联表进行连接，这样占用的资源比较少，执行效率也比较高。HAVING则需要先把结果集准备好，也就是用未被筛选的数据集进行关联，然后对这个大的数据集进行筛选，这样占用的资源就比较多，执行效率也较低。</li>
</ul>
<h4 id="sql底层执行原理">7、SQL底层执行原理：</h4>
<p>Select语句的完整结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># sql92</span><br><span class="line">SELECT ... , ... , ... (存在聚合函数)</span><br><span class="line">FROM ... , ... , ...</span><br><span class="line">WHERE 多表连接条件 AND 不包含聚合函数的过滤条件</span><br><span class="line">GROUP BY ...</span><br><span class="line">HAVING 包含聚合函数的过滤条件</span><br><span class="line">ORDER BY ... (ASC/DESC)</span><br><span class="line">LIMIT ...,...</span><br><span class="line"></span><br><span class="line"># sql92</span><br><span class="line">SELECT ... , ... , ... (存在聚合函数)</span><br><span class="line">FROM ... JOIN ... ON 多表连接条件</span><br><span class="line">JOIN ... ON ...</span><br><span class="line">WHERE 不包含聚合函数的过滤条件</span><br><span class="line">GROUP BY ...</span><br><span class="line">HAVING 包含聚合函数的过滤条件</span><br><span class="line">ORDER BY ... (ASC/DESC)</span><br><span class="line">LIMIT ...,...</span><br></pre></td></tr></table></figure>
<ul>
<li>SQL语句如何执行，执行过程？
<ul>
<li>FROM—&gt; ON( 多表连接条件)—&gt; ( LEFT / RIGHT JOIN
根据左外右外连接补充数据 ) —&gt; WHERE（筛选数据）</li>
<li>—&gt; GROUP BY（分组） —&gt; HAVING（分组后筛选） —&gt;
SELECT（选择） —&gt; ORDER BY（排序） —&gt;</li>
<li>LIMIT （限制条数）</li>
</ul></li>
</ul>
<h3 id="二子查询">二、子查询</h3>
<p>​
很多时候查询需要从结果集中获取数据，或者<strong>需要从同一个表中先计算得出一个数据结果，然后与这个数据结果（可能是某个标量，也可能是某个集合）进行比较。</strong></p>
<p>​ <strong>虽然有的时候子查询可以通过
两个连续的SQL查询或自连接实现同样的功能，但是子查询性能更优。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &gt; (</span><br><span class="line"> 			SELECT salary</span><br><span class="line">			FROM employees</span><br><span class="line">			WHERE last_name = &#x27;Abel&#x27;</span><br><span class="line"> 			);</span><br></pre></td></tr></table></figure>
<p>​ <strong>子查询在主查询之前一次执行完成</strong></p>
<p>​ <strong>将子查询放在比较条件的右侧</strong></p>
<p>​ <strong>单行操作对应单行子查询，多行操作对应多行子查询</strong></p>
<h4
id="内查询返回的结果条目数单行多行子查询">1、内查询返回的结果条目数（单行、多行子查询）：</h4>
<ul>
<li><p>单行子查询（内查询返回单行数据）</p></li>
<li><p>多行子查询：应当使用多行比较操作符： IN ， ANY ， ALL</p>
<ul>
<li><p>返回其它job_id中比job_id为 'IT_PROG'
部门任一工资低的员工的员工号</p></li>
<li><p>```mysql SELECT employee_id,last_name,job_id,salary FROM
employees WHERE job_id &lt;&gt; 'IT_PROG' AND salary &lt; ANY ( SELECT
salary FROM employees WHERE job id = 'IT PROG' );
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2、内查询是否被执行多次（相关子查询、不相关子查询）：</span><br><span class="line"></span><br><span class="line">- 相关子查询</span><br><span class="line"></span><br><span class="line">  - 内查询返回的值与外查询相关</span><br><span class="line"></span><br><span class="line">  - 如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，**因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为关联子查询。**</span><br><span class="line"></span><br><span class="line">    ```mysql</span><br><span class="line">    # 查询工资大于本部门平均工资的员工信息</span><br><span class="line">    # 张三在部门A，李四在部门B，那么张三来查和李四来查，内查询查的是各自部门的平均工资，返回的是不一样的，也就是内查询执行了多次</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
</ul>
<p>​ <strong>执行流程</strong>：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220907113232810.png" style="zoom: 67%;" /></p>
<p><strong>查询员工中工资大于本部门平均工资的员工的lat_name，salary和其department_id</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT last_name,salry,department_id</span><br><span class="line">FROM employees AS e1</span><br><span class="line">WHERE salry &gt; (</span><br><span class="line">			SELECT AVG(salary) as avg_sal</span><br><span class="line">			FROM employees as e2</span><br><span class="line">			WHERE e2.department_id = e1.department_id</span><br><span class="line">			GROUP BY department_id )</span><br></pre></td></tr></table></figure>
<p><strong>查询员工的id,salary,按照department_name排序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee id, salary</span><br><span class="line">FROM employees AS e</span><br><span class="line">ORDER BY(</span><br><span class="line">		SELECT department_name</span><br><span class="line">		FROM departments AS d</span><br><span class="line">		WHERE e.department_id = d.department_id </span><br><span class="line">) ASC;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>不相关子查询</p>
<ul>
<li><p>内查询返回的值与外查询无关</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查询工资大于本公司平均工资的员工信息</span><br><span class="line"># 张三在部门A，李四在部门B，那么张三来查和李四来查，内查询查的都是全公司的平均工资，返回的是一样的，也就是内查询执行了一次</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>相关子查询结论：<strong>在SELECT语句中，除了GROUP BY 和
LIMIT之外，其他地方都可以声明子查询</strong></p></li>
</ul>
<h4
id="相关子查询中的exists-和-not-exists关键字">3、相关子查询中的EXISTS 和
NOT EXISTS关键字</h4>
<ul>
<li><p>如果在子查询中不存在满足条件的行：</p>
<ul>
<li><p>条件返回 FALSE</p></li>
<li><p>继续在子查询中查找</p></li>
</ul></li>
<li><p>如果在子查询中存在满足条件的行：</p>
<ul>
<li>不在子查询中继续查找</li>
<li>条件返回 TRUE</li>
</ul></li>
</ul>
<p><strong>查询公司管理者的employee_id，last_name，job_id，department_id信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee id, last name, job id, department id</span><br><span class="line">FROM employees e1</span><br><span class="line">WHERE EXISTS(</span><br><span class="line">			SELECT *</span><br><span class="line">			FROM employees e2</span><br><span class="line">			WHERE e1.employee_id= e2.manager_id</span><br><span class="line">		 );</span><br><span class="line"># 将外查询中的第1条记录送入子查询中，执行查找，如果存在则返回TRUE</span><br><span class="line"># 将外查询中的第2条记录送入子查询中，执行查找，如果存在则返回TRUE</span><br><span class="line"># 将外查询中的第...条记录送入子查询中，执行查找，如果存在则返回TRUE   </span><br><span class="line"># 相关子查询的执行过程就是如上所述</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>数据库精简笔记</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap1 Mysql基本查询内容</title>
    <url>/2022/09/03/7e7267227ba3/</url>
    <content><![CDATA[<h4 id="一些非关系型数据库">1、一些非关系型数据库</h4>
<h5 id="键值型数据库">键值型数据库：</h5>
<p>​
查找速度极快，但无法使用条件过滤。最典型的应用场景为内存缓存，Redis是最流行的键值型数据库</p>
<h5 id="文档型数据库">文档型数据库：</h5>
<p>​
存放并获取文档，文档作为基本单位，一个文档为一条记录，可以是XML或JSON格式，MongoDB是最常见的文档型数据库</p>
<h5 id="搜索引擎数据库">搜索引擎数据库：</h5>
<p>​ 核心是“倒排索引”。</p>
<h5 id="列式数据库">列式数据库：</h5>
<p>​ 大量降低系统IO，适合于分布式文件系统</p>
<h5 id="图形数据库">图形数据库：</h5>
<p>​ 利用了图这种数据结构存储实体对象之间的关系 比如Neo4J</p>
<h4 id="er模型与表记录">2、ER模型与表记录</h4>
<ul>
<li>ER模型，三个主要概念：<strong>实体集、属性、联系集</strong></li>
<li>ORM思想：Object Relational Mapping 对象关系映射 【 数据库中的一个表
对应编程语言中的一个类】</li>
</ul>
<h5 id="一对一关系">1) 一对一关系：</h5>
<p>​
实际应用中不多，因为1对1的关系实际上可以建立成一张表。<strong>主要应用于优化性能。</strong>比如说设计学生表，把他拆解为基础信息表和不常用信息表，这样子快速查询时只需要查询基础信息表即可，提升查询速度</p>
<h5 id="一对多关系多对多关系等">2) 一对多关系、多对多关系等</h5>
<h4 id="sql分类">3、SQL分类：</h4>
<ul>
<li>DDL：数据定义语言（CREATE ALTER TRUNCATE等）</li>
<li>DML：数据操作语言（INSERT DELETE等）</li>
<li>DCL：数据控制语言（COMMIT ROLLBACK SAVEPOINT GRANT REVOKE）</li>
</ul>
<h4 id="sql使用规范与规则">4、SQL使用规范与规则</h4>
<ul>
<li>MYSQL在Windows环境下是大小写不敏感的</li>
<li>MYSQL在Linux环境下：数据库名、表名、变量名严格区分大小写</li>
<li>在Linux环境下：关键字、函数名、列名忽略大小写</li>
</ul>
<h4 id="select基础操作">5、SELECT基础操作：</h4>
<ul>
<li>列的别名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id AS emp_id,last_name AS lname,salary * 12 AS sal</span><br><span class="line">FROM employees</span><br></pre></td></tr></table></figure>
<ul>
<li>去除重复：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT department_id</span><br><span class="line">FROM employees</span><br><span class="line">/** 将department_id 和 salary视作一个整体去重**/</span><br><span class="line">SELECT DISTINCT department_id,salary</span><br><span class="line">FROM employees</span><br></pre></td></tr></table></figure>
<ul>
<li>空值NULL如何参与运算</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT salary AS &quot;月工资&quot;,salary * (1 + IFNULL(commission_pct,0)) * 12 AS &quot;年工资&quot;</span><br><span class="line">FROM employees</span><br></pre></td></tr></table></figure>
<ul>
<li>显示表结构,显示表字段的相关信息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESCRIBE employees</span><br></pre></td></tr></table></figure>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220903195253736.png" /></p>
<h4
id="比较运算符使用关键是null值参与比较时规则">6、比较运算符使用：（关键是NULL值参与比较时规则）</h4>
<ul>
<li><p>= 运算符：</p>
<ul>
<li><p>在MYSQL中，如果数值和字符串比较，字符串存在隐式转换，如果转换数值不成功，则看作0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 0 = &#x27;a&#x27;  # 为 1</span><br><span class="line">FROM DUAL;</span><br></pre></td></tr></table></figure></li>
<li><p>只要有NULL参与比较，则结果均为NULL</p></li>
</ul></li>
<li><p>若使用安全等于运算符 &lt;=&gt; 会有所不同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 &lt;=&gt; NULL  #为0   </span><br><span class="line">NULL&lt;=&gt;NULL #为1</span><br></pre></td></tr></table></figure></li>
<li><p>LEAST  GREATEST 运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT LEAST(first_name,last_name)</span><br><span class="line">FROM employees</span><br></pre></td></tr></table></figure></li>
<li><p>IN  NOT IN运算符： 离散值查找</p></li>
</ul>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT last_name</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id IN (10,20,30)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>LIKE 模糊查询：</p>
<ul>
<li>% 0个及以上的字符占位符</li>
<li>_ 1个字符占位符</li>
</ul></li>
<li><p>REGEXP 使用正则表达式进行匹配</p></li>
</ul>
<h4 id="排序与分页">7、排序与分页：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id</span><br><span class="line">FROM employees</span><br><span class="line">ORDER BY salary DESC;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>可以使用列的别名进行排序，但不可以使用列的别名在WHERE中</p></li>
<li><p>可以使用不在SELECT中的字段进行排序操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id,salary,salary*12 AS annual_sal</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id &lt; 50</span><br><span class="line">ORDER BY annual_sal;</span><br></pre></td></tr></table></figure></li>
<li><p>数据库查询操作的执行顺序：</p>
<ul>
<li>FROM + WHERE部分最优先</li>
<li>执行SELECT 部分，确定要查询的字段</li>
<li>执行ORDER BY部分</li>
<li>执行LIMIT部分</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LIMIT $&#123;offset&#125;,$&#123;count&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="多表查询">8、多表查询：</h4>
<ul>
<li>连接条件，笛卡尔积，A表中的每一条记录都去对应B表中的每一条记录，进行组合。</li>
<li>如果查询语句中出现了多个表中都存在的字段，则必须指明此字段所在的表。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee id，department name #两个表的连接条件</span><br><span class="line">FROM employees,departments</span><br><span class="line">WHERE employees.&#x27;department_id&#x27;=departments.department_id</span><br></pre></td></tr></table></figure>
<ul>
<li><p>可以给表起别名，在SELECT和WHERE中使用表的别名。注意：如果给表起了别名，一旦在SELECT或WHERE中使用表名的话，则必须使用表的别名，而不能再使用表的原名。</p></li>
<li><p>如果有n个表实现多表的查询，则需要至少n-1个连接条件</p></li>
<li><p>自连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee _id, last name, employee id, last_name</span><br><span class="line">FROM employees emy, employees mgr</span><br><span class="line">WHERE emp.manager_id = mgr. employee_id</span><br></pre></td></tr></table></figure></li>
<li><p>内连接：合并具有同一列的两个以上的表的行，结果集中不包含一个表与另一个表不匹配的行</p></li>
<li><p>外连接：合并具有同一列的两个以上的表的行，结果集中除了包含一个表与另一个表匹配的行之外，还查询到了左表或右表中不匹配的行。</p>
<ul>
<li>左外连接 &amp; 右外连接</li>
<li>两个表在连接过程中除了返回满足连接条件的行以外还返回左表（右表）中不满足条件的行，</li>
</ul></li>
<li><p>示例：查询<strong>所有的</strong>员工的last_name，department_name信息</p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT last name, department name</span><br><span class="line">FROM employees e LEFT OUTER JOIN departments d</span><br><span class="line">ON e.department_id = d.department_id</span><br></pre></td></tr></table></figure>
<ul>
<li>示例：查询<strong>有部门的</strong>员工的last_name，department_name信息(内连接)，使用
JOIN ON语法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT last name, department name</span><br><span class="line">FROM employees e INNER JOIN departments d</span><br><span class="line">ON e.department_id = d.department_id</span><br></pre></td></tr></table></figure>
<h4 id="union关键字">9、UNION关键字</h4>
<p>​ 用于合并两个结果集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT ... FROM ... </span><br><span class="line">UNION</span><br><span class="line">SELECT ... FROM ...</span><br></pre></td></tr></table></figure>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220905112924821.png" /></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220905112945650.png" /></p>
<p>​
<strong>注意：执行UNIONALL语句时所需要的资源比UNION语句少。如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复的数据，则尽量使用UNIONALL语句，以提高数据查询的效率。</strong></p>
<h4 id="种sql的-join操作">10、7种SQL的 JOIN操作：</h4>
<p>​ 有些具体数据库不支持的操作，可以通过UNION或UNION
ALL来合并支持操作的结果集</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220905112815584.png" style="zoom: 80%;" /></p>
<h4 id="natural-join-和-using-连接sql99新特性">11、NATURAL JOIN 和 USING
连接（SQL99新特性）</h4>
<ul>
<li>Natural Join
它会帮你自动查询两张连接表中所有柯同的字段，然后进行等值连接。</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220905113547787.png" /></p>
<ul>
<li>以下两条语句等价：</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220905113555008.png" /></p>
<ul>
<li>Using 优化：
<ul>
<li>USING指定了具体的相同的字段名称，你需要在USING的括号（）中填入要指定的同名字段。同时使用JOIN...USING可以简化JOIN
ON的等值连接。它与下面的SQL查询结果是相同的：</li>
</ul></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220905113740065.png" /></p>
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>数据库精简笔记</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式1</title>
    <url>/2022/09/03/2ceecb19279d/</url>
    <content><![CDATA[<h4 id="设计模式">1、设计模式</h4>
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>Java开发经验——0823日志1</title>
    <url>/2022/08/15/ebbd271e8df3/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="7bff88e0012b18d8d7d0270af5c6c0fe7b6a1bc7f11bd1a7e92faf07212330a7">5b75cfd994443fd8ef220370f00a3fa4461ecbc081186bae611d070e9fac23e9bc70aee727e83acc5bb7a91a891e516e4a7b3fd9cf39579ef096d21236333396f794cc835ab3097bfe35b4dda2385dd584508e057a30d7bd06ec04e2dc73c3f8741b5b7dcee0a1f3f9360ff2a0478348e84408b422a74ae1ebbe1e485c4ee94a138d82b3a03cca25d37b022cc57a256448a271bcd406eee952fa793fc4adb35c08aacffa6f8e5d5cc8d24ff852792129bfe885e0d7571801eda5c0b47272d7d8ab0040619816e92492992688e9ac6eb9d76d9d79289134f74441c8418384a7d25782a07e65f33f29b7f808a5fe498f44ad90f1f44347298e83b2397e634e01ec7584df70b79831bd9194f968e34dc0808f303675c9f345d47c6fc7efa752356cdd6f54ae0c9b3ab34d456302d54140c0bf1cdf6f407761262135cfc21706c5ab18d3a0b036a6b3a5c2368a07c1aaa77dc2f28175a783cb7939565efad831c619303b3bd0890a79e95a3478c502d3da62609a3fe137013b832d36616f780effe126cf07d8311919e28fd941e7d35d1af90faf67e78c9234fe80b85296b8498c02bdc9ea6a2ef507f0c3320bd6e382b42e39f7fdb6169d557bf0085443e9ca26c3f422631a258e6154f5c3f5ef4eaae9912be7235917368017516bedb052299f1d5bfd82433462771cdd533407252baf3085ba5f3bf7d582d45757552e911824002deeb436402f16b79f1226c7127348134c450b6d11470ebff8ca358da7e05059565f3c023fbc1f2c584742ad8d921b7e1a54d081d8c26f6a56e70120a79058ff1710cbb4afb58a684c38c109ce21a71628f99242043c8de76703cc715314eb06</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>⑧  经验整理类笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Java开发经验——0815日志1</title>
    <url>/2022/08/15/bb402ab73028/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="1d61c0fc9529643c45934df25f1801317a5a9ec15f14590d9a4e5a71a20a39cd">5b75cfd994443fd8ef220370f00a3fa4461ecbc081186bae611d070e9fac23e9bc70aee727e83acc5bb7a91a891e516e3ed3f53ca3563506c209cec7f7dd47cf43d7f8ad90a64f771f2c739c94cc8635d2692fd7a86e1afabd60f14467bb6285dd9e4985732f2300fef62c7f85acda2d8014669dc425265465c14a8300636aff0ba4fa04a6095d3cadf517a55e8f51e38db73692bd140f1cc7f31b2d0bc19da8c1dd8a14b5cdc5d1e82f7b88e1025db02739a66c7ddc9ed3f40a4b60f3cea054940df4527fc090191c611597601f26dc9f070070b296626315afe89dbb6c682f6ff8439f43dd46d4bd7bfc0489b3c60f6f9940d72965ba74687751d978a3e4ad8bb332486e98d449ef121e6ef93f1c9f3c4c181958863dfc33587f8d0532f026eb797c3f38c400d667187e7d75e598da336a177ff7ab5956c8a690c743a19cec437c9a7c36b993fb460b129f1e605559bc32bc64ee995b0f5a33eeb1741c82a71ce0e4be7fb99fa6d017e86af11a322d5318e1bdcd86c649e9a4aa52f7cefa377f139797d78470cf275fba9751ff4e5d8b51f88084aefabc50bb0c5c877cf841d2899bc11935d14ed4b4a7618a87b3f9459a57800ebe5725760821930ee2e4bfc42467ba96e164965bd93e264f0e8eef715cd59fc65348f48e98c1f075f0b2073b43db94ea80bdcb44cdd0db24edd6bab5c91618292f0d69e70a75cfec38dc653f1a742aadc54ae7c9757ce0c09409dd7068fa8d9d664996eda7c76711fdf73023fa6576c00284367ac83c6335812f919ea091dba2856d27296e86e3a8fafcca69138f59103bdc711bae1e5d82a1a9d2ee8fdd760d31f7b9b85028b44f28766c3289c6be836a86690e4f9a4eda49791a043037ce46e3b6d72a666ac59635cd7dc3ffbe61aa9caf46f6b459eb56e851f667d53b3353b748a1f484cc95504a63e8b9880a1e10bc5390889d1ce07c0c55808cd360bccfb60c97325eb8559f62c365485b0d9707e35ea8dbd387eaf70a258cd2d55f4b2439821921e81eeffc0077e8a760bafc921cd29bca02d0db79896f3a459f9b1b61b767ccb84cdc315bc7706af0a0d9762a17208c382d6048d54c828c40f3a0b5015c9154aca60bcf8fe776d8cddc87cd4eb0bfe42e2191dc00d5e6e887d11ed873071c046797004d767611a4a32f3948be4bb0414759e9fdcdda1e33da668279b1ff5c1e4bf03478e5cfa1b1c83d0da7a0b45195fc063f6958e29c48afd02e85c165433da66112822589345ef7aa2cf37b1d1de830821262f4bc0daa002da156ba87ef20c825f5a3a212d8fa2a884d08af7ddd678f022a2613c59546cf7d3644b1e0c9cb890a3ec14ace7d9452bda6019a9625e348c6c7cb3deaad044682f29e2ef7d61fa84402f7115d4b7b088ba52afd3314d72891262011fce124d4cec399413efd5d51c7eea8099a88cfa40b1951a32a66607cb422dc0af05c88c74149b14be30574112cdeb834a1a76918ed1c23f1bc39b80324b0458c0cf515f6f3f207443bdc2bd6840b2984ddef36e71a441b6a03a0894f6fd9682cadd0c42f290d4727363aa1529b2aeba36f993bebf34b167a23b9c55ccaa81b0fdb07610ffe25e8d4c58ae96de382622d0d7353fd5e803d0ebd632a245057f5e192ff4522cb8877c8bc1ef933390d35d212f2eb</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>⑧  经验整理类笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Java实现多人实时通信系统</title>
    <url>/2022/08/14/4cdc462e541f/</url>
    <content><![CDATA[<h3 id="一架构体系">一、架构体系</h3>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220814172432459.png" /></p>
]]></content>
      <categories>
        <category>①  项目笔记</category>
        <category>java项目</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>java精简系列笔记8——网络编程</title>
    <url>/2022/08/13/8699249df0f2/</url>
    <content><![CDATA[<h3 id="一inetaddress类">一、InetAddress类:</h3>
<ul>
<li><p>获取本机的InetAddress对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InetAddress.getLocalHost();</span><br></pre></td></tr></table></figure></li>
<li><p>根据主机名 获得InetAddress对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InetAddress.getByName(&quot;DESKTOP-ICFPFA0&quot;)</span><br></pre></td></tr></table></figure></li>
<li><p>根据域名 获得InetAddress对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InetAddress.getByName(&quot;www.baidu.com&quot;);</span><br></pre></td></tr></table></figure></li>
<li><p>根据InetAddress对象 获取对应的 地址 或者 主机名/域名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inet.getHostAddress(); </span><br><span class="line">inet.getHostName(); </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="二socket编程">二、Socket编程</h3>
<p>Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输。</p>
<p>当我们需要通讯时：</p>
<ul>
<li><p>socket.getOutputStream()</p></li>
<li><p>socket.getInputStream()</p></li>
</ul>
<h3
id="三基于socket的tcp字节流编程">三、基于Socket的TCP字节流编程：</h3>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220813170808297.png" style="zoom:67%;" /></p>
<p>服务器和客户端的互相通信</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketTCPServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.程序监听在9999端口，等待链接</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.当没有客户端连接时，程序会阻塞，等待连接</span></span><br><span class="line">        <span class="comment">//如果有客户端连接，则会返回一个socket对象，程序继续执行</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.通过socket读取客户端写入到数据通道的数据，显示</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((readLen = inputStream.read(buf)) != -<span class="number">1</span>)&#123;   </span><br><span class="line">            <span class="comment">//该读取语句会阻塞，知道client方调用了socket.shutdownOutput();即告知此次消息已经发送结束</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buf,<span class="number">0</span>,readLen));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.通过输出流，写入数据到数据通道</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        outputStream.write(<span class="string">&quot;hello,client&quot;</span>.getBytes());</span><br><span class="line">        socket.shutdownOutput(); <span class="comment">//让对方知道你该次的消息已经发送完毕</span></span><br><span class="line"></span><br><span class="line">        outputStream.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketTCPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.连接服务端（ip，端口）</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(),<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2.连接上后，生成Socket，通过socket.getOutputStream（）</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//3.通过输出流，写入数据到数据通道，发送完数据后应当有一个结束标记</span></span><br><span class="line">        outputStream.write(<span class="string">&quot;hello,server&quot;</span>.getBytes());</span><br><span class="line">        socket.shutdownOutput();  <span class="comment">//让对方知道你该次的消息已经发送完毕，非常重要</span></span><br><span class="line"></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((readLen = inputStream.read(buf)) != -<span class="number">1</span>)&#123;  </span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buf,<span class="number">0</span>,readLen));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.关闭流对象和socket</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3
id="四基于socket的tcp字符流编程">四、基于Socket的TCP字符流编程：</h3>
<p>和字节流编程有少许差别，需要使用转换流。</p>
<p>服务器和客户端的互相通信：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketTCPServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.程序监听在9999端口，等待链接</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.当没有客户端连接时，程序会阻塞，等待连接</span></span><br><span class="line">        <span class="comment">//如果有客户端连接，则会返回一个socket对象，程序继续执行</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.通过socket读取客户端写入到数据通道的数据，显示</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> bufferedReader.readLine();</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.通过输出流，写入数据到数据通道</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream));</span><br><span class="line">        bufferedWriter.write(<span class="string">&quot;hello,client&quot;</span>);</span><br><span class="line">        bufferedWriter.newLine(); <span class="comment">// 插入换行符，代表写入的内容结束了</span></span><br><span class="line">        bufferedWriter.flush(); <span class="comment">//需要手动刷新，否则不会写入数据通道</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        outputStream.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketTCPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.连接服务端（ip，端口）</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(),<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2.连接上后，生成Socket，通过socket.getOutputStream（）</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//3.通过输出流，写入数据到数据通道，发送完数据后应当有一个结束标记</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream));</span><br><span class="line">        bufferedWriter.write(<span class="string">&quot;hello,server&quot;</span>);</span><br><span class="line">        bufferedWriter.newLine(); <span class="comment">// 插入换行符，代表写入的内容结束了</span></span><br><span class="line">        bufferedWriter.flush(); <span class="comment">//需要手动刷新，否则不会写入数据通道</span></span><br><span class="line"></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> bufferedReader.readLine();</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.关闭流对象和socket</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="五tcp编程网络上传文件">五、TCP编程——网络上传文件：</h3>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220814095756722.png" style="zoom:67%;" /></p>
<ul>
<li><p>常用依赖类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fileupload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamUtil</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输入流对象转字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> is</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] streamToByteArray(InputStream is) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>(); <span class="comment">//创建输出流对象</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = is.read(b)) !=-<span class="number">1</span>)&#123;   <span class="comment">//相当于使用ByteArrayOutputStream做了中转</span></span><br><span class="line">            bos.write(b,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">byte</span>[] array = bos.toByteArray();</span><br><span class="line">        bos.close();</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输入流对象转字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> is</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">streamToString</span><span class="params">(InputStream is)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is)); <span class="comment">//创建输出流对象</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = reader.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            builder.append(line + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>客户端程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fileupload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileTCPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.连接服务端（ip，端口）</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(),<span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\1.jpg&quot;</span>;</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath));</span><br><span class="line">        <span class="type">byte</span>[] fileBytes = StreamUtil.streamToByteArray(bufferedInputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.连接上后，生成Socket，通过socket.getOutputStream();</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bufferedOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(outputStream);</span><br><span class="line">        bufferedOutputStream.write(fileBytes);</span><br><span class="line">        bufferedInputStream.close();</span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取服务器返回的信息</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> StreamUtil.streamToString(inputStream);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.关闭流对象和socket</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>服务器对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fileupload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileTCPServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.程序监听在9999端口，等待链接</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.当没有客户端连接时，程序会阻塞，等待连接</span></span><br><span class="line">        <span class="comment">//如果有客户端连接，则会返回一个socket对象，程序继续执行</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.通过socket读取客户端写入到数据通道的数据，显示</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] fileBytes = StreamUtil.streamToByteArray(bufferedInputStream);</span><br><span class="line">        <span class="type">String</span> <span class="variable">savaPath</span> <span class="operator">=</span> <span class="string">&quot;src\\new.jpg&quot;</span>;</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bufferedOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(savaPath));</span><br><span class="line">        bufferedOutputStream.write(fileBytes);</span><br><span class="line">        bufferedOutputStream.close();</span><br><span class="line"></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream));</span><br><span class="line">        bufferedWriter.write(<span class="string">&quot;file upload success&quot;</span>);</span><br><span class="line">        bufferedWriter.flush();</span><br><span class="line">        bufferedWriter.newLine();</span><br><span class="line"></span><br><span class="line">        bufferedWriter.close();  <span class="comment">//在close的时候，也会调用flush方法</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="六常用命令">六、常用命令</h3>
<ul>
<li>netstat -an | more</li>
<li>netstat -anb | more</li>
</ul>
<h3 id="七udp编程">七、UDP编程</h3>
<p><strong>DatagramSocket和DatagramPacket类</strong></p>
<ul>
<li>UDP数据报通过数据报套接字DatagramSocket
发送和接收，系统不保证UDPUDP数据报通过数据报套接</li>
<li>DatagramSocket 发送和接收，系统不保证UDP
数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。</li>
<li>DatagramPacket
对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号。</li>
<li>UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接</li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220814165451640.png" style="zoom:67%;" /></p>
<ul>
<li><p>基本流程：</p>
<ul>
<li>建立发送端，接收端</li>
<li>发送数据前，建立数据包 DatagramSocket 对象</li>
<li>调用DatagramSocket的发送、接收方法</li>
<li>关闭DatagramSocket</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPClientA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个DatagramSocket对象，准备接收数据</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">8000</span>);</span><br><span class="line">        <span class="comment">// 2、构建一个DatagramPacket对象，准备接受数据</span></span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf,buf.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、调用接收方法，没有接收到数据包的时候，程序会阻塞。</span></span><br><span class="line">        socket.receive(packet);</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> packet.getLength();</span><br><span class="line">        <span class="type">byte</span>[] data = packet.getData();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(data,<span class="number">0</span>,length);</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPClientB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个DatagramSocket对象，准备发送数据</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">8002</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、构建一个DatagramPacket对象，准备发送</span></span><br><span class="line">        <span class="type">byte</span>[] data = <span class="string">&quot;hello clientA&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data,data.length, InetAddress.getLocalHost(),<span class="number">8000</span>);</span><br><span class="line">        socket.send(packet);</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>⑤  编程语言类笔记</category>
        <category>java精简系列笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java精简系列笔记7——并发</title>
    <url>/2022/08/05/b77a426aa9cd/</url>
    <content><![CDATA[<p><strong>知识来源：《Java核心技术卷I》第12章节</strong></p>
<h4 id="多进程与多线程的区别">1、多进程与多线程的区别：</h4>
<ul>
<li>每个进程都拥有自己的一整套变量，而线程则共享数据</li>
<li>线程更轻量级，创建、撤销一个线程比启动新进程的开销要小得多。</li>
</ul>
<h4 id="多线程基础">2、多线程基础</h4>
<ul>
<li><p>如何开启一个新线程？</p>
<ul>
<li><p>将代码放在一个类的run方法中，这个类需要实现Runnable接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class T2 implements Runnable&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>从这个类构造一个Thread对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var r = new T2();</span><br><span class="line">var t = new Thread(r)</span><br></pre></td></tr></table></figure></li>
<li><p>启动线程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t.start()</span><br></pre></td></tr></table></figure></li>
<li><p>注意：不要直接调用Thread类或者Runnable对象的run方法。直接调用run方法只会在同一个线程中执行这个任务而非启动了新的线程</p></li>
</ul></li>
<li><p>Thread和Runnable关系：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220809180159239.png" style="zoom:50%;" /></p></li>
<li><p>除去上述方法，还有一种方法可以创建线程：</p>
<ul>
<li><p>方法1：继承Thread类，该类就可以当作线程使用，重写run方法即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Cat <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">//重写</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">cat.start();</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>为什么调用start()方法，而不是调用run()方法</p>
<ul>
<li>如果调用run方法，相当于是主线程直接执行了run方法，而不是新开了一个线程去调用。</li>
</ul></li>
<li><p>start方法干了什么？</p>
<ul>
<li>start方法中有一个关键的方法叫做start0方法</li>
<li>start0方法是一个native方法，由JVM机来调用的，底层是C或者C++实现的。</li>
<li>start方法调用了start0方法后，该线程不一定会马上执行，而是只是将线程变成了可运行状态，具体什么时候执行取决于CPU统一调度。</li>
<li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220809222307189.png" style="zoom:67%;" /></li>
</ul></li>
</ul>
<h4 id="多线程机制">3、多线程机制</h4>
<p>​
当开始运行Main的时候，开启了一个进程。该进程会开启一个Main线程。当在Main线程中开启新的线程时，Main线程不会阻塞。当所有线程都结束后，进程就会退出。</p>
<p>​ 以下有一个多线程售票的问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SellTicket01</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket01</span>();</span><br><span class="line">        <span class="type">SellTicket01</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket01</span>();</span><br><span class="line">        <span class="type">SellTicket01</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket01</span>();</span><br><span class="line">        s1.start();</span><br><span class="line">        s2.start();</span><br><span class="line">        s3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SellTicket01</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticketNum</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ticketNum &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Sells Finished&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Sells One,Left:&quot;</span> + --ticketNum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>如何通知线程退出？
<ul>
<li>可以通过在主线程内调用子线程的一个方法，来人为控制子线程的退出.</li>
</ul></li>
</ul>
<h4 id="线程的六种状态thread.state">4、线程的六种状态：Thread.State</h4>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/Java线程.png"
alt="Java线程" />
<figcaption aria-hidden="true">Java线程</figcaption>
</figure>
<ul>
<li>New 新建状态
<ul>
<li>线程还没有开始运行</li>
</ul></li>
<li>Runnable 可运行
<ul>
<li>一旦调用start方法，县城就处于可运行状态。将由操作系统为其分配具体的运行时间。处于该状态下的线程可能在运行，也可能不在运行。</li>
</ul></li>
<li>Blocked 阻塞</li>
<li>Waiting 等待
<ul>
<li>当线程处于阻塞或等待状态，是暂时不活动的。需要由线程调度器重新激活这个线程。</li>
<li>当一个线程试图获取一个内部的对象锁，而这个锁被其他线程所占用，就会处于阻塞状态。当其他所有进程都释放了这个锁并且线程调度器允许该线程持有这个锁，将变成非阻塞状态</li>
<li>当线程等待另一个线程通知调度器出现一个条件的时候，这个线程会进入等待状态
<ul>
<li>例如调用 Object.wait或 Thread.join方法</li>
</ul></li>
</ul></li>
<li>Timed waiting
<ul>
<li>Thread.sleep
等带有超时参数的方法被调用时，会使得线程进入计时等待状态，这一状态一直保持到超时期满或者接收到适当的通知。</li>
</ul></li>
<li>Terminated
<ul>
<li>run方法正常退出，线程终止</li>
<li>因为一个没有捕获的异常，线程意外终止。</li>
</ul></li>
</ul>
<h4 id="线程的属性与常用方法">5、线程的属性与常用方法：</h4>
<ul>
<li><p>中断线程</p>
<ul>
<li><p>每个线程有一个布尔标志，叫做中断状态。每个线程都应该不时地检查该标志，以判断线程是否被中断。对一个线程调用<code>interrupt</code>方法时，会设置这个标志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;  <span class="comment">//检测中断标志</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果线程被阻塞，就无法检查中断状态。当在一个被阻塞的线程上调用interrupt方法时，阻塞调用将被一个InterruptedException异常中断。</p></li>
<li><p>被中断地线程可以不需要终止。中断一个线程只是要引起它的注意，被中断的线程可以决定如何来响应中断。</p></li>
</ul></li>
<li><p>守护进程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t.setDaemon(true)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>守护线程的唯一用途是给其他线程提供服务。比如说计时器线程。当只剩下守护线程时，虚拟机就会退出。</p></li>
<li><p>常见的守护线程：垃圾回收机制</p></li>
</ul></li>
<li><p>可以利用<code>setName</code>方法为线程设置名字</p></li>
<li><p>未捕获异常的处理器：</p>
<ul>
<li>线程的run方法不能抛出任何检查型异常。线程死亡前，一场会传递到一个用于处理未捕获异常的处理器。这个处理器必须属于一个实现了Thread.UncaughtExceptionHandler的类。</li>
<li>可以使用setUncaughtExceptionHandler方法为任何线程安装一个处理器。如果没有为单个线程安装处理器，则处理器是该线程的ThreadGroup对象，它的uncaughtException方法执行以下操作：
<ul>
<li>如果该线程组有父线程组，调用父线程组的uncaughtException方法</li>
<li>否则，如果Thread.getDefaultExceptionHandler返回一个非null的处理器，调用这个处理器</li>
<li>否则如果Throwable是ThreadDeath的一个实例，什么都不做</li>
<li>否则将线程的名字以及Throwable的展柜及输出到Sytem.err</li>
</ul></li>
</ul></li>
<li><p>线程优先级：</p>
<ul>
<li>每个线程都有一个优先级，默认情况下继承构造它的那个线程的优先级。</li>
<li>用setPriority方法设定优先级
<ul>
<li>MIN_PRIORITY 1</li>
<li>MAX_PRIORITY 10</li>
</ul></li>
<li>每当线程调度器有机会选择新的线程时，它首先选择具有较高优先级的线程。但是线程的优先级极度依赖于宿主机平台的线程实现。</li>
</ul></li>
<li><p>常用方法</p>
<ul>
<li><p>setName</p></li>
<li><p>getName</p></li>
<li><p>start</p></li>
<li><p>run</p></li>
<li><p>setPriority 更改线程的优先级</p></li>
<li><p>getPriority 获取线程优先级</p></li>
<li><p>sleep 线程休眠</p></li>
<li><p>interrupt 中断线程</p></li>
</ul></li>
<li><p>线程礼让与插队：</p>
<ul>
<li>yield方法：线程让出CPU，让其他线程执行，但礼让的时间不确定，所以也不一定礼让成功。具体由系统底层来决定.</li>
<li>join方法：线程插队，插队的线程插队后，则肯定先执行完插入的线程所有的任务。</li>
</ul></li>
</ul>
<h4 id="线程同步问题">6、线程同步问题</h4>
<p>​
如果两个线程同时存取同一个对象，取决于线程访问数据的顺序，可能会导致对象被破坏，这种情况被称为<strong>竞态条件</strong>。</p>
<p>​ 考虑如下银行转账代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span>[] accounts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bank</span><span class="params">(<span class="type">int</span> n,<span class="type">double</span> initialBalance)</span>&#123;</span><br><span class="line">        accounts = <span class="keyword">new</span> <span class="title class_">double</span>[n];</span><br><span class="line">        Arrays.fill(accounts,initialBalance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to,<span class="type">double</span> amount)</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread());</span><br><span class="line">        accounts[from] -= amount;</span><br><span class="line">        System.out.printf(<span class="string">&quot; %10.2f from %d to %d&quot;</span>,amount,from,to);</span><br><span class="line">        accounts[to] += amount;</span><br><span class="line">        System.out.printf(<span class="string">&quot; TotalBalance: %10.2f\n&quot;</span>,getTotalBalance());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getTotalBalance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">double</span> a:accounts)&#123;</span><br><span class="line">            sum += a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accounts.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NACCOUNTS</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">INITIAL_BALANCE</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">MAX_AMOUT</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DELAY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>(NACCOUNTS,INITIAL_BALANCE);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NACCOUNTS;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fromAccount</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> ()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">toAccount</span> <span class="operator">=</span> (<span class="type">int</span>)(bank.size() * Math.random());</span><br><span class="line">                        <span class="type">double</span> <span class="variable">amount</span> <span class="operator">=</span> MAX_AMOUT * Math.random();</span><br><span class="line">                        bank.transfer(fromAccount,toAccount,amount);</span><br><span class="line">                        Thread.sleep((<span class="type">int</span>)(DELAY*Math.random()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="type">var</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码其中有几个线程会更新银行账户越，运行一段时间后，很有可能有些钱会丢失，导致总金额出现问题。问题在于accounts[to]
+= amount 这一操作不是原子操作。</p>
<p><code>accounts[to] += amount</code> 指令可能需要如下步骤来执行：</p>
<ul>
<li>将accounts[to]加载到寄存器</li>
<li>增加amount</li>
<li>将结果写回accounts[to]</li>
</ul>
<p>线程在任何一个步骤的时候都有可能失去运行权。假设线程1执行了步骤1和2，运行权被抢占。此时线程2执行步骤1、2、3，完成后线程1再执行步骤3.那么线程2所作的操作相当于被抹去了。</p>
<p><strong>线程同步，即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作。</strong></p>
<h5 id="利用锁对象完成同步">1）利用锁对象完成同步：</h5>
<p>​ 利用ReentrantLock保护代码块：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">bankLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">bankLock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">// 需要被保护的方法</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	bankLock.unlock();  <span class="comment">//解锁方法必须被放在finally方法中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
假设一个线程调用了内部的方法，但在执行结束前被抢占。假设此时第二个线程调用了方法，由于第二个线程不能获得锁，将在调用lock方法时被阻塞。直到锁被释放。</p>
<p>​ 这个锁称为重入锁，线程可以反复获得已经拥有的锁。</p>
<p>​ 所有一个持有计数，来跟踪对lock方法的嵌套调用。</p>
<ul>
<li>注意：临界区的代码不要因为抛出异常而跳出临界区，因为如此可能锁被释放的时候，对象处于被破坏的状态。</li>
</ul>
<h5 id="条件对象">2）条件对象</h5>
<p>​
可以使用一个条件对象来管理那些已经获得了一个锁却不能做有用工作的线程。</p>
<p>​
具体使用场景如下：如果一个账户没有足够的资金，我们不希望从这个账户有钱转出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(bank.getBalance(from) &gt;= amount)</span><br><span class="line">    <span class="comment">//使用这样的判断，执行该代码块的线程可能在此处被打断</span></span><br><span class="line">	bank.transfer(fromAccount,toAccount,amount);</span><br><span class="line"><span class="comment">//所以线程再次运行前，有可能账户余额已经低于提款金额。必须确保在检查余额和转账活动之间，没有其他线程修改余额，我们需要使用一个锁来保护这个测试和转账操作。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to,<span class="type">double</span> amount)</span>&#123;</span><br><span class="line">    bankLock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(accounts[from] &lt; amount)&#123;</span><br><span class="line">        	<span class="comment">//等待</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        bankLock.unlock();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当账户中没有足够资金的时候，我们需要等待，直到另一个线程往账户中增加了资金。但是该线程又获得了对bankLock的排他性访问权，因此别的线程没有存款的机会，所以此处要引入条件对象。</p>
<p>​ 一个锁对象可以有一个或多个关联的条件对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Condition sufficientFunds;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;</span><br><span class="line">    sufficientFunds = bankLock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果transfer方法发现资金不足则调用<code>sufficientFunds.await()</code>，当前线程暂停，并放弃锁。这允许其他线程执行。</p>
<p>​
一旦该线程调用await方法，它进入了这个条件的等待集。即使锁重新可用，它也不会回到活动状态。只有另一个线程在同一个条件上调用signalAll方法的时候，才会回到活动状态。</p>
<p>​
所以，当另一个线程完成转账的时候，应该调用<code>sufficientFunds.signalAll()</code></p>
<p>​
这个调用重新激活等待这个条件的所有线程。调度器会再次将他们激活，一旦锁可用，它们中的某个线程将从await调用返回得到这个锁，并且从之前暂停的地方继续执行。</p>
<p>​
<strong>注意：此时应当重新再次测试条件，因为不能保证现在一定满足条件。signalAll方法仅仅起到通知作用。</strong></p>
<p><strong>非常重要的是：当一个线程调用.await()的时候，它没有办法重新自己激活</strong></p>
<p><strong>从经验上讲，只要一个对象的状态有变化，而且有可能利于等待的线程，就可以调用signalAll</strong></p>
<p><strong>signalAll调用并不会立即激活一个等待的线程，只是解除等待线程的阻塞，使得这些线程可以在当前线程释放锁以后竞争访问对象。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span>[] accounts;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">bankLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">	<span class="keyword">private</span> Condition sufficientFunds;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bank</span><span class="params">(<span class="type">int</span> n,<span class="type">double</span> initialBalance)</span>&#123;</span><br><span class="line">        accounts = <span class="keyword">new</span> <span class="title class_">double</span>[n];</span><br><span class="line">        Arrays.fill(accounts,initialBalance);</span><br><span class="line">        sufficientFunds = bankLock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to,<span class="type">double</span> amount)</span>&#123;</span><br><span class="line">        bankLock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(accounts[from] &lt; amount)</span><br><span class="line">                sufficientFunds.await();</span><br><span class="line">            System.out.println(Thread.currentThread());</span><br><span class="line">            accounts[from] -= amount;</span><br><span class="line">            System.out.printf(<span class="string">&quot; %10.2f from %d to %d&quot;</span>,amount,from,to);</span><br><span class="line">            accounts[to] += amount;</span><br><span class="line">            System.out.printf(<span class="string">&quot; TotalBalance: %10.2f\n&quot;</span>,getTotalBalance());</span><br><span class="line">            sufficientFunds.signalAll();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bankLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getTotalBalance</span><span class="params">()</span>&#123;</span><br><span class="line">        bankLock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">double</span> a:accounts)&#123;</span><br><span class="line">                sum += a;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bankLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accounts.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<h5
id="同步具体方法1synchronized关键字">3）同步具体方法1——synchronized关键字：</h5>
<p>​
Lock和Condition对象可以充分控制锁定，但大多数情况下，可以使用synchronized关键字。如果一个方法声明时有synchronized关键字，那么对象的锁将保护整个方法。</p>
<p>​ <strong>内部对象锁只有一个关联条件</strong>
<code>wait</code>方法可以将线程增加到等待集中,<code>notifyAll</code>可以接触等待线程的阻塞.以下代码等价于上述代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to,<span class="type">double</span> amount)</span>&#123;</span><br><span class="line">    <span class="comment">//需要被同步的代码，即同一时刻无论多少线程访问，只能由一个线程执行如下代码。</span></span><br><span class="line">    <span class="keyword">while</span>(accounts[from] &lt; amount)</span><br><span class="line">        wait();</span><br><span class="line">    accounts[from] -= amount;</span><br><span class="line">    accounts[to] += amount;</span><br><span class="line">    notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：如果加synchronized的方法是非静态方法，锁是加在this或者其他对象上的</p>
<p>如果加synchronized的方法是静态方法，锁是加载当前类本身。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123; </span><br><span class="line">	<span class="keyword">synchronized</span>(SellTicket03.class)&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;m2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="同步具体方法2同步代码块">4）同步具体方法2——同步代码块：</h5>
<p>每一个Java对象都有一个锁，当线程进入如下形式的块时，也可以获得锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj)&#123; <span class="comment">//获得对象obj的锁</span></span><br><span class="line">  <span class="comment">//需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="关于一些建议">5）关于一些建议：</h5>
<ul>
<li><p>在代码中最好既不使用Lock/Condition也不适用synchronized关键字。在许多情况下，应当使用java.util.concurrent包中的一些机制。</p></li>
<li><p>如果synchronized适合，尽可能使用此关键字</p></li>
<li><p>如果需要Lock/Condition独有的能力，再使用此种方式</p></li>
</ul>
<h5 id="锁什么时候会释放">6）锁什么时候会释放？</h5>
<ul>
<li>当前线程的同步方法、同步代码块执行结束</li>
<li>当前线程在同步代码块、同步方法中遇到break、return。</li>
<li>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束</li>
<li>当前线程在同步代码块、同步方法中执行了线程对象的wait（）方法，当前线程暂停，并释放锁。</li>
</ul>
<p>注意，以下操作不会释放锁：</p>
<ul>
<li>线程执行同步代码块或同步方法时，程序调用Thread.sleep、Thread.yield0方法暂停当前线程的执行，不会释放锁</li>
<li>线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁。</li>
</ul>
<h4 id="一些线程安全的集合">7、一些线程安全的集合</h4>
<p>如果多个线程并发的修改一个数据结构，很容易破坏。我们需要线程安全的集合</p>
<h5 id="阻塞队列">1）阻塞队列</h5>
<p>许多线程问题可以使用一个或多个队列的方式来描述。</p>
<p>​
比如银行转账，转账线程可以将转账指令插入队列中，而不是直接访问银行对象。同时另一个线程专门负责从队列中取出指令，访问修改银行对象。</p>
<p>​
试图将队列添加元素而队列已满或者试图取元素而队列为空时，阻塞队列将导致线程阻塞。</p>
<p>​ LinkedBlockingQueue PriorityBlockingQueue
等许多java.util.concurent包内的集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> blockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockQueueTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FILE_QUEUE_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span>  <span class="type">int</span> <span class="variable">SEARCH_THREADS</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Path</span> <span class="variable">DUMMY</span> <span class="operator">=</span> Path.of(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;Path&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(FILE_QUEUE_SIZE);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">var</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in))&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;Enter base directory&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">directory</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line">            System.out.print(<span class="string">&quot;Enter keyword&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">keyWord</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//生产者线程</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">enumerator</span> <span class="operator">=</span> () -&gt;&#123;</span><br><span class="line">              <span class="keyword">try</span>&#123;</span><br><span class="line">                  enumerate(Path.of(directory));</span><br><span class="line">                  queue.put(DUMMY);  <span class="comment">//在罗列完的最后，添加一个空的虚拟元素</span></span><br><span class="line">              &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(enumerator).start();</span><br><span class="line">            <span class="comment">//搜索线程</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=SEARCH_THREADS;i++)&#123;</span><br><span class="line">                <span class="type">Runnable</span> <span class="variable">searcher</span> <span class="operator">=</span> () -&gt;&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="type">var</span> <span class="variable">start</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">                        <span class="type">var</span> <span class="variable">done</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">while</span>(!done)&#123;</span><br><span class="line">                            <span class="type">Path</span> <span class="variable">file</span> <span class="operator">=</span> queue.take();</span><br><span class="line">                            <span class="keyword">if</span>(file == DUMMY)&#123;   <span class="comment">//当搜索线程拿到这个空的虚拟路径的时候，该线程终止，并且我们需要把这个空的虚拟路径重新放回队列中，让别的搜索线程也知晓</span></span><br><span class="line">                                queue.put(file);</span><br><span class="line">                                done = <span class="literal">true</span>;</span><br><span class="line">                            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                search(file,keyWord);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="type">var</span> <span class="variable">end</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;Thread %s Finished! Totally Cost:%dms\n&quot;</span>,Thread.currentThread(),end-start);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(searcher).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">enumerate</span><span class="params">(Path directory)</span> <span class="keyword">throws</span> IOException,InterruptedException&#123;</span><br><span class="line">        <span class="keyword">try</span>(Stream&lt;Path&gt; children = Files.list(directory))&#123;</span><br><span class="line">            <span class="keyword">for</span>(Path child:children.collect(Collectors.toList()))&#123;</span><br><span class="line">                <span class="keyword">if</span>(Files.isDirectory(child)) enumerate(child);</span><br><span class="line">                <span class="keyword">else</span> queue.put(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">search</span><span class="params">(Path file,String keyWord)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">var</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(file,StandardCharsets.UTF_8))&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">lineNumber</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(in.hasNextLine())&#123;</span><br><span class="line">                lineNumber++;</span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line">                <span class="keyword">if</span>(line.contains(keyWord)) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%s,%s:%d:%s\n&quot;</span>,Thread.currentThread(),file,lineNumber,line);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​
上述代码，生产者线程枚举所有子目录下的所有文件，并把他们放到一个阻塞队列中。</p>
<p>​
同时启用大量的搜索线程，每个搜索线程从队列中去除一个文件，打开它后打印所有包含该关键字的行。</p>
<h5
id="高效的映射集和队列并发散列映射">2）高效的映射、集和队列——并发散列映射</h5>
<p>详见书</p>
<h4 id="任务和线程池">8、任务和线程池：</h4>
<p>​
构造一个新的线程开销很大，因为这涉及与操作系统的交互。如果你的程序中创建了大量的生命期很短的线程，那么不应该把每个任务映射到一个单独的线程，而应该使用线程池。</p>
<p>​
线程池中有许多准备运行的线程，为线程池提供一个Runable对象，就会有一个线程调用run方法。当run方法退出时，该线程也不会死亡，而是留在池中准备为下一个调用提供服务。</p>
<h5 id="callable和runnable">1）Callable和Runnable</h5>
<p>Runnable封装了异步任务，没有返回值。Callable类似但有返回值。</p>
<p>Future接口用于保存异步计算的结果。</p>
<p>FutureTask实现了Future和Runnable接口，所以可以构造一个线程来运行这个任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Callable&lt;Integer&gt; task = ...;</span><br><span class="line"><span class="type">var</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(task);</span><br><span class="line"><span class="type">var</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">t.start();</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> task.get();</span><br></pre></td></tr></table></figure>
<h5 id="执行器">2）执行器：</h5>
<p>​ Executors类有许多方法用于构造线程池。</p>
<ul>
<li><p>newCachedThreadPool
缓存线程池，如果有空闲线程可用就使用，没有就创建一个新的线程。空闲线程会保留60s。（如果线程生存期短，可以使用该线程）</p></li>
<li><p>newFixedThreadPool
池中包含固定数目的线程。空闲线程会一直保留。为了达到最优的运行速度，并发线程数等于处理器内核数，应当使用该种固定线程池。</p></li>
<li><p>newSingleThreadExecutor
只有一个线程的线程池，用于性能分析</p></li>
</ul>
<h5 id="如何使用">3）如何使用？</h5>
<ul>
<li>调用执行器的静态方法创建线程池</li>
<li>调用submit提交Runnable或Callable对象</li>
<li>保存好返回的Future对象，以便得到结果或者取消任务</li>
<li>当不想再提交任何任务的时候，调用shutdown。</li>
</ul>
<h5
id="使用执行器来控制一组相关的任务">4）使用执行器来控制一组相关的任务</h5>
<ul>
<li><p>invokeAny方法提交一个Callable对象集合中的所有对象，并返回某个已经完成任务的结果。（往往用于搜索结果）只要其中一个任务得到了答案，计算就可以停止了。</p></li>
<li><p>invokeAll方法提交一个Callable对象集合中的所有对象，该方法会阻塞直到所有任务都完成，并返回一个表示所有任务答案的一个Future对象列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Callable&lt;T&gt;&gt; tasks = ...</span><br><span class="line">List&lt;Future&lt;T&gt;&gt; results = executor.invokeAll(tasks);</span><br><span class="line"><span class="keyword">for</span>(Future&lt;T&gt; result:results)</span><br><span class="line">	processFurther(result.get());</span><br></pre></td></tr></table></figure></li>
<li><p>利用ExecutorCompletionService来管理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExecutorCompletionService</span>&lt;T&gt;(executor);</span><br><span class="line"><span class="keyword">for</span>(Callable&lt;T&gt; task:tasks) service.submit(task);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tasks.size();i++)&#123;</span><br><span class="line">	processFurther(service.take().get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="示例程序">5) 示例程序：</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorDemo</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">occurrences</span><span class="params">(String word, Path path)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(path))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (in.hasNext())</span><br><span class="line">                <span class="keyword">if</span> (in.next().equals(word)) count++;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Path&gt; <span class="title function_">descendants</span><span class="params">(Path rootDir)</span> <span class="keyword">throws</span> IOException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> (Stream&lt;Path&gt; entries = Files.walk(rootDir))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> entries.filter(Files::isRegularFile)</span><br><span class="line">                    .collect(Collectors.toSet());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Path&gt; <span class="title function_">searchForTask</span><span class="params">(String word, Path path)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(path))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (in.hasNext())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (in.next().equals(word)) <span class="keyword">return</span> path;</span><br><span class="line">                    <span class="keyword">if</span> (Thread.currentThread().isInterrupted())</span><br><span class="line">                    &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Search in &quot;</span> + path + <span class="string">&quot; canceled.&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException, ExecutionException, IOException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;Enter base directory (e.g. /opt/jdk-9-src): &quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">start</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line">            System.out.print(<span class="string">&quot;Enter keyword (e.g. volatile): &quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line"></span><br><span class="line">            Set&lt;Path&gt; files = descendants(Path.of(start));</span><br><span class="line">            <span class="type">var</span> <span class="variable">tasks</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Callable&lt;Long&gt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (Path file : files)</span><br><span class="line">            &#123;</span><br><span class="line">                Callable&lt;Long&gt; task = () -&gt; occurrences(word, file);</span><br><span class="line">                tasks.add(task);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">            <span class="comment">// use a single thread executor instead to see if multiple threads</span></span><br><span class="line">            <span class="comment">// speed up the search</span></span><br><span class="line">            <span class="comment">// ExecutorService executor = Executors.newSingleThreadExecutor();</span></span><br><span class="line"></span><br><span class="line">            <span class="type">Instant</span> <span class="variable">startTime</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">            List&lt;Future&lt;Long&gt;&gt; results = executor.invokeAll(tasks);</span><br><span class="line">            <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (Future&lt;Long&gt; result : results)</span><br><span class="line">                total += result.get();</span><br><span class="line">            <span class="type">Instant</span> <span class="variable">endTime</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">            System.out.println(<span class="string">&quot;Occurrences of &quot;</span> + word + <span class="string">&quot;: &quot;</span> + total);</span><br><span class="line">            System.out.println(<span class="string">&quot;Time elapsed: &quot;</span></span><br><span class="line">                    + Duration.between(startTime, endTime).toMillis() + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">var</span> <span class="variable">searchTasks</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Callable&lt;Path&gt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (Path file : files)</span><br><span class="line">                searchTasks.add(searchForTask(word, file));</span><br><span class="line">            <span class="type">Path</span> <span class="variable">found</span> <span class="operator">=</span> executor.invokeAny(searchTasks);</span><br><span class="line">            System.out.println(word + <span class="string">&quot; occurs in: &quot;</span> + found);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (executor <span class="keyword">instanceof</span> ThreadPoolExecutor) <span class="comment">// the single thread executor isn&#x27;t</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Largest pool size: &quot;</span></span><br><span class="line">                        + ((ThreadPoolExecutor) executor).getLargestPoolSize());</span><br><span class="line">            executor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="fork-join框架">6）fork-join框架</h5>
<p>​
该框架用于支持计算密集型任务，为每一个处理器内核分别使用一个线程，如图像或视频处理。</p>
<h4 id="进程">8、进程</h4>
<ul>
<li><p>建立一个进程，指定想要执行的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var builder = new ProcessBuilder(&quot;gcc&quot;,&quot;myapp.c&quot;);</span><br></pre></td></tr></table></figure></li>
<li><p>默认情况下，进程的工作目录与虚拟机相同，即为启动java程序的那个目录</p></li>
</ul>
]]></content>
      <categories>
        <category>⑤  编程语言类笔记</category>
        <category>java精简系列笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java精简系列笔记6——集合</title>
    <url>/2022/08/02/66adf86c9b3f/</url>
    <content><![CDATA[<p><strong>知识来源：《Java核心技术卷I》第9章节</strong></p>
<h3 id="一集合简介">一、集合简介</h3>
<h4 id="设计特点">1、设计特点：</h4>
<h5
id="在java的集合框架中采用了集合接口和实现分离的形式">1）在java的集合框架中，采用了集合接口和实现分离的形式</h5>
<p>以队列为例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Queue</span>&lt;E&gt;&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element)</span>;</span><br><span class="line">	E <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上述接口并不关心队列是如何实现的，每一个实现都可以用一个实现了Queue接口的类表示。这样子当想要更换队列的实现方式的时候，维护就变得十分方便。</li>
</ul>
<h5 id="支持泛型">2）支持泛型</h5>
<p>我们可以限制在一个集合中只能放入同一种数据类型的元素。</p>
<h4 id="如何访问集合">2、如何访问集合：</h4>
<p>​
通过统一的方式—迭代器Iterator，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。</p>
<ul>
<li>Iterator接口如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt;&#123;</span><br><span class="line">	E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于标准类库中的任何集合都可以使用for each循环</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(String element : c)&#123;</span><br><span class="line">	<span class="comment">//do something with element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>注意：Iterator接口的next方法和remove方法之间存在依赖性。</p>
<ul>
<li><p>remove方法将会删除上次调用next方法时返回的元素</p></li>
<li><p>在调用remove方法前，必须调用next方法</p></li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">it.next();</span><br><span class="line">it.remove();</span><br></pre></td></tr></table></figure>
<h4 id="集合的基本接口collection">3、集合的基本接口：Collection</h4>
<p>Java类库中，<strong>集合类的基本接口是Collection接口，它是除<code>Map</code>外所有其他集合类的根接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt;&#123;</span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E element)</span>;</span><br><span class="line">	Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>主要提供了以下三种类型的集合：
<ul>
<li><code>List</code>：一种有序列表的集合</li>
<li><code>Set</code>：一种保证没有重复元素的集合</li>
<li><code>Map</code>：一种通过键值（key-value）查找的映射表集合</li>
</ul></li>
</ul>
<h4 id="java集合类的接口示意图">4、Java集合类的接口示意图：</h4>
<ul>
<li><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/QQ图片20220803104614.jpg" style="zoom: 33%;" /></p></li>
<li><p>java集合具体的类：</p>
<ul>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/63EB72806CBE9A7185533D84D249B482.jpg" /></li>
</ul></li>
</ul>
<h3 id="二list">二、List:</h3>
<h4 id="list接口">1、List<E>接口</h4>
<ul>
<li>在末尾添加一个元素：<code>boolean add(E e)</code></li>
<li>在指定索引添加一个元素：<code>boolean add(int index, E e)</code></li>
<li>删除指定索引的元素：<code>E remove(int index)</code></li>
<li>删除某个元素：<code>boolean remove(Object e)</code></li>
<li>获取指定索引的元素：<code>E get(int index)</code></li>
<li>获取链表大小（包含元素的个数）：<code>int size()</code></li>
<li>是否包含某个指定元素：<code>boolean contains(Object o)</code></li>
<li>返回某个元素的索引,如果不存在返回-1：<code>int indexOf(Object o)</code></li>
</ul>
<h5 id="特点">1）特点：</h5>
<ul>
<li>允许添加null</li>
<li>允许添加重复元素</li>
</ul>
<h5 id="其他操作">2）其他操作：</h5>
<ul>
<li>使用List.of(1,2,3)根据给定元素快速创建List</li>
<li>如何转换List至Array</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">String[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[list.size()]);</span><br></pre></td></tr></table></figure>
<h4 id="链表-linkedlist">2、链表 LinkedList:</h4>
<p>​ Java中，所有链表的实现都是双向的，即Doubly LinkedList.</p>
<p>​
我们可以用迭代器来修改或遍历这个集合，如果两个迭代器同时对某个集合操作，则会造成混乱。所以链表迭代器设计为可以检测到这种修改，会抛出一个ConcurrentModificationException异常。</p>
<p>​
<strong>遵循规则</strong>：可以为一个集合关联多个迭代器，但都是只能读取集合。或者可以关联一个能够同时读写的迭代器。</p>
<h4 id="数组列表-arraylist">3、数组列表 ArrayList:</h4>
<p>​
访问集合中的元素可以通过迭代器，或get和set随机访问。get不适用于链表，但很适用于数组。所以实现了ArrayList类，其实现了List接口。封装了一个可以动态再分配的对象数组。</p>
<h3 id="三map">三、Map：</h3>
<h4 id="mapkv接口">1、Map&lt;K,V&gt;接口</h4>
<ul>
<li>获得一个元素的值：<code>V get(K key)</code></li>
<li>删除一个键值对：<code>V remove(K key)</code></li>
<li>添加一个键值对：<code>V put(K key, V value)</code></li>
<li>是否包含某个键：<code>boolean containsKey(K key)</code></li>
<li>获得键集(详见映射)：<code>Set&lt;K&gt; keySet()</code></li>
<li>获得值集(详见映射)：<code>Collection&lt;V&gt; values()</code></li>
<li>获得键值对集合(详见映射)：<code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code></li>
</ul>
<h4 id="注意">2、注意：</h4>
<p>​ 使用<code>Map</code>时，任何依赖顺序的逻辑都是不可靠的。</p>
<h4 id="遍历map">3、遍历Map：</h4>
<p>​
对<code>Map</code>来说，要遍历<code>key</code>可以使用<code>for each</code>循环遍历<code>Map</code>实例的<code>keySet()</code>方法返回的<code>Set</code>集合，它包含不重复的<code>key</code>的集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">    System.out.println(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四equals方法和hashcode">四、equals方法和HashCode</h3>
<p>​
要正确使用<code>List</code>的<code>contains()</code>、<code>indexOf()</code>这些方法，放入的实例必须正确覆写<code>equals()</code>方法，否则，放进去的实例，查找不到。同时，在<code>Map</code>的内部，对<code>key</code>做比较也是通过<code>equals()</code>实现的，这一点和<code>List</code>查找元素需要正确覆写<code>equals()</code>是一样的，即正确使用<code>Map</code>必须保证：作为<code>key</code>的对象必须正确覆写<code>equals()</code>方法。</p>
<p>​
<code>List</code>内部并不是通过<code>==</code>判断两个元素是否相等，而是使用<code>equals()</code>方法判断两个元素是否相等。因此，要正确使用<code>List</code>的<code>contains()</code>、<code>indexOf()</code>这些方法，放入的实例必须正确覆写<code>equals()</code>方法。</p>
<h4 id="equals方法需要满足的条件-rstc">1、Equals方法需要满足的条件：
RSTC</h4>
<ul>
<li>自反性（Reflexive）：对于非<code>null</code>的<code>x</code>来说，<code>x.equals(x)</code>必须返回<code>true</code>；</li>
<li>对称性（Symmetric）：对于非<code>null</code>的<code>x</code>和<code>y</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，则<code>y.equals(x)</code>也必须为<code>true</code>；</li>
<li>传递性（Transitive）：对于非<code>null</code>的<code>x</code>、<code>y</code>和<code>z</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，<code>y.equals(z)</code>也为<code>true</code>，那么<code>x.equals(z)</code>也必须为<code>true</code>；</li>
<li>一致性（Consistent）：对于非<code>null</code>的<code>x</code>和<code>y</code>来说，只要<code>x</code>和<code>y</code>状态不变，则<code>x.equals(y)</code>总是一致地返回<code>true</code>或者<code>false</code>；</li>
<li>对<code>null</code>的比较：即<code>x.equals(null)</code>永远返回<code>false</code>。</li>
</ul>
<h4 id="equals编写的方法">2、Equals编写的方法</h4>
<p>因此，我们总结一下<code>equals()</code>方法的正确编写方法：</p>
<ol type="1">
<li>先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等；</li>
<li>用<code>instanceof</code>判断传入的待比较的<code>Object</code>是不是当前类型，如果是，继续比较，否则，返回<code>false</code>；</li>
<li>对引用类型用<code>Objects.equals()</code>比较，对基本类型直接用<code>==</code>比较。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(<span class="built_in">this</span>.name, p.name) &amp;&amp; <span class="built_in">this</span>.age == p.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="hashcode方法的编写规范">3、HashCode方法的编写规范：</h4>
<p>​
通过<code>key</code>计算索引的方式就是调用<code>key</code>对象的<code>hashCode()</code>方法，它返回一个<code>int</code>整数。<code>HashMap</code>正是通过这个方法直接定位<code>key</code>对应的<code>value</code>的索引，继而直接返回<code>value</code>。</p>
<p>因此，正确使用<code>Map</code>必须保证：</p>
<ol type="1">
<li>作为<code>key</code>的对象必须正确覆写<code>equals()</code>方法，相等的两个<code>key</code>实例调用<code>equals()</code>必须返回<code>true</code>；</li>
<li>作为<code>key</code>的对象还必须正确覆写<code>hashCode()</code>方法，且<code>hashCode()</code>方法要严格遵循以下规范：</li>
</ol>
<ul>
<li>如果两个对象相等，则两个对象的<code>hashCode()</code>必须相等；</li>
<li>如果两个对象不相等，则两个对象的<code>hashCode()</code>尽量不要相等。</li>
</ul>
<p>（第二条如果尽量满足，则可以保证查询效率，因为不同的对象，如果返回相同的<code>hashCode()</code>，会造成<code>Map</code>内部存储冲突，使存取的效率下降）</p>
<h4 id="hashcode编写的方法">4、HashCode编写的方法：</h4>
<p>​
<code>equals()</code>用到的用于比较的每一个字段，都必须在<code>hashCode()</code>中用于计算；<code>equals()</code>中没有使用到的字段，绝不可放在<code>hashCode()</code>中计算。</p>
<p>​
实现<code>hashCode()</code>方法可以通过<code>Objects.hashCode()</code>辅助方法实现。</p>
<h3 id="五map具体类的使用">五、Map具体类的使用</h3>
<h4 id="enummap">1、EnumMap</h4>
<p>​
如果作为key的对象是<code>enum</code>类型，那么，还可以使用Java集合库提供的一种<code>EnumMap</code>，它在内部以一个非常紧凑的数组存储value，并且根据<code>enum</code>类型的key直接定位到内部数组的索引，并不需要计算<code>hashCode()</code>.</p>
<h4 id="sortedmaptreemap">2、SortedMap——TreeMap</h4>
<p>​
还有一种<code>Map</code>，它在内部会对Key进行排序，这种<code>Map</code>就是<code>SortedMap</code>。注意到<code>SortedMap</code>是接口，它的实现类是<code>TreeMap</code>。<strong><code>SortedMap</code>
保证遍历时以Key的顺序来进行排序。</strong></p>
<p>​
使用<code>TreeMap</code>时，放入的Key必须实现<code>Comparable</code>接口。<code>Comparator</code>接口要求实现一个比较方法，<strong>它负责比较传入的两个元素<code>a</code>和<code>b</code>，如果<code>a&lt;b</code>，则返回负数，通常是<code>-1</code>，如果<code>a==b</code>，则返回<code>0</code>，如果<code>a&gt;b</code>，则返回正数，通常是<code>1</code>。<code>TreeMap</code>内部根据比较结果对Key进行排序。</strong></p>
<p>​ 也可以通过直接定义Comparator的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Student, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student p1, Student p2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1.score == p2.score) &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> p1.score &gt; p2.score ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="六使用properties类">六、使用Properties类：</h3>
<h4 id="读取配置文件">1、读取配置文件</h4>
<p>​
Java默认配置文件以<code>.properties</code>为扩展名，每行以<code>key=value</code>表示，以<code>#</code>课开头的是注释。以下是一个典型的配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># setting.properties</span><br><span class="line"></span><br><span class="line">last_open_file=/data/hello.txt</span><br><span class="line">auto_save_interval=60</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">f</span> <span class="operator">=</span> <span class="string">&quot;setting.properties&quot;</span>;</span><br><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.load(<span class="keyword">new</span> <span class="title class_">java</span>.io.FileInputStream(f));</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">filepath</span> <span class="operator">=</span> props.getProperty(<span class="string">&quot;last_open_file&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">interval</span> <span class="operator">=</span> props.getProperty(<span class="string">&quot;auto_save_interval&quot;</span>, <span class="string">&quot;120&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="写入配置文件">2、写入配置文件</h4>
<p>​
如果通过<code>setProperty()</code>修改了<code>Properties</code>实例，可以把配置写入文件，以便下次启动时获得最新配置。写入配置文件使用<code>store()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.setProperty(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;http://www.liaoxuefeng.com&quot;</span>);</span><br><span class="line">props.setProperty(<span class="string">&quot;language&quot;</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">props.store(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:\\conf\\setting.properties&quot;</span>), <span class="string">&quot;这是写入的properties注释&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="七set">七、Set：</h3>
<ul>
<li>将元素添加进<code>Set&lt;E&gt;</code>：<code>boolean add(E e)</code></li>
<li>将元素从<code>Set&lt;E&gt;</code>删除：<code>boolean remove(Object e)</code></li>
<li>判断是否包含元素：<code>boolean contains(Object e)</code></li>
</ul>
<p>​
放入<code>Set</code>的元素需要正确实现<code>equals()</code>和<code>hashCode()</code>方法，<code>Set</code>接口并不保证有序，而<code>SortedSet</code>接口则保证元素是有序的：</p>
<ul>
<li><code>HashSet</code>是无序的，因为它实现了<code>Set</code>接口，并没有实现<code>SortedSet</code>接口；</li>
<li><code>TreeSet</code>是有序的，因为它实现了<code>SortedSet</code>接口。</li>
</ul>
<h4 id="散列集-hashset">1、散列集 HashSet:</h4>
<p>​
能够快速查找元素的数据结构。在Java中，散列表用链表数组实现，每个列表被称为桶。通常我们将桶数设置为预计元素个数的75%~150%。装填因子可以确定何时对散列表进行再散列，一般为0.75。</p>
<p>​
在散列表中插入某元素，需要先计算该元素的hash值，找到对应的桶，再将其与桶内的元素比较是否有重复即可，无需和散列表中所有元素比较.</p>
<h4 id="树集-treeset">2、树集 TreeSet:</h4>
<p>​
有序集合,<strong>由红黑树实现.值将自动的按照排序前后的顺序实现.要使用树集</strong>,必须能够比较元素,所以这些元素必须实现Comparable接口,或者构造集合的时候提供一个Comparator.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var parts = new TreeSet&lt;Item&gt;();   //会按照Item的默认排序</span><br><span class="line">parts.add(new Item(&quot;a&quot;,1));</span><br><span class="line">parts.add(new Item(&quot;b&quot;,2));</span><br><span class="line">parts.add(new Item(&quot;c&quot;,3));</span><br><span class="line"></span><br><span class="line">var sortByDescription = new TreeSet&lt;Item&gt;   (Comparator.comparing(Item::getDescription));  //提供一个Comparator,通过Item的描述排序</span><br><span class="line"> </span><br><span class="line">sortByDescription.addAll(parts);</span><br></pre></td></tr></table></figure>
<h3 id="八queue">八、Queue：</h3>
<ul>
<li><code>int size()</code>：获取队列长度；</li>
<li><code>boolean add(E)</code>/<code>boolean offer(E)</code>：添加元素到队尾；</li>
<li><code>E remove()</code>/<code>E poll()</code>：获取队首元素并从队列中删除；</li>
<li><code>E element()</code>/<code>E peek()</code>：获取队首元素但并不从队列中删除。</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221103102520030.png" /></p>
<h4 id="双端队列deque">1、双端队列Deque:</h4>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221103103318611.png" /></p>
<p>​ ArrayDeque和LinkedList都可以实现双端队列</p>
<h4 id="优先队列-priorityqueue带优先级的队列">2、优先队列
PriorityQueue【带优先级的队列】</h4>
<p>​ 使用堆来搭建.典型用法是任务调度.</p>
<p>​
放入<code>PriorityQueue</code>的元素，必须实现<code>Comparable</code>接口，<code>PriorityQueue</code>会根据元素的排序顺序决定出队的优先级。</p>
<ul>
<li>总是调用<code>xxxFirst()</code>/<code>xxxLast()</code>以便与<code>Queue</code>的方法区分开；</li>
<li>避免把<code>null</code>添加到队列。</li>
</ul>
<h3 id="九stack">九、Stack</h3>
<ul>
<li>把元素压栈：<code>push(E)</code>；</li>
<li>把栈顶的元素“弹出”：<code>pop()</code>；</li>
<li>取栈顶元素但不弹出：<code>peek()</code>。</li>
</ul>
<p>在Java中，我们用<code>Deque</code>可以实现<code>Stack</code>的功能：</p>
<ul>
<li>把元素压栈：<code>push(E)</code>/<code>addFirst(E)</code>；</li>
<li>把栈顶的元素“弹出”：<code>pop()</code>/<code>removeFirst()</code>；</li>
<li>取栈顶元素但不弹出：<code>peek()</code>/<code>peekFirst()</code>。</li>
</ul>
<h3 id="十iterator-遍历集合">十、Iterator 遍历集合：</h3>
<p>​
Java的集合类都可以使用<code>for each</code>循环，<code>List</code>、<code>Set</code>和<code>Queue</code>会迭代每个元素，<code>Map</code>会迭代每个key。调用方总是以统一的方式遍历各种集合类型，而不必关心它们内部的存储结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们自己编写了一个集合类，想要使用<code>for each</code>循环，只需满足以下条件：</p>
<ul>
<li>集合类实现<code>Iterable</code>接口，该接口要求返回一个<code>Iterator</code>对象；</li>
<li>用<code>Iterator</code>对象迭代集合内部数据。</li>
</ul>
<p>这里的关键在于，集合类通过调用<code>iterator()</code>方法，返回一个<code>Iterator</code>对象，这个对象必须自己知道如何遍历该集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ReverseList&lt;String&gt; rlist = <span class="keyword">new</span> <span class="title class_">ReverseList</span>&lt;&gt;();</span><br><span class="line">        rlist.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">        rlist.add(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">        rlist.add(<span class="string">&quot;Pear&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : rlist) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReverseList</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        list.add(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReverseIterator</span>(list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ReverseIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">        ReverseIterator(<span class="type">int</span> index) &#123;</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">return</span> ReverseList.<span class="built_in">this</span>.list.get(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="十一映射与视图">十一、映射与视图:</h3>
<h4 id="映射">1、映射</h4>
<ul>
<li><p>HashMap和TreeMap都实现了Map接口.
散列或比较函数都只应用于Key,而Value值不进行比较.</p></li>
<li><p>如何迭代处理映射的键和值?</p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scores.forEach((k,v)-&gt;System.out.println(&quot;k&quot;+k+&quot;v&quot;+v));</span><br></pre></td></tr></table></figure>
<ul>
<li><p>更新映射条目:</p>
<ul>
<li>当条目不存在时，counts.get(word)会返回一个NullPointerException异常，我们可以使用getOrDefault方法来补救。counts.getOrDefault(word,0)</li>
</ul></li>
<li><p>映射的视图：</p>
<ul>
<li><p>对于一个映射集合而言，可以得到3种不同的映射的视图</p>
<ul>
<li>键集</li>
<li>值集</li>
<li>键值对集合</li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.keySet()</span><br><span class="line">map.values()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String,Employee&gt; entry : staff.entrySet() )&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">k</span> <span class="operator">=</span> entry.getKey()</span><br><span class="line">	<span class="type">Employee</span> <span class="variable">v</span> <span class="operator">=</span> entry.getValue()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在键集视图上调用remove方法，会移除键和关联的值。不能向键集视图中添加元素</p>
<ul>
<li><p>弱散列映射</p>
<ul>
<li>如果对某个键的最后一个引用已经消失了，那么不会有任何途径引用这个值的对象了。在WeakHashMap中会将其自动回收。</li>
</ul></li>
<li><p>链接散列集和映射</p>
<ul>
<li>LinkedHashSet和LinkedHashMap会记录插入元素项的顺序。即在表中插入元素项时，就会并入到双向链表中，以保持插入顺序。</li>
<li>其也可以使用访问顺序而不是插入顺序来访问，具体见P401</li>
</ul></li>
<li><p>枚举集和映射</p>
<ul>
<li>EnumSet是枚举类型元素集的高效实现。其内部用位序列实现，对应的值在其中，则相应的位被置1.</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123; MONDAY,TUESDAY,WEDNESDAY &#125;</span><br><span class="line">EnumSet&lt;Weekday&gt; always = EnumSet.allOf(Weekday.class)</span><br></pre></td></tr></table></figure>
<h4 id="视图与包装器">2、视图与包装器：</h4>
<p>​
例如上述的keySet()方法，会返回一个实现了Set接口的类对象，有这个类的方法操纵原映射。这种集合就叫做视图。</p>
<ul>
<li><p>应用1：小集合：</p></li>
<li><p>应用2：子范围</p></li>
<li><p>应用3：不可修改视图</p></li>
<li><p>应用4：同步视图</p></li>
<li><p>应用5：检查型视图：</p></li>
</ul>
<h3 id="十二collections工具类">十二、Collections工具类</h3>
<h4 id="排序与混排">1、排序与混排：</h4>
<ul>
<li>Collections类中的sort方法可以对实现了List接口的集合进行排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">staff</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">Collections.sort(staff);  <span class="comment">//使用稳定的排序算法进行排序（如归并，所谓稳定，指的是不会改边值相同的元素的前后位置。）</span></span><br><span class="line"></span><br><span class="line">staff.sort(Comparator.comparingDouble(Employee::getSalary));</span><br><span class="line"></span><br><span class="line">staff.sort(Comparator.reverseOrder())</span><br><span class="line"></span><br><span class="line">staff.sort(Comparator.comparingDouble(Employee::getSalary).reversed())</span><br></pre></td></tr></table></figure>
<ul>
<li>Collections类中的shuffle方法可以随机打乱。</li>
</ul>
<h4 id="二分查找">2、二分查找：</h4>
<ul>
<li><p>Collections.binarySearch()
从有序列表中搜索一个键，如果元素类型实现了RandomAccess接口，则是二分查找，否则会采用线性查找。
对一个链表应用这个方法，将自动退化为线性查找。</p></li>
<li><p>简单算法：</p>
<ul>
<li>见P416页。</li>
</ul></li>
<li><p>集合与数组的转换：</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] values = ...</span><br><span class="line"><span class="type">var</span> <span class="variable">staff</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(List.of(values));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] values = staff.toArray();</span><br><span class="line"><span class="comment">//toArray返回的是Object对象数组，且不能改变里面的类型，所以应当使用如下方法：</span></span><br><span class="line">String[] values = staff.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[staff.size()]);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>⑤  编程语言类笔记</category>
        <category>java精简系列笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java精简系列笔记5——异常、断言和日志</title>
    <url>/2022/08/02/22cd7f0d9b01/</url>
    <content><![CDATA[<p><strong>知识来源：《Java核心技术卷I》第7章节</strong></p>
<h4 id="一异常">一、异常</h4>
<p>当发生错误的时候，应当做到以下三点：</p>
<ul>
<li>向用户通知错误</li>
<li>保存所有的工作</li>
<li>允许用户妥善的退出程序</li>
</ul>
<p>异常处理的任务是将控制权从产生错误的地方转移到能够处理这种情况的错误处理器</p>
<p>如下是Java中的异常层次结构：</p>
<ul>
<li><p>Throwable</p>
<ul>
<li>Error：内部错误和资源耗尽错误</li>
<li>Exception
<ul>
<li>IOException 其他异常，例如试图打开一个不存在的文件等</li>
<li>RuntimeException 一般由编程错误导致</li>
</ul></li>
</ul></li>
<li><p>Java将派生于Error和RuntimeException类的所有异常称为非检查型异常，所有其他的异常称为检查型异常。<strong>编译器将检查你是否为所有的检查型异常提供了异常处理器</strong></p></li>
<li><p>自己编写方法时，不必声明这个方法可能抛出的所有异常，需要记住在以下四种情况下抛出异常：</p>
<ul>
<li>调用了一个抛出检查型异常的方法</li>
<li>检测到一个错误，并利用throw语句抛出一个检查行异常</li>
<li>程序出现错误</li>
<li>Java虚拟机或运行时库出现内部错误</li>
</ul></li>
<li><p>如果一个类中的方法声明它会抛出一个异常，这个被抛出的异常可能属于这个类，也可能属于这个类的子类。</p></li>
<li><p>创建异常类：</p>
<ul>
<li><p>标准的做法是创建两个构造函数，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileFormatException</span> <span class="keyword">extends</span> <span class="title class_">IOException</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">FileFormatException</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">FileFormatException</span><span class="params">(String gripe)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(gripe)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>如果编写一个方法覆盖超类的方法，而这个超类方法没有抛出异常，你就必须捕获你的方法代码中出现的每一个检查型异常。不允许在子类的throws说明符中出现超类方法未列出的异常类。</p></li>
<li><p>可以在catch中再次抛出异常，通常希望改变异常类型的时候会这么做。</p></li>
<li><p>不管是否有异常被抛出，finally子句都会执行，一般用于关闭一些已经被占用的系统资源。</p></li>
<li><p>try-with-Resources语句</p></li>
<li><p>假设资源属于一个实现了AutoCloseable接口的类，可以使用如下语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(Resource res)&#123;</span><br><span class="line">	<span class="keyword">while</span>(in.hasNext())&#123;</span><br><span class="line">		<span class="comment">//....</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>try块正常退出或是存在一个异常时，会自动调用res.close()函数，如果使用常规方式编程就需要两个try和finally语句。</p></li>
<li><p>分析堆栈轨迹元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var t = new Throwable()</span><br><span class="line">t.printStackTrace()</span><br></pre></td></tr></table></figure>
<ul>
<li>使用StakcWalker类，来逐个分析</li>
</ul></li>
<li><p>使用异常的技巧：</p>
<ul>
<li>异常处理不能代替简单的if判断测试，因为耗时较久</li>
<li>不要过分地细化异常</li>
<li>充分利用异常层次结构
<ul>
<li>不要只抛出RuntimeException异常，不要只捕获Throwable异常。</li>
</ul></li>
<li>不要压制异常：</li>
<li>在检测错误时，尽可能地严苛</li>
<li>不要羞于传递异常，这样可以让更高层的方法更好的通知用户发生了错误</li>
</ul></li>
</ul>
<h4 id="二断言">二、断言：</h4>
<ul>
<li><p>断言机制允许在测试期间向代码中插入一些检查，而在生产代码中会自动删除这些检查。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> x&gt;=<span class="number">0</span>;   <span class="comment">//如果条件不成立，抛出一个AssertionError异常</span></span><br><span class="line"><span class="keyword">assert</span> x&gt;=<span class="number">0</span> : x;  <span class="comment">//如果条件不成立，抛出一个AssertionError异常，携带x的实际值</span></span><br></pre></td></tr></table></figure></li>
<li><p>在默认情况下，断言是禁用的，可以在运行程序时用-ea选项启用断言。</p></li>
<li><p>程序员使用断言来进行自我检查</p></li>
</ul>
<h4 id="三日志">三、日志</h4>
<ul>
<li><p>日志API用于调试所生，其优点如下所示：</p>
<ul>
<li>可以很容易地取消全部日志记录，或仅仅取消某个级别一下地日志</li>
<li>可以很简单地禁止日志记录</li>
<li>日志记录可以被定向到不同的处理器</li>
</ul></li>
<li><p>全局日志记录器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Logger.getGlobal().info(<span class="string">&quot;File-&gt;open menu&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Logger.getGlobal().setLevel(Level.OFF)  <span class="comment">//取消所有日志</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用getLogger方法创建或获取日志记录器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">mylogger</span> <span class="operator">=</span> Logger.getLogger(<span class="string">&quot;com.mycompany.myapp&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>日志记录器名具有层次结构，如果对"com.mycompany"设置了日志级别，它的子日志记录器也会继承这个级别。</p></li>
<li><p>日志级别：</p>
<ul>
<li>SEVERE</li>
<li>WARNING</li>
<li>INFO</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logger.setLevel(Level.WARNING)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logger.warning(message)</span><br><span class="line">logger.info(message)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>⑤  编程语言类笔记</category>
        <category>java精简系列笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java精简系列笔记3——java继承</title>
    <url>/2022/07/21/bfa2f3ecdb39/</url>
    <content><![CDATA[<p><strong>知识来源：《Java核心技术卷I》第5章节，继承</strong></p>
<ul>
<li>在Java中，对象变量是多态的。一个父类对象可以引用子类对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>()</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用final修饰符就代表该类无法被继承。使用final修饰符修饰类中的某个特定方法，代表子类不能覆盖这个方法</p></li>
<li><p>抽象方法的定义：</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getDescription</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>包含一个或多个抽象方法的类本身需要声明为抽象的，除了抽象方法，抽象类可以包含字段和具体方法</p></li>
<li><p>抽象类是不能实例化的，但我们可以定义一个抽象类的对象变量，这个变量只能引用非抽象子类的对象。</p></li>
<li><p>访问控制符小结：</p>
<ul>
<li>仅对本类可见——private</li>
<li>对外部完全可见——public</li>
<li>对本包和所有子类可见——protected</li>
<li>对本包可见——默认，不需要修饰符</li>
</ul></li>
<li><p>instanceof 函数：</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Employee</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;ss&quot;</span>,<span class="number">12</span>);</span><br><span class="line"><span class="type">Manager</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="string">&quot;ss&quot;</span>,<span class="number">12</span>,<span class="number">14</span>);</span><br><span class="line">System.out.println(a <span class="keyword">instanceof</span> Manager);   <span class="comment">//false</span></span><br><span class="line">System.out.println(c <span class="keyword">instanceof</span> Employee);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>getclass函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Employee</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;ss&quot;</span>,<span class="number">12</span>);</span><br><span class="line"><span class="type">Manager</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="string">&quot;ss&quot;</span>,<span class="number">12</span>,<span class="number">14</span>);</span><br><span class="line">System.out.println(a.getClass());  <span class="comment">// class com.company.Employee</span></span><br><span class="line">System.out.println(c.getClass());  <span class="comment">// class com.company.Manager</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>所有类的超类——Object</p>
<ul>
<li>Object.equals方法用于检测两个对象的引用是否相等</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Employee</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;ss&quot;</span>,<span class="number">12</span>);</span><br><span class="line"><span class="type">Employee</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;ss&quot;</span>,<span class="number">12</span>);</span><br><span class="line">System.out.print(a.equals(b));  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果需要基于对象状态进行检测，那么需要重写类的equals函数,如何编写一个正确完美的equals函数呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">    	<span class="meta">@override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object otherObject)</span>&#123;</span><br><span class="line">    		<span class="keyword">if</span>(<span class="built_in">this</span> == otherObject) <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">//检查引用是否相等</span></span><br><span class="line">    		<span class="keyword">if</span>(otherObject == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//检查是否为null</span></span><br><span class="line">    		</span><br><span class="line">    		<span class="comment">//如果需要该类不同的子类被判定为不一样，则使用该行      </span></span><br><span class="line">            <span class="keyword">if</span>(getClass() != otherObject.getClass()) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果该类不同的子类可能被需要判定为一样，则使用该行 (即 只要这个被比较的对象是Employee类或其子类即可)</span></span><br><span class="line">            <span class="keyword">if</span>(!(otherObject <span class="keyword">instanceof</span> Employee)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    		</span><br><span class="line">            <span class="comment">//使用强制类型转换</span></span><br><span class="line">    		<span class="type">Employee</span> <span class="variable">other</span> <span class="operator">=</span> (Employee)otherObject;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//随后根据相等性概念的要求比较字段即可</span></span><br><span class="line">    		<span class="keyword">return</span> name.equals(other.name) &amp;&amp; salary == other.salary;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">- hashCode方法：Object类中定义的hashCode方法默认会从对象的存储地址得出散列码</span><br><span class="line"></span><br><span class="line">- 注意equals和hashCode的定义必须相容，如果x.equals(y)返回<span class="literal">true</span>，那么x.hashCode(y)就必须返回<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">- toString()方法，强烈建议为自定义的每个类添加这个方法，用途广泛</span><br><span class="line">  - 只要对象和一个字符串用加号连接，那么java编译器就会自动调用toString方法来获得这个对象的字符串描述</span><br><span class="line"></span><br><span class="line">- 泛型数组列表ArrayList，可以支持数组列表自动扩展容量</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Employee&gt;();</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">staff.ensureCapacity(<span class="number">100</span>); <span class="comment">//分配一个包含100各对象的内部数组，这样的话前100次add调用不会带来很大的开销</span></span><br></pre></td></tr></table></figure>
<ul>
<li>只能使用set和get方法设置值以及取出值,可以用add和remove增加删除元素</li>
</ul></li>
<li><p>一个小技巧是可以用ArrayList动态扩展完所有元素以后，执行以下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = new Employee[list.size];</span><br><span class="line">list.toArray(a);</span><br></pre></td></tr></table></figure></li>
<li><p>对象包装器与自动装箱</p>
<ul>
<li><p>由于泛型的类型参数不可以是基本类型，这时候就可以用对应的对象包装器，其和基本类型一一对应</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">list.add(<span class="number">3</span>) <span class="comment">//等价于 list.add(Integer.valueOf(3));  叫做自动装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> list.get(<span class="number">1</span>); <span class="comment">// 自动拆箱</span></span><br></pre></td></tr></table></figure></li>
<li><p>装箱类都是不可变的，即封装好数据后就不能变化内部封装的数值了。</p></li>
</ul></li>
<li><p>可变参数方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static double max(double... values)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上述这个函数可以接受任意个double类型的输入调用</li>
</ul></li>
<li><p>枚举类：</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Size</span>&#123; SMALL,MEDIUM,LARGE &#125;</span><br></pre></td></tr></table></figure>
<p>所有的枚举类型都是Enum类的子类，其中有许多有意义的方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Size.SMALL.toString()</span><br><span class="line"><span class="type">Size</span> <span class="variable">s</span> <span class="operator">=</span> Enum.valueOf(Size.class,<span class="string">&quot;SMALL&quot;</span>)</span><br><span class="line">Size[] values = Size.values()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>⑤  编程语言类笔记</category>
        <category>java精简系列笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java精简系列笔记4——java接口、lambda表达式、内部类</title>
    <url>/2022/07/21/a3dcc1a0d43c/</url>
    <content><![CDATA[<p><strong>知识来源：《Java核心技术卷I》第6章节</strong></p>
<h4 id="一接口interface">一、接口Interface</h4>
<ul>
<li><p>接口用来描述类应当做什么</p></li>
<li><p>我们可以定义一个Comparable接口，注意接口内的所有方法都自动是public方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt;&#123;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T other)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>接口中不能包含实例字段，但是可以包含常量。接口中的字段总是public
static final</p></li>
<li><p>为了让类实现一个接口，需要完成以下两个步骤：</p>
<ul>
<li>1、将类声明为实现给定的接口</li>
<li>2、对接口中的所有方法，在类中提供实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Employee&gt;&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Employee other)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Double.compare(salary,other.salary);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>我们不能构造接口的对象，但可以声明接口的变量</p></li>
<li><p>接口的变量必须引用实现了这个接口的类的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Comparable</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(...)</span><br></pre></td></tr></table></figure></li>
<li><p>可以使用instanceof检查一个对象是否实现了某个特定的接口</p></li>
<li><p>接口也可以继承拓展,从通用性高的接口拓展到专用性高的接口</p></li>
<li><p>每个类虽然只能有一个超类，但是可以实现多个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>,Comparable</span><br></pre></td></tr></table></figure></li>
<li><p>可以为接口方法提供一个默认实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt;&#123;</span><br><span class="line">	<span class="keyword">default</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T other)</span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如何解决默认方法冲突？</p>
<ul>
<li><p>超类优先原则。如果超类提供了一个具体方法，则接口的默认方法会被忽略</p>
<ul>
<li>如果类A继承了类B，实现了接口C，B和C中有同名方法，则类优先</li>
</ul></li>
<li><p>如果两个接口定义了同名的默认方法，有一个类同时实现了这两个接口，那么会报错让程序员在类中实现一个同名方法，来决定使用哪个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>,Named&#123;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123; <span class="keyword">return</span> Person.<span class="built_in">super</span>().getName(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>接口与回调函数：</p>
<ul>
<li><p>一个经典的定时器回调的实现，其接收一个类，这个类必须是实现了以下接口的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ActionListener</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent event)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimePrinter</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;At the tone,the time is&quot;</span> + Instant.ofEpochMilli(e.getWhen()));</span><br><span class="line">        Toolkit.getDefaultToolkit().beep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimePrinter</span>();</span><br><span class="line"><span class="type">Timer</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="number">1000</span>,listener);</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>Comparator接口：</p>
<ul>
<li><p>Arrays.sort可以接收两个参数，第一个为数组，第二个为比较器，比较器需要是实现了Comparator接口的类的实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LengthComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;String&gt;&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String first,String second)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> first.length() - second.length();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] friends = &#123; <span class="string">&quot;peter&quot;</span>,<span class="string">&quot;paul&quot;</span>&#125;</span><br><span class="line">Arrays.sort(frineds, <span class="keyword">new</span> <span class="title class_">LengthComparator</span>())</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>对象克隆 .clone() 方法：</p>
<ul>
<li>正常克隆为浅拷贝，即如果对象中包含子对象的引用，就容易出错。所以，我们需要重新在类中定义clone方法，来建立一个深拷贝，同时克隆所有子对象。类需要实现Clonable接口，并重新定义clone方法，并指定public修饰符。</li>
</ul></li>
</ul>
<h4 id="二lambda表达式">二、Lambda表达式：</h4>
<ul>
<li><p>语法示例：无需指定返回类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(String first, String second)-&gt;&#123;</span><br><span class="line">	first.length() - second.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(friends,(String first, String second)-&gt;&#123;</span><br><span class="line">	first.length() - second.length();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。这种接口称为函数式接口</p></li>
<li><p>我们可以将lambda表达式保存在函数式接口的引用中，java.util.function中</p></li>
<li><p>变量的作用域：</p>
<ul>
<li>lambda表达式中可以访问外围方法或者类中的变量，但是其只能引用值不会改变的变量。另外如果引用了一个变量，该变量可能在外部改变，这也是不合法的。其捕获的比那辆必须是
初始化后不会为其赋新值的变量。</li>
</ul></li>
<li><p>如何接收Lambda表达式？如何处理？</p>
<ul>
<li><p>如果想要接收某一个Lambda表达式，需要选择一个函数式接口。P253页提供了常用的函数式接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">repeat</span><span class="params">(<span class="type">int</span> n,Runnable action)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) action.run();  <span class="comment">//调用action.run时会执行传入的lambda表达式的主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>更便捷的Comparator：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(people,Comparator.comparing(Person::getName).thenComparing(Person::getFirstName));</span><br><span class="line"></span><br><span class="line"><span class="comment">//为comparing方法提取的键指定一个比较器</span></span><br><span class="line">Arrays.sort(people,Comparator.comparing(Person::getName,(s,t)</span><br><span class="line">                                        -&gt;Integer.compare(s.length(),t.length()));</span><br><span class="line"><span class="comment">//更简洁</span></span><br><span class="line">Arrays.sort(people,Comparator.comparingInt(p-&gt;p.getName().length());</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="三内部类">三、内部类：</h4>
<ul>
<li><p>内部类可以对同一个包中的其他类隐藏</p></li>
<li><p>内部类方法可以访问定义这个类的作用域中的数据，包括private</p></li>
<li><p>局部内部类：</p>
<ul>
<li><p>可以在一个方法种局部地定义一个类，声明局部类时不能有访问说明符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">TimePrinter</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span>&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>匿名内部类：</p>
<ul>
<li><p>使用局部内部类时，如果只想创建这个类的一个对象，都不需要指定类的名字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">var</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActionListener</span>()   <span class="comment">//含义为：创建一个类的新对象，这个类实现了ActionListener接口</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//.........</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注意此和构造一个新对象的区别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">queen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Mary&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Dracula&quot;</span>)&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>静态内部类：</p>
<ul>
<li><p>当内部类不需要访问外围类对象时，就应当使用静态内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayAlg</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&#123;</span><br><span class="line">		<span class="comment">//不需要访问ArrayAlg对象		</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>静态内部类可以有静态字段和方法</p></li>
<li><p>在接口中声明的内部类自动是static和public</p></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>⑤  编程语言类笔记</category>
        <category>java精简系列笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java精简系列笔记2——java对象与类</title>
    <url>/2022/07/19/a0c6d353048d/</url>
    <content><![CDATA[<p><strong>知识来源：《Java核心技术卷I》第4章节</strong></p>
<ul>
<li><p>如果一个类的方法使用或操纵另一个类的对象，我们就说一个类依赖于另一个类。应该尽可能地将相互依赖的类减至最少，尽可能减少类之间的耦合。因为：如果类A不知道B的存在，它就不会关心B的任何改变，意味着B的改变不会导致A产生任何BUG。</p></li>
<li><p>所有Java对象都存储在堆中，当一个对象包含另一个对象变量时，其只是包含着另一个堆对象的指针.</p></li>
<li><p>Date()方法用于记录时间戳,而<strong>LocalDate</strong>类可以用于记录日历相关的时间信息</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">t</span> <span class="operator">=</span> LocalDate.of(<span class="number">1999</span>,<span class="number">12</span>,<span class="number">31</span>)</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">tAfter</span> <span class="operator">=</span> t.plusDays(<span class="number">1000</span>)</span><br><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> t.getYear()</span><br></pre></td></tr></table></figure>
<ul>
<li>在构造类的时候，最好清楚的知道哪些字段可能为null，对于那些不希望为null的字段，可以设置如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(string n)</span>&#123;</span><br><span class="line">	Objects.requireNonNull(n,<span class="string">&quot;The name can not be null&quot;</span>);  <span class="comment">//会抛出一个异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意不要编写返回可变对象引用的访问器方法，如果需要返回，则应该进行克隆，具体见P113页</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> hireDay.clone()</span><br></pre></td></tr></table></figure>
<ul>
<li><p>私有方法与公有方法的区别：</p>
<ul>
<li><strong>重点在于，只要方法是私有的，类的设计者就能确信其不会在别处使用，可以将其删去。如果方法是公有的，则无法保证它没有在其他地方被调用，故而维护的时候不能简单删去。</strong></li>
</ul></li>
<li><p>final关键字可以指明某成员变量只能在初始化构造的时候确定值，后续值不能再改变</p></li>
<li><p>每一个类都可以有一个main方法，通常用于做单元测试，这样的话，运行java
Employee 即可完成单元测试</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>()&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Java中的方法参数都是按值传参，而非按引用传参。</p></li>
<li><p>可以在类定义中，直接给任何字段赋初值，例如</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>()&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一个构造方法可以调用其他构造方法，便于代码复用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>(name, <span class="number">18</span>); <span class="comment">// 调用另一个构造方法Person(String, int)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果类的静态字段需要很复杂的初始化代码，可以使用静态的初始化块</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>()&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> nextId;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>()</span><br><span class="line">		nextId = generator.nextInt(<span class="number">10000</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>要想将类放入包中，则必须将包的名字放在源文件的开头：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ming;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>()&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>类的路径必须与包名匹配，编译器在编译源文件时不会检查目录结构</p></li>
<li><p>位于同一个包的类，可以访问包作用域的字段和方法。不用<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法就是包作用域。</p></li>
<li><p><strong>JAR文件</strong>是一个Java归档文件，其既可以包含类文件，也可以包含其他格式的文件，其使用ZIP压缩格式进行组织。</p></li>
<li><p><strong>javadoc文档</strong>注释，可以自动为源代码生成一些接口类的注释选项</p></li>
<li><p>一些类设计技巧：</p>
<ul>
<li>一定要保证数据私有，对数据进行初始化</li>
<li>不要在类中使用过多的基本类型，而是用其他类来替换基本类型</li>
<li>分解有过多职责的类</li>
<li><strong>优先使用不可变的类</strong>，即没有方法能够修改对象的状态，如此一来可以安全地在多个线程间共享其对象</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>⑤  编程语言类笔记</category>
        <category>java精简系列笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java精简系列笔记1——java基础</title>
    <url>/2022/07/18/457df2a64c92/</url>
    <content><![CDATA[<p><strong>知识来源：《Java核心技术卷I》第3章节</strong></p>
<ul>
<li>Java整型的数据范围与运行java代码的机器无关</li>
<li>三个特殊的浮点类型值：（注意：所有非数值的值都认为是不同的）
<ul>
<li><code>NaN</code>表示Not a Number</li>
<li><code>Infinity</code>表示无穷大</li>
<li><code>-Infinity</code>表示负无穷大</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">0.0</span> / <span class="number">0</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="number">1.0</span> / <span class="number">0</span>; <span class="comment">// Infinity</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d3</span> <span class="operator">=</span> -<span class="number">1.0</span> / <span class="number">0</span>; <span class="comment">// -Infinity</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果加上<code>final</code>修饰符，这个变量就变成了常量：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span>; <span class="comment">// PI是一个常量</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>可以用<code>static final</code>声明类常量</p></li>
<li><p>可以用<code>"""..."""</code>表示多行字符串（Text
Blocks）。</p></li>
<li><p>一个<code>char</code>保存一个Unicode字符, 占用两个字节：</p></li>
<li><p>枚举类型：</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Size</span> &#123; SMALL,MEDIUM,LARGE &#125;;</span><br><span class="line"><span class="type">Size</span> <span class="variable">m</span> <span class="operator">=</span> Size.SMALL;</span><br></pre></td></tr></table></figure>
<ul>
<li>floorMod方法，用于整数取余，解决一些取余的负数问题</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">floorMod(12,4); </span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>&gt;&gt;&gt;</code>运算符会用0来填充高位，而<code>&gt;&gt;</code>运算符会用符号位填充高位。</p></li>
<li><p><code>"Java".repeat(3)</code>方法</p></li>
<li><p><code>"Hello".substring(1,3)</code></p></li>
<li><p>字符串不可变,<strong>即不能修改Java字符串中的单个字符</strong></p></li>
<li><p>字符串是否相等的比较必须使用<code>equals</code>方法，如果要不区分大小写，则使用<code>equalsIgnoreCase</code></p></li>
<li><p>码点与代码单元：</p>
<ul>
<li><p>最常用的一个Unicode字符使用一个代码单元就可以表示，而辅助字符需要一对代码单元表示。</p></li>
<li><p>length()方法返回代码单元数量，codePointCount()表示码点数量</p></li>
<li><p>可以使用如下方法将遍历字符串的每一个码点：</p></li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] codePoints = str.codePoints().toArray()</span><br></pre></td></tr></table></figure>
<ul>
<li>如何构建字符串？避免使用String类，这样效率较低，应该使用StringBuilder类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>()</span><br><span class="line">builder.append(ch)</span><br><span class="line">builder.append(str)</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> builder.toString()</span><br></pre></td></tr></table></figure>
<ul>
<li>构造输入流：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); <span class="comment">// 创建Scanner对象</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Input your name: &quot;</span>); <span class="comment">// 打印提示</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.nextLine(); <span class="comment">// 读取一行输入并获取字符串</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Input your part: &quot;</span>); <span class="comment">// 打印提示</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">part</span> <span class="operator">=</span> scanner.next(); <span class="comment">// 读取输入的下一个单词</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Input your age: &quot;</span>); <span class="comment">// 打印提示</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">// 读取一行输入并获取整数</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;Hi, %s, you are %d\n&quot;</span>, name, age); <span class="comment">// 格式化输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>格式化输出：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.printf(<span class="string">&quot;%tF %tT&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>(),<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">System.out.printf(<span class="string">&quot;%tF %&lt;tT&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br></pre></td></tr></table></figure>
<ul>
<li>想要读取一个文件：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(Path.of(<span class="string">&quot;myfile.txt&quot;</span>),StandardCharsets.UTF_8); <span class="comment">// 创建Scanner对象</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">dir</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>);  <span class="comment">//获取当前目录</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(Path.of(dir + <span class="string">&quot;/myfile.txt&quot;</span>), StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>
<ul>
<li>想要写入文件：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="string">&quot;file.txt&quot;</span>,StandardCharsets.UTF_8)</span><br></pre></td></tr></table></figure>
<ul>
<li>新Switch表达式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="string">&quot;apple&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;apple&quot;</span> -&gt; System.out.println(<span class="string">&quot;Selected apple&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;pear&quot;</span> -&gt; System.out.println(<span class="string">&quot;Selected pear&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;mango&quot;</span> -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Selected mango&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Good choice!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;No fruit selected&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>大数类<code>BigInteger</code>和<code>BigDecimal</code></p></li>
<li><p>命令行参数类型是<code>String[]</code>数组；
命令行参数由JVM接收用户输入并传给<code>main</code>方法；如何解析命令行参数需要由程序自己实现。</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;-version&quot;</span>.equals(arg)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;v 1.0&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Java的不规则数组：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span>[][] arr = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">8</span>][]</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;n&lt;<span class="number">8</span>;n++)</span><br><span class="line">    arr[n] = <span class="keyword">new</span> <span class="title class_">double</span>[n+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>交换数组中的行</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span>[] temp = arr[i]</span><br><span class="line">arr[i] = arr[i+<span class="number">1</span>]</span><br><span class="line">arr[i+<span class="number">1</span>] = temp</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>⑤  编程语言类笔记</category>
        <category>java精简系列笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>计网微课堂Chap6——应用层原理</title>
    <url>/2022/07/17/78c11b2eddea/</url>
    <content><![CDATA[<p>视频地址：https://www.bilibili.com/video/BV1c4411d7jb?p=67</p>
<h4 id="一客户服务器方式-和-对等方式">一、客户/服务器方式 和
对等方式：</h4>
<ul>
<li><strong>C/S方式（包括万维网、电子邮件、文件传输FTP等）</strong>
<ul>
<li>客户是服务请求方，服务器是服务提供方。服务器总是处于运行状态，并等待客户的服务请求。服务器具有固定端口号（例如HTTP服务器的默认端口号为80），而运行服务器的主机也具有固定的IP地址。</li>
</ul></li>
<li><strong>P2P方式（包括文件共享、即时通信、P2P流媒体、分布式存储）</strong>：
<ul>
<li>在P2P方式中，没有固定的服务请求者和服务提供者，分布在网络边缘各端系统中的应用进程是对等的，被称为对等方。</li>
<li>对等方相互之间直接通信，每个对等方既是服务的请求者，又是服务的提供者。</li>
</ul></li>
</ul>
<h4 id="二dhcp协议">二、DHCP协议：</h4>
<ul>
<li><p>DHCP的作用：</p>
<ul>
<li><p><strong>可以为局域网中各主机配置以下信息：</strong></p>
<ul>
<li>IP地址、子网掩码、默认网关、DNS服务器</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220717094843438.png" /></p></li>
</ul></li>
<li><p><strong>DHCP的工作过程：</strong></p></li>
</ul>
<p>​
在DHCP服务器上运行DHCP服务器进程，在用户主机上运行DHCP客户端进程，其基于UDP协议。主机启动后，主机首先会广播<strong>DHCP发现报文</strong>，源IP地址为0.0.0.0，因为此时主机还没有IP地址。对于DHCP服务器，接收该报文，根据其中封装的客户端MAC地址来查找自己的数据库，并根据相应信息发送DHCP提供报文。该报文的目的地址为广播地址，因为用户主机还没有IP地址。对于DHCP客户而言，根据DHCP提供报文中的<strong>事务ID</strong>来判断该报文是不是自己请求的报文，如果是，则接收该DHCP提供报文，并根据其内封装的信息配置自己的默认信息。</p>
<p>​
此时DHCP客户从多个DHCP服务器中返回的信息中挑选一个（一般是先到的），然后发送广播DHCP请求报文，向该DHCP服务器请求使用该IP地址。随后对应DHCP服务器发送<strong>DHCP确认报文</strong>，客户机接收到以后，使用ARP检测所分配到的IP地址是否已被网络中其他主机占用：若被占用：给DHCP服务器发送“DHCP若被占用：给DHCP服务器发送“DHCPDECLINE"报文撤销lP地址租约，并重新发送“DHCP
DISCOVER"报文；若未被占用：可以使用租约中的IP地址与网络中其他主机通信了。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220717095933859.png" /></p>
<ul>
<li><p>DHCP中继代理：</p></li>
<li><p>使用中继代理的原因是，我们并不愿意在每个网络中都设置一个DHCP服务器，所以需要中继代理。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220717100100162.png" /></p></li>
</ul>
<h4 id="三dns协议">三、DNS协议：</h4>
<p>​ 因特网采用层次树状结构的域名结构<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220717104938232.png" /></p>
<ul>
<li><p>顶级域名包含三类：</p>
<ul>
<li><p>国家顶级域名</p></li>
<li><p>通用顶级域名</p></li>
<li><p>反向域</p>
<p>在国家顶级域名下注册的二级域名均由该国家自行确定。例如，顶级域名为jp的日本，将其教育和企业机构的二级域名定为ac和co，而不用edu和com。</p></li>
</ul></li>
<li><p>域名空间</p></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220717105639917.png" /></p>
<ul>
<li><p>DNS使用分布在各地的域名服务器来实现域名到IP的转换</p></li>
<li><p>域名服务器可以划分为以下四种类型：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220717105930441.png" /></p></li>
<li><p>域名解析的过程</p>
<ul>
<li>递归查询：
<ul>
<li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220717110034788.png" style="zoom:67%;" /></li>
</ul></li>
<li>迭代查询：
<ul>
<li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220717110127143.png" style="zoom:67%;" /></li>
</ul></li>
</ul></li>
<li><p>为了提高DNS的查询效率，并减轻根域名服务器的负荷和减少因特网上的DNS查询报文数量，在域名服务器中广泛地使用了高速缓存。高速缓存用来存放最近查询过的域名以及从何处获得域名映射信息的记录。</p></li>
<li><p>由于域名到IP地址的映射关系并不是永久不变，为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并删除超过合理时间的项（例如，每个项目只存放两天）。</p></li>
<li><p>不但在本地域名服务器中需要高速缓存，在用户主机中也很需要。许多用户主机在启动时从本地域名服务器下载域名和IP地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到域名时才向域名服务器查询。同理，主机也需要保持高速缓存中内容的正确性。</p></li>
</ul>
<h4 id="四ftp协议">四、FTP协议：</h4>
<ul>
<li><p>FTP的基本工作原理：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220717110619535.png" /></p></li>
</ul>
<p>​
总共会开通两个TCP连接，用于传送控制命令的TCP连接一直保持打开状态，二用于传送数据的TCP连接每次传送完数据后都会关闭。</p>
<h4 id="五电子邮件">五、电子邮件：</h4>
<ul>
<li>三个步骤：</li>
</ul>
<p><img
src="C:\Users\14012\AppData\Roaming\Typora\typora-user-images\image-20220717110817694.png" /></p>
<ul>
<li><p>三个主要构件：</p>
<ul>
<li>用户代理、邮件服务器、电子邮件所需要的协议</li>
<li><strong>用户代理</strong>是用户与电子邮件系统的接口，又称为电子邮件客户端软件。</li>
<li><strong>邮件服务器</strong>是电子邮件系统的基础设施。因特网上所有的ISP都有邮件服务器，其功能是发送和接收邮件，同时还要负责维护用户的邮箱。</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220717111014969.png" /></p></li>
<li><p>邮件发送和接收过程：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220717111159217.png" /></p></li>
<li><p>SMTP协议基本工作原理：</p>
<ul>
<li>注意：1.为了简单起见，省略了认证过程；2.应答代码后面一般都跟有简单的描述信息3.不同的SMTP服务器给出的相同应答代码的描述信息可能不同</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220717111351617.png" /></p></li>
<li><p>电子邮件的定义：</p>
<ul>
<li>一个电子邮件有信封和内容两部分。而内容又由首部和主体两部分构成。</li>
</ul></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220717111501861.png" /></p>
<ul>
<li>MIME：
<ul>
<li>SMTP协议只能传送ASCII码文本数据，不能传送可执行文件或其他的二进制对象。SMTP不能满足传送多媒体邮件（例如带有图片、音频或视频数据）的需要。并且许多其他非英语国家的文字（例如中文、俄文、甚至带有重音符号的法文或德文）也无法用SMTP传送。</li>
<li>为解决SMTP传送非ASCI码文本的问题，提出了<strong>多用途因特网邮件扩展MIME（Mulipurpose
Internet Mail Extensions）</strong></li>
<li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220717111557311.png" style="zoom:67%;" /></li>
</ul></li>
<li>常用的邮件读取协议：
<ul>
<li>邮局协议POP
<ul>
<li>非常简单、功能有限的邮件读取协议。用户只能以下载并删除方式或下载并保留方式从邮件服务器下载邮件到用户方计算机。<strong>不允许用户在邮件服务器上管理自己的邮件。</strong>（例如创建文件夹，对邮件进行分类管理等）。</li>
</ul></li>
<li>因特网邮件访问协议IMAP
<ul>
<li>功能比POP3强大的邮件读取协议。<strong>用户在自己的计算机上就可以操控邮件服务器中的邮箱，就像在本地操控一样，因此IMAP是一个联机协议。</strong></li>
</ul></li>
<li>POP3和IMAP4都采用基于TCP连接的客户/服务器方式。POP3使用熟知端口110，IMAP4使用熟知端口143。</li>
</ul></li>
</ul>
<h4 id="六万维网www">六、万维网WWW</h4>
<ul>
<li>浏览器最重要的部分是渲染引擎，也就是浏览器内核。负责对网页内容进行解析和显示。</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220717112048715.png" /></p>
<ul>
<li>HTTP/1.0
<ul>
<li>HTTP/1.0采用非持续连接方式。在该方式下，每次浏览器要请求一个文件都要与服务器建立TCP连接，当收到响应后就立即关闭连接。</li>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220717132023000.png" /></li>
</ul></li>
<li>HTTP1.1
<ul>
<li>HTTP/1.1采用持续连接方式。在该方式下，万维网服务器在发送响应后仍然保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。这并不局限于传送同一个页面上引用的对象，而是只要这些文档都在同一个服务器上就行。</li>
</ul></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220717132217029.png" /></p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220717132242334.png" style="zoom:67%;" /></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220717132321231.png" /></p>
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Computer Network</tag>
      </tags>
  </entry>
  <entry>
    <title>计网微课堂Chap5——运输层原理</title>
    <url>/2022/07/15/b846bd0fbb3c/</url>
    <content><![CDATA[<p>视频地址：https://www.bilibili.com/video/BV1c4411d7jb?p=58</p>
<h4 id="一运输层的基本概念">一、运输层的基本概念：</h4>
<p>​ 先前的所有层共同解决了<strong>主机到主机的通信</strong></p>
<p>​
实际上计算机网络中进行<strong>通信的真正实体是位于通信两端主机中的进程</strong></p>
<p>​
<strong>如何为运行在不同主机上的应用进程提供直接的通信服务是运输层的任务，运输层协议又称为端到端协议。</strong></p>
<p>​
运输层向高层用户屏蔽了下面网络核心的细节（如网络拓扑、所采用的路由选择协议等），它使应用进程看见的就好像是在两个运输层实体之间有一条端到端的逻辑通信信道。</p>
<p>​
根据应用需求的不同，因特网的运输层为应用层提供了两种不同的运输协议，即面向连接的TCP和无连接的UDP，这两种协议就是本章要讨论的主要内容。</p>
<h4
id="二运输层端口号复用与分用的概念">二、运输层端口号、复用与分用的概念</h4>
<ul>
<li>​ 端口号：</li>
</ul>
<p>​ 运行在计算机上的进程使用进程标识符PID来标志。</p>
<p>​
因特网上的计算机<strong>并不是使用统一的操作系统</strong>，不同的操作系统（windows，Linux，Mac
OS）又使用不同格式的进程标识符。</p>
<p>​
为了使运行不同操作系统的计算机的应用进程之间能够进行网络通信，就必须使用统一的方法对TCP/IP体系的应用进程进行标识。<strong>TCP/IP体系的运输层使用端口号来区分应用层的不同应用进程。</strong></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715215440625.png" /></p>
<ul>
<li>发送方的复用和接收方的分用</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715215959063.png" /></p>
<ul>
<li>常用的应用层协议使用的运输层端口号</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715220025060.png" /></p>
<h4 id="三udp和tcp的区别">三、UDP和TCP的区别：</h4>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>UDP</th>
<th>TCP</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>无连接，随时传输数据</td>
<td>面向连接，需要建立连接、释放连接</td>
</tr>
<tr class="even">
<td>支持单播、多播、广播</td>
<td>仅支持单播</td>
</tr>
<tr class="odd">
<td>面向应用报文的</td>
<td>面向字节流的</td>
</tr>
<tr class="even">
<td>向上层提供无连接不可靠传输服务（适用于IP电话、视频会议等实时应用）。</td>
<td>向上层提供面向连接的可靠传输服务（适用于要求可靠传输的应用，例如文件传输）</td>
</tr>
<tr class="odd">
<td>首部仅8字节</td>
<td>首部更为复杂，因为要实现可靠传输、流量控制、拥塞控制</td>
</tr>
</tbody>
</table>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715221236586.png" /></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715221534600.png" /></p>
<h4 id="四tcp的流量控制">四、TCP的流量控制：</h4>
<p>​ 所谓流量控制（flow
control）就是让发送方的发送速率不要太快，要让接收方来得及接收。</p>
<ul>
<li><p>可以使用滑动窗口机制实现，示例如下：</p></li>
<li><p><strong>主机A根据主机B的ACK帧中的接收窗口大小来调整自己的发送窗口大小。</strong></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220716111424822.png" /></p></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220716111513511.png" /></p>
<p>​
为避免上述情况发生，每个主机当收到零窗口通知时，会启动一个持续计时器，当该计时器超时，则主机会发送一个<strong>零窗口探测报文</strong>，仅携带1字节数据，询问接收窗口大小。如下所示：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220716111638398.png" /></p>
<h4 id="五tcp的拥塞控制">五、TCP的拥塞控制：</h4>
<p>​
在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏。这种情况就叫做拥塞（congestion）。</p>
<ul>
<li>在计算机网络中的链路容量（即带宽）、交换结点中的缓存和处理机等，都是网络的资源。若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷的增大而下降。</li>
</ul>
<p><strong>TCP共有以下四种拥塞控制算法</strong>：</p>
<ul>
<li><p>假设：</p>
<ul>
<li>数据是单方向传送，而另一个方向只传送确认。</li>
<li>接收方总是有足够大的缓存空间，因而发送方发送窗口的大小由网络的拥塞程度来决定。</li>
<li>以最大报文段MSS的个数为讨论问题的单位，而不是以字节为单位。</li>
</ul></li>
<li><p><strong>TCP使用拥塞避免算法的基本过程：</strong></p></li>
<li><p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220716112248505.png" /></p></li>
<li><p>慢开始算法：</p></li>
</ul>
<p>​ 每收到一个确认报文，拥塞窗口大小增加1.
每个传输轮次结束后，按照<strong>指数速度</strong>增长拥塞窗口。</p>
<ul>
<li>拥塞避免算法：</li>
</ul>
<p>​
每个传输轮次结束后，拥塞窗口大小增加1.每个传输轮次结束后，按照<strong>线性速度</strong>增长拥塞窗口。</p>
<p>​
当某一次，重传计时器超时，则<strong>网络很可能出现了拥塞，进行以下工作</strong>：</p>
<p>​ 1、将ssthresh值更新为发生拥塞时cwnd值的一半；</p>
<p>​ 2、将cwnd值减少为1，并重新开始执行慢开始算法。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220716112813706.png" /></p>
<ul>
<li><p>快重传和快恢复：</p>
<ul>
<li>有时，个别报文段会在网络中丢失，但实际上网络并未发生拥塞。这将导致发送方超时重传，并误认为网络发生了拥塞；这两个算法将会<strong>改进TCP的性能</strong></li>
</ul></li>
<li><p>快重传算法：</p>
<p>​ 采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。</p>
<p>​
所谓快重传，就是使发送方尽快进行重传，而不是等超时重传计时器超时再重传。</p>
<p>​
口要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认；</p>
<p>​ 囗即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。</p>
<p>​
口发送方一旦收到3个连续的重复确认，就将相应的报文段立即重传，而不是等该报文段的超时重传计时器超时再重传。</p></li>
</ul>
<p>​
口对于个别丢失的报文段，发送方不会出现超时重传，也就不会误认为出现了拥塞（进而降低拥塞窗口cwnd为1）。使用快重传可以使整个网络的吞叶量提高约20%。.</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220716122753536.png" /></p>
<ul>
<li><p>快恢复算法：</p>
<p>​
发送方一旦收到3个重复确认，就知道现在只是丢失了个别的报文段。于是不启动慢开始算法，而执行快恢复算法；</p>
<p>​
<strong>发送方将慢开始门限ssthresh值和拥塞窗口cwnd值调整为当前窗口的一半；开始执行拥塞避免算法。</strong></p></li>
<li><p>综合总结</p></li>
</ul>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220716122929537.png"
alt="image-20220716122929537" />
<figcaption aria-hidden="true">image-20220716122929537</figcaption>
</figure>
<h4 id="六tcp超时重传时间的选择">六、TCP超时重传时间的选择：</h4>
<p>​ 不能直接使用某次测量得到的RTT样本来计算超时重传时间RTO。</p>
<p>​
利用每次测量得到的RTT样本，计算加权平均往返时间RTTs利用每次测量得到的RTT样本，计算加权平均往返时间RTTs（又称为平滑的往返时间）。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220716123516884.png" style="zoom:67%;" /></p>
<ul>
<li>往返时间RTT的测量比较复杂：</li>
</ul>
<p>​
针对出现超时重传时无法测准往返时间RTT的问题，Karn提出了一个算法：在计算加权平均往返时间RTTs时，只要报文段重传了，就不采用其往返时间RTT样本。也就是出现重传时，不重新计算RTTs，进而超时重传时间RTO也不会重新计算。</p>
<p>​
因此，Karn算法也需要修正。方法是：<strong>报文段每重传一次，就把超时重传时间RTO增大一些。</strong>典型的做法是将新RTO的值取为旧RTO值的2倍。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220716123844458.png" /></p>
<h4 id="七可靠传输的实现">七、可靠传输的实现：</h4>
<ul>
<li><p>TCP基于<strong>以字节为单位的滑动窗口</strong>来实现可靠传输</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220716132341532.png" /></p></li>
<li><p>如何描述发送窗口的状态：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220716132527433.png" /></p></li>
<li><p>接收窗口：</p>
<ul>
<li>接收方只能应答已收到报文的最高序号</li>
<li>对于不按需到达的数据应如何处理，TCP无明确规定：
<ul>
<li>TCP通常对不按序到达的数据是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。</li>
</ul></li>
<li>TCP要求接收方必须有累积确认和捎带确认机制，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。</li>
</ul></li>
<li><p>TCP是全双工通信。每一方都有自己的接收窗口和发送窗口</p></li>
</ul>
<h4 id="八tcp的连接建立三次握手">八、TCP的连接建立——三次握手</h4>
<p>TCP运输连接有以下三个阶段：</p>
<ul>
<li>建立TCP连接</li>
<li>数据传送</li>
<li>释放TCP连接</li>
</ul>
<p>TCP的连接建立要解决以下问题：</p>
<ul>
<li>使TCP双方能够确知对方的存在；</li>
<li>使TCP双方能够协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）；</li>
<li>使TCP双方能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。</li>
</ul>
<p><strong>TCP连接建立的过程：</strong></p>
<p>​ <img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220716133727985.png" /></p>
<ul>
<li><p>x是客户端选择的初始序号</p></li>
<li><p>y是服务器选择的初始序号</p></li>
<li><p>TCP连接请求帧和TCP连接请求确认帧不能携带其他数据</p></li>
<li><p>为什么最后要发送确认报文？</p>
<ul>
<li>如果有TCP连接请求滞留在网络中，那么当该连接请求到达服务器后，服务器又会处于连接建立状态，而客户端已经处于关闭状态，故而会浪费服务器资源。</li>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220716134101110.png" /></li>
</ul></li>
</ul>
<h4 id="九tcp的连接释放四次挥手">九、TCP的连接释放——四次挥手</h4>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220716140346765.png" /></p>
<ul>
<li>客户端为什么要有TIME-WAIT阶段？
<ul>
<li>如果最后一个客户端的确认数据报文丢失，则：</li>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220716140540038.png" /></li>
</ul></li>
<li>如果TCP客户端出现故障，TCP服务器进程如何发现呢？
<ul>
<li>TCP服务器进程每收到一次TCP客户进程的数据，就重新设置并启动保活计时器（2小时定时）。</li>
<li>若保活计时器定时周期内未收到TCP客户进程发来的数据，则当保活计时器到时后，TCP服务器进程就向TCP客户进程发送一个探测报文段，以后则每隔75秒钟发送一次。</li>
<li>若一连发送10个探测报文段后仍无TCP客户进程的响应，TCP服务器进程就认为TCP客户进程所在主机出了故障，接着就关闭这个连接。</li>
</ul></li>
</ul>
<h4 id="十tcp报文段的首部格式">十、TCP报文段的首部格式</h4>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220716140957849.png" /></p>
<ul>
<li><p>源端口：占16比特，写入源端口号，用来标识发送该TCP报文段的应用进程。</p></li>
<li><p>目的端口：占16比特，写入目的端口号，用来标识接收该TCP报文段的应用进程。</p></li>
<li><p>序号：占32比特，取值范围[0，<span class="math inline">\(2^{32} -
1\)</span>]，序号增加到最后一个后，下一个序号就又回到0。指出本TCP报文段数据载荷的第一个字节的序号。</p></li>
<li><p>确认号：占32比特，取值范围[0，<span class="math inline">\(2^{32}
-
1\)</span>]，确认号增加到最后一个后，下一个确认号就又回到0。指出期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认。</p></li>
<li><p>确认标志位ACK：取值为1时确认号字段才有效；取值为0时确认号字段无效。TCP规定，在连接建立后所有传送的TCP报文段都必须把ACK置1。</p></li>
<li><p>数据偏移：占4比特，并以4字节为单位。用来指出TCP报文段的数据载荷部分的起始处距离TCP报文段的起始处有多远。这个字段实际上是指出了TCP报文段的首部长度。</p></li>
<li><p>窗口：占16比特，以字节为单位。指出发送本报文段的一方的接收窗口。窗口值作为接收方让发送方设置其发送窗口的依据。这是以接收方的接收能力来控制发送方的发送能力，称为流量控制。</p></li>
<li><p>校验和：占16比特，检查范围包括TCP报文段的首部和数据载荷两部分。在计算校验和时，要在TCP报文段的前面加上12字节的伪首部。</p></li>
<li><p>同步标志位SYN：在TCP连接建立时用来同步序号。</p></li>
<li><p>终止标志位FIN：用来释放TCP连接。</p></li>
<li><p>复位标志位RST：用来复位TCP连接。当RST=1时，表明TCP连接出现了异常，必须释放连接，然后再重新建立连接。RST置1还用来拒绝一个非法的报文段或拒绝打开一个TCP连接。</p></li>
<li><p>推送标志位PSH：接收方的TCP收到该标志位为1的报文段会尽快上交应用进程，而不必等到接收缓存都填满后再向上交付。</p></li>
<li><p>紧急标志位URG：取值为1时紧急指针字段有效；取值为0时紧急指针字段无效。</p></li>
<li><p>紧急指针：占16比特，以字节为单位，用来指明紧急数据的长度。</p></li>
<li><p>填充：由于选项的长度可变，因此使用填充来确保报文段首部能被4整除（因为数据偏移字段，也就是首部长度字段，是以4字节为单位的）。</p></li>
</ul>
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Computer Network</tag>
      </tags>
  </entry>
  <entry>
    <title>计网微课堂Chap4——网络层原理</title>
    <url>/2022/07/12/a63746099b02/</url>
    <content><![CDATA[<p>视频地址：https://www.bilibili.com/video/BV1c4411d7jb?p=41</p>
<h4 id="一网络层的基本概念">一、网络层的基本概念：</h4>
<p>​
网络层的主要任务是实现网络互连，进而实现数据包在各网络之间的传输。</p>
<p>​ 要实现网络层任务，需要解决以下主要问题：</p>
<ul>
<li><p>网络层向运输层提供怎样的服务（“可靠传输”还是“不可靠传输"）</p></li>
<li><p>网络层寻址问题</p></li>
<li><p>路由选择问题</p></li>
</ul>
<p><strong>因特网（Internet）是目前全世界用户数量最多的互联网，它使用TCP/IP协议栈。由于TCP/IP协议栈的网络层使用网际协议IP，它是整个协议栈的核心协议，因此在TCP/IP协议栈中网络层常称为网际层。</strong></p>
<h4 id="二网络层提供的两种服务">二、网络层提供的两种服务</h4>
<ul>
<li>面向连接的虚电路服务</li>
</ul>
<p>​ 可靠通信由网络来保证，必须建立网络层的连接——虚电路VC（Virtual
Circuit），通信双方沿着已建立的虚电路发送分组。通信结束后，需要释放之前所建立的虚电路。</p>
<ul>
<li>无连接的数据报服务
<ul>
<li>可靠通信应当由用户主机来保证</li>
<li>不需要建立网络层连接</li>
<li>每个分组可走不同的路径</li>
<li>每个分组的首部必须携带目的主机的完整地址</li>
<li>这种通信方式所传送的分组可能误码、丢失、重复和失序。</li>
<li>由于网络本身不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉（与电信网的交换机相比较）。</li>
<li>因特网采用了这种设计思想，也就是将复杂的网络处理功能置于因特网的边缘（用户主机和其内部的运输层），而将相对简单的尽最大努力的分组交付功能置于因特网核心。</li>
</ul></li>
</ul>
<h4 id="三ipv4地址">三、IPV4地址</h4>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220712145410048.png" /></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220713152341503.png" /></p>
<h4 id="四分类编址的ipv4地址">四、分类编址的IPV4地址：</h4>
<p>​ 划分为ABCDE五类地址，</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-07-14 下午1.10.50.png" style="zoom:50%;" /></p>
<p>​ 只有ABC类地址可以分配给主机或路由器。</p>
<ul>
<li>A类地址：
<ul>
<li>最小网络号为0保留不指派</li>
<li>最大网络号127，作为本地回环测试地址，不指派。
<ul>
<li>最小的本地回环测试地址：127.0.0.1</li>
<li>最大的本地回环测试地址：127.255.255.254</li>
</ul></li>
</ul></li>
<li>BC类地址：
<ul>
<li>最小最大网络号均可指派</li>
</ul></li>
</ul>
<p><strong>注意，</strong>一些特殊地址如下所示：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-07-14%20下午1.17.12.png" /></p>
<h4 id="五划分子网的ipv4地址">五、划分子网的IPV4地址：</h4>
<p>​ 从主机号部分借用一部分作为子网号，来避免主机号的浪费。</p>
<p>​
32比特的子网掩码可以表明分类IP地址的主机号部分被借用了几个比特作为子网号。</p>
<ul>
<li>默认子网掩码：
<ul>
<li>未划分子网的情况下使用的子网掩码</li>
</ul></li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-07-14 下午1.26.26.png" style="zoom: 50%;" /></p>
<h4 id="六无分类编址的ipv4地址">六、无分类编址的IPV4地址：</h4>
<p>​
划分子网在一定程度上缓解了因特网在发展中遇到的困难，但是数量巨大的C类网因为其地址空间太小并没有得到充分使用，而因特网的1P地址仍在加速消耗，整个PV4地址空间面临全部耗尽的威胁。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-07-14%20下午1.45.27.png" /></p>
<ul>
<li>以192.168.4.0/30为例：</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-07-14%20下午1.52.48.png" /></p>
<ul>
<li><p><strong>路由聚合（构造超网）</strong></p>
<ul>
<li>找共同前缀，然后写在网络号部分即可</li>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-07-14%20下午1.48.49.png" /></li>
<li>聚合地址块：172.1.4.0/22</li>
<li>网络前缀越长，地址块越小，路由越具体；</li>
<li>若路由器查表转发分组时发现有多条由可选，选择网络前缀最长的那条，这称为最长前缀匹配，因为这样的路由更具体。</li>
</ul>
<h4 id="七分配ipv4地址的应用规划">七、分配IPV4地址的应用规划</h4>
<ul>
<li>使用定长的子网掩码分配</li>
<li>使用变长的子网掩码分配</li>
</ul></li>
<li><p>采用定长的子网掩码分配示例：</p></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-07-14%20下午2.10.28.png" /></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-07-14%20下午2.13.56.png" /></p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-07-14 下午2.14.21.png" style="zoom: 50%;" /></p>
<p><strong>最终结果如下：</strong></p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-07-14%20下午2.16.48.png"
alt="截屏2022-07-14 下午2.16.48" />
<figcaption aria-hidden="true">截屏2022-07-14 下午2.16.48</figcaption>
</figure>
<ul>
<li>使用变长的子网掩码分配示例：</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-07-14%20下午2.19.31.png" /></p>
<p><strong>最终结果：</strong></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-07-14%20下午2.21.06.png" /></p>
<h4 id="八ip数据包的发送与转发">八、IP数据包的发送与转发</h4>
<ul>
<li>主机如何发送IP数据报</li>
<li>路由器如何发送IP数据报</li>
</ul>
<h5
id="源主机如何知道自己与目的主机不在同一个网络下">1、源主机如何知道自己与目的主机不在同一个网络下？</h5>
<p>其将 主机IP地址和子网掩码作与操作，即可得到网络号，比对即可</p>
<h5
id="源主机如何知道路由器r的存在">2、源主机如何知道路由器R的存在？</h5>
<p>​
用户会为每个主机指定一个路由器，作为转发的路由器，即该主机的<strong>默认网关</strong></p>
<p>​
这样当本网络中的主机要和其他网络中的主机通信时，就交付给默认网关进行转发</p>
<h5
id="路由器收到ip数据报后如何转发">3、路由器收到IP数据报后如何转发？</h5>
<p>检查IP数据报首部是否出错：</p>
<ul>
<li>若出错，则直接丢弃该P数据报并通告源主机。</li>
<li>若没有出错，则进行转发</li>
</ul>
<p>根据数据报的目的地址在路由表中查找匹配的条目：</p>
<ul>
<li><p>若找到匹配的条目，则转发给条目中指示的下一跳</p></li>
<li><p>若找不到，则丢弃该P数据报并通告源主机</p></li>
</ul>
<h5 id="路由表">4、路由表：</h5>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-07-14 下午2.48.32.png" style="zoom:50%;" /></p>
<p><strong>注意：路由器是隔离广播域的，即不会转发广播数据报</strong></p>
<h4
id="九静态路由配置和可能产生的路由环路问题">九、静态路由配置和可能产生的路由环路问题</h4>
<p>​
静态路由配置是指用户或网络管理员使用路由器的相关命令给路由器人工配置路由表。<strong>开销小，但是容易产生错误，仅适用于小型网络</strong></p>
<ul>
<li>默认路由条目：目的网络地址为 0.0.0.0/0</li>
<li>特定主机路由条目：目的网络地址为特定主机的IP地址，子网掩码为255.255.255.255</li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-07-14 下午3.08.12.png" style="zoom: 67%;" /></p>
<h4
id="十动态路由配置路由选择协议概述">十、动态路由配置——路由选择协议概述：</h4>
<p>英特网采用的路由选择协议特点：</p>
<ul>
<li>自适应：路由动态选择，能较好的适应网络状态的变化</li>
<li>分布式：路由器之间交换路由信息</li>
<li>分层次：将整个因特网划分为许多较小的自治系统AS
<ul>
<li>在自治系统内部使用的协议叫做<strong>内部网关协议</strong>，不同自治系统内部可以使用不同的内部网关协议</li>
<li>在自治系统之间使用的协议叫做<strong>外部网关协议</strong></li>
<li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-07-14 下午5.02.09.png" style="zoom:50%;" /></li>
</ul></li>
<li>常见的路由选择协议（在路由器上运行）：</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-07-14%20下午5.09.56.png" /></p>
<ul>
<li><p>路由器的基本结构：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-07-14%20下午5.13.08.png" /></p></li>
</ul>
<p>进入的分组有两种类型：<strong>普通的数据分组 / 路由报文</strong></p>
<ul>
<li><p>普通的数据分组经由转发表转发至对应输出端口</p></li>
<li><p>路由报文进入路由选择处理机，路由选择处理机根据此更新路由表。</p></li>
<li><p>路由选择处理机还会定期的给其他路由器发送路由报文，告知自己知道的路由信息</p></li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-07-14 下午5.14.34.png" style="zoom:50%;" /></p>
<ul>
<li>路由器还有输入和输出缓冲区</li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-07-14 下午5.21.54.png" style="zoom:50%;" /></p>
<h4 id="十一路由信息协议rip">十一、路由信息协议RIP：</h4>
<ul>
<li><p>RIP要求自治系统AS内的每一个路由器<strong>都要维护从它自己到AS内其他每一个网络的距离记录。这是一组距离，称为“距离向量D-V(Distance-.Vector)”</strong></p></li>
<li><p>RIP使用<strong>跳数(Hop
Count)作为度量(Metric)</strong>来衡量到达目的网络的距离。</p>
<ul>
<li>路由器到直连网络的距离定义为1</li>
<li>路由器到非直连网络的距离定义为<strong>所经过的路由器数+1</strong></li>
<li>允许一条路径最多只能包含15个路由器。“距离”等于16时相当于不可达。
因此，<strong>RIP只适用于小型互联网。</strong></li>
</ul></li>
<li><p>RIP认为好的路由就是“距离短”的路由，也就是所通过路由器数量最少的路由。</p></li>
<li><p><strong>三个要点</strong>：</p>
<ul>
<li>1、和谁交换？仅和相邻路由器交换信息</li>
<li>2、交换什么？交换自己的路由表</li>
<li>3、何时交换？周期性交换</li>
</ul></li>
<li><p><strong>基本工作过程</strong>：</p>
<ul>
<li>1、路由器刚开始工作时，只知道自己到直连网络的距离为1。</li>
<li>2、每个路由器<strong>仅和相邻路由器</strong>周期性地交换并更新路由信息。</li>
<li>3、若干次交换和更新后，每个路由器都知道到达本AS内各网络的最短距离和下一跳地址，称为收敛。</li>
<li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715135934147.png" style="zoom:67%;" /></li>
</ul></li>
<li><p><strong>路由条目的更新规则</strong>：</p>
<ul>
<li><p>假设C向D发送封装有路由信息的RIP更新报文</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715140223941.png" style="zoom:50%;" /></p></li>
<li><p>路由器D收到报文后，有两个步骤</p>
<ul>
<li>1、更新发来的路由表，具体步骤：将下一跳全部改成C，然后距离增加1</li>
<li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715140524648.png" style="zoom: 67%;" /></li>
<li>2、根据改造后的路由表改造D的路由表：
<ul>
<li>到达目的网络如果下一跳相同，用最新消息更新。</li>
<li>到达目的网络如果下一跳不同，新路由如果有优势则更新，如果等价则添加（负载均衡）。</li>
<li>如果发现新的目的网络，则添加。</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715140751946.png" style="zoom:67%;" /></p>
<ul>
<li>RIP存在问题：
<ul>
<li>坏消息传播的慢—路由环路问题</li>
<li>可行解决方案：
<ul>
<li>限制最大路径距离为15（16表示不可达）</li>
<li>当路由表发生变化时就立即发送更新报文（即“触发更新”），而不仅是周期性发送</li>
<li>让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向传送（即“水平分割"）</li>
</ul></li>
</ul></li>
</ul>
<h4
id="十二开放最短路径优先ospf协议">十二、开放最短路径优先OSPF协议：</h4>
<ul>
<li><p>特点：</p>
<ul>
<li><p>不限制网络规模，收敛快。</p></li>
<li><p>基于链路状态</p></li>
<li><p>链路状态是指本路由器都和哪些路由器相邻，以及相应链路的“代价”（cost）。</p>
<ul>
<li>“代价”用来表示费用、距离、时延、带宽，等等。这些都由网络管理人员来决定。）</li>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715141321395.png"
title="fig:" alt="image-20220715141321395" /></li>
</ul></li>
</ul></li>
<li><p>OSPF相邻路由器之间通过<strong>交互问候分组，建立和维护邻居关系</strong></p>
<ul>
<li>40s未收到来自另据路由器的问候分组，则认为该邻居不可达。</li>
<li>发送周期为10s</li>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715141512773.png" /></li>
</ul></li>
<li><p>使用OSPF的每个路由器都会产生<strong>链路状态通告LSA（Link State
Advertisement）</strong>。LSA中包含以下内容：</p>
<ul>
<li>直连网络的链路状态信息</li>
<li>邻居路由器的链路状态信息</li>
<li>LSA被封装在<strong>链路状态更新分组LSU中</strong>，采用洪泛法发送。</li>
</ul></li>
<li><p>使用OSPF的每个路由器都有一个<strong>链路状态数据库LSDB，用于存储LSA。</strong>通过各路由器洪泛发送封装有自己LSA的LSU分组，各路由器的LSDB最终将达到一致。</p>
<ul>
<li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715141716322.png" style="zoom:50%;" /></li>
</ul></li>
<li><p>使用OSPF的<strong>各路由器基于LSDB进行最短路径优先SPF计算</strong>，构建出各自到达其他各路由器的最短路径，即构建各自的路由表。</p></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715141814166.png" /></p>
<ul>
<li>OSPF的五种分组类型：
<ul>
<li>类型1，<strong>问候（Hello）分组</strong>，用来发现和维护邻居路由器的可达性。</li>
<li>类型2，<strong>数据库描述（Database
Description）分组</strong>，向邻居路由器给出自己的链路状态数据库中的所有链路状态项目的摘要信息</li>
<li>类型3，<strong>链路状态请求（Link State
Request）分组</strong>，向邻居路由器请求发送某些链路状态项目的详细信息。</li>
<li>类型4，<strong>链路状态更新（Link State
Update）分组</strong>，路由器使用这种分组将其链路状态进行洪泛发送，即用洪泛法对全网更新链路状态。</li>
<li>类型5，<strong>链路状态确认（Link State
Acknowledgment）分组</strong>，这是对链路状态更新分组的确认分组。</li>
</ul></li>
<li>OSPF的基本工作过程：
<ul>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715142215113.png" /></li>
</ul></li>
<li>DR/BDR路由器：
<ul>
<li>在多点接入网络中，</li>
<li>选举<strong>指定路由器DR（designated
router）</strong>和<strong>备用的指定路由器BDR（backup designated
router）</strong></li>
<li>所有的非DR/BDR只与DR/BDR建立邻居关系，非DR/BDR之间通过DR/BDR交换信息</li>
</ul></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715142449139.png" /></p>
<ul>
<li><p>为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做区域（Area）</p>
<ul>
<li><p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715142704821.png" /></p></li>
<li><p>这样使得链路状态通告仅需要在区域内部进行，减少了网络中的通信量。</p></li>
<li><p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715142752029.png" /></p></li>
</ul></li>
</ul>
<h4 id="十三边界网关协议bgp">十三、边界网关协议BGP：</h4>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715143025813.png"
alt="image-20220715143025813" />
<figcaption aria-hidden="true">image-20220715143025813</figcaption>
</figure>
<p>​
<strong>由于没有统一的度量，所以考虑最佳路由是没有意义的</strong></p>
<p>​
<strong>自治系统之间的路由选择必须考虑相关策略（政治，经济，安全等）</strong></p>
<p>​
<strong>基于上述策略,BGP只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由</strong></p>
<ul>
<li><strong>BGP工作原理：</strong>
<ul>
<li>在配置BGP时，每个自治系统的管理员要选择至少一个路由器作为该自治系统的“BGP发言人”。</li>
<li>不同自治系统的BGP发言人要交换路由信息，首先必须建立TCP连接，端口号为179
<ul>
<li>在此TCP连接上交换BGP报文以建立BGP会话</li>
<li>利用BGP会话交换路由信息（例如，增加新的路由，或撤销过时的路由，以及报告出错的情况等）</li>
<li>使用TCP连接交换路由信息的两个BGP发言人，彼此称为对方的邻站（neighbor）或对等站（peer）</li>
</ul></li>
<li>BGP发言人除了运行BGP外，还必须运行自己所在自治系统所使用的内部网关协议IGP，例如OSPF或RIP。</li>
<li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715143347153.png" style="zoom:67%;" /></li>
<li>当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各自治系统的较好的路由。也就是构造出树形结构、不存在回路的自治系统连通图。</li>
</ul></li>
<li><strong>BGP的四种报文</strong>：
<ul>
<li>OPEN（打开）报文：用来与相邻的另一个BGP发言人建立关系，使通信初始化</li>
<li>UPDATE（更新）报文：用来通告某一路由的信息，以及列出要撤销的多条路由</li>
<li>KEEPALIVE（保活）报文：用来周期性地证实邻站的连通性。</li>
<li>NOTIFICATION（通知）报文：用来发送检测到的差错。</li>
</ul></li>
</ul>
<h4 id="十四ip数据包的首部格式">十四、IP数据包的首部格式</h4>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715150218837.png" /></p>
<ul>
<li><p>版本：指IPV4</p></li>
<li><p>首部长度：占4比特，表示IP数据报首部的长度。该字段的取值以4字节为单位。</p></li>
<li><p>可选字段：长度从1个字节到40个字节不等。用来支持排错、测量及安全等措施。</p></li>
<li><p>填充字段：确保首部长度为4字节的整数倍。使用全0进行填充。</p></li>
<li><p>区分服务：占8比特，用来获得更好的服务</p></li>
<li><p>总长度：占16比特，表示IP数据报的总长度（首部+数据载荷）。</p></li>
<li><p>标识、标志、片偏移：用于IP数据报分片</p>
<ul>
<li><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715151418051.png" style="zoom:67%;" /></p></li>
<li><p>标识：占16比特，属于同一个数据报的各分片数据报应该具有相同的标识。</p></li>
<li><p>标志：占3比特，各比特含义如下：</p>
<ul>
<li>DF位：1表示不允许分片； 0表示允许分片</li>
<li>MF位：1表示“后面还有分片”；0表示“这是最后一个分片”</li>
<li>保留位：必须为0</li>
</ul></li>
<li><p>片偏移：占13比特，指出分片数据报的数据载荷部分偏移其在原数据报的位置有多少个单位。以8个字节为单位</p></li>
</ul></li>
<li><p>分片示例：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715151832054.png" /></p></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715151823233.png" /></p>
<ul>
<li><p>生存时间TTL：占8比特，最初以秒为单位，最大生存周期为255秒；路由器转发IP数据报时，将IP数据报首部中的该字段的值减去IP数据报在本路由器上所耗费的时间，若不为0就转发，否则就丢弃。现在以“跳数”为单位，路由器转发IP数据报时，将IP数据报首部中的该字段的值减1，若不为0就转发，否则就丢弃。</p></li>
<li><p>协议：占8比特，指明IPv4数据报的数据部分是何种协议数据单元。</p></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715153014423.png" /></p>
<ul>
<li>首部检验和：占16比特，用来检测首部在传输过程中是否出现差错。比CRC检验码简单，称为因特网检验和。</li>
</ul>
<h4 id="十五网际控制报文协议icmp">十五、网际控制报文协议ICMP</h4>
<p>​
为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了网际控制报文协议ICMP（Internet
Control Message Protocol）。</p>
<p>​
主机或路由器使用ICMP来发送<strong>差错报告报文和询问报文</strong>。</p>
<p>​ ICMP报文被封装在IP数据报中发送。</p>
<ul>
<li><p><strong>差错报告报文</strong>共以下五种报文：</p>
<ul>
<li>终点不可达：
<ul>
<li>当路由器或主机不能交付数据报时，就向源点发送终点不可达报文。具体可再根据ICMP的代码字段细分为目的网络不可达、目的主机不可达、目的协议不可达、目的端口不可达、目的网络未知、目的主机未知等13种错误。</li>
</ul></li>
<li>源点抑制：
<ul>
<li>当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢。</li>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715153421685.png" /></li>
</ul></li>
<li>时间超过：
<ul>
<li>当路由器收到一个目的IP地址不是自己的IP数据报，会将其生存时间TTL字段的值减1。若结果不为0，则将该IP数据报转发出去；若结果为0，除丢弃该IP数据报外，还要向源点发送时间超过报文。</li>
</ul></li>
<li>参数问题：
<ul>
<li>当路由器或目的主机收到IP数据报后，根据其首部中的检验和字段发现首部在传输过程中出现了误码，就丢弃该数据报，并向源点发送参数问题报文。</li>
</ul></li>
<li>改变路由（重定向）：
<ul>
<li>路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）。</li>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715153600977.png" /></li>
</ul></li>
</ul></li>
<li><p><strong>询问报文</strong>有以下两种：</p>
<ul>
<li>回送请求和回答：
<ul>
<li>ICMP回送请求报文是由主机或路由器向一个特定的目的主机发出的询问。
收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。这种询问报文用来测试目的站是否可达及了解其有关状态。</li>
</ul></li>
<li>时间戳请求和回答：
<ul>
<li>ICMP时间戳请求报文是请某个主机或路由器回答当前的日期和时间。在ICMP时间戳回答报文中有一个32位的字段，其中写入的整数代表从
1900年1月1日起到当前时刻一共有多少秒。这种询问报文用来进行时钟同步和测量时间。</li>
</ul></li>
</ul></li>
<li><p>应用举例：</p>
<ul>
<li><p>分组网间探测PING：</p>
<ul>
<li>用来测试主机或路由器间的连通性</li>
<li>应用层直接使用网际层的ICMP（没有通过运输层的TCP或UDP）</li>
<li>使用ICMP回送请求和回答报文</li>
</ul></li>
<li><p>跟踪路由traceroute</p>
<ul>
<li><p>用来测试IP数据报从源主机到达目的主机要经过哪些路由器</p></li>
<li><p>Windows版本</p>
<ul>
<li>tracert命令</li>
<li>应用层直接使用网际层ICMP</li>
<li>使用了ICMP回送请求和回答报文以及差错报告报文</li>
</ul></li>
<li><p>Unix版本</p>
<ul>
<li>traceroute命令</li>
<li>在运输层使用UDP协议</li>
<li>仅使用ICMP差错报告报文</li>
</ul></li>
<li><p>原理：</p>
<ul>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715154351576.png" /></li>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715154401767.png" /></li>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715154421381.png" /></li>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715154432533.png" /></li>
<li>如此循环往复</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h4 id="十六虚拟专用网vpn">十六、虚拟专用网VPN</h4>
<p>​
<strong>利用公用的因特网作为本机构各专用网之间的通信载体</strong>，这样的专用网又称为虚拟专用网。</p>
<p>​
由于IPv4地址的紧缺，一个机构能够申请到的IPV4地址数量往往远小于本机构所拥有的主机数量。因此，虚拟专用网中的各主机所分配的地址应该是本机构可自由分配的专用地址，而不是需要申请的、在因特网上使用的公有地址。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715160004940.png" /></p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715160042220.png"
alt="image-20220715160042220" />
<figcaption aria-hidden="true">image-20220715160042220</figcaption>
</figure>
<ul>
<li>如何发送数据报？
<ul>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715160245145.png" /></li>
</ul></li>
<li>同一机构内不同部门的内部网络所构成的虚拟专用网VPN又称为内联网VPN。</li>
<li>有时一个机构的VPN需要有某些外部机构（通常就是合作伙伴）参加进来。这样的VPN就称为外联网VPN。</li>
<li>在外地工作的员工需要访问公司内部的专用网络时，只要在任何地点接入到因特网，运行驻留在员工PC中的VPN软件，在员工的PC和公司的主机之间建立VPN隧道，即可访问专用网络中的资源。这种VPN称为远程接入VPN。</li>
</ul>
<h4 id="十七网络地址转换nat">十七、网络地址转换NAT</h4>
<p>​
1994年提出了一种网络地址转换NAT的方法再次缓解了IPv4地址空间即将耗尽的问题。</p>
<p>​
NAT能使大量<strong>使用内部专用地址的专用网络用户共享少量外部全球地址</strong>来访问因特网上的主机和资源。</p>
<ul>
<li>发送与接收示意图如下：</li>
</ul>
<p>​ <img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715160540637.png" /></p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715160554747.png"
alt="image-20220715160554747" />
<figcaption aria-hidden="true">image-20220715160554747</figcaption>
</figure>
<p>​
由于绝大多数的网络应用都是使用运输层协议TCP或UDP来传送数据，因此可以利用运输层的端口号和IP地址一起进行转换。这样，用一个全球IP地址就可以使多个拥有本地地址的主机同时和因特网上的主机进行通信。这种将端口号和IP地址一起进行转换的技术叫作<strong>网络地址与端口号转换NAPT（Network
Address and Port Translation）。</strong></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715160700885.png" /></p>
<p><strong>注意：在通信中，外网主机是不能首先发起通信的，因为NAPT路由器收到来自外网的IP数据报后，在NAPT转换表中找不到相应的记录。故而内网主机不能直接充当因特网服务器</strong></p>
<p><strong>对一些P2P网络应用，需要外网主机主动与内网主机进行通信，在通过NAT
时会遇到问题，需要网络应用自己使用一些特殊的NAT穿越技术来解决问题。</strong></p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220715161612437.png"
alt="image-20220715161612437" />
<figcaption aria-hidden="true">image-20220715161612437</figcaption>
</figure>
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Computer Network</tag>
      </tags>
  </entry>
  <entry>
    <title>计网微课堂Chap3——数据链路层原理</title>
    <url>/2022/05/12/feb80abbdc95/</url>
    <content><![CDATA[<p>视频地址：https://www.bilibili.com/video/BV1c4411d7jb?p=21</p>
<h4 id="一数据链路层概述">一、数据链路层概述:</h4>
<p><strong>链路</strong>：
从一个结点到相邻节点的一段物理线路，而中间没有任何其他的交换节点</p>
<h5
id="点对点信道数据链路层中的三个重要问题">1、点对点信道数据链路层中的<strong>三个重要问题</strong>：</h5>
<ul>
<li>封装成帧
<ul>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220518094607556.png" /></li>
</ul></li>
<li>差错检测
<ul>
<li>帧在传输过程中，可能会出现冲突，导致误码。</li>
<li>接收端主机通过<strong>检错码</strong>来判别帧在传输过程中是否有误码</li>
</ul></li>
<li>可靠传输
<ul>
<li>数据链路层向上层提供可靠传输服务，如果帧出错了需要丢弃，那么就需要一种机制来保证接收方的主机仍然能够收到丢弃了帧的副本。</li>
</ul></li>
</ul>
<h5
id="共享式局域网使用广播信号的数据链路层">2、共享式局域网(使用广播信号的数据链路层)</h5>
<ul>
<li>CSMA/CD</li>
</ul>
<h5 id="交换式局域网">3、交换式局域网</h5>
<ul>
<li>交换机如何转发帧？网桥和交换机的工作原理</li>
<li>集线器与交换机的区别</li>
</ul>
<h5 id="无线局域网">4、无线局域网</h5>
<ul>
<li>CSMA/CA</li>
</ul>
<h4 id="二封装成帧">二、封装成帧：</h4>
<ul>
<li><strong>帧定界</strong>：帧头和帧尾的作用之一就是帧定界，接收方的数据链路层可以通过帧定界标志将物理层交付的比特流变成帧。但并不是所有数据链路层帧格式都有帧定界标志。</li>
<li>以太网MAC帧：
<ul>
<li>没有帧定界标识符，其交付给物理层后会加上前导码，并且规定了帧间传输间隔时间为96比特时间</li>
</ul></li>
<li><strong>透明传输：</strong>指数据链路层对上层交付的传输数据没有任何限制，就好像数据链路层不存在一样。<strong>注意</strong>：没有限制指对上层交付的数据没有任何要求，比如说不能包含某些字符
<ul>
<li>面向字节的物理链路使用字节填充（或称字符填充）的方法实现透明传输。【添加转义符号】</li>
<li>面向比特的物理链路使用比特填充的方法实现透明传输。【零比特填充法】</li>
</ul></li>
<li>考虑到差错控制等多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即最大传送单元MTU（Maximum
Transfer Unit）。</li>
</ul>
<h4 id="三差错检测">三、差错检测：</h4>
<ul>
<li><p><strong>奇偶校验</strong>：在待发送的数据后面添加1位奇偶校验位，使得整个数据中的1个数为奇数或偶数</p>
<ul>
<li>如果偶数个位发生误码，无法检测出，误码率较高</li>
</ul></li>
<li><p><strong>循环冗余校验CRC</strong>：（广泛应用）收发双方约定好一个生成多项式G(x)，发送方基于待发送的数据和生成多项式计算出差错检测码，并将其添加到传输数据的后面进行传输。</p>
<p><img src="C:\Users\14012\AppData\Roaming\Typora\typora-user-images\image-20220518155614124.png" style="zoom:50%;" /></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220518155639797.png" /></p>
<p>示例：待发送信息为101001，生成多项式为<span
class="math inline">\(G(x) =x^3 + x^2 + 1\)</span>,求余数</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220518155840739.png" style="zoom:50%;" /></p></li>
<li><p><strong>注意</strong>：检错码只能检错，而不能纠错。在计算机网络中通常采用检错重传方式来纠正传输中的差错，或者仅仅是丢弃检测到差错的帧，<strong>这取决于数据链路层向其上层提供的是可靠传输服务还是不可靠传输服务。</strong></p></li>
</ul>
<h4 id="四可靠传输的基本概念">四、可靠传输的基本概念：</h4>
<ul>
<li><p>若数据链路层向上层提供不可靠传输服务：仅仅丢弃有误码的帧</p></li>
<li><p>若数据链路层向上层提供可靠传输服务：想办法实现发送端发送什么，接收端就收到神恶魔</p></li>
</ul>
<p>​
<strong>一般情况下，有线链路的误码率比较低，为了减小开销，并不要求数据链路层向上提供可靠传输服务。即使出现了误码，可靠传输的问题由其上层处理。</strong></p>
<p>​
<strong>无线链路易受干扰，误码率比较高，因此要求数据链路层必须向上层提供可靠传输服务。</strong></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220518160641668.png" /></p>
<h4
id="五可靠传输的实现机制1停止等待协议stop-wait">五、可靠传输的实现机制1——停止等待协议Stop
Wait：</h4>
<h5 id="基本机制">1、基本机制：</h5>
<p>​
此处提及的实现机制与六七种的实现机制并不局限于数据链路层，可以应用到计算机网络体系结构的任意一层。</p>
<ul>
<li>Case1：针对传输错误的情况，通过ACK和NAK来告知发送方是否传输正确。</li>
<li>Case2：针对发送方数据丢失的情况，发送方需要一个定时器，如果一定时间内接收不到确认帧则需要重传上一个数据包。</li>
<li>Case3：针对接收方返回的确认帧丢失的情况：发送方会重传数据包，接收方如何确认不是重复数据包呢？通过单个比特来编码数据包0或1，给数据分组编号</li>
<li>Case4：针对接收方返回的确认帧重复的情况：给确认帧加上编号，使用比特0或1来标识。</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220518163736899.png" /></p>
<p>​
接收端检测到数据分组有误码时，将其丢弃并等待发送方的超时重传。但对于误码率较高的点对点链路，为使发送方尽早重传，也可给发送方发送NAK分组。</p>
<p>​
为了让接收方能够判断所收到的数据分组是否是重复的，需要给数据分组编号。由于停止-等待协议的停等特性，只需1个比特编号就够了，即编号0和1。</p>
<p>​
为了让发送方能够判断所收到的ACK分组是否是重复的，需要给ACK分组编号，所用比特数量与数据分组编号所用比特数量一样。<strong>数据链路层一般不会出现ACK分组迟到的情况，因此在数据链路层实现停止-等待协议可以不用给ACK分组编号。</strong></p>
<ul>
<li>超时计时器设置的重传时间应仔细选择。一般可将重传时间选为略大于“从发送方到接收方的平均往返时间"。
<ul>
<li>在数据链路层点对点的往返时间比较确定，重传时间比较好设定。</li>
<li>然而在运输层，由于端到端往返时间非常不确定，设置合适的重传时间有时并不容易。</li>
</ul></li>
</ul>
<h5 id="信道利用率">2、信道利用率：</h5>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220518172223346.png" /></p>
<p>​
当往返时延RTT远大于数据帧发送时延时（比如使用卫星链路），会导致信道利用率非常低</p>
<h4
id="六可靠传输的实现机制2回退n帧协议">六、可靠传输的实现机制2——回退N帧协议：</h4>
<p>​
停等式协议信道利用率十分低，为提高信道利用率，可以使用流水线发送数据的形式.在此基础上通过发送窗口来限制发送接收即为回退N帧协议.</p>
<p>首先,假设如下：</p>
<ul>
<li>采用3个比特给分组遍序号，序号为0-7</li>
<li>发送窗口的尺寸为<span
class="math inline">\(W_T\)</span>，取值范围应为<span
class="math inline">\(1 至 2^3-1\)</span>本例取5</li>
<li>接收窗口的尺寸为<span class="math inline">\(W_R = 1\)</span></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220518215743424.png" /></p>
<p>接收到确认分组后，发送方发送窗口向后滑动</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220518220042728.png" style="zoom:50%;" /></p>
<p><strong>累积确认</strong>：<strong>接收方不一定要对收到的数据分组逐个发送确认，</strong>而是可以在收到几个数据分组后（由具体实现决定），对按序到达的最后一个数据分组发送确认。<strong><span
class="math inline">\(ACK_n\)</span>表示序号为n及以前的所有数据分组都已正确接收。</strong></p>
<p><strong>有差错情况</strong>：假设现在数据包5、6、7、0、1被发送送往接收方，数据包5产生误码，那么数据包5将被丢弃，接收窗口对应的序号为5，故数据包6、7、0、1也因为序号不匹配而被丢弃。然后接收方回向发送方发回最后一个确认的序号的ACK帧，即<span
class="math inline">\(ACK_4\)</span>。发送方收到<span
class="math inline">\(ACK_4\)</span>后，收到重复的确认，就知道之前所发送的数据分组出现了差错，就可以开始重传。</p>
<p><strong>当通信线路质量不好时，回退N帧协议的信道利用率并不比停止：等待协议高。</strong></p>
<p><strong>如果<span
class="math inline">\(W_T\)</span>超过其大小上限，就会导致接收方没法分辨新、旧数据分组。</strong></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220518220819263.png" /></p>
<h4
id="七可靠传输的实现机制3选择重传协议">七、可靠传输的实现机制3——选择重传协议：</h4>
<p>​
回退N帧协议<strong>接收窗口尺寸</strong>只能为1，一个数据分组的误码会导致后续多个分组无法按序接收而丢弃。</p>
<p>​
为了进一步提高性能，<strong>可设法只重传出现误码的数据分组。</strong>因此，接收窗口的尺寸W：不应再于1（而应大于1），以便接收方先收下失序到达但无误码并且序号落在接收窗口内的那些数据分组，等到所缺分组收齐后再一并送交上层。这就是选择重传协议。</p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220704151242946.png"
alt="image-20220704151242946" />
<figcaption aria-hidden="true">image-20220704151242946</figcaption>
</figure>
<ul>
<li><p>发送窗口与接收窗口的尺寸限制：</p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220704152510668.png"
alt="image-20220704152510668" />
<figcaption aria-hidden="true">image-20220704152510668</figcaption>
</figure></li>
<li><p>总结：</p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220704154038765.png"
alt="image-20220704154038765" />
<figcaption aria-hidden="true">image-20220704154038765</figcaption>
</figure></li>
</ul>
<h4 id="八点对点协议ppp">八、点对点协议PPP：</h4>
<p>​ 点对点协议PPP（Point-to-Point
Protocol）是目前使用最广泛的点对点数据链路层协议。广泛应用于广域网路由器之间的交换。</p>
<p><strong>PPP协议为在点对点链路传输各种协议数据报提供了一个标准方法，主要由以下三部分构成：</strong></p>
<ul>
<li>对各种协议数据报的封装方法</li>
<li>链路控制协议LCP：用于建立、配置以及测试数据链路的连接</li>
<li>一套网络控制协议NCPs：其中的每一个协议支持不同的网络层协议</li>
</ul>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220704170505457.png"
alt="image-20220704170505457" />
<figcaption aria-hidden="true">image-20220704170505457</figcaption>
</figure>
<p><strong>透明传输</strong>：取决于使用的数据链路</p>
<p><strong>差错检测</strong>：使用CRC来计算该字段的取值</p>
<p>接收方每收到一个PPP帧，就进行CRC检验。若CRC检验正确，就收下这个帧；反之，就丢弃这个帧。使用PPP的数据链路层向上不提供可靠传输服务。</p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220704171056851.png"
alt="image-20220704171056851" />
<figcaption aria-hidden="true">image-20220704171056851</figcaption>
</figure>
<h4 id="九媒体接入控制">九、媒体接入控制 ：</h4>
<p>​
共享信道要着重考虑的一个问题就是<strong>如何协调多个发送和接收站点对一个共享传输媒体的占用</strong>，即媒体接入控制MAC（Medium
Access Control）。</p>
<ul>
<li>静态划分信道</li>
<li>动态接入控制-随机接入</li>
</ul>
<p><strong>随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局域网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术。</strong></p>
<h5 id="静态划分信道">1、静态划分信道：</h5>
<ul>
<li>频分复用、时分复用、波分复用（光载波）</li>
<li>码分复用：</li>
</ul>
<p>​
与FDM和TDM不同，CDM的每一个用户可以在同样的时间使用同样的频带进行通信。</p>
<p>​
由于各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。</p>
<h5
id="动态接入控制csmacd协议-载波监听多址接入碰撞检测早期总线式以太网使用广播信道的有线局域网采用的机制">2、动态接入控制——CSMA/CD协议
（载波监听多址接入/碰撞检测）早期总线式以太网（使用广播信道的有线局域网）采用的机制</h5>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220709215138023.png" /></p>
<ul>
<li><strong>争用期的概念</strong>：</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220709215431183.png" /></p>
<ul>
<li><strong>最小帧长</strong>：</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220709215734966.png" /></p>
<ul>
<li><p><strong>最大帧长</strong>：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220709215824549.png" /></p></li>
<li><p><strong>截断二进制指数退避算法</strong>：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220709215937630.png" /></p></li>
<li><p><strong>帧发送流程</strong>：</p></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220709220244808.png" /></p>
<ul>
<li><p><strong>帧接收流程</strong>：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220709220327190.png" /></p></li>
</ul>
<p>注：CSMA/CD协议曾经用于各种总线结构以太网和双绞线以太网的早期版本中。现在的以太网基于交换机和全双工连接，不会有碰撞，因此没有必要使用CSMA/CD协议。</p>
<h5
id="动态接入控制csmaca协议载波监听多址接入碰撞避免使用广播信道的无线局域网802.11无线局域网使用的协议">3、动态接入控制——CSMA/CA协议（载波监听多址接入/碰撞避免）使用广播信道的无线局域网（802.11无线局域网）使用的协议</h5>
<p>​
在无线局域网中，不能使用碰撞检测CD，原因如下：口由于无线信道的传输条件特殊，其信号强度的动态范围非常大，无线网卡上接收到的信号，强度往往会远远小于发送信号的强度（可能相差百万倍）。如果要在无线网卡上实现碰撞检测CD，对硬件的要求非常高。
即使能够在硬件上实现无线局域网的碰撞检测功能，但由于无线电波传播的特殊性（存在<strong>隐蔽站问题</strong>），进行碰撞检测的意义也不大。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220709220829915.png" style="zoom: 67%;" /></p>
<ul>
<li><p>帧间间隔IFS：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220709220922160.png" style="zoom:67%;" /></p></li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220709221000176.png" alt="image-20220709221000176" style="zoom:67%;" /></p>
<ul>
<li><p><strong>CSMA/CA工作原理：</strong></p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220709221319393.png" style="zoom:67%;" /></p></li>
</ul>
<p>​
1、为何源站检测到信道空闲后，仍然要等待一个DIFS帧间间隔再发送数据帧？</p>
<p><strong>就是考虑到可能有其他的站有高优先级的帧要发送。若有，就要让高优先级帧先发送。</strong></p>
<p>​
2、为何目的站接收到第一帧以后，要等待一个SIFS帧间间隔再发送数据帧？</p>
<p><strong>SIFS是最短的帧间间隔，用来分隔开属于一次对话的各帧。在这段时间内，一个站点应当能够从发送方式切换到接收方式。</strong></p>
<p>​
3、为何其他站再检测到信道忙转为空闲且经过DIFS时间后，还要退避一段随机时间才能使用信道？</p>
<p><strong>防止多个站点同时发送数据而产生碰撞。</strong></p>
<ul>
<li><p><strong>退避算法</strong>：</p>
<p>​
当站点检测到信道是空闲的，并且所发送的数据帧不是成功发送完上一个数据帧之后立即连续发送的数据帧，则不使用退避算法。</p>
<p><strong>以下情况必须使用退避算法：</strong></p>
<ul>
<li>在发送数据帧之前检测到信道处于忙状态时；</li>
<li>在每一次重传一个数据帧时；</li>
<li>在每一次成功发送后要连续发送下一个帧时（这是为了避免一个站点长时间占用信道）。</li>
</ul></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711133229589.png" /></p>
<ul>
<li>CSMA/CA 示例：</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711133457488.png" /></p>
<ul>
<li><p><strong>802.11信道预约机制：RTS帧和CTS帧</strong></p>
<ul>
<li><p>（1）源站在发送数据帧之前先发送一个短的控制帧，称为请求发送RTS（Request
To
Send），它包括<strong>源地址、目的地址以及这次通信（包括相应的确认帧）所需的持续时间</strong>。</p></li>
<li><p>（2）若目的站正确收到源站发来的RTS帧，且媒体空闲，就发送一个响应控制帧，称为允许发送CTS（Clear
To Send），它也包括这次通信所需的
持续时间（从RTS帧中将此持续时间复制到CTS帧中）。</p></li>
<li><p>（3）源站收到CTS帧后，再等待一段时间SIFS后，就可发送其数据帧。</p></li>
<li><p>（4）若目的站正确收到了源站发来的数据帧，在等待时间SIFS后，就向源站发送确认帧ACK。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711133923678.png" /></p></li>
<li><p><strong>除源站和目的站以外的其他各站，在收到CTS帧（或数据帧）后就推迟接入到无线局域网中。这样就保证了源站和目的站之间的通信不会受到其他站的干扰。</strong>如果RTS帧发生碰撞，源站就收不到CTS帧，需执行退避算法重传RTS帧。</p></li>
<li><p>由于RTS帧和CTS帧很短，发送碰撞的概率、碰撞产生的开销及本身的开销都很小。而对于一般的数据帧，其<strong>发送时延往往大于传播时延（因为是局域网）</strong>，碰撞的概率很大，且一旦发生碰撞而导致数据帧重发，则浪费的时间就很多，因此用很小的代价对信道进行预约往往是值得的。</p></li>
</ul></li>
<li><p><strong>802.11虚拟载波监听机制：数据帧也能携带通信所需时间</strong></p>
<ul>
<li>由于利用虚拟载波监听机制，站点只要监听到RTS帧、CTS帧或数据帧中的任何一个，就能知道信道被占用的持续时间，而不需要真正监听到信道上的信号，因此虚拟载波监听机制能减少隐蔽站带来的碰撞问题。</li>
</ul></li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711134106642.png" style="zoom: 67%;" /></p>
<h4 id="十mac地址">十、MAC地址 ：</h4>
<ul>
<li>当<strong>多个主机连接在同一个广播信道上</strong>，要想实现两个主机之间的通信，则每个主机都必须有一个唯一的标识，即一个数据链路层地址。</li>
<li>在每个主机发送的帧中必须携带标识发送主机和接收主机的地址。由于这类地址是用于<strong>媒体接入控制MAC（Media
Access Control）</strong>，因此这类地址被称为MAC地址；</li>
</ul>
<p><strong>一般情况下，用户主机会包含两个网络适配器：有线局域网适配器（有线网卡）和无线局域网适配器（无线网卡）。每个网络适配器都有一个全球唯一的MAC地址。而交换机和路由器往往拥有更多的网络接口，所以会拥有更多的MAC地址。综上所述，严格来说，MAC地址是对网络上各接口的唯一标识，而不是对网络上各设备的唯一标识。</strong></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711163330450.png" /></p>
<h4 id="十一ip地址">十一、IP地址 ：</h4>
<p><strong>IP地址是因特网（Internet）上的主机和路由器所使用的地址</strong>，用于标识两部分信息：</p>
<ul>
<li>网络编号：标识因特网上数以百万计的网络</li>
<li>主机编号：标识同一网络上不同主机（或路由器各接口）</li>
</ul>
<p>​
<strong>很显然，之前介绍的MAC地址不具备区分不同网络的功能。如果只是一个单独的网络，不接入因特网，可以只使用MAC地址（这不是一般用户的应用方式）。如果主机所在的网络要接入因特网，则IP地址和MAC地址都需要使用。</strong></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711164732641.png" /></p>
<h4
id="十二地址解析协议arp协议仅能在一段链路或一个网络下使用">十二、地址解析协议ARP协议：（仅能在一段链路或一个网络下使用）</h4>
<p>现在面临这样一个问题：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711165421809.png" /></p>
<p><strong>ARP高速缓存表</strong>：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711165459322.png" style="zoom: 67%;" /></p>
<p>​
在主机B想要给主机C发送数据包时，首先会查找自己的ARP高速缓存，发现没有主机C的IP地址和MAC地址的转换记录，此时便会发送如下所示ARP请求报文：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711165839100.png" /></p>
<p>当广播帧到达C时：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711165949206.png" style="zoom:67%;" /></p>
<ul>
<li><p>主机C先将B的IP地址与MAC地址记录到自己的ARP高速缓存表中；</p></li>
<li><p>随后给B发送ARP响应，以告知自己的MAC地址。</p></li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711170027736.png" style="zoom: 80%;" /></p>
<p>总线上A、B收到单播帧后：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711170135425.png" /></p>
<p>​
主机B的网卡将帧交付上层的ARP解析进程，其将C的IP地址与MAC地址记录到自己的ARP高速缓存表中。</p>
<ul>
<li>ARP高速缓存的记录类型有两种</li>
</ul>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711170244005.png"
alt="image-20220711170244005" />
<figcaption aria-hidden="true">image-20220711170244005</figcaption>
</figure>
<h4 id="十三集线器与交换机">十三、集线器与交换机</h4>
<ul>
<li><strong>集线器</strong><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711172230039.png"
alt="image-20220711172230039" /></li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711173900724.png" style="zoom: 67%;" /></p>
<ul>
<li><strong>交换机：</strong></li>
</ul>
<p>​
以太网交换机通常都有多个接口。每个接口都可以直接与一台主机或另一个以太网交换机相连。一般都工作在<strong>全双工方式</strong>。</p>
<p>​
以太网交换机具有并行性，能同时连通多对接口，使多对主机能同时通信，无碰撞（不使用CSMA/CD协议）。</p>
<p>​
以太网交换机工作在数据链路层（也包括物理层），<strong>它收到帧后，在帧交换表中查找帧的目的MAC地址所对应的接口号，然后通过该接口转发帧。</strong></p>
<p>​
<strong>以太网交换机是一种即插即用设备，其内部的帧交换表是通过自学习算法自动地逐渐建立起来的。</strong></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711181652815.png" /></p>
<h4
id="十四以太网交换机自学习和转发帧流程">十四、以太网交换机自学习和转发帧流程</h4>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711222156764.png" /></p>
<p>​
<strong>主机A要给主机B发送一个帧，首先到达以太网交换机1，以太网交换机1首先进行登记，将MAC地址A和对应接口1记录到帧交换表中，然后查找目的地址B，如果找不到，则进行盲目泛洪，将帧转发给其他的所有接口。如果找到了，则转发至对应接口
</strong>以此类推</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711223207055.png" alt="image-20220711223207055" style="zoom:67%;" /></p>
<p>​
<strong>主机G给主机A发送一个帧，帧沿着总线到达A和交换机接口1，主机A接收该帧，交换机1查找表，发现应当转发至接口1，但此时这个帧就是来源于接口1，故以太网交换机1就会丢弃该帧</strong></p>
<ul>
<li><strong>注意：每条记录都有自己的有效时间，到期自动删除！这是因为MAC地址与交换机接口的对应关系并不是永久性的！</strong></li>
</ul>
<h4
id="十五以太网交换机的生成树协议stp">十五、以太网交换机的生成树协议STP</h4>
<p>​
如图所示，如果AB的链路或者BC的链路出现问题，则互相之间就无法通信。那么如何提高以太网的可靠性？</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220712094950883.png" alt="image-20220712094950883" style="zoom:67%;" /></p>
<p>​
<strong>添加冗余链路可以提高以太网的可靠性</strong>，但是，冗余链路也会带来负面效应——形成网络环路。</p>
<p>​ <strong>网络环路</strong>会带来以下问题：</p>
<ul>
<li><p>广播风暴：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220712095252611.png" /></p>
<p>广播帧将会在交换机之间反复转发，大量消耗网络资源。</p></li>
<li><p>主机会收到重复的广播帧</p></li>
<li><p>交换机的帧交换表震荡漂移</p></li>
</ul>
<p>​ <strong>故而以太网交换机使用生成树协议STP（Spanning Tree
Protocol），可以在增加冗余链路来提高网络可靠性的同时又避免网络环路带来的各种问题。</strong></p>
<p>​
不论交换机之间采用怎样的物理连接，交换机都能够自动计算并构建一个逻辑上没有环路的网络，其逻辑拓扑结构必须是树型的（无逻辑环路）；（如下图所示）</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220712095713041.png" style="zoom:50%;" /></p>
<p>​
<strong>当首次连接交换机或网络物理拓扑发生变化时（有可能是人为改变或故障），交换机都将进行生成树的重新计算。</strong></p>
<h4 id="十六虚拟局域网vlan">十六、虚拟局域网VLAN</h4>
<p>​
随着交换式以太网规模的扩大，广播域相应扩大。巨大的广播域会带来很多弊端，比如广播风暴，难以管理和维护等。</p>
<p><strong>分割广播域的方法</strong>：</p>
<ul>
<li><p>使用路由器分割广播域（因为路由器默认情况下不对广播帧进行转发）</p></li>
<li><p>虚拟局域网技术VLAN：</p>
<p>虚拟局域网VLAN（Virtual Local Area
Network）是一种将局域网内的设备划分成与物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求。</p>
<p><strong>同一VLAN之间可以广播通信，不同VLAN之间不可以广播通信</strong></p></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220712134553537.png" /></p>
<p><strong>VLAN的实现机制</strong>：</p>
<p>​ VLAN基于交换机实现，需要交换机满足两个条件：</p>
<ul>
<li>支持IEEE802.1q帧，其对MAC帧格式进行了扩展，插入了4字节的VLAN标识
<ul>
<li>802.1Q帧是由交换机来处理的，而不是用户主机来处理的。</li>
<li>当交换机收到普通的以太网帧时，会将其插入4字节的VLAN标记转变为802.1Q帧，简称“打标签”</li>
<li>当交换机转发802.1Q帧时，可能会删除其4字节VLAN标记转变为普通以太网帧，简称“去标签"”。</li>
</ul></li>
<li>交换机的端口类型有三种
<ul>
<li><strong>Access：</strong>一般用于连接用户计算机，只能属于一个VLAN，Access端口的PVID值与端口所属VLAN的ID相同（默认为1）
<ul>
<li>接收处理方法：<strong>一般只接受“未打标签”的普通以太网MAC帧。</strong>根据接收帧的端口的PVID给帧“打标签”，即插入4字节VLAN标记字段，字段中的VID取值与端口的PVID取值相等。</li>
<li>发送处理方法：<strong>若帧中的VID与端囗的PVID相等，则“去标签”并转发该帧；否则不转发。</strong></li>
</ul></li>
<li><strong>Trunk：</strong>一般用于交换机之间或交换机与路由器之间的互联，其可以属于多个VLAN。用户可以设置Trunk端口的PVID值。默认情况下，Trunk端口的PVID值为1。
<ul>
<li>接收处理方法：
<ul>
<li>接收“未打标签”的帧，<strong>根据接收帧的端口的PVID给帧“打标签”，</strong>即插入4字节VLAN标记字段，字段中的VID取值与端口的PVID取值相等。</li>
<li>接收”已打标签“的帧，</li>
</ul></li>
<li>发送处理方法：
<ul>
<li><strong>对VID等于PVID的帧</strong>，“去标签”再转发；</li>
<li><strong>对VID不等于PVID的帧</strong>，直接转发；</li>
</ul></li>
</ul></li>
<li><strong>Hybrid：</strong>Hybrid端口既可用于交换机之间或交换机与路由器之间的互连（同Trunk端口），也可用于交换机与用户计算机之间的互连（同Access端口）
<ul>
<li>接收处理方法：（同Trunk端口）</li>
<li>发送处理方法：
<ul>
<li>查看帧的VID是否在端囗的“去标签”列表中：</li>
<li>若存在，则“去标签”后再转发；</li>
<li>若不存在，则直接转发；</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Computer Network</tag>
      </tags>
  </entry>
  <entry>
    <title>计网微课堂Chap2——物理层原理</title>
    <url>/2022/05/01/81ac33552c19/</url>
    <content><![CDATA[<p>视频地址：https://www.bilibili.com/video/BV1c4411d7jb?p=14</p>
<h4 id="一物理层的基本概念">一、物理层的基本概念：</h4>
<p>​
解决在各种传输媒体上传输比特0和1流的问题，从而给数据链路层提供透明的传输比特流的服务。</p>
<p>​ <strong>物理层为数据链路层屏蔽了各种传输媒体的差异。</strong></p>
<p>物理层协议的主要任务：</p>
<ul>
<li>机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置。</li>
<li>电气特性：指明在接口电缆的各条线上出现的电压的范围。</li>
<li>功能特性：指明某条线上出现的某一国平的电压表示何种意义。</li>
<li>过程特性：指明对于不同功能的各种可能事件的出现顺序。</li>
</ul>
<p>由于物理层传输媒体众多，物理层协议众多，主要需要把握以上四个任务。</p>
<h4 id="二物理层下面的传输媒体">二、物理层下面的传输媒体：</h4>
<h5 id="导引型传输媒体固体线缆">1、导引型传输媒体（固体线缆）</h5>
<ul>
<li>同轴电缆：</li>
</ul>
<p><img src="C:\Users\14012\AppData\Roaming\Typora\typora-user-images\image-20220501094821175.png" style="zoom:50%;" /></p>
<ul>
<li>双绞线：
<ul>
<li>常用于局域网传输</li>
</ul></li>
</ul>
<p>​ <img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501094949365.png" /></p>
<ul>
<li><p>光纤：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501095410880.png" /></p>
<ul>
<li>通信容量大（25000~30000GHz的带宽）</li>
<li>传输损耗小，远距离传输时更加经济。</li>
<li>抗雷电和电磁干扰性能好。这在大电流脉冲干扰的环境下尤为重要。</li>
<li>无串音干扰，保密性好，不易被窃听。</li>
<li>体积小，重量轻。</li>
<li>割接需要专用设备</li>
<li>接口价格较贵</li>
</ul></li>
<li><p>电力线</p></li>
</ul>
<h5
id="非导引型传输媒体自由空间电磁波">2、非导引型传输媒体（自由空间，电磁波）</h5>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501095538393.png" style="zoom: 67%;" /></p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501095701647.png" style="zoom:67%;" /></p>
<ul>
<li>无线电波：</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501095636403.png" /></p>
<ul>
<li><p>微波：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501095750323.png" /></p></li>
<li><p>红外线：</p>
<ul>
<li>电视、空调等遥控器</li>
<li>点对点无线传输，</li>
<li>直线传输，中间不能有障碍物，</li>
<li>传输距离短传输速率低（4Mb/s~16Mb/s）</li>
</ul></li>
</ul>
<h4 id="三传输方式">三、传输方式：</h4>
<h5 id="串行传输和并行传输">1、串行传输和并行传输：</h5>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501100428195.png" style="zoom:67%;" /></p>
<h5 id="同步传输与异步传输">2、同步传输与异步传输：</h5>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501100542991.png" /></p>
<ul>
<li><p>同步传输比特流逐一发送，接收方在比特信号的中间时刻进行检测，由于不同设备的时钟频率不一样，容易产生时钟误差累积，导致比特信号的误检测。所以我们需要一种方法实现收发双方时钟同步：</p>
<ul>
<li><p>外同步：在收发双方之间添加一条单独的时钟信号线</p></li>
<li><p>内同步：发送端将时钟同步信号编码到发送数据中一起传输（例如传统以太网采用的曼彻斯特编码）</p></li>
</ul></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501100823960.png" /></p>
<ul>
<li>异步传输以字节为单位，接收端仅在每个字节的起始处对字节内的比特实现同步，故而需要在字节前后加上起始位和结束位。</li>
</ul>
<h5 id="单工半双工全双工">3、单工、半双工、全双工：</h5>
<ul>
<li>单工示例：广播</li>
<li>半双工示例：对讲机</li>
<li>全双工示例：电话</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501101002739.png" /></p>
<h4 id="四编码与调制">四、编码与调制：</h4>
<p>​
<strong>计算机中二进制数据是运送消息的实体，计算机的网卡会将二进制的数据调制成电信号，</strong>通过网线发送出去。信源发送的原始电信号成为基带信号，其又分为数字基带信号与模拟基带信号。</p>
<p>​ 信号需要在信道中进行传输，信道又分数字信道和模拟信道。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501134907767.png" /></p>
<ul>
<li><p>码元：代表不同离散数值的基本波形。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501135008970.png" style="zoom:50%;" /></p></li>
<li><p>计算机网络中，常用的是将数字信号编码或调制后在信道中进行传输</p></li>
</ul>
<h4 id="五常用编码">五、常用编码：</h4>
<ul>
<li>归零编码：自同步，但编码效率低。</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501135231432.png" /></p>
<ul>
<li><p>曼彻斯特编码：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501135335053.png" /></p></li>
<li><p>曼彻斯特差分编码：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501135411267.png" /></p></li>
</ul>
<h4 id="六常用调制方法">六、常用调制方法：</h4>
<ul>
<li>基本调制方法，1个码元只能包含1个比特信息</li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501135556799.png" style="zoom:50%;" /></p>
<ul>
<li><p>混合调制：</p>
<p>正交振幅调制QAM:</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501135724678.png" style="zoom:50%;" /></p></li>
<li><p>12种相位</p></li>
<li><p>每种相位有1或2种振幅可选,故可以调制出16种码元（波形）</p></li>
<li><p>每种码元可以对应表示4个比特</p></li>
<li><p>码元与4个比特的对应关系采用格雷码，即任意两个码元只有一个比特不同</p></li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501155644426.png" style="zoom:50%;" /></p>
<h4 id="七信道的极限容量">七、信道的极限容量：</h4>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501155815683.png" style="zoom: 50%;" /></p>
<h5 id="奈氏准则"><strong>1、奈氏准则：</strong></h5>
<h5
id="在假定的理想条件下为了避免码间串扰码元的传输速率是有上限的"><strong>在假定的理想条件下，为了避免码间串扰，码元的传输速率是有上限的。</strong></h5>
<ul>
<li><p>理想低通信道的最高码元传输速率=2W Baud=2W码元/秒</p></li>
<li><p>理想带通信道的最高码元传输速率=W Baud =W码元/秒</p></li>
<li><p>W：信道带宽（单位为Hz）</p></li>
<li><p>Baud：波特，即码元/秒</p></li>
</ul>
<p><strong>码元传输速率又称为波特率</strong>：</p>
<ul>
<li>当1个码元只携带一比特的信息量时，波特率 = 比特率</li>
<li>当1个码元携带 N 比特的信息量时，波特率 = 比特率 / N</li>
</ul>
<p><strong>要提高信息传输速率（比特率），就必须设法使每一个码元能携带更多个比特的信息量。</strong></p>
<p><strong>实际的信道所能传输的最高码元速率，要明显低于奈氏准则给出的这个上限数值。</strong></p>
<h5 id="香农公式">2、香农公式：</h5>
<p>​
按照上述公式所说，难道只要采用更好的调制方法，使得码元可以携带更多的比特，就能无限制地提高信息的传输速率？</p>
<p>​
答案是否定的。因为<strong>信道的极限信息传输速率还要受限于实际的信号在信道中传输时的信噪比。</strong></p>
<p><strong>香农公式</strong>：</p>
<p>​
带宽受限且有高斯白噪声干扰的信道的<strong>极限信息传输速率如下</strong>：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501160421428.png" style="zoom: 67%;" /></p>
<p><strong>信道带宽或信道中信噪比越大，信息的极限传输速率越高。</strong></p>
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Computer Network</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机科学笔记1——P1~P10集内容笔记</title>
    <url>/2022/04/27/87bb1a3b00a2/</url>
    <content><![CDATA[<h4 id="一电子计算机组成">一、电子计算机组成：</h4>
<h5 id="控制电路">1、控制电路</h5>
<p>​ 计算机控制电路开关发展历程：电磁继电器——真空管——晶体管</p>
<p>​ 发展趋势：每秒开关次数更大，更不容易损坏，体积更小</p>
<ul>
<li>硅谷的名字来由？晶体管的主要制作来源是硅</li>
</ul>
<h5
id="为什么电子计算机是二进制表示">2、为什么电子计算机是二进制表示？</h5>
<p>​
1、晶体管本身是不仅可以有电流流过和不流过两种状态，还可以表示电流大小，所以早期电子计算机可能采用三进制、五进制。但是由于状态太多，晶体管变化太快，很容易导致信号混杂出现问题。</p>
<p>​ 2、布尔代数的理论完善。</p>
<h5 id="逻辑门">3、逻辑门：</h5>
<p>​
我们可以通过二进制的形式，使用晶体管来构建逻辑门。可以构建更为复杂的逻辑电路。我们可以搭建最基础的
AND/ OR / NOT / XOR 逻辑门，从而构建更为复杂的逻辑门。</p>
<p><img src="C:\Users\14012\AppData\Roaming\Typora\typora-user-images\image-20220427175830177.png" alt="“与”逻辑电路" style="zoom:25%;" /></p>
<h5 id="计算机如何存储">4、计算机如何存储？</h5>
<p>​
使用True和False表示二进制数的0和1。计算机中使用二进制数进行存储和计算。</p>
<p>​
<strong>整数表示：</strong>使用第一位表示数字的正负，1是负，0为正。</p>
<p>​
<strong>浮点数表示：</strong>IEEE754标准，使用科学计数的形式进行存储。</p>
<p>​ 32位浮点数：1 + 8 + 23 （正负 + 指数 + 数字）</p>
<p>​ <strong>ASCII码：</strong>8位，用于表示各种各样的英文符号。</p>
<p>​
<strong>Unicode编码：</strong>设计与1992年，解决了不同国家不同标准的问题。最常见的Unicode是16位，完全足够所有语言、表情进行使用。</p>
<h5 id="计算机如何计算">5、计算机如何计算：</h5>
<p>​ <strong>算数逻辑单元ALU</strong>：计算机里负责运算的组件</p>
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>计算机科学课</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机科学笔记1——P1~P10集内容笔记</title>
    <url>/2022/04/27/698edcb24aab/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>计算机科学课</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理Chapter1—概述</title>
    <url>/2022/04/27/5b4ea41fcadf/</url>
    <content><![CDATA[<p>视频地址：https://www.bilibili.com/video/BV1BE411D7ii</p>
<h4 id="一计算机硬件发展">一、计算机硬件发展：</h4>
<p>​ 电子管时代——晶体管时代——中小规模集成电路——大规模集成电路</p>
<h4
id="二计算机硬件的基本组成冯诺依曼-现代计算机">二、计算机硬件的基本组成（冯诺依曼
&amp; 现代计算机）</h4>
<h5 id="冯诺依曼的计算机工作原理">1、冯诺依曼的计算机工作原理：</h5>
<ul>
<li><strong>存储程序：</strong>指将指令<strong>以二进制代码的形式事先输入计算机的主存储器，</strong>然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。</li>
<li><strong>程序控制：</strong>按指令地址访问存储器并取出指令，经译码依次产生指令执行所需的控制信号，实现对计算的控制，完成指令的功能。</li>
</ul>
<h5 id="冯诺依曼的计算机的组成">2、冯诺依曼的计算机的组成：</h5>
<ul>
<li><p>硬件系统总览：</p>
<ul>
<li><p>主机：CPU（运算器【算数运算、逻辑运算】 +
控制器【指挥程序运行】）、内存</p></li>
<li><p>外设：输入输出设备（将信息转换成机器能识别的形式）、外存储器</p></li>
<li><p>总线：地址线、数据线、控制线</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430165516086.png" style="zoom: 50%;" /></p>
<p><strong>在计算机系统中，软件和硬件在逻辑上是等效的</strong></p></li>
</ul></li>
<li><p>特点：</p>
<ul>
<li><p>计算机由五大部件组成【如下图】</p></li>
<li><p>指令和数据以同等地位存于存储器，可按照地址寻访</p></li>
<li><p>指令和数据用二进制标识</p></li>
<li><p>指令由操作码和地址码组成</p></li>
<li><p>存储程序</p></li>
</ul></li>
</ul>
<p>​
<strong>以运算器为中心</strong>，数据的传输都要经过运算器进行中转</p>
<h5 id="现代计算机的组成">3、现代计算机的组成：</h5>
<p>​
相比于冯诺依曼计算机，现代计算机以<strong>存储器为核心</strong>，如下图所示</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430170456159.png" style="zoom:50%;" /></p>
<p>由于运算器和控制器联系很紧密，在现代的大规模集成电路中，运算器和控制器往往会被集成到一个芯片中，即我们熟知的CPU。</p>
<p>故：<strong>CPU = 运算器 +
控制器</strong>，简化后的现代计算机结构如下：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430170613131.png" alt="image-20220430170613131" style="zoom:50%;" /></p>
<p>各个专业名词的区分：</p>
<ul>
<li>主存一般指
主存储器，比如手机中经常写的运行内存RAM就是指主存储器</li>
<li>辅存一般指 像机械硬盘、固态硬盘等外部IO设备</li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430170848656.png" style="zoom:50%;" /></p>
<h4 id="三各个硬件部件">三、各个硬件部件</h4>
<h5 id="主存储器的基本组成">1、主存储器的基本组成</h5>
<h6 id="总览">1）总览</h6>
<ul>
<li>1、存储体：用于存放数据</li>
<li>2、MAR 存储地址寄存器、3、MDR 存储数据寄存器：
<ul>
<li>CPU将地址放到MAR中，主存储器根据MAR中的地址，去存储体中拿到这个数据，然后把这个数据写入MDR中，CPU通过数据线路从MDR中取走数据。</li>
</ul></li>
<li>示意图：</li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430171815662.png" style="zoom:50%;" /></p>
<h6 id="存储体">2）存储体：</h6>
<p>​ 存储体由许多存储单元组成。</p>
<ul>
<li>存储单元：每个存储单元中将会存放一串二进制代码，每个存储单元会对应一个地址</li>
<li>存储字：存储单元中二进制代码的组合</li>
<li>存储字长：存储单元中二进制代码的位数（常见的有8bit,16bit,32bit,64bit）</li>
<li>存储元：存储二进制的电子元件，每个存储元可以存1bit【电容】</li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430172031137.png" style="zoom:50%;" /></p>
<h6 id="marmdr">3）MAR、MDR</h6>
<p>​ MAR的位数反映了存储单元的个数（因为要指明地址）</p>
<p>​ MDR的位数 = 存储字长,即一个存储单元可以存储二进制代码的位数</p>
<h5 id="运算器的基本组成">2、运算器的基本组成</h5>
<p>​ 用于实现算术运算、逻辑运算，由三个寄存器和算术逻辑单元组成</p>
<p><img src="C:\Users\14012\AppData\Roaming\Typora\typora-user-images\image-20220430204256104.png" style="zoom:50%;" /></p>
<ul>
<li>ACC：累加器，用于存放操作数或运算结果</li>
<li>MQ（Multiple-Quotient）：乘商寄存器，在乘、陈运算时，用于存放操作数或运算结果。</li>
<li>X：通用的操作数寄存器，用于存放操作数</li>
<li>ALU: 算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算</li>
</ul>
<h5 id="控制器的基本组成">3、控制器的基本组成</h5>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430204642685.png" style="zoom:50%;" /></p>
<ul>
<li>CU：控制单元，分析指令，给出控制信号</li>
<li>IR：指令寄存器，存放当前执行的指令</li>
<li>PC：程序计数器，存放下一条指令地址，有自动+1的功能。</li>
</ul>
<p>我们的计算机每完成一条指令，需要有以下三个步骤：</p>
<ul>
<li>取指令，由PC配合执行</li>
<li>分析指令，由IR配合执行</li>
<li>执行指令，由CU配合执行</li>
</ul>
<h4 id="四计算机的工作过程示例">四、计算机的工作过程示例</h4>
<p>​ <strong>步骤1：</strong>高级语言 —》 编译装入主存</p>
<p>​ <img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430213423487.png" /></p>
<p>​ <strong>步骤2</strong>：完成指令的示例过程：</p>
<p>​ 初始：指令、数据存入主存，PC指向第一条指令</p>
<p>​
步骤概述：从主存中取指令放入IR、PC自动加1、CU分析指令、CU指挥其他部件执行指令<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430213124210.png" /></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430213216295.png" /></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430213523337.png" /></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430213547286.png" /></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501000330518.png" /></p>
<p>总结：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501000641611.png" style="zoom:67%;" /></p>
<h4 id="三计算机系统性能评价">三、计算机系统性能评价</h4>
<h5 id="非时间指标">1、非时间指标：</h5>
<ul>
<li><p>1）机器字长：指机器一次能处理的二进制位数</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429110326661.png" style="zoom: 67%;" /></p>
<ul>
<li>由加法器、寄存器的位数决定；</li>
<li>一般与内部寄存器的位数相等（字长）；</li>
<li>字长越长，表示数据的范围就越大，精确度越高；</li>
<li>目前常见的有32位和64位字长。</li>
</ul></li>
<li><p>2）总线宽度：数据总线一次能够并行传送的最大信息位数</p>
<p>​ <img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429110651202.png" /></p>
<ul>
<li>一般指运算器与存储器之间的数据总线位数。有些计算机内部与外部数据总线宽度不一致：</li>
</ul></li>
<li><p>3）主存容量与存储带宽</p>
<ul>
<li><strong>主存容量：</strong>一台计算机贮存所包含的存储单元总数</li>
<li><strong>存储带宽：</strong>指单位时间内与贮存交换的二进制信息量</li>
</ul></li>
</ul>
<h5 id="时间指标">2、时间指标：</h5>
<ul>
<li>主频f / 时钟周期T，外频与倍频
<ul>
<li>主频f：CPU内核工作的时钟频率</li>
<li>时钟周期T：</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>Computer Composition</tag>
      </tags>
  </entry>
  <entry>
    <title>计网微课堂Chap1——计网基础知识与概述</title>
    <url>/2022/04/27/dcdee696a9ce/</url>
    <content><![CDATA[<p>视频地址：https://www.bilibili.com/video/BV1c4411d7jb?p=2</p>
<h4 id="一网络互联网和因特网概述">一、网络、互联网和因特网概述：</h4>
<p>1、网络（Network）由若干结点（Node）和连接这些结点的链路（Link）组成。</p>
<p>2、多个网络可以通过路由器互联，就构成了一个覆盖范围更大的网络，即<strong>互联网</strong></p>
<p>3、<strong>因特网</strong>是世界上给最大的互联网。</p>
<h4 id="二因特网发展阶段">二、因特网发展阶段：</h4>
<p>1、从单个网络ARPANET向互联网发展</p>
<p>2、逐步构成三级结构的因特网</p>
<p>3、逐步形成多层次ISP结构的因特网（ISP：因特网服务提供者）</p>
<h4 id="三因特网服务提供者isp">三、因特网服务提供者ISP：</h4>
<p>​ ISP拥有接入因特网的能力，个人或企业需要向ISP申请IP。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428140348424.png" /></p>
<h4
id="四基于isp的三层结构的因特网">四、基于ISP的三层结构的因特网：</h4>
<ul>
<li>第一层：国际性区域</li>
<li>第二层：区域性或国家性覆盖规模</li>
<li>第三层：本地范围</li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428140515599.png" style="zoom: 33%;" /></p>
<p>​
一个个人主机在接入因特网后也可以成为一个ISP，只要使用路由器等内容将其他主机连入即可。</p>
<h4 id="五因特网的标准化工作">五、因特网的标准化工作：</h4>
<p>​
因特网在制定其标准上的一个很大的特点是<strong>面向公众。</strong></p>
<p>​ 因特网所有的RFC（Request For
Comments）技术文档都可从因特网上免费下载；</p>
<p>​
因特网协会ISOC是一个国际性组织，它负责对因特网进行全面管理，以及在世界范围内促进其发展和使用。</p>
<h4 id="六因特网的组成">六、因特网的组成：</h4>
<ul>
<li>边缘部分：
<ul>
<li>由所有连接在因特网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。</li>
</ul></li>
<li>核心部分：
<ul>
<li>由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（<strong>提供连通性和交换</strong>）。</li>
</ul></li>
</ul>
<h4 id="七三种交换方式">七、三种交换方式：</h4>
<h5 id="电路交换-circuit-switching">1、电路交换 Circuit Switching</h5>
<p>​
当电话数量增多时，无法使得两两电话机之间接通，只能使用电话交换机来完成电话机之间两两的通信任务。</p>
<p>​
<strong>电话交换机接通电话线的方式称为电路交换；</strong>从通信资源的分配角度来看，<strong>交换（Switching）就是按照某种方式动态地分配传输线路的资源；</strong></p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428141032502.png" alt="image-20220428141032502" style="zoom:33%;" /></p>
<p><strong>电路交换的三个步骤</strong>：</p>
<ul>
<li><p>建立连接：分配通信资源（一条固定的物理连接，在双方通信时不会被其他用户占用）</p></li>
<li><p>通话（一直占用通信资源）</p></li>
<li><p>释放连接（归还通信资源）</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428141314096.png" style="zoom: 33%;" /></p>
<p>​
当使用电路交换来传送计算机数据时，其线路的传输效率往往很低。<strong>这是由于计算机的数据往往是突发的出现在链路上的</strong></p></li>
</ul>
<h5 id="分组交换-packet-switching">2、分组交换 Packet Switching</h5>
<p>​ <strong>路由器是分组交换中最重要的设备</strong></p>
<p>发送方：</p>
<ul>
<li>构造分组 + 发送分组</li>
</ul>
<p>路由器：</p>
<ul>
<li>缓存分组 + 转发分组</li>
</ul>
<p>接收方：</p>
<ul>
<li>接受分组 + 还原报文</li>
</ul>
<h5 id="报文交换">3、报文交换：</h5>
<p>​
大致与分组交换一致，但是报文交换<strong>不限制报文的大小，也就要求转发的中间节点有足够的缓存空间</strong>，而分组交换是会把整个报文分成一个个分组，从而进行传输。</p>
<h5 id="对比">4、对比：</h5>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428142115539.png" alt="image-20220428142115539" style="zoom:50%;" /></p>
<ul>
<li>电路交换：
<ul>
<li>通信延时小、有序传输、无冲突、适用范围广（传输模拟、数字信号都可）、实时性强</li>
<li>建立连接时间长，线路独占，使用效率低、灵活性差（只要中间有一个点出错就要重新拨号）</li>
</ul></li>
<li>报文交换：
<ul>
<li>无需建立连接</li>
<li>动态分配线路（节点交换机会先存储整个报文，再选择合适的空闲路径转发报文）</li>
<li>提高线路利用率，可靠性。</li>
<li>提供多目标服务</li>
<li>存在转发时延、需要较大存储缓存空间、需要传输额外信息量（报文头等）</li>
</ul></li>
<li>分组交换：
<ul>
<li>优点：报文交换所拥有的所有优点，同时简化了存储管理，因为分组的大小固定，所有缓冲区大小也会固定，方便管理。加速传输、减少出错概率和重发数据量（如果出错，只需要重传出错分组即可）</li>
<li>缺点：存在转发时延、需要较大存储缓存空间、需要传输额外信息量（控制信息等）。</li>
</ul></li>
<li>分组交换中：
<ul>
<li>对于数据报服务而言：存在失序、丢序、或者重复分组的问题</li>
<li>对于虚电路服务而言：存在呼叫建立、数据传输、虚电路释放三个过程</li>
</ul></li>
</ul>
<h4 id="八计算机网络分类">八、计算机网络分类：</h4>
<ul>
<li>按照覆盖范围分类：
<ul>
<li>广域网WAN（覆盖范围最广，用于高速长途传输）</li>
<li>城域网MAN（通常作为城市骨干网）</li>
<li>局域网LAN</li>
<li>个域网PAN</li>
</ul></li>
<li>按拓扑结构分类：
<ul>
<li>总线型网络</li>
<li>星型网络</li>
<li>环型网络</li>
<li>网状型网络</li>
</ul></li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428150509644.png" style="zoom:50%;" /></p>
<h4 id="九计算机网络的性能指标">九、计算机网络的性能指标：</h4>
<h5 id="速率">1、速率</h5>
<p>​
连接在计算机网络上的<strong>主机在数字信道上传送比特的速率</strong>，也称为比特率或数据率。</p>
<h5 id="带宽">2、带宽</h5>
<ul>
<li>在模拟信号系统中的意义：
<ul>
<li>信号所包含的各种不同频率成分所占据的频率范围；</li>
<li>单位：Hz ，带宽3.1Hz( 300Hz ~ 3.4kHz)</li>
</ul></li>
<li>在计算机网络中的意义：
<ul>
<li>用来表示<strong>网络的通信线路所能传送数据的能力</strong>，因此<strong>网络带宽表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”；</strong></li>
<li>单位：b/s</li>
</ul></li>
</ul>
<h5 id="吞吐量">3、吞吐量</h5>
<p>​ 吞吐量表示在单位时间内通过某个网络（或信道、接口）的数据量。</p>
<p>​ 吞吐量受网络的带宽或额定速率的限制</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428173106779.png" style="zoom: 50%;" /></p>
<h5 id="时延">4、时延</h5>
<p>​
网络时延由三部分组成：发送时延、传播时延、处理时延，计算公式如下所示：（处理时延一般不做计算）</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428173416712.png" /></p>
<h5 id="时延带宽积">5、时延带宽积</h5>
<ul>
<li><p>时延带宽积 = 传播时延 * 带宽</p>
<p>若发送端连续发送数据，则在所发送的第一个比特即将到达终点时，发送端就已经发送了时延带宽积个比特；</p></li>
</ul>
<p>​ 链路的时延带宽积又称为以比特为单位的链路长度。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428173800437.png" style="zoom:50%;" /></p>
<h5 id="往返时间-rtt">6、往返时间 RTT</h5>
<p>​ 从源主机到目标主机，直到源主机收到目标主机的答复所花费的时间</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428173913426.png" style="zoom: 67%;" /></p>
<h5 id="利用率">7、利用率</h5>
<ul>
<li>信道利用率
<ul>
<li>用来表示某信道有百分之几的时间是被利用的（有数据通过）。</li>
</ul></li>
<li>网络利用率
<ul>
<li>全网络的信道利用率的加权平均。</li>
</ul></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428174105464.png" /></p>
<h5 id="丢包率">8、丢包率</h5>
<p>​
是指在一定的时间范围内，<strong>传输过程中丢失的分组数量与总分组数量的比率。</strong></p>
<p>​ <strong>分组丢失一般有两种情况</strong>：</p>
<ul>
<li>分组在传输过程中出现误码，被节点丢弃</li>
<li>分组到达一台队列已满的分组交换机时被丢弃，在通信量较大时就可能造成网络拥塞。</li>
</ul>
<p>因此，丢包率反映了网络的拥塞情况：</p>
<ul>
<li>无拥塞时路径丢包率为0</li>
<li>轻度拥塞时路径丢包率为1%~4%</li>
<li>严重拥塞时路径丢包率为5%~15%</li>
</ul>
<h4 id="十计算机网络体系结构">十、计算机网络体系结构：</h4>
<h5 id="常见的计算机网络体系结构">1、常见的计算机网络体系结构：</h5>
<p>​ OSI体系结构 （法律上的国际标准）、TCP/IP
体系结构（事实上的国际标准）</p>
<ul>
<li>OSI协议制定较为复杂，运行效率低，层次划分并不合理，被TCP/IP体系代替</li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429160500448.png" style="zoom:50%;" /></p>
<p>​
如果用户主机需要接入因特网，必须含有TCP/IP协议族。路由器也需要含有TCP/IP协议族，但是往往路由器只具有
网际层和网络接口层。</p>
<p>​
TCP/IP的网络接口层并没有做过多规定，可以兼容多种网络接口，如有线网络、WIFI接口等。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429160803014.png" style="zoom:50%;" /></p>
<p>​
使用IP协议互联不同的网络接口，为向其上的TCP协议和UDP协议提供网络互联服务，TCP协议在享受IP提供的网络互联服务基础上，可向应用层部分协议提供可靠传输的服务，而UDP协议在享受IP提供的网络互联服务基础上，可向应用层部分协议提供不可靠传输的服务。</p>
<h5 id="计网结构分层的必要性">2、计网结构分层的必要性：</h5>
<p>在实现计算机网络的过程中常见需要考虑的问题，并将相应问题划分给相应的层去进行处理：</p>
<p><strong>情况1：</strong></p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429161416991.png" alt="两台直连计算机间的传输" style="zoom:50%;" /></p>
<ul>
<li><p>物理层问题</p>
<ul>
<li><p>采用何种传输媒体</p></li>
<li><p>采用怎样的物理接口</p></li>
<li><p>使用怎样的信号表示比特0和比特1</p></li>
</ul></li>
</ul>
<p><strong>情况2：在上述问题解决前提下，考虑如下总线型网络：（现在已经不常用了）</strong></p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429161454976.png" alt="总线型网络" style="zoom:50%;" /></p>
<ul>
<li><p>数据链路层问题：</p>
<ul>
<li><p>如何标识网络中各主机（主机编址问题，例如MAC地址）</p></li>
<li><p>如何从信号所标识的一连串比特流中区分出<strong>地址和数据</strong></p></li>
<li><p>如何协调各个主机争用总线</p></li>
<li><p>使用以太网交换机将多台主机互联形成的交换式以太网中：以太网交换机是如何实现的</p></li>
</ul></li>
</ul>
<p><strong>情况3：解决以上问题后，分组就可以在一组网络中传输了，然而我们日常使用的因特网更为复杂，其是由许多路由器将多个网络进行互连起来的互联网，考虑如下由3个路由器和4个网络构成的小型互联网</strong></p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429162242434.png" alt="=" style="zoom:50%;" /></p>
<ul>
<li><p>网络层:</p>
<ul>
<li><p>如何标识各个网络以及网络中的各主机（网络和主机共同编址的问题，如IP地址）</p></li>
<li><p>分组从源主机到目的主机可走路径不止一条，路由器应当如何转发分组，如何进行路由选择</p></li>
</ul></li>
</ul>
<p><strong>情况4：解决以上问题后，可以实现分组在网络两主机间传输的问题，对于计算机网络应用而言远远不够，对于一台主机而言，可能存在多个进程</strong></p>
<ul>
<li><p>运输层</p>
<ul>
<li><p><strong>如何标识与网络通信相关的应用进程</strong>，即解决进程之间基于网络的通信问题</p></li>
<li><p>出现传输错误时，如何处理？（某个分组在传输过程中出现误码，或由于路由器繁忙丢弃分组）</p></li>
</ul></li>
</ul>
<p><strong>情况5：解决上述问题后，可以实现进程之间，基于网络的通信，在此基础上，制定应用层协议，根据协议内容完成特定网络应用即可</strong></p>
<ul>
<li>应用层
<ul>
<li>支持万维网应用的HTTP</li>
<li>支持邮件服务的SMTP</li>
<li>……</li>
</ul></li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429162801442.png" style="zoom:50%;" /></p>
<h5 id="分层思想举例">3、分层思想举例：</h5>
<video src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/2022_04_29_19_04_47_435.mp4">
</video>
<h5 id="专用术语">4、专用术语：</h5>
<ul>
<li>实体：任何可发送或接收信息的硬件或软件进程。</li>
<li>对等实体：收发双发相同层次中的实体
<ul>
<li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429202752020.png" style="zoom:50%;" /></li>
</ul></li>
<li>协议：控制两个对等实体<strong>进行逻辑通信</strong>的规则的集合。
<ul>
<li>协议的三要素：
<ul>
<li>语法：定义所交换信息的格式</li>
<li>语义：定义收发双方所要完成的操作</li>
<li>同步：定义收发双方的时序关系（ 例如 TCP客户端与
TCP服务器之间的时序关系，状态转换）</li>
</ul></li>
<li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429202822644.png" style="zoom:50%;" /></li>
</ul></li>
<li>服务：在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务。
<ul>
<li>要实现本层协议，还需要使用下面一层所提供的服务。</li>
<li>协议是“水平的"，服务是“垂直的"。</li>
<li>实体看得见相邻下层所提供的服务，但并不知道实现该服务的具体协议。也就是说，下面的协议对上面的实体是“透明”的。</li>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429203246032.png" /></li>
</ul></li>
<li>服务访问点：在同一系统中相邻两层的实体交换信息的逻辑接口，用于区分不同的服务类型。</li>
<li>服务原语：上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令称为服务原语。</li>
<li>协议数据单元PDU：对等层次之间传送的数据包称为该层的<strong>协议数据单元</strong>。
<ul>
<li>比特流、帧、IP数据报、TCP报文段、UDP用户数据报、报文</li>
<li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429203352501.png" style="zoom:67%;" /></li>
</ul></li>
<li>服务数据单元SDU：同一系统内，层与层之间交换的数据包称为服务数据单元。</li>
</ul>
<h4 id="十一习题">十一、习题：</h4>
<h5 id="section">1、</h5>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430113545991.png" /></p>
<h5 id="section-1">2、</h5>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430113940223.png" /></p>
<h5 id="section-2">3、</h5>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430114621627.png" /></p>
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Computer Network</tag>
      </tags>
  </entry>
  <entry>
    <title>计网微课堂Chap1——计网基础知识与概述</title>
    <url>/2022/04/27/70c42ee7d534/</url>
    <content><![CDATA[<p>视频地址：https://www.bilibili.com/video/BV1c4411d7jb?p=2</p>
<h4 id="一网络互联网和因特网概述">一、网络、互联网和因特网概述：</h4>
<p>1、网络（Network）由若干结点（Node）和连接这些结点的链路（Link）组成。</p>
<p>2、多个网络可以通过路由器互联，就构成了一个覆盖范围更大的网络，即<strong>互联网</strong></p>
<p>3、<strong>因特网</strong>是世界山给最大的互联网。</p>
<h4 id="二因特网发展阶段">二、因特网发展阶段：</h4>
<p>1、从单个网络ARPANET向互联网发展</p>
<p>2、逐步构成三级结构的因特网</p>
<p>3、逐步形成多层次ISP结构的因特网（ISP：因特网服务提供者）</p>
<h4 id="三因特网服务提供者isp">三、因特网服务提供者ISP：</h4>
<p>​ ISP拥有接入因特网的能力，个人或企业需要向ISP申请IP。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428140348424.png" /></p>
<h4
id="四基于isp的三层结构的因特网">四、基于ISP的三层结构的因特网：</h4>
<ul>
<li>第一层：国际性区域</li>
<li>第二层：区域性或国家性覆盖规模</li>
<li>第三层：本地范围</li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428140515599.png" style="zoom: 33%;" /></p>
<p>​
一个个人主机在接入因特网后也可以成为一个ISP，只要使用路由器等内容将其他主机连入即可。</p>
<h4 id="五因特网的标准化工作">五、因特网的标准化工作：</h4>
<p>​
因特网在制定其标准上的一个很大的特点是<strong>面向公众。</strong></p>
<p>​ 因特网所有的RFC（Request For
Comments）技术文档都可从因特网上免费下载；</p>
<p>​
因特网协会ISOC是一个国际性组织，它负责对因特网进行全面管理，以及在世界范围内促进其发展和使用。</p>
<h4 id="六因特网的组成">六、因特网的组成：</h4>
<ul>
<li>边缘部分：
<ul>
<li>由所有连接在因特网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。</li>
</ul></li>
<li>核心部分：
<ul>
<li>由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（<strong>提供连通性和交换</strong>）。</li>
</ul></li>
</ul>
<h4 id="七三种交换方式">七、三种交换方式：</h4>
<h5 id="电路交换-circuit-switching">1、电路交换 Circuit Switching</h5>
<p>​
当电话数量增多时，无法使得两两电话机之间接通，只能使用电话交换机来完成电话机之间两两的通信任务。</p>
<p>​
<strong>电话交换机接通电话线的方式称为电路交换；</strong>从通信资源的分配角度来看，<strong>交换（Switching）就是按照某种方式动态地分配传输线路的资源；</strong></p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428141032502.png" alt="image-20220428141032502" style="zoom:33%;" /></p>
<p><strong>电路交换的三个步骤</strong>：</p>
<ul>
<li><p>建立连接：分配通信资源（一条固定的物理连接，在双方通信时不会被其他用户占用）</p></li>
<li><p>通话（一直占用通信资源）</p></li>
<li><p>释放连接（归还通信资源）</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428141314096.png" style="zoom: 33%;" /></p>
<p>​
当使用电路交换来传送计算机数据时，其线路的传输效率往往很低。<strong>这是由于计算机的数据往往是突发的出现在链路上的</strong></p></li>
</ul>
<h5 id="分组交换-packet-switching">2、分组交换 Packet Switching</h5>
<p>​ <strong>路由器是分组交换中最重要的设备</strong></p>
<p>发送方：</p>
<ul>
<li>构造分组 + 发送分组</li>
</ul>
<p>路由器：</p>
<ul>
<li>缓存分组 + 转发分组</li>
</ul>
<p>接收方：</p>
<ul>
<li>接受分组 + 还原报文</li>
</ul>
<h5 id="报文交换">3、报文交换：</h5>
<p>​
大致与分组交换一致，但是报文交换<strong>不限制报文的大小，也就要求转发的中间节点有足够的缓存空间</strong>，而分组交换是会把整个报文分成一个个分组，从而进行传输。</p>
<h5 id="对比">4、对比：</h5>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428142115539.png" alt="image-20220428142115539" style="zoom:50%;" /></p>
<ul>
<li>电路交换：
<ul>
<li>通信延时小、有序传输、无冲突、适用范围广（传输模拟、数字信号都可）、实时性强</li>
<li>建立连接时间长，线路独占，使用效率低、灵活性差（只要中间有一个点出错就要重新拨号）</li>
</ul></li>
<li>报文交换：
<ul>
<li>无需建立连接</li>
<li>动态分配线路（节点交换机会先存储整个报文，再选择合适的空闲路径转发报文）</li>
<li>提高线路利用率，可靠性。</li>
<li>提供多目标服务</li>
<li>存在转发时延、需要较大存储缓存空间、需要传输额外信息量（报文头等）</li>
</ul></li>
<li>分组交换：
<ul>
<li>优点：报文交换所拥有的所有优点，同时简化了存储管理，因为分组的大小固定，所有缓冲区大小也会固定，方便管理。加速传输、减少出错概率和重发数据量（如果出错，只需要重传出错分组即可）</li>
<li>缺点：存在转发时延、需要较大存储缓存空间、需要传输额外信息量（控制信息等）。</li>
</ul></li>
<li>分组交换中：
<ul>
<li>对于数据报服务而言：存在失序、丢序、或者重复分组的问题</li>
<li>对于虚电路服务而言：存在呼叫建立、数据传输、虚电路释放三个过程</li>
</ul></li>
</ul>
<h4 id="八计算机网络分类">八、计算机网络分类：</h4>
<ul>
<li>按照覆盖范围分类：
<ul>
<li>广域网WAN（覆盖范围最广，用于高速长途传输）</li>
<li>城域网MAN（通常作为城市骨干网）</li>
<li>局域网LAN</li>
<li>个域网PAN</li>
</ul></li>
<li>按拓扑结构分类：
<ul>
<li>总线型网络</li>
<li>星型网络</li>
<li>环型网络</li>
<li>网状型网络</li>
</ul></li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428150509644.png" style="zoom:50%;" /></p>
<h4 id="九计算机网络的性能指标">九、计算机网络的性能指标：</h4>
<h5 id="速率">1、速率</h5>
<p>​
连接在计算机网络上的<strong>主机在数字信道上传送比特的速率</strong>，也称为比特率或数据率。</p>
<h5 id="带宽">2、带宽</h5>
<ul>
<li>在模拟信号系统中的意义：
<ul>
<li>信号所包含的各种不同频率成分所占据的频率范围；</li>
<li>单位：Hz ，带宽3.1Hz( 300Hz ~ 3.4kHz)</li>
</ul></li>
<li>在计算机网络中的意义：
<ul>
<li>用来表示<strong>网络的通信线路所能传送数据的能力</strong>，因此<strong>网络带宽表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”；</strong></li>
<li>单位：b/s</li>
</ul></li>
</ul>
<h5 id="吞吐量">3、吞吐量</h5>
<p>​ 吞吐量表示在单位时间内通过某个网络（或信道、接口）的数据量。</p>
<p>​ 吞吐量受网络的带宽或额定速率的限制</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428173106779.png" style="zoom: 50%;" /></p>
<h5 id="时延">4、时延</h5>
<p>​
网络时延由三部分组成：发送时延、传播时延、处理时延，计算公式如下所示：（处理时延一般不做计算）</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428173416712.png" /></p>
<h5 id="时延带宽积">5、时延带宽积</h5>
<ul>
<li><p>时延带宽积 = 传播时延 * 带宽</p>
<p>若发送端连续发送数据，则在所发送的第一个比特即将到达终点时，发送端就已经发送了时延带宽积个比特；</p></li>
</ul>
<p>​ 链路的时延带宽积又称为以比特为单位的链路长度。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428173800437.png" style="zoom:50%;" /></p>
<h5 id="往返时间-rtt">6、往返时间 RTT</h5>
<p>​ 从源主机到目标主机，直到源主机收到目标主机的答复所花费的时间</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428173913426.png" style="zoom: 67%;" /></p>
<h5 id="利用率">7、利用率</h5>
<ul>
<li>信道利用率
<ul>
<li>用来表示某信道有百分之几的时间是被利用的（有数据通过）。</li>
</ul></li>
<li>网络利用率
<ul>
<li>全网络的信道利用率的加权平均。</li>
</ul></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428174105464.png" /></p>
<h5 id="丢包率">8、丢包率</h5>
<p>​
是指在一定的时间范围内，<strong>传输过程中丢失的分组数量与总分组数量的比率。</strong></p>
<p>​ <strong>分组丢失一般有两种情况</strong>：</p>
<ul>
<li>分组在传输过程中出现误码，被节点丢弃</li>
<li>分组到达一台队列已满的分组交换机时被丢弃，在通信量较大时就可能造成网络拥塞。</li>
</ul>
<p>因此，丢包率反映了网络的拥塞情况：</p>
<ul>
<li>无拥塞时路径丢包率为0</li>
<li>轻度拥塞时路径丢包率为1%~4%</li>
<li>严重拥塞时路径丢包率为5%~15%</li>
</ul>
<h4 id="十计算机网络体系结构">十、计算机网络体系结构：</h4>
<h5 id="常见的计算机网络体系结构">1、常见的计算机网络体系结构：</h5>
<p>​ OSI体系结构 （法律上的国际标准）、TCP/IP
体系结构（事实上的国际标准）</p>
<ul>
<li>OSI协议制定较为复杂，运行效率低，层次划分并不合理，被TCP/IP体系代替</li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429160500448.png" style="zoom:50%;" /></p>
<p>​
如果用户主机需要接入因特网，必须含有TCP/IP协议族。路由器也需要含有TCP/IP协议族，但是往往路由器只具有
网际层和网络接口层。</p>
<p>​
TCP/IP的网络接口层并没有做过多规定，可以兼容多种网络接口，如有线网络、WIFI接口等。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429160803014.png" style="zoom:50%;" /></p>
<p>​
使用IP协议互联不同的网络接口，为向其上的TCP协议和UDP协议提供网络互联服务，TCP协议在享受IP提供的网络互联服务基础上，可向应用层部分协议提供可靠传输的服务，而UDP协议在享受IP提供的网络互联服务基础上，可向应用层部分协议提供不可靠传输的服务。</p>
<h5 id="计网结构分层的必要性">2、计网结构分层的必要性：</h5>
<p>在实现计算机网络的过程中常见需要考虑的问题，并将相应问题划分给相应的层去进行处理：</p>
<p><strong>情况1：</strong></p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429161416991.png" alt="两台直连计算机间的传输" style="zoom:50%;" /></p>
<ul>
<li><p>物理层问题</p>
<ul>
<li><p>采用何种传输媒体</p></li>
<li><p>采用怎样的物理接口</p></li>
<li><p>使用怎样的信号表示比特0和比特1</p></li>
</ul></li>
</ul>
<p><strong>情况2：在上述问题解决前提下，考虑如下总线型网络：（现在已经不常用了）</strong></p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429161454976.png" alt="总线型网络" style="zoom:50%;" /></p>
<ul>
<li><p>数据链路层问题：</p>
<ul>
<li><p>如何标识网络中各主机（主机编址问题，例如MAC地址）</p></li>
<li><p>如何从信号所标识的一连串比特流中区分出<strong>地址和数据</strong></p></li>
<li><p>如何协调各个主机争用总线</p></li>
<li><p>使用以太网交换机将多台主机互联形成的交换式以太网中：以太网交换机是如何实现的</p></li>
</ul></li>
</ul>
<p><strong>情况3：解决以上问题后，分组就可以在一组网络中传输了，然而我们日常使用的因特网更为复杂，其是由许多路由器将多个网络进行互连起来的互联网，考虑如下由3个路由器和4个网络构成的小型互联网</strong></p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429162242434.png" alt="=" style="zoom:50%;" /></p>
<ul>
<li><p>网络层:</p>
<ul>
<li><p>如何标识各个网络以及网络中的各主机（网络和主机共同编址的问题，如IP地址）</p></li>
<li><p>分组从源主机到目的主机可走路径不止一条，路由器应当如何转发分组，如何进行路由选择</p></li>
</ul></li>
</ul>
<p><strong>情况4：解决以上问题后，可以实现分组在网络两主机间传输的问题，对于计算机网络应用而言远远不够，对于一台主机而言，可能存在多个进程</strong></p>
<ul>
<li><p>运输层</p>
<ul>
<li><p><strong>如何标识与网络通信相关的应用进程</strong>，即解决进程之间基于网络的通信问题</p></li>
<li><p>出现传输错误时，如何处理？（某个分组在传输过程中出现误码，或由于路由器繁忙丢弃分组）</p></li>
</ul></li>
</ul>
<p><strong>情况5：解决上述问题后，可以实现进程之间，基于网络的通信，在此基础上，制定应用层协议，根据协议内容完成特定网络应用即可</strong></p>
<ul>
<li>应用层
<ul>
<li>支持万维网应用的HTTP</li>
<li>支持邮件服务的SMTP</li>
<li>……</li>
</ul></li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429162801442.png" style="zoom:50%;" /></p>
<h5 id="分层思想举例">3、分层思想举例：</h5>
<video src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/2022_04_29_19_04_47_435.mp4">
</video>
<h5 id="专用术语">4、专用术语：</h5>
<ul>
<li>实体：任何可发送或接收信息的硬件或软件进程。</li>
<li>对等实体：收发双发相同层次中的实体
<ul>
<li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429202752020.png" style="zoom:50%;" /></li>
</ul></li>
<li>协议：控制两个对等实体<strong>进行逻辑通信</strong>的规则的集合。
<ul>
<li>协议的三要素：
<ul>
<li>语法：定义所交换信息的格式</li>
<li>语义：定义收发双方所要完成的操作</li>
<li>同步：定义收发双方的时序关系（ 例如 TCP客户端与
TCP服务器之间的时序关系，状态转换）</li>
</ul></li>
<li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429202822644.png" style="zoom:50%;" /></li>
</ul></li>
<li>服务：在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务。
<ul>
<li>要实现本层协议，还需要使用下面一层所提供的服务。</li>
<li>协议是“水平的"，服务是“垂直的"。</li>
<li>实体看得见相邻下层所提供的服务，但并不知道实现该服务的具体协议。也就是说，下面的协议对上面的实体是“透明”的。</li>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429203246032.png" /></li>
</ul></li>
<li>服务访问点：在同一系统中相邻两层的实体交换信息的逻辑接口，用于区分不同的服务类型。</li>
<li>服务原语：上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令称为服务原语。</li>
<li>协议数据单元PDU：对等层次之间传送的数据包称为该层的<strong>协议数据单元</strong>。
<ul>
<li>比特流、帧、IP数据报、TCP报文段、UDP用户数据报、报文</li>
<li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429203352501.png" style="zoom:67%;" /></li>
</ul></li>
<li>服务数据单元SDU：同一系统内，层与层之间交换的数据包称为服务数据单元。</li>
</ul>
<h4 id="十一习题">十一、习题：</h4>
<h5 id="section">1、</h5>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430113545991.png" /></p>
<h5 id="section-1">2、</h5>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430113940223.png" /></p>
<h5 id="section-2">3、</h5>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430114621627.png" /></p>
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Computer Network</tag>
      </tags>
  </entry>
  <entry>
    <title>《Not All Tokens Are Equal Human-centric Visual Analysis via Token Clustering Transformer》</title>
    <url>/2022/04/24/22e32ee5ba59/</url>
    <content><![CDATA[<h4
id="论文名称not-all-tokens-are-equal-human-centric-visual-analysis-via-token-clustering-transformer">论文名称：《Not
All Tokens Are Equal Human-centric Visual Analysis via Token Clustering
Transformer》</h4>
<h4 id="论文地址-httparxiv.orgabs2204.08680">论文地址：
http://arxiv.org/abs/2204.08680</h4>
<h2 id="关键词">1、关键词：</h2>
<p>​ Dynamic Token</p>
<h2 id="摘要">2、摘要：</h2>
<p>​
ViT在许多计算机视觉任务中取得了巨大的成功。大多数方法通过将图像分割成规则的固定patches并将每个patch作为一个token来生成视觉token。
​
然而，在以人为中心的视觉任务中，并不是所有区域都同等重要，例如，人体需要一个带有许多token的精细表示，而图像背景可以由少量token建模。
​
为了解决这个问题，论文提出了一种新的ViT，称为令牌聚类转换器(TCFormer)，它通过渐进聚类来合并token，其中token可以从不同的位置以灵活的形状和大小合并。</p>
<p>​
TCFormer中的令牌不仅可以关注重要区域，还可以调整令牌形状以适应语义概念，并对包含关键细节的区域采用精细分辨率，有利于捕获详细信息。</p>
<h2 id="领域背景">3、领域背景：</h2>
<p>​ 暂略</p>
<h2 id="先前工作描述与比较">4、先前工作描述与比较：</h2>
<p>​ 暂略</p>
<h2 id="主要设计思想">5、主要设计思想：</h2>
<p>​
为了解决传统ViT中，大多将图像分割成规则的固定patches并将每个patch作为一个token来生成视觉token。然而在以人为中心的视觉任务中，并不是所有区域都同等重要，所以论文提出了一种新的ViT(TCFormer)，它通过渐进的令牌聚类生成TOKENS。</p>
<p>​
TCFormer在每个阶段动态生成TOKENS。如图所示，它能够生成具有不同位置、大小和形状的Token。首先，与基于网格的标记不同，聚类后的标记不局限于规则形状，可以专注于重要的区域，如人体。其次，TCFormer动态生成具有适当大小的令牌来表示不同的区域。比如说：<strong>对于充满重要细节(如人脸)的区域，分配更小尺寸的令牌。而仅有单个token(例如，图中的蓝色标记)被用来表示背景的大片区域。</strong></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220424202223439.png" /></p>
<p>​ 在TCFormer中，特征图中的每个像素在第一阶段被初始化为一个vision
token，其token区域就是像素所覆盖的区域。我们逐步合并语义相近的token，在不同阶段得到不同数量的token。</p>
<p>​ 为此，我们精心设计了一个聚类令牌合并(CTM)块：</p>
<ul>
<li>首先，给定上一阶段的tokens，CTM模块使用k-nearest-neighbor based
density peaks clustering聚类算法对token进行分组。</li>
<li>那些被分到一组的tokens，会合并到一个单独的token，其值为所有特征的平均值。</li>
<li>最后，将tokens输入到一个transformer
block中进行特征聚合。最终合并得到的token区域是所有输入导transformer
block中的tokens的并集。</li>
</ul>
<p>​
多阶段特征的聚合已经被证明有利于以人为中心的分析。大多数之前的研究将视觉token转换为特征图，并以特征图的形式聚合特征。然而，当我们将动态视觉token转换为特征图时，多个token可能位于同一个像素网格中，导致细节丢失。
​
为了解决这一问题，我们提出了一种多阶段令牌聚合(MTA)块，它能够有效地保存所有阶段的图像细节。具体来说：</p>
<ul>
<li>MTA从最后一个阶段的令牌开始，然后从前一个阶段逐步上采样tokens并聚合token特征，直到聚合所有阶段的特征。聚合的tokens与特征映射中的像素一一对应，并被reshape为特征映射以进行后续处理。</li>
</ul>
<h2 id="具体方法与网络架构">6、具体方法与网络架构：</h2>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220424203340869.png" /><strong>概述：</strong>TCFormer由4个阶段和一个(MTA)头组成。每个阶段包含几个堆叠的Transformer块。在两个相邻的阶段之间，插入一个(CTM)块，以合并令牌并为下一个阶段生成令牌。最后MTA头将所有阶段的token特征聚集起来，并输出最终的热图</p>
<h4 id="核心1-transformer-block">1） 核心1： Transformer Block：</h4>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220424203928917.png" style="zoom:50%;" /></p>
<p>​ 采用Spatial Reduction层来降低计算复杂度。Spatial
Reduction层首先将视觉token转换为特征映射，然后通过跨卷积层降低特征映射分辨率。处理后的特征图中的像素，比视觉标记要少得多，被作为K和V输入到多头注意模块。多头注意模块在token之间聚合特征。
​我们利用Depth-Wise
Convolution来捕获局部特征和位置信息，并去除显式位置嵌入。</p>
<h4 id="核心2-clustering-based-token-merge-ctm-block">2） 核心2：
Clustering-based Token Merge (CTM) Block：</h4>
<p>​
如图所示，我们的CTM块有两个过程，即Clustering和特征Merge。我们使用通过Clustering来将vision
tokens归到一定数量的聚类中.</p>
<ul>
<li>Clustering
<ul>
<li>在Clustering过程中，我们使用了一种基于k近邻密度峰值聚类算法(DPC-KNN)的变体。</li>
<li>给定一组令牌X，我们根据其k近邻计算每个令牌的局部密度ρ:</li>
<li>然后，对于每个令牌，我们 计算距离
作为它与任何其他具有更高局部密度的令牌之间的最小距离。
对于局部密度最高的token，其指示器设置为
它与任何其他标记之间的最大距离。</li>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220425150522682.png" /></li>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220425150412421.png" /></li>
<li>δi 是距离指示指标 ，ρi 是局部密度指标</li>
<li>我们将δi 和 ρi 结合起来，得到每个token的得分为 ρi×δi。</li>
<li>分数越高，成为集群中心的可能性就越大。我们通过选择得分最高的token来确定聚类中心，然后根据特征距离将其他标记分配到最近的聚类中心。</li>
</ul></li>
<li>Merge</li>
</ul>
<p>​
对于token特征的合并，一种直观的方法是直接对一个聚类中的token特征进行平均。但是，即使是语义意义相似的符号，其重要性也不完全相同。论文引入了一个重要度评分P来明确表示每个token的重要性，它是由token的特征估计的。然后在token重要性的指导下，对token特征进行平均:</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220425150756742.png" /></p>
<p>​ 其中<span class="math inline">\(C_i\)</span>表示第<span
class="math inline">\(i\)</span>个聚类的集合，<span
class="math inline">\(x_j\)</span>和<span
class="math inline">\(p_j\)</span>分别为原始token特征和对应的重要性得分，yi为合并后token的特征。合并令牌的令牌区域是原始令牌区域的并集。</p>
<ul>
<li><p>Final</p>
<p>最终合并好的令牌作为查询Q被送入一个Transformer
Block，原始的Token用作K和V。为了保证
重要的token对输出的贡献更大，在注意力机制中增加重要性权重P，如下所示:</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220425151005438.png" style="zoom:50%;" /></p>
<p>引入token重要性评分使我们的CTM块在合并视觉标记时能够专注于关键的图像特征</p></li>
</ul>
<h4 id="核心3-multi-stage-token-aggregation-mta-head">3） 核心3：
Multi-stage Token Aggregation (MTA) Head：</h4>
<p>​
之前的研究证明了在以人为中心的视觉任务中，在多个阶段中进行特征聚合的好处。为了聚合特性，我们提出了一种基于Transformer的多阶段令牌聚合(MTA)头，它能够维护所有阶段的细节信息。</p>
<p>​ 下图
(a)显示了令牌上采样过程。在令牌合并过程中(章节3.3)，每个令牌被分配到一个聚类，每个聚类由一个合并的令牌表示。
我们记录原始token和合并token之间的关系。在token上采样过程中，我们利用所记录的信息将合并的token特征复制到相应的上采样token中。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220425152443159.png" style="zoom:67%;" /></p>
<p>​ MTA
Head将上一阶段的token特征添加到上采样的视觉token。然后，视觉token进入一个Transformer块。这样的处理是逐步执行的，直到所有的视觉token被聚合。最终的token，其token表示的区域是高分辨率特征图中的单个像素，可以很容易地重构为特征图进行进一步处理。</p>
<p>​ 整体而言，有点像UFormer的那种形式。</p>
]]></content>
      <categories>
        <category>③  论文阅读笔记</category>
        <category>CV相关论文</category>
      </categories>
      <tags>
        <tag>Transformer</tag>
      </tags>
  </entry>
  <entry>
    <title>《Vision Transformer with Deformable Attention》</title>
    <url>/2022/04/24/503bff4618b7/</url>
    <content><![CDATA[<h4
id="论文名称vision-transformer-with-deformable-attention">论文名称：《Vision
Transformer with Deformable Attention》</h4>
<h4 id="论文地址-httparxiv.orgabs2201.00520">论文地址：
http://arxiv.org/abs/2201.00520</h4>
<h2 id="关键词">1、关键词：</h2>
<p>​ Deformable Attention</p>
<h2 id="摘要">2、摘要：</h2>
<p>​
Transformer最近在各种视觉任务中表现优异。全局的感知域使Transformer模型比CNN具有更强的表示能力。
​
然而，简单地扩大感受野也引起了一些问题。一方面，使用较为密集的注意力，例如在ViT中，会导致过多的内存和计算成本，并且功能可能会受到超出兴趣区域的无关部分的影响。另一方面，在PVT或Swin
Transformer中采用的较为稀疏的注意机制是与数据无关的，这可能会限制对于长距离关系的建模能力。
​为了缓解这些问题，论文提出了一种新的可变形的Self
Attention模块，在自我注意模块中，KV键值对与数据相关。这种灵活的方案使Self
Attention模块能够关注相关区域，并捕获更多的信息特性。 ​
大量实验表明，我们的模型在综合基准上取得了持续改进的结果。</p>
<p>【类似于DCN对于普通卷积的改进思想】</p>
<h2 id="研究背景">3、研究背景：</h2>
<p>​
Transformer最初是为了解决自然语言处理任务而引入的。近年来，它在计算机视觉领域显示出巨大的潜力。Vision
Transformer
(ViT)这项开创性的工作，将多个Transformer块堆叠起来，以处理不重叠的图像patches序列，从而产生用于图像分类的无卷积模型。与CNN模型相比，基于transformer的模型具有更大的接受域，擅长建模远程依赖关系，在大量训练数据和模型参数的情况下具有更优越的性能。</p>
<p>​ 然而，在视觉识别中过多的注意力是一把双刃剑，存在着多方面的弊端。</p>
<p>​
具体来说，如果每个查询patch要参与的Key数过多，会导致计算成本高、收敛速度慢，并增加过拟合的风险。为了避免过度的注意力计算，现有的研究都利用精心设计的高效注意力模式来降低计算复杂度。其中以Swin
Transformer和金字塔视觉转换器(PVT)作为两个最经典的方式。</p>
<p>​
理想情况下，我们期望对于一个给定Query而言，Key和Value的选择应该是具有弹性的，这样才能避免因为人工指定的稀疏注意模式中存在的问题。</p>
<p>​
事实上，在cnn的文献中，学习卷积滤波器的可变形感受野已被证明可以有效地在数据依赖的基础上选择性地关注更有信息的区域，也就是DCN变形卷积。</p>
<p>​
CNN中DCN的思想如果直接应用在SelfAttention机制中，会导致不合理的高内存/计算复杂度。由可变形偏移引入的开销是Patches数量的二次方。
​
因此，尽管最近的一些工作研究了Transformer中的变形机制的思想，但由于计算成本高，它们都没有将其作为构建像DCN这样强大的骨干网络的基本构件。它们的变形机制要么被用于Head网络中，要么作为预处理层对后续骨干网络中的Patches进行采样。</p>
<h2 id="先前工作描述与比较">4、先前工作描述与比较：</h2>
<p>​ 暂略</p>
<h2 id="主要设计思想">5、主要设计思想：</h2>
<p>​
基于上述研究背景，该论文提出了一个简单高效的可变形自我注意模块，并通过该模块构造了一个强大的金字塔形式的骨干网络，名为Deformable
Attention Transformer(DAT)，用于图像分类和各种密集预测任务。 ​
与DCN学习整个feature
map中不同像素的不同偏移量不同，论文提出的方法基于这样一个思想：对于不同的查询，全局attention通常会导致对于不同的Query来说，都是近乎相同的attention模式。于是论文提出，网络通过学习几组与Query无关的偏移量，将键和值移到重要区域。</p>
<p>​ 该设计既具有线性空间复杂性，又引入了变形的注意模式。</p>
<p>​ 具体来说，对于每个注意力模块：</p>
<ul>
<li>参考点首先作为统一的网格生成，这些网格在输入数据中是相同的。</li>
<li>然后，一个offset网络以query特征为输入，生成所有参考点对应的偏移量。</li>
<li>通过这种方式，候选 键/值
向重要区域转移，从而使原来的self-attention模块具有更高的灵活性和效率，从而捕捉到更多的信息特征。</li>
</ul>
<h2 id="具体方法与网络架构">6、具体方法与网络架构：</h2>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220425194741367.png" /></p>
<p>​ 现有的ViT，特别是PVT和Swin
Transformer试图解决过度关注的挑战。前者的下采样技术会导致严重的信息丢失，而后者的滑动窗口注意力会导致接收域的缓慢增长，这限制了对大对象建模的潜力。
​
因此，需要一种与数据相关的稀疏Attention机制来灵活地建模相关特征，这导致DCN中首次提出了可变形机制。</p>
<p>​
然而，在Transformer模型中简单地实现DCN并不是一个微不足道的问题。在DCN中，feature
map上的每个元素单独学习其偏移量，其中在<span class="math inline">\(H
\times W \times C\)</span> 的特征图上的<span class="math inline">\(3
\times 3\)</span>可变形卷积的空间复杂度为<span class="math inline">\(9
\times H \times W \times
C\)</span>。如果我们直接在Attention模块中应用同样的机制，空间复杂度将急剧上升到<span
class="math inline">\(N_qN_kC\)</span>，其中<span
class="math inline">\(N_q,N_k\)</span>为Query和Key的数量，通常与特征图的size：<span
class="math inline">\(HW\)</span>具有相同的比例，带来近似双二次复杂度。</p>
<h4 id="核心机制1-deformable-attention">1）核心机制1： Deformable
Attention</h4>
<p>​ 具体来说，我们提出了
在特征图中重要区域的指导下，使用可变形Attention来有效地建模tokens之间的关系。
​
这些被视为重要的区域是由偏移网络从查询中学习到的多组变形采样点来确定的。
我们对特征图中的sample特征应用双线性差值，然后在将插值后的特征送入Key和Value的映射矩阵中，得到变形后的Key和Value。
​
最后，应用标准的多头注意力机制对采样点Key进行查询，并从变形的Value中聚合特征。
​此外，变形点的位置提供了一个更强大的相对位置偏差，以促进Deformable
Attention的学习。这个会在第二个核心机制中讨论。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220425201030829.png" /></p>
<ul>
<li><p><strong>Input:</strong> 特征图: <span class="math inline">\(x \in
R^{H \times W \times C}\)</span></p></li>
<li><p><strong>Step1:</strong>
根据特征图建立全局的网格参考点，网格的尺寸是由输入特征图依据因子r下采样得到的。网格
<span class="math inline">\(p \in R^{H_G \times W_G \times C}\)</span>,
<span class="math inline">\(H_G = H /r , W_G = W /r\)</span></p></li>
<li><p><strong>Step2:</strong> 参考点的值为网格的线性二维坐标：<span
class="math inline">\(\{
(0,0),……,(H_G-1,W_G-1)\}\)</span>，我们将这些值根据网格的大小Normalize归一化到[-1,+1]之间。(-1,-1)代表最左上角的网格点，(+1,+1)代表最右下角的网格点。</p></li>
<li><p><strong>Step3:</strong>
为了获得每个参考点的偏移量Offset，特征图通过映射矩阵<span
class="math inline">\(W_q\)</span>得到<span
class="math inline">\(q\)</span>，然后将<span
class="math inline">\(q\)</span>喂入一个轻量级的子网络<span
class="math inline">\(\theta_{offset}\)</span>中，得到每个Q的Offsets。</p>
<p>（注：为了稳定训练过程，我们将网格点p的振幅用一些预定义的因素s来缩放以防止过大的偏移，具体公式如下：使用<span
class="math inline">\(s\times tanh(offset_p)\)</span> 代替 <span
class="math inline">\(offset_p\)</span></p></li>
<li><p><strong>Step4:</strong>
将Step2得到的参考点值和Step3得到的Offset相加，得到变形后的网格参考点Deformed
Points。</p></li>
<li><p><strong>Step5:
</strong>在变形后的网格参考点的位置进行特征采样，使用Bilinear
Interpolation作为采样函数<span
class="math inline">\(\phi\)</span>，将采样后的变形特征作为Key和Value，然后经过投影矩阵<span
class="math inline">\(W_v\)</span>和<span
class="math inline">\(W_k\)</span>，得到<span class="math inline">\(\hat
v\)</span>和<span class="math inline">\(\hat k\)</span>。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220425202601636.png" style="zoom:67%;" /></p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220425202654922.png" style="zoom: 67%;" /></p>
<p><span class="math inline">\(g(a,b) = max(0,1-|a-b|)\)</span>，<span
class="math inline">\((r_x,r_y)\)</span>代表z上所有的位置索引。</p>
<p>​
因为函数g使得只有在4个最接近(px,py)的点上才会是非零，所以可以将等式(8)简化为4个位置的加权平均值</p></li>
<li><p><strong>Step6</strong>:</p>
<p>​
对q,k,v应用相对位置偏差编码R，然后再经过经典的多头注意力层。单层的输出如下：最后，每个head输出的特征拼接在一起，然后经过Wo进行投影，得到最终输出。<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220426100345837.png" style="zoom:67%;" /></p></li>
</ul>
<h4 id="核心机制2offset-generation">2）核心机制2：Offset Generation</h4>
<p>​
先前说道，Offset使用一个子网络进行生成，这个自网络接受Query特征，然后输出参考点的偏移值。考虑到每个参考点覆盖了一个局部的<span
class="math inline">\(s \times
s\)</span>的区域，为了学习到合理的偏移量，生成网络还需要对局部特征进行感知。因此，具体做法如下：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220426100823173.png" style="zoom: 67%;" /></p>
<p>​ 输入特征先通过 一个 <span class="math inline">\(5\times
5\)</span>的depthwise卷积层，来捕获局部特征。然后，应用GELU激活层，以及<span
class="math inline">\(1\times1\)</span>的卷积层。注意：我们没有使用<span
class="math inline">\(1\times1\)</span>的卷积层中的Bias，是为了避免所有位置的强制位移。</p>
<p>其中：<strong>模仿MHSA设计了Offset Group的机制：</strong></p>
<p>​ 为了提高变形参考点的多样性，我们遵循MHSA（MultiHead Self
Attention）中类似的范式，将特征通道划分为G组。 ​
每个组的特征使用共享的子网络参数分别产生相应的偏移量。
在实际操作中，注意模块的Head数：M，将会是OffsetGroup中Group数：G的数倍，以确保多个注意头能被分配给一组变形Key和Value。</p>
<h4 id="核心机制3-deformable-relative-position-bias">3）核心机制3：
Deformable Relative Position Bias</h4>
<p>​
相对位置偏差对每对查询和键之间的相对位置进行编码，用空间信息来增加普遍的注意。考虑一个<span
class="math inline">\(H \times
W\)</span>的特征图，相对位置偏差应该在<span
class="math inline">\([-H,H]和[-W,W]\)</span>间。</p>
<p>​
因为我们的可变形的注意力，有keys的连续位置，我们在正则化的范围内计算位置偏差，即在<span
class="math inline">\([-1,+1]\)</span>之间。然后，我们对Swin
Transformer中的 BiasTable 应用插值函数，来覆盖所有可能的offset值。</p>
]]></content>
      <categories>
        <category>③  论文阅读笔记</category>
        <category>CV相关论文</category>
      </categories>
      <tags>
        <tag>Transformer</tag>
      </tags>
  </entry>
  <entry>
    <title>论文略读笔记——CVPR2022 Transformer相关（1）</title>
    <url>/2022/04/22/1076c1e77e53/</url>
    <content><![CDATA[<h2
id="一论文名称batchformer-learning-to-explore-sample-relationships-for-robust-representation-learning">一、论文名称：《BatchFormer:
Learning to Explore Sample Relationships for Robust Representation
Learning》</h2>
<p>论文地址： https://arxiv.org/abs/2203.01522</p>
<h4 id="关键词">1、关键词：</h4>
<p>​ deep representation learning 深度表征学习</p>
<h4 id="摘要">2、摘要：</h4>
<p>​
尽管深度神经网络取得了成功，但由于数据不平衡、不可见分布、域漂移等数据稀缺问题，深度表征学习仍面临许多挑战。为了解决上述问题，已经设计了各种方法以一种普通的方式(即从输入函数或损失函数的角度)探索样本关系，但未能探索具有样本关系学习的深度神经网络的内部结构。受此启发，<strong>我们建议使深度神经网络本身具有从每个小批中学习样本间关系的能力。</strong></p>
<p>​
<strong>我们引入了一个模块BatchFormer，然后将其应用到每个mini-batch的batch维度上，以隐式地探索训练期间的样本间关系。通过这样做，所提出的方法可以实现不同样本之间的协作，例如，头类样本也可以有助于尾类的学习以进行长尾识别。</strong></p>
<p>​
<strong>此外，为了减少训练和测试之间的差距，我们在训练过程中使用或不使用BatchFormer共享分类器，从而可以在测试过程中删除。</strong></p>
<h4 id="主要设计思想">3、主要设计思想：</h4>
<p>​
我们引入了一个模块BatchFormer，然后将其应用到每个mini-batch的batch维度上，以隐式地探索训练期间的样本间关系。</p>
<p>​
对于深度神经网络来说，由于训练和推理的差距，在批处理维度上进行学习并不容易。因此，为了探索用于鲁棒表示学习的样本关系，我们建议通过样本关系学习的结构改进来增强深度神经网络。</p>
<p>​
<strong>具体来说，我们试图通过在批维度中引入一个Transformer来捕获和建模每个小批训练数据样本中的样本关系，此外，为了减少训练和测试之间的差距，我们在BatchFormer模块之前和之后使用一个共享分类器来强制批不变学习。这样，BatchFormer模块只在训练过程中需要使用，即不需要改变深度神经网络的推理结构。</strong></p>
<p>​
从优化的角度来看，BatchFormer实现了小批量样本所有特征的信息传播。</p>
<p>​
因此，所有的样本都可以帮助学习任何类别的对象，而这可能会从整个小批量中含蓄地用幻觉特征丰富当前的训练样本</p>
<h4 id="具体方法与网络架构">4、具体方法与网络架构：</h4>
<p>​
设计了一个简单而有效的模块，称为BatchFormer，这是一个即插即用模块，用于探索每个小批中的样本关系.</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220422091934114.png" /></p>
<p>​
具体来说，骨干网首先用来学习单个数据样本的表示，即在每个小批量中，不同样本之间不存在交互。在此之后，我们引入了一个新的模块，利用Transformer中的交叉注意机制对不同样本之间的关系进行建模，我们将其称为Batch
transformer或BatchFormer模块。然后，BatchFormer的输出被用作最终分类器的输入。</p>
<p>​
为了满足训练和测试之间的差距，我们还在BatchFormer模块之前使用了一个辅助分类器，<strong>即通过共享最终分类器和辅助分类器之间的权值，</strong>我们可以将从样本关系中学习到的知识转移到骨干和辅助分类器。
因此，在测试时我们可以去掉BatchFormer，直接使用辅助分类器进行分类。</p>
<p>​ 多头注意层已被广泛用于从Channel和Spatial维度建模关系</p>
<p>​
<strong>因此，我们认为它也可以被扩展以探索Batch维度中的关系。因此，与变压器层的典型使用不同，BatchFormer的输入将首先被重构，以使变压器层能够处理输入数据的批处理维度。</strong>
​
通过这样做，变压器层中的自我注意机制就变成了BatchFormer不同样本之间的交叉注意。</p>
<ul>
<li>测试时的差别：
<ul>
<li>由于我们不能为测试假定批处理统计信息，例如样本关系，因此在BatchFormer模块之前和之后的特性之间可能存在差距。</li>
<li>因此，除了最终的分类器，我们还引入了一个新的辅助分类器，既可以学习最终的分类器，又可以保持BatchFormer之前的特征。</li>
<li>为了实现这一点，我们只需在辅助分类器和最终分类器之间共享参数/权重。
我们将这种简单而有效的策略称为“共享分类器”。
有了提议的“共享分类器”，我们可以在测试期间删除BatchFormer模块，同时仍然受益于使用BatchFormer的示例关系学习。</li>
</ul></li>
<li><img
src="C:\Users\14012\AppData\Roaming\Typora\typora-user-images\image-20220422093222300.png" /></li>
</ul>
<h4 id="梯度传播过程及视角">5、梯度传播过程及视角：</h4>
<p>​ <img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220422093240599.png" /></p>
<p>​
直观上，没有BatchFormer，所有损失只传播梯度在相应的样本和类别。与其他示例相比，BatchFormer(虚线)具有梯度，如图所示。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220422093454357.png" /></p>
<p>​ 从梯度优化的角度来看，Li还根据样本Xj(j !=
i)对网络进行了优化，这与没有BatchFormer的模型有显著的差异。换句话说，Xj(j
!= i)可以看作yi的一个虚拟样本，其中yi是Xi的标签。</p>
<p>​ 我们认为BatchFormer和Mixup都可以看作是数据依赖的扩充。</p>
<p>​
BatchFormer隐式地通过交叉注意模块从样本的附近分布中提取虚拟示例。</p>
<p>​
从这个角度来看，BatchFormer通过小批量样品之间的关系建模，隐式增加了每个标签yi的N
- 1虚拟样本。</p>
<h2
id="二论文名称beyond-fixation-dynamic-window-visual-transformer">二、论文名称：《Beyond
Fixation: Dynamic Window Visual Transformer》</h2>
<p>论文地址：https://arxiv.org/abs/2203.12856</p>
<h4 id="关键词-1">1、关键词：</h4>
<p>​ Dynamic Window</p>
<h4 id="摘要-1">2、摘要：</h4>
<p>​
近年来，人们对视觉变压器的兴趣越来越大，主要是通过将自我注意的计算限制在局部窗口来降低计算成本。目前大多数工作默认使用固定的单尺度窗口进行建模，忽略了窗口大小对模型性能的影响。然而，这可能会限制这些基于窗口的模型对多尺度信息的建模潜力。</p>
<p>​
<strong>使用动态多尺度窗口来探索窗口设置对模型性能影响的上限。在DW-ViT中，通过将不同大小的窗口分配给不同的WMSA来获得多尺度信息。然后，通过对多尺度窗口分支分配不同的权重来动态融合信息。</strong></p>
<h4 id="主要设计思想-1">3、主要设计思想：</h4>
<p>​
Swin提出将自我注意的计算限制在局部窗口，以降低计算复杂度，并取得了一定的效果。这种局部窗口自我注意很快吸引了大量的注意.然而，大多数这些方法默认使用固定的单尺度窗口(例如，win
= 7)。 ​ 以下问题随之产生:</p>
<ul>
<li>这个窗口大小是最佳的吗?</li>
<li>更大的窗口意味着更好的性能吗?</li>
<li>多尺度窗口是否比单尺度窗口更有优势?</li>
<li>此外，动态多尺度窗口会产生更好的结果吗?</li>
</ul>
<p>作者实验后得出：</p>
<p>​
<strong>随着窗口大小的增加，模型的性能得到了显著的提高，但这并不是绝对单调的。此外，很难从多个可选窗口大小中选择最佳窗口大小。而不同图层的最佳窗口设置也可能不同。一个自然的想法是将来自不同规模窗口的信息混合用于预测任务。</strong></p>
<p>​
基于这一思想，我们设计了一种基于窗口的ViT的多尺度窗口多头自关注(MSW-MSA)机制。</p>
<p>​
<strong>在DW-ViT中，我们首先通过给变压器中多头自注意的不同头组分配不同的尺度窗口来获得多尺度信息。然后，通过对多尺度窗口分支分配权重，实现信息的动态融合。具体来说，在DW-ViT中，MSW-MSA负责多尺度窗口信息的提取，而DMSW负责这些多尺度信息的动态增强。通过以上两部分，DW-ViT可以动态地提高模型的多尺度信息建模能力，同时保证相对较低的计算复杂度。</strong></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220422095955551.png" /></p>
<h4 id="具体方法与网络架构-1">4、具体方法与网络架构：</h4>
<p>​ <img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220422100027793.png"
alt="DW-ViT网络结构图" /></p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220422100222424.png" alt="DWM模块示意图" style="zoom:150%;" /></p>
<p>​
如图5所示，我们设计的多尺度窗口自关注模块主要由两部分组成:多尺度窗口多头自关注模块(MSW-MSA)和动态多尺度窗口模块(DMSW)。</p>
<h5 id="msw-msa模块">1） MSW-MSA模块</h5>
<p>​
将MSA的多头h均匀分成nwin组，在不同尺度的窗口上进行多头自我注意，获取多尺度窗口信息。</p>
<p>​ 将每个窗口展开为一个长度为wini ×
wini的令牌序列，作为MSW-MSA的第i支W-MSA 的输入。</p>
<p>​ 将W- msa的输出在空间维数上重构为H × W，最终输出维数为H × W ×
Cnwin。</p>
<p>​
最后这些分支的输出在通道维度上被连接起来，并用作整个MSW-MSA模块的输出。</p>
<h5 id="dmsw模块">2） DMSW模块：</h5>
<p>​
这个过程分为两个主要步骤:Fuse和Select。前者负责整合所有分支的信息，后者根据全局信息为每个分支生成相应的权值，完成分支信息的融合。</p>
<ul>
<li>Fuse主要由池化层<span class="math inline">\(F_{gp}\)</span> 和
两对全连接层<span class="math inline">\(F_{fc}\)</span> 和 激活层<span
class="math inline">\(F_a\)</span>组成。</li>
<li>Select 主要由两部分组成：
<ul>
<li>第一部分由一组全连通层<span class="math inline">\(F_{\alpha} =
\{F_{\alpha_i},i=1,2,……,n_{win}\}\)</span>
和softmax层为每个分支生成相应的权值</li>
<li>第二部分包含两个线性映射层<span
class="math inline">\(F_{fc}\)</span>，用于恢复融合特征的通道维数。</li>
</ul></li>
<li>最终还有一个Res的过程</li>
</ul>
<h3
id="三论文名称mixformer-mixing-features-across-windows-and-dimensions">三、论文名称：《MixFormer:
Mixing Features across Windows and Dimensions》</h3>
<p>论文地址：https://arxiv.org/abs/2204.02557</p>
<h4 id="关键词-2">1、关键词：</h4>
<p>​ Mix</p>
<h4 id="摘要-2">2、摘要：</h4>
<p>​
局部窗口自我注意在视觉任务中表现突出，<strong>但存在接收野有限和建模能力弱的问题。</strong>这主要是因为它在非重叠窗口中执行自我注意，并在通道维度上共享权重。
​
我们提出的MixFormer找到一个解决方案。首先，我们将局部窗口自关注与深度卷积并行设计，建模跨窗口连接，以扩大接收域。其次，我们提出跨分支的双向交互，以在渠道和空间维度上提供互补的线索。
​这两种设计集成在一起，以实现窗口和尺寸之间的高效特征混合。</p>
<h4 id="主要设计思想-2">3、主要设计思想：</h4>
<p>​
我们提出了混合块。首先，我们将局部窗口自关注与深度卷积相结合，但以并行的方式。并行设计通过同时模拟窗口内和窗口间的关系来扩大接收域。其次，我们引入跨分支的双向交互(如图1中的蓝色箭头所示)。这些交互抵消了权重共享机制造成的限制，通过为局部窗口自关注和深度卷积提供互补线索，增强了通道维和空间维的建模能力。综合以上设计，实现窗口和尺寸之间的互补特征混合。</p>
<p>​</p>
<h4 id="具体方法与网络架构-2">4、具体方法与网络架构：</h4>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220422205646202.png" /></p>
<p>​ 我们的混合块(图1)在标准的基于窗口的注意块上增加了两个关键设计:</p>
<ul>
<li><ol type="1">
<li>采用并行设计，将局部窗口自我注意和深度卷积结合起来</li>
</ol></li>
<li>(2)引入跨分支的双向交互。用于解决 局部窗口自我注意中
有限的接受域和薄弱的建模能力 的问题。</li>
</ul>
<h5 id="并行设计">1 并行设计</h5>
<p>​
虽然在非重叠窗口内执行自我注意可以提高计算效率，但由于没有提取跨窗口连接，它会导致有限的接收域。考虑到<strong>卷积层是用来模拟局部关系的，我们选择了一种有效的方法(深度卷积)来连接窗口。</strong></p>
<p>​
在本文中，我们提出了一种并行设计，通过同时建模窗口内和窗口间关系来扩大接收野</p>
<p>​
如图1所示，局部窗口自关注和深度卷积位于两条平行路径上。具体来说，它们使用不同的窗口大小。
本地窗口自我注意采用7 ×
7窗口，遵循前人的工作，而在深度卷积中，考虑到效率，采用了一个较小的核大小3
x 3。</p>
<p>​ 它们的输出被不同的归一化层[1,27]归一化，并通过拼接进行合并。 ​
合并后的特征被发送到后续的前馈网络(FFN)，跨信道混合学习到的关系，生成最终的输出特征。</p>
<p><strong>好处</strong>：
首先，将局部窗口的自我关注与跨分支的深度卷积结合起来，建模跨窗口的连接，解决有限的接受域问题。其次，并行设计同时建模窗口内和窗口间的关系，为跨分支的特征交织提供机会，并实现更好的特征表示学习。</p>
<h5 id="双向交互">2 双向交互</h5>
<p>​
通常，共享权值限制了共享维度上的建模能力。解决这一困境的常见方法是生成与数据相关的权重，就像在动态网络中所做的那样。局部窗口自关注在空间维度上动态计算权值，同时跨Channel
共享权值，导致在Channel 维度上建模能力弱。</p>
<p>​ 为了提高局部窗口自关注在 Channel
维度上的建模能力，我们尝试生成基于Channel 的动态权值。
考虑到深度卷积在关注Channel
的同时，在Spatial维度上共享权重,它可以为局部窗口的自我注意提供补充线索，反之亦然。因此，我们提出了双向交互(如图1和图2所示)，以增强在Channel和Spatial维度上对局部窗口自我关注和的建模能力。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220422210802291.png" /></p>
<h5 id="channel交互设计">Channel交互设计</h5>
<p>​
对于通道交互，我们遵循SE层[24]的设计，如图2所示。通道交互包括一个全局平均池化层，然后是两个连续的1X1卷积层，它们之间有归一化(BN[27])和激活(GELU[20])。
​
最后，我们在C维度上使用sigmoid来产生注意。虽然我们的通道交互与SE层[24]具有相同的设计，但它们在两个方面有所不同:</p>
<p>（1）注意模块的输入不同。我们的通道交互的输入来自另一个并行分支，而SE层在同一个分支中执行。
（2）我们只将通道交互应用于local window
self-attention中的值，而不是像SE层那样将其应用于模块的输出。</p>
<h5 id="spatial交互设计">Spatial交互设计</h5>
<p>​ 我们还采用了一种简单的设计，它由两个1 X
1卷积层组成，其次是BN[27]和GELU[20]。 ​
这两层将通道的数量减少到一个。最后，采用sigmoid层生成空间注意图。与我们在通道交互中所做的一样，空间注意是由另一个分支产生的，其中应用了本地窗口自我注意模块。
​它比深度3 X 3卷积具有更大的核大小(7 X
7)，并且侧重于空间维度，为深度卷积分支提供了强有力的空间线索。</p>
]]></content>
      <categories>
        <category>③  论文阅读笔记</category>
        <category>CV相关论文</category>
      </categories>
      <tags>
        <tag>CVPR2022</tag>
        <tag>Transformer</tag>
      </tags>
  </entry>
  <entry>
    <title>2.3.2 经典问题（生产者-消费者等）</title>
    <url>/2022/04/15/ef402168a5bd/</url>
    <content><![CDATA[<p>笔记课程视频：https://www.bilibili.com/video/BV1YE411D7nH?p=19</p>
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>2.3.1 进程同步与进程互斥及信号量机制</title>
    <url>/2022/04/13/c34143b1b4b5/</url>
    <content><![CDATA[<p>笔记课程视频：https://www.bilibili.com/video/BV1YE411D7nH?p=18</p>
<h3 id="一进程同步与进程互斥">一、进程同步与进程互斥</h3>
<h4 id="进程同步">1、进程同步</h4>
<p>​
同步亦称<strong>直接制约关系</strong>，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p>
<p>​ 例如：必须按照写进程然后再读进程的数据进行。</p>
<h4 id="进程互斥">2、进程互斥</h4>
<p>​
我们把一个时间段内只允许一个进程使用的资源称为临界资源。多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</p>
<p>​
对临界资源的访问，<strong>必须互斥地进行。</strong>互斥，亦称<strong>间接制约关系</strong>。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</p>
<h4 id="对临界资源的互斥访问">3、对临界资源的互斥访问：</h4>
<p>在逻辑上分为4个部分：</p>
<ul>
<li>进入区
<ul>
<li>负责检查是否可进入临界区，若可进入，则应设置正在访问临界资源的标志（可理解为“上锁”），以阻止其他进程同时进入临界区</li>
</ul></li>
<li>临界区
<ul>
<li>访问临界资源的那段代码</li>
</ul></li>
<li>退出区
<ul>
<li>负责解除正在访问临界资源的标志（可理解为“解销”）</li>
</ul></li>
<li>剩余区
<ul>
<li>做其他处理</li>
</ul></li>
</ul>
<h4 id="进程互斥需要遵循的原则">4、进程互斥需要遵循的原则：</h4>
<p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：</p>
<p>​
1.空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</p>
<p>​
2.忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</p>
<p>​
3.有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；</p>
<p>​
4.让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</p>
<h3 id="二进程互斥的软件实现方法">二、进程互斥的软件实现方法：</h3>
<h4 id="单标志法">1、单标志法：</h4>
<p>​
<strong>算法思想：</strong>两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412173137552.png" /></p>
<ul>
<li>这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是Po，而PO一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问。</li>
<li><strong>因此，单标志法存在的主要问题是：违背“空闲让进”原则。</strong></li>
</ul>
<h4 id="双标志先检查法">2、双标志先检查法</h4>
<p>​</p>
<h4 id="双标志后检查法">3、双标志后检查法</h4>
<h4 id="peterson算法">4、Peterson算法</h4>
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>Java绘图机制与事件处理机制</title>
    <url>/2022/04/01/9d060fe0d5ae/</url>
    <content><![CDATA[<h4 id="一绘图机制">一、绘图机制：</h4>
<p>​ 面板 JPanel 和 窗口 JFrame</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPanel</span> <span class="keyword">extends</span> <span class="title class_">JPanel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">(Graphics g)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>.paint(g);</span><br><span class="line">        g.drawOval(<span class="number">10</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当JFrame窗口最大化、最小化、尺寸发生变化时都会重新调用paint函数</span></span><br><span class="line"><span class="comment">//当调用repaint函数时，会重新调用paint函数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawMap</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">MyPanel</span> <span class="variable">myPanel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyPanel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">drawMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DrawMap</span>();</span><br><span class="line">        drawMap.DrawCircle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">DrawCircle</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//把面板放到窗口内</span></span><br><span class="line">        <span class="built_in">this</span>.add(myPanel);</span><br><span class="line">        <span class="comment">//设置窗口的大小</span></span><br><span class="line">        <span class="built_in">this</span>.setSize(<span class="number">400</span>,<span class="number">300</span>);</span><br><span class="line">        <span class="built_in">this</span>.setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二事件处理机制">二、事件处理机制：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameMap</span> <span class="keyword">extends</span> <span class="title class_">JPanel</span> <span class="keyword">implements</span> <span class="title class_">KeyListener</span> &#123;</span><br><span class="line">	<span class="comment">//某个类实现了KeyListener接口，其需要实现三个接口</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keyTyped</span><span class="params">(KeyEvent e)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keyPressed</span><span class="params">(KeyEvent e)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keyReleased</span><span class="params">(KeyEvent e)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给JFrame类添加事件监听器即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TankGameWindow</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">GameMap</span> <span class="variable">gameMap</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TankGameWindow</span><span class="params">()</span>&#123;</span><br><span class="line">        gameMap = <span class="keyword">new</span> <span class="title class_">GameMap</span>();</span><br><span class="line">        <span class="built_in">this</span>.add(gameMap);</span><br><span class="line">        <span class="built_in">this</span>.setSize(<span class="number">1000</span>,<span class="number">750</span>);</span><br><span class="line">        <span class="built_in">this</span>.addKeyListener(gameMap);</span><br><span class="line">        <span class="built_in">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        <span class="built_in">this</span>.setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>几个重要概念：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220809163829929.png" style="zoom:67%;" /></p>
<ul>
<li>事件源：产生事件的对象，比如按钮、窗口</li>
<li>事件：承载 事件源
状态改变时的对象，比如KeyEvent、MouseEvent对象等等</li>
<li>事件监听接口：
<ul>
<li>（1）当事件源产生一个事件，可以传送给事件监听者处理</li>
<li>（2）事件监听者实际上就是一个类，该类实现了某个事件监听器接口。比如上述实现了KeyListener接口的GameMap类，它就可以作为一个事件监听者，对接受到的事件进行处理</li>
<li>（3）事件监听器接口有多种，不同的事件监听器接口可以监听不同的事件，<strong>一个类可以实现多个监听接口。</strong></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>①  项目笔记</category>
        <category>java项目</category>
      </categories>
      <tags>
        <tag>JPanel</tag>
      </tags>
  </entry>
  <entry>
    <title>字体生成论文研究进度</title>
    <url>/2022/04/01/f225f383e158/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="f490f6d4eff128b6f8c23e395e0b13f44dd14e197fc50f16d44b6fec836d5931">1557a4d06c41b8b7cb942a6d0525c027cbeeadc10caf98a45705387558304bb469290ed727bac22c14368bef657fb469dfaa63f24918c0cff3b2760cd4c7e41d903d1a82d66af59312cac4cac46cf8eb876b40a6bca879a6bb5005f2de6cb7700621bad9f290d26f23d98ad7d10aad36bec4e6306e0626ed5b58ff9d6c87b6b9fb9358b7c8663eb4e3f6b73813f33f206cb37ad8174d4a8dec552525d1b17d29a7ff9a69af1c0464d7be2cd47663a8511470a8a9ecf52a3eea3d24def5ef2b867aabfebd01f658d97f48cb62241de8f7a8c19ea8bc92d6c680ec59bc38b048d425d487212984d3aa9277e8bafa990fdb34d8a30bc941854858dcbd2c49e5f28f21e8ba546f2f0da3365f940432813ee29c950135eadb5b7ed325594771d8ec8a9d1f3ad8cf5cc9eae23197303a55f47176df2e97551922502deccc82ba3a0d0fa712a9261862f2788aace95a046bffc7cce1f66e50a2c6021f4cfc9cd90935fbb6ec3c290ffa4add6317fab63a83f5691b98f8d19efca83ec4ffbd8614b8e7ac3a4260a007377813591b13e3737b007a82ef659ab4845a4799af73318bfedd75e021f0cee0157996154ee0b0d89a5481f558e1ea747d3de2bffa3166672fac1271864c41d9dbc04032d309ab8a8324d0df005f78c8f05a18e52d005529009028238e2e96252ca2ef67df0c8bb09b9894362b07c22ed169e86ba234b046d063a31a0dc8f90ad0cd26dc956e5280d31639778338271930a6aa2a2a4fcc6fe161b45a9a85fd07125410a1633279d8c785ab1913ad30f45a18498b3fb2829dd6f067a17c541be12a01e37c08c82707915cbfb4e002bf5025e5d81f5fa08ce6bf18c3184420ff1921e17f4126b1f10ebc8e7395006f2a552f0c0c37ef4b17c2138b950e4574c440a94e9bd4e400277723250738f15e2d9bbf5e2116f22848e8102dc33ac5d504f10f4a7f3d18f2687064f51f963e819f143fdf829a9d4db46e025d1d774c60ec1e91eca7e55241e8fe4fb65bb309cfa0f612aa9422a90d9ac32ece2d4ba42db909f0efd04c39637eb5e351870d5f1d12e57dda4f141f9f11058392e3f5f378451f43884cceaf6e78ec090bbf3eaf9f919ecc6d0d84b01f1be6501f387c8daacebaa9c608e9bcabc8790e3c1cb980add9e6fb12430856ede148fd91c08f7485709962926e803d404c3c7a7f38fd0ef69e9c4a32f491d49234a74432572a5090c296002c73df41a4ed7bcfd4bc6d23ba76427aa950f5128a0455186d99b9a09cf6789e31f76f8938a95d8e861be3b1f051b1af3a674a08677aa18071301825dcfb11697eae002fa97923a9ee69ad49ab4b3ba810ade6c531b4a79f4c0befa976492d07ded5cb76ace66549c6c40f7e4927fe047273209af3269d43d4905b4c271ce055d131103b7bc6bb7fe95d94f338b1e2a31a90e512eb78fbfe8469b69718a88307a747af389488f2d91fd56813772a3e6c47de32f4ae1e0fe965f791663fa3173d62c91644df73790f4ff69fba0170822a1ef6cb002f7e2a1179ec3c6ac8fb8f138ad559c2ffb4938d0a710d78d62ebb23944ae7255d6a6a3eecf42d65a95f6adb81f85952df61009dfc7477c9fe7228478a902c5fc3ddcb883dd4975a19f59ad4bf0b1ef764536efeecc05dcf770806e90809f6698e4575294da06eb572d6c224c03a0711d84ed672dde635e459697ba656dac1ba45a831f42bb618e0b8fec82eb048869dc25e32748d1cbd62069b10b52ea4a07640142bb989a33eadf9672c17a80e88328d20704a54fc7a2714c339717b286d7981e643ec7d4b6cc15c2e071390341a281de9143f1e24a1ba629221a707b69c80a2ca9f094c7d9ac03335d7e218eefe70f727e2722b8fb97393e0f9a6353fdb707beafa0f757512e806cc385fdcbb7a6bad6d0dde17bf69fe942694ead75e3fef7d1128d59bba906687e0fa41d2c5adda355b8beaab883286c47ad6a7935b4d036c683a27e003c07a6c671a4b5bf4ab53186d38e6b33062a44d06bad09cbc1fabe988b57e55f879cfc52a48a3122b85aa3cbdeb48fcdaaf94296cbc36c01e36baa2fe7f949bef7d33fa5ef3c4d389b202f0838b69bc5d0ed3f1394795785c66cd0a747454f5a1399b9d92c8f99a77cf57d076a26926921ff5c8197a4a885243cb34ce767b60e9f245801b12f26031a04fe4328d2797c2cf89401fd2175cd14c67aabbbd136babd04d29aa82d8ca0d1cafe077dad0cdf3388733c9ee25d4b35b64bba9e08d8c8ba76794d1fdaeb04698e65ca41db67949d35d2c397123ffc1952a230ab01eaab37b123d12c3b4ea86e1a35148bdd509196a1b11b94f7abc212664e048b6973f6bb0017907e7efbb27541b4d2e1d716e04bc604babb71480d50734739670e3223ccbcaa4262d018c9b95d0a836dc8fd0671aa9adbc636dccdf1a9900c72273a3e1c515a4388028aeafc9a40c278ba0412abf4015a3b12974704e0a2fe7c3cbb7ec3fc4daf29c429127f91fc7b7f506a0270cbdd3c58b07a637ddabc02b9221ed0ea1c8f0810fdd468017f05a24345cd00a3ba386fa7b8c518d992cf3aaf8a79f19a2ed8608c07d06f753c99c9aa3aa3533cf953e77c7bf1a618e2f27312484a43e066ee4bfe2d466bc6f4f8edab0c0ef1dbbc67ac4567d0d0caba0d28016e3ed175c99760f18ef52da6b4439ce583a602f770519a0e5b51afadd40555fafaa5ce1fca1fcad4719415e24768a8f20e499df0ae6470725b9eff2620b05c9e6e9ea3f5ebaf0ce68f61a7d490055fe37751d95d68377ab85ebc1d0a7fd7b442cb6072ceb86c0924a05b543e812d2e8e4f356401d7159fc7a21ac96260f4ae955820bca21c4acb3fdae05d173dace8314e19951f6f124fe423f91024cdf37d0e204543a3091c59d33fbdbda6c8972ac935b64eaba4fd416b03c03ba1dc8c55b8c11ecbc13d7fe7d0291e791da4f296d6e1d88a9ac411003fac452f1b46d269896cebb2c509719309ff7709c2cd9af21c774e3c9f08fb35395b94b26425fb5e45bf3e2c8280650041dffadffb2c34c5ed0e524f1dc9aa40fce6e468410537ba94cee8bcfbcbf0353f5a762a834ee2bb5c0e9a5c4dd8c917a847435444d4f9d33079bb6734eb4a98e22ad71346eec0132955e314951125e75f7103b7c3ef355592ad38c19a7c315215ac4b8be62211e9de5861e2d1dcee6a51090401dcdcb4099624335e58169a57268cfcb4d2f41e1dfa88f39c75b1695c70ae4fd6050beb6302eebaeb6d6a803830336ee92e95d2ce4e7a8b9b7aa5dd47bb6407ad3e36950c100aede82aebf699f08f70b62e1dfa50b01396f2be85393aa07852c093d7b69fa4862ce0ef60329ec0fcd416de1b9d479d7aa332de7dc01b474368e84d60f39161fc67f2b07f61b04be956424c8e451dad46365faafb4465f8d451e62d3fe766dfb221f1a70980d5758f476eef24ac1f8d2caac580b408f2171575e698c2fd12e466fc7d45cb653cebf8799ceb658e0dbf40bef8edc696a809d141f2b75348d04bab8aa089ff4248f83fd0779926e912ad6c82f6b0af284bc2cd9e11b54b429c868e90c07e73a6bd619916c9bc2e327868dd10a301093aee43d806daf59c6b8e7043afcf7cfdd3fa7ae79aad1b622e9bfb108e3a455828c2c2fec2104101521cee7d2475a55000b6d5c22054c591774eb3aae62e1db8707002ee75677a33b1d7f7a885a97311eceff5ef2cbdd7698da1e3c2fac51c933f96209442681db84800ee1d89ea7377c46c09e7daac64a025245fa6a595caf6d1929c1327f6467cc213fb500a3f68a35122feeb20bac0a103e4796e5dfb8be3735404e07d57f21e1348fe0d9c33509a6478ae6633e103ca91feacf073a3205b225347e66865afc10a701835c36f32300e7161c2994ab08de939bd5de7ab73b941d19c5fd8c09dfbf691bc63d2170d6906b84a0a8db17e19f4773d9ca159bcaf99eb65437489c4e700eda4d245f560522c07562701efd7c8e2e32f45babe30163086d26d47b39ac7e85626c206bc4237dfac9429ed9a86ab5d003ac6f72a4aa60275fc0e48421d9bf4a463b12ee7f177c2e24daf3b328674371add4a53541779ba630c65e9f9fffb20ca8ce56971110d7754ac06047715efc3686d26fe48f012fd58124b6d6df9ec48cde85e88186377aac90aa5127e8f713f6184b71ee8e4a292937f16f080beaefe3361bd75f5c388f7a38e78fbd4b02e1b29801f11145f9de4d3dbbd7755c69b6eddd0fce30fc4340b92632823672bc9e1487f20b709951f45df5d16177c7c4650d0d1c515d6aff984b4971bc82d6ad77e51e75e825b58b5d11aa8a0b3dda15bb83f31fd2e4e7510de5430181fece3add3b5eeb4933b3c3a3791a741a9f722104336308b335786f9fbf9b3f723eca78ead99c66989a6d670c4f1b258f8ac919a7f94d4c363e02d0416a0ae22fefde72d4735d0b80b8e8aa83644987f13c80ecfabd0ed22fa069f7acb2a83a24cedfafccaf394b9cf4c9b03ac2feb7031632e9fbb30b940ba4a0e2de53004caab755c9534e723b4cc6bcc60e54ad911b442d8b9c9a4a8f6763a9f081243659b47a24cc6338390d23946ee0164b30967142610116332f56cde7db6f2daeacb12c30c038bdb5237f3f9c42eb7dd663fa087736f22fdf05080ffa45fe5fb9c615ae00bbf09eb2510eb373a699e5f5962547d949689862216c4192b6ae6031ef9fd3aa371e9ca9a3295689c25e5fb79b99d346f6da797d002e75b3cdc00c57575d223f34bf68f08e7ab2eb4008c979f6383c9d477fb9a3e1ab53d13a91daa2f19a38e9fc0e12aa2a5df9c22d78b22a889184f0401b192f826ce9310b8c68a5598971c12eeabbc295b4d4453de6831141f45d571f5921b3f85079746c5155d3a35cc42a5fe4cc6977e840d6be74b53319b045596bcf749eed8da82be7f1c6f936c5de1b23f465e90d214b69041f532bd1dd88a43c4fcaa3008bfe9851b718fdaefb3e13250e68eeffcf81db7d34bb8f70fb9ffa88dff8e16ab79f8e1034c067123bc9fb66d14d6bf46afe66a0f450d5423746e937ed07bca09c57ba91ec9c5e5815bc5c8a32ea1db6c302a35facfb8bdc6b862e71d65636cefa270d95fa347c9823be59a0c9417f60d2ed67b8785f856ea2d9e048aa7268902e11598fda3bcd39f52adbcd44e268390bcf9973cb8b944fd1960b577687c5b4e86a2997f3e619715e007d9ab31dd677c4281c664ce7b5469f06e28e856f22ef62cfe95302a40fe42a16f666796e4e770901f21d721d63638b9f45c2313e20e0ac139157d80cf580afa4496f20fe85fc426cf8705f4be4919090758c3325de703e9d0081bbf50d2afbe83543b93c195e07def8f34776d11fb0c756ef40ede73663a12368fb3f1c4e55421fa946b797d882d273274ba821d71a6f93ecbc03aed844915bcd8aafa216a4726adc56a755251d806f7f83c4206ecb932cf420e5cd7bc7389e6854c8b015d71cef2b8a40ab49c471299fb802ff6e9b7c8430a07d90a77a920d501a09e9caba863221e29cb1e7231949327e29e907636f3d157108f4908a12b026dce46a1da809d45fdbf270b59e184d8628df5ce958b3adba4fae387965e478bcbab63a1421b7df5754fc27b5cc14646264d4ddffb063828e7e25bfdf83c581d58dd74788773ca428698b5d6fd46262d2f02555a14bac6a4ee60dc727713b5f85ebec1d23910f39ea85feaa7b7e6ab13f9dab626ad218f027fe2b43c5cdcbf53f6898b644bf13cad3d3bd7c14656660f0d327c052f012871e9c6bf41dc8457653df9ffcb0c26a696a8feb3c0a9952ddd025cde585204166ad2669f91c6a0a937c8562585b9003924622f7d2bc317389dc3ddec19c8980cc2e59d821ddba53615f061d262678b7b7713f52ea40ef12e4fe0ee5a9a338d66d6440c50c7eb13379ac3580da2574dd9fab111273ee68c1ac56b598cefdb154c1c4e78e00a7aa82b317883a5a6e689fd071b734b6c482b1dcfb190de4819724acf30499c192fc908c5721072b908635d509a5966c399809329acc0727066ab852eb2db99af278c804b3a4548374accabe91274035d7f15d46f8f76b16f9c4ef167c24042490da7fe0d3f6ee446976b118279397627ed23d5995aad439f7f5e1993f3f15e9c8bace901a6f7dcd62075705385653bf17476b369618af5a94c9e290fca4bf9fa0562a616bd1f515a0935bb9f102fa600629d195e85c45e1dcafabc243e295665f510bcf862a1f34fe24ec7f66cc1c5ed3a1001f042b0860fea84e0ce9e4397137ee8c1d174224d2dbb1343b7e9073821e3f3d296d4bfe4f760447631f6c36cbe35bc3571687572ad714d350bc6a4d850c8b229534f643b18079ab04f609daac0d626a3469b6f53fb36e1bf6fb9edba4f7759ef47108820e61ad2139ac5abebe02d143aee1aac859eb14b85d626ee563148799fbe718038e042a0bcacdc9f807c537e0f4998f30cc0cf89fed226e07964fb29ce934ebdcec140b9f7b05cce7d5c6a607e1a3d4919e572fe58874552607440919d5a4fd88d4f86ceb9297396da5945c558c9f7750b7ec161461cec373dcc2eb32ff3f50fe7556d4fc76b343340e04602142bd528b3133cf43ad5b284f27b69689c539642382163e59cfde59a816e68d1d26cf9cd9a79ef7b8dc2a6d42a39d6c13aa76620da6740bfc9bec628108a357576b397ed1fca004a6f9d73290b1cdfcff2fc60089dc6142a45e1aeb49e8c816a368156e10179cec538ef0ae075c2cda37644f59134e259da190cd1faee883136451af3c09869c47bf92fc20082f249a45a51cd2e06828b6b19c0bf5cc9cd31513b0cf8550f4663290c29a34c3340779df57a029784e443d0d83ecbe9b02ae27ed3ac8348ffc2ad0d6eb84ad5d3ec25c86d633913847b92d670d868a64526ffd2515dc88537f490558d11204bb6f212dad15d4d5c03891c3ef00861e44296410cb23e7b1fc01348557ca64d87cc840ca74fba4cd07f1f412eb85bad3033cc3631f6cbf81d7667200003767784947a38d0351bbc85dd08f8bddcc992d3a10ca8abba0c0f7b152e2ea35ee4bb1484338037a29ff9e00bc8fc8fe91949c23f759849675f8e95e7eb777da28c3600d8c322dd3e1323dfe13deac921e38053436260001746a5f67dc92fa29ddd5c9b34a83cd12008bfe0f1f0e7757f8ffc768fc3c4a01d00df7367ae93915596b1a7415403f0e84274454d2930edb66a303bdb10fabf7be9a8d5c3642e80236b49c5119740896226fc7518bc198fad8be3b031a0237599f821a060d07c668ad23073c4ebea6329e640b073a571c2991666b63a79ff019570c2c0b14c6afc336d992349894cca1db80e46204756d7d301e86d66f682e0d899607c5afdd8631ca51c941c2dd71348da367cbee6386cb27ef982731c92a72cad6ed6199f49ef7d65da85999695783ee29bc427f93cf15646eb6ed8d453aa193591e32bd861e7fac62265993eb5c8087132e3d8bea229f066841bf3ede3015695e0216d17ae0eada638d28e11bb5f76fe0da18809bfe83f21061ddcaa3b9835a1fa16d8d5ab9441ec3bbd64b22b36581b15525100f79e86e2217ab24505168b6710f7b1c4680b76a769de32aa6306c19a721a83b6df9f6690a8b43d25f491110259de1717a01db232c8bd56b36b5985923d3f5682db9b484cee9432f32d75fe8425ea0aa476ece0986d3755dbd475f95b15600b6bdd18e414e865bd952ca7e9d1032b774d0f0613905c016f906371784e0e4d48b39a7068aeb70ef5cd5c30c86756ccd01bdfb1ef076a6e76bf46888cc6e7eab8f10f26139f9abfd2cdd3a08fae5db925df506c9b30d0e7f8d10845debf4e9bdd4c9617fead37bab5d6cdabfc86893a3e0fe373de13860318f5e711f87a5168b09b6b630f9babe385e34a4822f48a1492841ff914a188052e5a26e2c0d3714fb7412390900d7036f4cd7cd2a017f4db9c2d5c5b224685d868c94e37f5352f7c17b14eb7bfc2ad380ac75f1a9d47038086cebd8b363107348251dd80c5baab6ce35bac1231949a43f7ac5b8aa9974ef49f8f728b464d8e948bc7a51349d0d79ce82b7457b15b626e3f483ce11453de74be0d9e68054321b537b57bd9b941854ae7e6171ceb4fb860f33dd478a0f23c4e57f8db51ee5d26b50164e696a842170998a6e401914b833e494b284d14afe73f2023be88b18e5c980fa4f4fa837134f582ea850d4d354a33da91d5d576eb17a2f00e4eb06e0847856ae845b64e200737b44a63c82d595e7c9673385f0cbfba514e73335e45bdf9de3a303d9087be57a7fdfa26f66197381eb977bf2f3e0538bb82e83137eb0b3003ae9e7ab65fa75611985ffcb8c5c18b5e920b89cc9745aa17f62c0b530390820d0bc2d70173bcba06443abbe645d320b3c3e57c0aaace8e0d1d0889791091ad7103cc6506f79142064cda2c34e1e89f8b141cfc812f03b71c89c686d2c2ac432ba11f3811e4e18b188b099d843e6e2c21d99bed95e5ddd12b51df0e84ecf8a5a9b0be4e0315bf702783d32283d28798846c15586a473268e8c61ca0f598190780c2c0b7d5db3e4b1fef37dd1a619979dc1ba9411f1f7867df2cc952f4925aab542d1bec25c3498d4618e141611daf17f0bfec0ebca2c3fe3a41d484fe198d6f13fdf1f6ad921d8257f6ea26a02cd8759e8be76aaa285b428a001a254b36dfeac65aa0b30798decccaa5983c8bfe2deaf163a6d1be4d8bfbb27a283d1a1331a979e4cdf9b216b1f82597c0cbaea4aeb5e3d062ece79e9ddd76040c02c7e0c0af4c091ff0d9056d46ce6b40e7730f9f151bab2fb7c8773a1160164d4b512748b5e0866c6b68ac494cb833506e7e2d7722315133fff8295841e1c672d5b18cc775c0be4605358ba1bfcfeef5d69de194ec9c9082e22e6c7ea9c168844d12f734f02080ecafb0d8a5446ec1661c9a80fc72829322c626df2d55c46355d958d1ded286c4cf163549c0fb5e9a9396dcd7eb857047538acdeaf4a4862a4994e38697664b31baa24861f7822c68e1f97d1f880d0308959f1605fed18589f412edd6c0e7fe0912d73337c4467fe4d299bc40efc863ef29666c2e1b094eafc88788b63a51ad5080013fe9b9922486ec3408dabb6aebc95291d8dee2bc120406161076049ddb71a3b87c7dd0b5e32c054ef38c73c3fdfc730d17062a2baaef8fdf19c15f0a5affda581cb0e07d39ce15f242bdff89ef539b69cefc691dae5259a2364dea76353298453e8751bf6193a0de6e0a6b0c678bece9ee54518c3d30ebe95c1df456101c9d52d149310f41bc2587584d102492d4864a6df55b60a2264602d30d02740edabb574b93b4c7ab23f0c30c89e60829972d663ae7b493726a15419b88a4812817de34ff4561b70638c909ec55debf03180f76564e807be3005f1a472477dd02062bef43d96cc9867dc1f2fd445b4d74d6901bccbc6d03f71eb88bc0a97055a9fdc796d25185083174d673420a1fed53642cc055878ec2059015fb8678ea9dfd4445f26d71fd529282e73880999058de5050258974c1f6949a66006f78dde2a097c3eb9c1ac863ef683662f77bb0a53677d87af675d2d93057c93233bcfb1b54f2eb5a7b432d30bf4b71af6833064c1d9381e58f50cfe334c31653bfffd099d84a37d5e544836fbe7e2bc19dbad13d3f7dad18e31f7e295f2ceac01fa39180dbf817b15efad01379a4bd6e81470b85a04862b48755e4f1d6c959b6d94114f27ebe0e24fcf8d3e40ff5da01b3b72a3d2d2d8a7ffbc4aeb5331d0d3684f8be5d4d48316026f45df634b8938c336799c27023833d67ed9363afc3dbdf3db0593a10b00cf24055d0348623540be1c30ffbbd43e9cb7f50d8605e44231c64df2a0b518a8a3110e908b53edbf83bdbd32c4e128d5fed12a2bee6220f0faaa0ec5f07c65edc6a88fe5fa5c5bc7f1ecbb0f362298b72facb48adb83c3d8d707ec3fc7883d6ab5f50b6d022555cdf3782c4b71718925e722f779e069b010a41437e6f85651ff5e8d3b8adbfa6606afac8966dce53909d08047034eff0fb8b03ed275b349f6e31667302ac4b4e1904f89374a1b4da0b8bb51806be747e13fb89b69d8f4cf1e8db8484233d3505a8dcb17a09f08354ecb2bf7e9abf243ac4a573545cddb60126260cdca26f4343e87a56a8c5ce95ddc7ba8f3c4690d3d0eaa4963aecce8fe4b2ecb740ea8ed140186040380d51ca7bf146405e7c20298468b66868c8c54bdc4ef20d5f930f512e20cfde7336608c54c094a4b26168fce225551305e53124cffdea17af778e5c91bfee4f54ffa3904dba95e12e2ab3410e2efc94f04919f322d57ada05f1766aba019df8dde45174f555df82dfd577d6bf1d0156361685934d5db47781ec306d21133bb804d681a6b8a59072c274d65931cffa1b580d7a28140a4248f8470e4fc4336c83deaa752eb4a71fd8fe541fc31f5f01aa00e0657c75989a4767a69f17d06229f5b2cea466c8a38d46c5000a24869c519decff81c1b6e96ad448000746e294bcde4d2e3fd5dbc28eca3d09c7a7a73ba2fea7be3f7d0c17a13de552af929df3d0fea29b75bc3b1a4c6146289df0c52a97f9b3e552a417a5ec88ac5067dfe368e457a004c35036a617da6f3434003905551fff6d77336b813b2af4b90f792ad486373403b0c80459dc29f5911ca89e940b15d7cc20b72c9e12dc4fcd0a258d8ff89bf75257fc0f9dbdaea4e4c8dfa776becbdbdc64b09a915b18d6960ad54e78238cba555358a0267ee39924846201f1233774283b22efd33f1fe14ef286a754c3cf7172c1981484a7ffe1673a6e30609ecb32909206cc1c3046401870d3b10fe2ebb04f05a62d09340784e91b170529497868e7fec0c7687da90f8c45a97716906368f169c728effdf3d94eaa6822ee2dfa6c0e4e7520d8bf2125e0ca416f299e26db08e71a4f0d353310950bd4eae7235292744b218dd4d6f22cd4c61eba3df2e6b1649ffe83207b46d46cf9816739178f1cb587a7ca1125d0c715cccd3d1ee2262d0edf724dd907412b1405c67c10cfd084984bf3c2ae470173aeca8459779910bed14b0ea8210f751db4d0b7cafb40ec5e156e271d8b2fe0ea84a252b894ff1fdec04b208774307a10b7d22cac0c453360a6fbe2497ad808707dc16343909e0acb4adddf342a881d29ec7f97533a921f3a53e8ee8d117f44787dee0b1a4869d0482250fffb5168d9f40cd36a852f11bd5857d3f46849578ecc2d849216f530fa16e7a36c13f7a648e76d22990a5875e55686b67c33968e6e549f5f943eb3d843305f01a0af7bd3579a3549dedddac797b9b7d20ddb7ceeb8d11d23aa6fad0e2e8c6b2befd812aaa8a220a3c69a4977d00f3efe1d0ee40bf0ccc98ae</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>①  项目笔记</category>
        <category>字体生成项目</category>
      </categories>
      <tags>
        <tag>Font Generation</tag>
      </tags>
  </entry>
  <entry>
    <title>GPU占用清除</title>
    <url>/2022/03/30/18c6bc9e09ef/</url>
    <content><![CDATA[<p>当服务器上的显卡如果被奇怪的进程占用了，但是nvidia-smi并没有显示的时候，可以使用如下命令清除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fuser -v /dev/nvidia*</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>⑦  工具使用类笔记</category>
      </categories>
      <tags>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch学习笔记12——分布式DDP基本概念</title>
    <url>/2022/03/29/5a94914aa20a/</url>
    <content><![CDATA[<h4 id="node">1、Node</h4>
<p>​ 物理节点，就是一台机器，节点内部可以有多个GPU(一台机器有多卡)。</p>
<h4 id="rank-local_rank">2、Rank &amp; Local_Rank</h4>
<p>​
用于表示进程的序号，用于进程间通信。每一个进程对应了一个rank。rank=0的进程就是master进程。</p>
<p>​
rank是指在整个分布式任务中进程的序号；local_rank是指<strong>在一台机器上(一个node上)进程的相对序号</strong>，例如机器一上有0,1,2,3,4,5,6,7，机器二上也有0,1,2,3,4,5,6,7。local_rank在node之间相互独立。</p>
<h4 id="n_nodes">3、n_nodes</h4>
<p>​ 物理节点数量</p>
<h4 id="node_rank">4、node_rank</h4>
<p>​ 物理节点的序号</p>
<h4 id="nproc_per_node">5、nproc_per_node</h4>
<p>​ 每个物理节点上面进程的数量</p>
<h4 id="world-size">6、world size</h4>
<p>​ 全局（一个分布式任务）中，进程的数量</p>
<p>​
每个node包含16个GPU，且nproc_per_node=8，n_nodes=3，机器的node_rank=5，请问world_size是多少？</p>
<p>​ 答案：world_size = 3*8 = 24</p>
<p><img
src="https://img-blog.csdnimg.cn/20210811144558161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h4eGp4dw==,size_16,color_FFFFFF,t_70" /></p>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Pytorch系列笔记</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习基础系列笔记19——EMA指数滑动平均原理</title>
    <url>/2022/03/27/6de89f1d1ae9/</url>
    <content><![CDATA[<p>​ 在训练神经网络时，通常会使用一个叫 Exponential Moving Average (EMA)
的方法，中文名叫指数滑动平均。它的意义在于利用滑动平均的参数来<strong>提高模型在测试数据上的健壮性</strong>。</p>
<h4 id="一什么是滑动平均">一、什么是滑动平均？</h4>
<p>​ 滑动平均(exponential moving
average)，或者叫做指数加权平均(exponentially weighted moving
average)，可以用来估计变量的局部均值，使得变量的更新与一段时间内的历史取值有关。</p>
<p>​ 首先我们假设一个训练参数a，它在不同的epoch结束后的值分别为： <span
class="math display">\[
a_1,a_2,a_3,……,a_t
\]</span> ​ <span
class="math inline">\(a_1\)</span>代表第1轮epoch迭代结束后，可训练参数a的值，以此类推。</p>
<p>​ 然后，我们假设不同的epoch结束后，滑动平均的值分别为： <span
class="math display">\[
mv_1,mv_2,mv_3,……,mv_t
\]</span> ​ <span
class="math inline">\(mv_1\)</span>代表第1轮epoch迭代结束后，滑动平均mv的值，以此类推。</p>
<p>​ 滑动平均计算的递推式如下： <span class="math display">\[
mv_t = decay * mv_{t-1} + (1-decay)*a_t
\]</span> ​
其中，decay为衰减率，用于控制模型更新的速度。递推式中其实就是利用加权的思想，把新的a和先前的平均，做了一个相加。我们可以发现，再很多轮之后，有些离<span
class="math inline">\(a_t\)</span>很远的a,它已经乘了很多遍decay，相当于权重为0，也就是不影响最新的<span
class="math inline">\(mv_t\)</span>的值了。</p>
<p>​ 从直观意义上来看，我们可以把<span
class="math inline">\(a_1,a_2,a_3,……,a_t\)</span>
看作是t个位置，然后想象有一个长度为k的窗口，从最前面开始向后滑动。为了方便说明，我们先假设k=3。最开始的时候，窗口把<span
class="math inline">\(a_1\)</span>涵括在内，然后一个epoch过后窗口右移，现在窗口内有<span
class="math inline">\(a_1,a_2\)</span>，再一个epoch过后窗口再右移，现在窗口内有<span
class="math inline">\(a_1,a_2,a_3\)</span>，再一个epoch过后窗口再右移，此时由于窗口长度为3，所以<span
class="math inline">\(a_1\)</span>就不在窗口内了，窗口内的元素为<span
class="math inline">\(a_2,a_3,a_4\)</span>，从公式上来讲就是在此时，由于<span
class="math inline">\(a_1\)</span>已经乘了较多遍数的decay衰减系数了，所以其的系数接近于0了，不会再影响窗口内计算的值了。</p>
<p>​ 故此称为滑动平均。</p>
<h4 id="二更为公式化的解读">二、更为公式化的解读：</h4>
<p>EMA 在实现时如下所述：</p>
<p>​ Exponential Moving Average 对每一个变量（ <span
class="math inline">\(variable\)</span> ）会维护一个影子变量（ <span
class="math inline">\(shadow\_variable\)</span>
），这个影子变量的初始值就是相应变量的初始值，而每次运行变量更新时，影子变量的值会更新为：
<span class="math display">\[
shadow\_variable = decay * shadow\_variable + (1-decay) * variable
\]</span> ​ 其中：<span
class="math inline">\(variable\)</span>为每一轮结束时，训练参数的值；<span
class="math inline">\(shadow\_variable\)</span>为影子变量；<span
class="math inline">\(decay\)</span>为衰减速率。</p>
<p>​ decay 决定了影子变量的更新速度，decay
越大影子变量越趋于稳定。在实际运用中，decay一般会设成非常接近 1
的数（比如0.999或0.9999）。</p>
<p>​ 为了使得影子变量在训练前期可以更新更快，Exponential Moving Average
还提供了 num_updates 参数动态设置 decay 的大小。如果在初始化 Exponential
Moving Average 时提供了 num_updates 参数，那么每次使用的衰减率将是：
<span class="math display">\[
decay = min\{decay,\frac{1+num\_updates}{10+num\_updates}\}
\]</span></p>
<h4 id="三什么时候用到ema">三、什么时候用到EMA？</h4>
<p>请注意：</p>
<p>​ <strong>EMA不参与实际的训练过程，是用在测试过程的</strong>！</p>
<p>​ <strong>EMA不参与实际的训练过程，是用在测试过程的</strong>！</p>
<p>​ <strong>EMA不参与实际的训练过程，是用在测试过程的</strong>！</p>
<p>​
在训练过程中，EMA只是以一个记录者的身份，在进行记录。实际的实现中，如果你在正常训练的网络是network['C']，那么你可以再实例化一个新的网络，叫做network['C_EMA'],其最初和network['C']一模一样，但是network['C_EMA']并不参与实际记录，其里面的参数只是用来记录滑动平均！！！<strong>（这就是DG-Font代码中，network['C_EMA']的作用）</strong></p>
<p>​
EMA作用是<strong>使得模型在测试数据上更加健壮，有更好的鲁棒性。或者是最后save模型时存储ema的值，取最近n次的近似平均值，使模型具备更好的测试指标(accuracy)等，更强的泛化能力。</strong></p>
<p>参考：</p>
<p>https://zhuanlan.zhihu.com/p/51672655</p>
<p>https://zhuanlan.zhihu.com/p/343210667</p>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Basic系列笔记</category>
      </categories>
      <tags>
        <tag>EMA</tag>
      </tags>
  </entry>
  <entry>
    <title>2.2 处理机调度及相关算法</title>
    <url>/2022/03/25/9887f629bb62/</url>
    <content><![CDATA[<p>笔记课程视频：https://www.bilibili.com/video/BV1YE411D7nH?p=13</p>
<h3 id="一处理机调度-概念与层次">一、处理机调度 概念与层次</h3>
<h4 id="调度的基本概念">1、调度的基本概念：</h4>
<p>​
当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。</p>
<p>​
在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。<strong>处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。</strong></p>
<h4
id="调度的三个层次高级调度作业调度">2、调度的三个层次—高级调度（作业调度）：</h4>
<p>​
<strong>按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使它（们）获得竞争处理机的权利。</strong></p>
<ul>
<li>由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。</li>
<li>高级调度是辅存（外存）与内存之间的调度。</li>
<li>每个作业只调入一次，调出一次。</li>
<li>作业调入时会建立相应的PCB，作业调出时才撤销PCB。</li>
</ul>
<p>​
<strong>高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</strong></p>
<h4
id="调度的三个层次中级调度内存调度">3、调度的三个层次—中级调度（内存调度）：</h4>
<p>​ 引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。</p>
<p>​
等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。<strong>这么做的目的是为了提高内存利用率和系统吞吐量。</strong></p>
<ul>
<li>暂时调到外存等待的进程状态为挂起状态。</li>
<li>PCB并不会一起调到外存，而是会常驻内存。</li>
<li>PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。<strong>被挂起的进程PCB会被放到的挂起队列中。</strong></li>
</ul>
<p><strong>中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。</strong></p>
<p><strong>注意：</strong>“挂起”和“阻塞”的区别，两种状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中。</p>
<h4
id="调度的三个层次低级调度进程调度">4、调度的三个层次—低级调度（进程调度）</h4>
<p>​
低级调度（进程调度），其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。</p>
<p>​
进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。</p>
<h4 id="三层调度的联系和对比">5、三层调度的联系和对比：</h4>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220326111647450.png" /></p>
<h3
id="二进程调度的时机切换过程与方式">二、进程调度的时机、切换过程与方式</h3>
<h4 id="何时需要进行进程调度">1、何时需要进行进程调度？</h4>
<ul>
<li>当前运行的进程主动放弃
<ul>
<li>正常终止</li>
<li>发生异常而终止</li>
<li>进程主动请求阻塞</li>
</ul></li>
<li>当前进行的进程被动放弃
<ul>
<li>分给进程的时间片用完</li>
<li>有更紧急的事需要处理（如I/O中断）</li>
<li>有更高优先级的进程进入就绪队列</li>
</ul></li>
</ul>
<h4 id="何时不能进行进程调度">2、何时不能进行进程调度？</h4>
<ul>
<li>在处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难
做到在中断处理过程中进行进程切换。</li>
<li>进程在<strong>操作系统内核程序临界区</strong>中不能进行进程调度。（但是进程在普通临界区中是可以进行调度、切换的。</li>
<li>在原子操作过程中（原语）。原子操作不可中断，要一气呵成（如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列）</li>
</ul>
<p><strong>注：什么是临界资源？</strong></p>
<p>​
临界资源：一个时间段内只允许一个选程使用的资源。各进程需要互斥地访问临界资源。</p>
<p>​ 临界区：访问临界资源的那段代码。</p>
<p>​
<strong>内核程序临界区</strong>一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）</p>
<p>​
<strong>内核程序临界区</strong>访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换</p>
<h4 id="进程调度的方式">3、进程调度的方式</h4>
<p>​
有的系统中只允许进程主动放弃处理机，有的系统中，进程可以主动放弃处理机，当有更紧急的任务需要处理时，也会强行剥夺处理机（被动放弃）</p>
<h5 id="非抢占方式">1）非抢占方式：</h5>
<p>​ 只允许进程主动放弃处理</p>
<h5 id="抢占方式">2）抢占方式</h5>
<p>​
当有更紧急的任务需要处理时，会强行剥夺处理机（被动放弃）。可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操停系统、实时操作系统</p>
<h4 id="进程的切换与过程">4、进程的切换与过程</h4>
<h5
id="狭义的进程调度与进程切换的区别">1）“狭义的进程调度”与“进程切换”的区别：</h5>
<ul>
<li><strong>狭义的进程调度</strong>：指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被暂停执行的进程，</li>
<li><strong>进程切换</strong>：是指一个进程让出处理机，由另一个进程占用处理机的过程。广义的进程调度包含了选择一个进程和进程切换两个步骤。</li>
</ul>
<h5
id="进程切换的过程主要完成了">2）<strong>进程切换的过程主要完成了：</strong></h5>
<ul>
<li>对原来运行进程各种数据的保存</li>
<li>对新的进程各种数据的恢复（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）</li>
</ul>
<p><strong>注意：</strong>进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p>
<h4 id="调度算法的评价指标">5、调度算法的评价指标</h4>
<h5 id="cpu利用率">1）CPU利用率：</h5>
<p>​ CPU利用率 = 忙碌时间 / 总时间</p>
<h5 id="系统吞吐量">2）系统吞吐量：</h5>
<p>​ 系统吞吐量 = 总共完成了多少道作业 / 总共花了多少时间</p>
<h5 id="周转时间">3）周转时间：</h5>
<p>​
周转时间，是指<strong>从作业被提交给系统开始，到作业完成为止的这段时间间隔。</strong></p>
<p>​ 它包括四个部分：</p>
<ul>
<li>作业在外存后备队列上等待作业调度（高级调度）的时间、</li>
<li>进程在就绪队列上等待进程调度（低级调度）的时间、</li>
<li>进程在CPU上执行的时间、</li>
<li>进程等待I/0操作完成的时间。</li>
</ul>
<p>后三项在一个作业的整个处理过程中，可能发生多次。</p>
<p>​ 平均周转时间 = 各作业周转时间之和 / 作业数</p>
<h5 id="带权周转时间">4）带权周转时间：</h5>
<p>​ 带权周转时间 = 作业周转时间 / 作业实际运行的时间</p>
<ul>
<li>对于周转时间相同的两个作业，实际运行时间长的作业在相同时间内被服务的时间更多，
带权周转时间更小，用户满意度更高。</li>
<li>对于实际运行时间相同的两个作业，周转时间短的带权周转时间更小，用户满意度更高。</li>
</ul>
<h5 id="等待时间">5）等待时间：</h5>
<p>​
等待时间，指进程/作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。</p>
<h5
id="对于进程来说等待时间就是指进程建立后等待被服务的时间之和在等待i0完成的期间其实进程也是在被服务的所以不计入等待时间">对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/0完成的期间其实进程也是在被服务的，所以不计入等待时间。</h5>
<p>​
<strong>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</strong></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220326114401542.png" /></p>
<h5 id="响应时间">6）响应时间：</h5>
<p>​ 响应时间，指从用户提交请求到首次产生响应所用的时间。</p>
<h4 id="调度算法-1">6、调度算法 1</h4>
<p><strong>调度算法的重点</strong>：</p>
<ul>
<li>算法思想</li>
<li>算法规则</li>
<li>用于作业调度还是进程调度</li>
<li>抢占式还是非抢占式</li>
<li>优点和缺点</li>
<li>是否会导致饥饿</li>
</ul>
<h5 id="fcfs-先来先服务非抢占式算法">1） FCFS
先来先服务（非抢占式算法）</h5>
<p>​ 主要从公平的角度考虑，按照作业/进程到达的先后顺序进行服务。</p>
<ul>
<li>用于作业调度时，考虑的是哪个作业先到达后备队列</li>
<li>用于进程调度时，考虑的是哪个进程先到达就绪队列</li>
<li>非抢占式算法
<ul>
<li>优点：公平，算法实现简单</li>
<li>缺点：排在长作业后的短作业需要等待很长时间，带权周转时间很大.
FCFS算法对长作业有利,对短作业不利.</li>
</ul></li>
<li>不会导致饥饿</li>
</ul>
<h5 id="sjf-短作业优先算法-非抢占式算法">2） SJF 短作业优先算法
(非抢占式算法):</h5>
<p>​ 追求最少的平均等待时间,最短的作业或进程优先得到服务(指
要求服务时间最短)</p>
<p>​
<strong>[每次调度时选择当前已到达且运行时间最短的作业/进程]</strong></p>
<ul>
<li>用于作业调度时，称为 短作业优先算法</li>
<li>用于进程调度时，称为 SPF 短进程优先算法</li>
<li>SJF和SPF是非抢占式算法,也有抢占式的算法: 最短剩余时间优先算法SRTN
<ul>
<li>优点：“最短的”平均等待时间、平均周转时间</li>
<li>缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先</li>
</ul></li>
<li>可能导致饥饿,如果有源源不断有短作业来</li>
<li><strong>示例1:</strong> SPF 算法
<ul>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412092135300.png" /></li>
</ul></li>
<li><strong>示例2:</strong> SRTN 算法( 最短剩余时间优先算法 ):
每当有进程加入就绪队列改变时就需要调度，<strong>如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，</strong>当前运行进程重新回到就绪队列。另外，<strong>当一个进程完成时也需要调度</strong>
<ul>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412092403526.png" /></li>
</ul></li>
</ul>
<h5 id="hrrn-高响应比优先非-抢占式-算法">3） HRRN 高响应比优先:(非
抢占式 算法 )</h5>
<p>​
综合考虑作业和进程的等待时间和要求服务的时间,在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务.
<span class="math display">\[
响应比 = \frac{等待时间 + 要求服务时间}{要求服务时间}
\]</span></p>
<ul>
<li><p>既可以用于进程调度也可以用于作业调度</p>
<ul>
<li>优点:
综合考虑了等待时间和运行时间,对于长作业来说,随着等待时间越来越久,其响应比也会越来越大,从而避免了长作业饥饿的问题</li>
<li>缺点:</li>
</ul></li>
<li><p>示例1:</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412104029587.png" /></p>
<ul>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412104019832.png" /></li>
</ul></li>
<li><p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412104148079.png" /><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412104351880.png" /></p></li>
</ul>
<h4 id="调度算法-2">7、调度算法 2</h4>
<h5
id="时间片轮转算法抢占式算法常用于分时操作系统更注重响应时间">1）时间片轮转算法：（抢占式算法）【常用于分时操作系统，更注重响应时间】</h5>
<ul>
<li>公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</li>
<li>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</li>
<li>一般只用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）</li>
<li>由时钟装置发出<strong>时钟中断</strong>来通知CPU时间片已到。
<ul>
<li><strong>优点：</strong>响应快，适合分时操作系统，不会导致饥饿</li>
<li><strong>缺点：</strong>由于高频率的进程切换，因此有一定开销</li>
</ul></li>
<li><strong>示例：</strong>
<ul>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412111910996.png" /></li>
</ul></li>
</ul>
<p>​
如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</p>
<p>​
另一方面，进程调度、切换是有时间代价的（保存、恢复运行环境），因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。</p>
<h5
id="优先级调度算法抢占式非抢占式版本都有常用于实时操作系统">2）优先级调度算法：（抢占式、非抢占式版本都有）【常用于实时操作系统】</h5>
<ul>
<li>随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程</li>
<li>既可用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的I/0调度中
<ul>
<li>非抢占式：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。</li>
<li>抢占式：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。<strong>另外，当就绪队列发生改变时也需要检查是会发生抢占。</strong></li>
</ul></li>
<li><strong>优点：</strong>用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活调整对各种作业/进程的偏好程度。</li>
<li><strong>缺点：</strong>若源源不断地有高优先级进程到来，则可能导致饥</li>
<li><strong>示例：</strong>
<ul>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412112408359.png" /></li>
<li></li>
</ul></li>
<li>通常：
<ul>
<li>系统进程优先级高于用户进程会得到提升</li>
<li>前台进程优先级高于后台进程</li>
<li>操作系统更偏好I/o型进程（或称I/o繁忙型进程）</li>
<li>注：与I/0型进程相对的是计算型进程（或称CPU繁忙型进程）</li>
</ul></li>
</ul>
<p>【由于I/o设备和CPU可以并行工作。如果优先让I/O繁忙型进程优先运行的话，则越有可能让I/O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升】</p>
<ul>
<li>可以从追求公平、提升资源利用率等角度考虑
<ul>
<li>如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级</li>
<li>如果某进程占用处理机运行了很长时间，则可适当降低其优先级</li>
<li>如果发现一个进程频繁地进行I/O操作，则可适当提升其优先级</li>
</ul></li>
</ul>
<h5
id="多级反馈队列调度算法抢占式算法可能导致饥饿">3）多级反馈队列调度算法：【抢占式算法，可能导致饥饿】</h5>
<ul>
<li>对其他调度算法的折中权衡
<ul>
<li>1.设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li>
<li>2.新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾</li>
<li>3.只有第k级队列为空时，才会为k+1级队头的进程分配时间片</li>
</ul></li>
<li>用于进程调度，抢占式算法
<ul>
<li>在k级队列的进程运行过程中，<strong>若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，</strong>原来运行的进程放回k级队列队尾。</li>
</ul></li>
<li><strong>优点：</strong>对各类型进程相对公平（FCFS的优点）；每个新到达的进程都可以很快就得到响应（RR的优点）；短进程只用较少的时间就可完成（SPF的优点）；不必实现估计进程的运行时间（避免用户作假）；可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/0密集型进程（拓展：可以将因l/O而阻塞的进程重新放回原队列，这样I/o型进程就可以保持较高优先级）</li>
<li><strong>示例：</strong>
<ul>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412113638505.png" /></li>
<li>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片。若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经在最下级的队列，则重新放回最下级队列队尾</li>
<li>只有第k级队列为空时，才会为k+1级队头的进程分配时间片</li>
<li>被抢占处理机的进程重新放回原队列队尾</li>
</ul></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412113856291.png" /></p>
<p>​
注：比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求。因此这三种算法适合用于交互式系统。（比如UNIX使用的就是多级反馈队列调度算法）*</p>
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>《StyTr2 Unbiased Image Style Transfer with Transformers》</title>
    <url>/2022/03/21/58ee25c0143c/</url>
    <content><![CDATA[<h4
id="论文名称stytr2-unbiased-image-style-transfer-with-transformers">论文名称：《StyTr^2
Unbiased Image Style Transfer with Transformers》</h4>
<h4 id="论文地址-httparxiv.orgabs2105.14576">论文地址：
http://arxiv.org/abs/2105.14576</h4>
<h2 id="关键词">1、关键词：</h2>
<p>​ Image Style Transfer、Transformer</p>
<h2 id="摘要">2、摘要：</h2>
<p>​
由于CNN的局部感知域性和空间不变性，输入图像的全局信息难以提取和维护。因此，传统的神经网络风格传递方法通常是有偏差的，对于同一幅参考风格图像，<strong>通过多次运行风格迁移过程可以观察到内容泄漏。</strong>为了解决这个关键问题，该文提出了一种基于Transformer的方法，即StyTr2，将输入图像的长期依赖关系考虑到无偏风格传输中。
​
与用于其他视觉任务的视觉转换器不同，我们的StyTr2包含两个不同的转换器编码器，分别为内容和样式生成特征序列。在编码器之后，采用多层Transformer解码器，根据样式序列对内容序列进行风格化。</p>
<h2 id="领域背景style-transfer">3、领域背景—Style Transfer：</h2>
<p>​
经典的基于深度学习的图像风格迁移，样式转换方法使用多层cnn来学习样式和内容表示。由于卷积层的接收域有限，CNN无法处理长距离依赖关系。输入图像难以获得全局信息，这是图像风格传递任务的关键。将Transformer应用于计算机视觉的魅力在于:</p>
<ul>
<li><ol type="1">
<li>它具有较强的表示能力，可以通过自注意机制自由地学习输入的全局信息，从而使每一层都能轻松获得整体的理解。</li>
</ol></li>
<li><ol start="2" type="1">
<li>Transformer不包含局部性和空间不变性引起的归纳偏差，可以避免风格传递任务中的内容泄漏</li>
</ol></li>
</ul>
<h2 id="先前工作描述与比较">4、先前工作描述与比较：</h2>
<p>​ 暂略</p>
<h2 id="主要设计思想">5、主要设计思想：</h2>
<p>​ 在StyTr2框架中使用两个编码器来获取特定领域（Content &amp;
Style）的信息。在编码器之后，使用Transformer解码器逐步生成输出序列。此外，针对自然语言处理中提出的位置编码方法，提出了两个方面的考虑:</p>
<ul>
<li><ol type="1">
<li>不同于按逻辑顺序排列的句子，图像序列符号是通过图像内容的语义信息进行关联的;</li>
</ol></li>
<li><ol start="2" type="1">
<li>对于风格迁移任务，目标是生成任意大小的风格化图像。输入图像大小的指数增长会导致位置编码的剧烈变化，从而导致较大的位置偏差和较差的输出质量。一般来说，视觉任务所需的位置编码应以输入内容为条件，而不受图像尺度变换的影响。</li>
</ol></li>
</ul>
<p>为此，该文还提出了<strong>基于图像语义特征的位置编码</strong>，并根据图像大小动态扩展位置编码。</p>
<p><strong>总结：主要贡献</strong></p>
<ul>
<li><ol type="a">
<li>一个基于Transformer的风格转换框架，即StyTr2，以减少内容泄漏并实现无偏的风格化;</li>
</ol></li>
<li><ol start="2" type="a">
<li>一种内容感知的位置编码机制，该机制是尺度不变的，适用于视觉生成任务;</li>
</ol></li>
</ul>
<h2 id="具体方法与网络架构">6、具体方法与网络架构：</h2>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321190212987.png" /></p>
<h3 id="图像分割为patches-linear-embedding与vit类似">1)
图像分割为Patches + Linear Embedding【与ViT类似】</h3>
<ul>
<li><strong>输入：</strong><span class="math inline">\(I_c \in R^{H
\times W \times 3}\)</span> 和 <span class="math inline">\(I_s \in R^{H
\times W \times 3}\)</span></li>
<li><strong>输出：</strong>一个特征序列：$ L C<span
class="math inline">\(，\)</span>L = $ ，<span
class="math inline">\(m\)</span>是PatchSize，<span
class="math inline">\(L\)</span>是特征序列tokens长度，<span
class="math inline">\(C\)</span>是单个Token的维度。</li>
</ul>
<h3 id="位置编码content-aware-positional-encoding">2) 位置编码（Content
Aware Positional Encoding）：</h3>
<ul>
<li><p><strong>想法：</strong>当使用基于Transformer的模型时，需要在输入序列中加入位置编码(PE)以获取结构信息。此论文提出了基于图像语义的位置编码，这一改进基于以下两个想法：</p></li>
<li><p>在传统的位置编码中：两个patch之间的位置相对关系仅仅与它们之间的距离有关。而对于图像生成任务，在计算位置编码时，我们应该考虑图像的语义</p></li>
<li><p>当输入图像的尺寸呈指数增长时，传统的正弦位置编码是否仍然适用于视觉任务?
如下所示当调整输入图像的大小时，相同语义的patches (blue
blocks)之间的相对关系会发生巨大的变化，这可能不适合视觉任务中多大小的输入。</p></li>
<li><p><strong>主要做法：</strong>提出了内容感知的位置编码(CAPE)，该编码具有<strong>尺度不变特性</strong>，更适合于风格迁移任务。与正弦PE只考虑Patches的相对距离不同，CAPE以图像内容语义为条件。</p></li>
<li><p>首先假设<span class="math inline">\(n \times n\)</span>
可以足够用于表示每幅图像的语义位置。</p></li>
<li><p>假设输入图像为：<span class="math inline">\(I \in R^{H \times W
\times 3}\)</span> ，我们将<span class="math inline">\(n \times
n\)</span>的位置编码（依据实验结果，一般情况下<span
class="math inline">\(n=18\)</span>），放缩至<span
class="math inline">\(L = \frac{H}{m} \times
\frac{W}{m}\)</span>的大小，这样就可以使得位置编码不受图像尺度的影响。即对于两个Image
Patches而言，它们直接的位置关系不会受到图像尺度的影响。如下图所示：假设有两个不同分辨率的图像，在PatchSize大小一样的情况下，左图分辨率小，被分割后，成为<span
class="math inline">\(2 \times 2\)</span>的Patch块，右图成为<span
class="math inline">\(4 \times
4\)</span>的Patch块。当位置编码会进行放缩以适应的时候，其就可以自己匹配不同尺度的图像。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321210140364.png" /></p></li>
<li><p><strong>公式化表达</strong>：</p>
<ul>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321210523455.png" /></li>
<li><span class="math inline">\(P_{CA}(x,y)\)</span>代表第<span
class="math inline">\((x,y)\)</span>坐标的Patch的位置编码值</li>
<li><span
class="math inline">\(F_{pos}\)</span>是一个可学习的编码函数</li>
<li><span
class="math inline">\(P_L\)</span>是一个可学习的位置编码，是基于图像的token序列的</li>
<li><span class="math inline">\(a_{ij}\)</span>为插值权重，<span
class="math inline">\(s\)</span>是邻居的数量，其是由周围邻居加权差值计算得到的。</li>
<li>对于token序列<span
class="math inline">\(\epsilon\)</span>中的第i个Patch块，假设这个Patch块的坐标是<span
class="math inline">\((x,y)\)</span>，那么我们将计算得到的<span
class="math inline">\(P_{CAu}\)</span>值加到<span
class="math inline">\(\epsilon_i\)</span>中，形成最后的序列。即，如果原来的token序列<span
class="math inline">\(\epsilon\)</span>形状是<span
class="math inline">\(L \times C\)</span>，那么新的也应当为<span
class="math inline">\(L \times C\)</span></li>
</ul></li>
</ul>
<h3 id="transformer-encoder">3) Transformer Encoder：</h3>
<p>​ StyTr2有两个转换Encoder来编码特定于风格（内容图像 &amp;&amp;
风格图像）的特性，这些特性用于在下一阶段将序列从一个风格转换到另一个风格。</p>
<h4 id="part1-content-image">Part1: Content Image</h4>
<ul>
<li><strong>输入：</strong>Tokens 序列 <span class="math inline">\(Z_c
\in L \times C\)</span></li>
<li><strong>输出：</strong>$Y_c L C $</li>
<li><strong>网络结构：</strong>每个transformer encoder
layer包含一个MSA和一个FFN，与Transformer结构一致，输入序列被编码至Q，K，V。
<ul>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321215744833.png" /></li>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321215804639.png" /></li>
<li><span
class="math inline">\(W_q,W_k,W_v,W_o\)</span>是可学习参数矩阵。</li>
<li>然后使用残差连接结构，每个模块后有LN归一化</li>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321220112862.png" /></li>
</ul></li>
</ul>
<h4 id="part2-style-image">Part2: Style Image：</h4>
<p>​ 按照Content Image那样子进行处理，但是对于Style
Image我们<strong>不需要进行位置编码，因为我们不需要保持它的图像结构。</strong></p>
<ul>
<li><strong>输入：</strong>风格图像Tokens 序列 <span
class="math inline">\(Z_s \in L \times C\)</span></li>
<li><strong>输出：</strong>$Y_s L C $</li>
</ul>
<h3 id="transformer-decoder">4）Transformer Decoder：</h3>
<ul>
<li><strong>输入：</strong>$Y_c L C $ ， $Y_s L C $ （<span
class="math inline">\(\hat Y_c\)</span>是<span
class="math inline">\(Y_c\)</span>增加了CAPE位置编码后的序列）</li>
<li><strong>输出：</strong><span class="math inline">\(output \in
\frac{HW}{64} \times C\)</span></li>
</ul>
<p>​
根据参考的风格序列，用回归的方式来生成内容序列。和传统NLP任务不一样，我们使用序列中的所有Patches一次性输入来预测结果。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321224013009.png" style="zoom: 80%;" /></p>
<p>​
由两个MSA和一个FNN模块组成。第一个MSA模块的K、V来源于Style序列，Q来源于Content序列。每个模块后面都有一个LN归一化。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321232914140.png" /></p>
<ul>
<li><p>公式化表达：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321232959747.png" /></p></li>
</ul>
<h3 id="decoder">5）Decoder：</h3>
<p>​
论文使用了一个三层的CNN解码器来细化后面的Transformer解码器的输出，而不是直接对输出进行上采样来构造结果。</p>
<ul>
<li>输入：<span class="math inline">\(input \in \frac{HW}{64} \times
C\)</span></li>
<li>输出：<span class="math inline">\(I_{out} \in H \times W \times
3\)</span></li>
<li>网络结构组成：
<ul>
<li>$3 $ 卷积层</li>
<li>ReLU</li>
<li><span class="math inline">\(2 \times\)</span> 上采样操作</li>
</ul></li>
</ul>
<h2 id="采用的损失函数">7、采用的损失函数：</h2>
<h4
id="content-percepture-loss-感知内容损失-style-percepture-loss感知风格损失">1）Content
Percepture Loss 感知内容损失 &amp;&amp; Style Percepture
Loss感知风格损失</h4>
<p>​
优化结果应保持原有的内容结构，同时传递参考风格的模式。VGG提取的特征图可以作为内容特征来表示图像结构。<strong>Gram</strong>矩阵是两两向量的内积组成,所以<em>Gram</em>矩阵可以反映出该组向量中各个向量之间的某种关系。特征图的Gram矩阵可以作为风格特征来表示颜色、纹理等信息。因此，论文构建了<strong>感知内容损失</strong>来衡量生成图像<span
class="math inline">\(I_{cs}\)</span>与参考风格图像<span
class="math inline">\(I_c\)</span>之间的内容差异，构建<strong>感知风格损失</strong>来衡量生成图像<span
class="math inline">\(I_{cs}\)</span>与参考风格图像<span
class="math inline">\(I_s\)</span>之间的风格差异。</p>
<ul>
<li>Content Percepture Loss：</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220322103100728.png" /></p>
<ul>
<li>Style Percepture Loss:</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220322103340777.png" /></p>
<p>​ 因为神经网络各层的统计量(如均值和方差)包含了不同领域的特征。<span
class="math inline">\(\phi_i\)</span>代表使用预训练的VGG19网络，其第i层提取出的特征。<span
class="math inline">\(\mu()\)</span>代表特征的均值，<span
class="math inline">\(\sigma()\)</span>代表特征的方差。风格的感知损失可以书写如上。</p>
<h4 id="identity-loss">2) Identity Loss</h4>
<p>​
自监督学习可以利用PreText从大规模的非监督数据中挖掘其监督信息。网络可以用这种构造的监督信息进行训练，以学习下游任务的有价值表示。
论文采用一个辅助的<strong>自我风格迁移任务</strong>来学习更丰富、更准确的语义和风格表达。<strong>该任务具体操作如下：</strong></p>
<p>​
<strong>注</strong>：Pretext任务可以进一步理解为：<strong>对目标任务有帮助的辅助任务。</strong></p>
<p>​ 论文在StyTr2中输入两个相同的<span
class="math inline">\(内容/风格\)</span>图像，生成的图像<span
class="math inline">\(I_{cc}/I_{ss}\)</span>应该与输入图像<span
class="math inline">\(I_{c}/I_{s}\)</span>相同。因此，<span
class="math inline">\(Identity Loss\)</span>模拟<span
class="math inline">\(I_{c}/I_{s}\)</span>与<span
class="math inline">\(I_{cc}/I_{ss}\)</span>之间的差异:</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220322104028070.png" /></p>
<h4 id="最终loss">3）最终Loss</h4>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220322104224116.png" /></p>
<p><span class="math inline">\(\lambda_c\)</span>、<span
class="math inline">\(\lambda_s\)</span>、<span
class="math inline">\(\lambda_{id1}\)</span>、<span
class="math inline">\(\lambda_{id2}\)</span> = { 10 , 7 , 50 , 1 }</p>
]]></content>
      <categories>
        <category>③  论文阅读笔记</category>
        <category>CV相关论文</category>
      </categories>
      <tags>
        <tag>CNN</tag>
        <tag>Style Transfer</tag>
        <tag>Transformer</tag>
      </tags>
  </entry>
  <entry>
    <title>关于文献综述、开题报告写作逻辑记录</title>
    <url>/2022/03/21/70cfb7bd8141/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="4eafc87be004f2fe6450b3b1187603d145c57273c5c643dcd6508b8936edc57f">0b64cd3abe5b0a0a039a37d86c66d75e30f1e5cc7662992b49707d8fb1532b69399debf3853b2258ca954efe35d1f8c5bd240504c5d2baeffc97196da2a36e61d5f8a60dbcda8be9c594f5556387c07fb682de586f5ae7d6a50c917baf4d54f0862c449297b85832444e70ca69090890ddac89cc2a436f08f1c0dbd21e6873b0e58d57c1b38a49b41fa8c0e67d43e32fa1e34777f2ccacf9c1d5468ffcc3ed12d66cdda1d779a044bc0be7fdc965365748e4773167d46b07566110f6088839a6d82913300492778bbcab5da1c68a70b13cccfdda91a9e1adbe37e8b7be858c62c4c6a621aed2b8ef1193c4d8080e6986328ecb374f1a8dad3ddaad6dc11b3f8c46600f971b005916b0e49f81a9b61fb259361f307287571d8d2e25d5ab6626fe9cb45227b68955988a39ebfa9879013c750f46c1c7753bcb0eefdb62685e80dba4ede9d8ad8a7d9e4428ae4e6c9aef107b5c8ee4bb5c0484a17bba61e414cb34da48ef487ef122212408a2ebe107094cc187a1a00157e9af5a93d7e804d4782fc3ea3b244d1a13497609db33835d72372212f64f782a68aef1c18c6fb689b3843d99988f49bb7adc182783ac104d1f56a7588c4d430f9bbbe08acffb5b8b531c7b4917821cf187d4fb94e1094b353649ff47117542cf97ba86515c181cf9c0540a378b6fd96fad66b8a72b3e79455f29a579bcf67caef08c3aa8d0b99d80fe52883c5df69a7e3b100a6afec6809593e9ff48d61b81ae127fbae3d2117f937d9933bf54c0f76f61f59b5bb5b42934e7c6c9ddca0f05f13ccfb275fce530b20b3ea5e2afc58ab6b3ac9dbf3e85ca524fc59f28ec6387d646b1f4c02ca064072e7213ce0a2f17e7064b957b4ec37383e7dc7f8533cd6dae7149480c4f6c6bc5923f4179c5df13fe46341085410906c1be463ec9991ae1e06e46a84f6994d37ff53d6349e592ddf6f6e76b0907f804f4082a752c014021d14c8981a81f233150b5d934d2ff2f93c100f21c33833130ae23171579b92ed0ad970a9064784e81373f1864f342fc8d23df6cfb82eb15644b1cb413bd8c96510fd83417098ef27a13d41cf89da8c7f9429e19adf9543cce25e5e57f0f819c66d91f5a606ba6f8c80b982e21e0267f065a9a65fd63f2830147e57d8f910e0f0f7762ec948caa94cc7cb936b492036540b741cee998c67cb7e5bba5280b59e83d44926e1a129d63058efbcc952a5ac166bc47177d5b6dff3534a37d59c9b276485599ffe0323c57ed4047f8ba1eff7058f03aae450a41e7a4f01ca8053ec3a1d7a84055dafcfa70eac567968648a2c2360a9849c4a673a5d287285cd0e3a4ee09358708ce2ad4cf9830b89eee93debcde71e3847540e0ee726019de7ed0ca61551705a67e0dae57bdfc0aeaef5dd382c608ec6ec5376956c750bbce18e0000d76eaf5ceaf0fd8c5a759be288ac3ab7feb5f0848560add3142db45c108986bf21f3c98cd5159f71eaf52db7b7c6f0d7bebffb3b5c2c18e921569ace25d7d47295812aafe4ace9f9701109708be8281a3c430db9031591ea9350bad04c1252d03efed20989cde1628c382ae0f688c685de54003c5587a5546ba51a0d3f28e8a57d133a21ed3a5445c6e4be3293b4868fa76dd46143fad504f9bcd033c831c7bb14e612de668723f9ab482cf936788556d7a98b239bef0554485805728604d7987534b8b24613dd43d8060d7ccbea5f4894db61ad7d75b21bd712db8f98d360c1ecf8008781140abca713b294449c3188a5440b06966891a855f63296e12215b3b54b0b0f1c301b46503f980e0d4825362931ec7751f7a053ebf57e7e809be17583374525e958e7b5c4407f870cf6c3023705a53946f385098eac8f17d688c5937d0766988a722573b0c278e6fa4a7d1e0400b13af03bb572ca3b23f02816f2178f67db6d829dea4182eef4a7d4fda6c91a6188d153a8a3f7e33aa57803f6895fe8115c34962507f083e0fa4fe59cc207bf06094aeaa7a149308d7b68f450d28651f86459f9d6498854f5f61c25128610974eb180f78eed024b8f58c575ef93f06f09aeb95b8c23968427a3754ad094ced75393b3fc26a570583312924581c10a0b05d5c2dd7322cffe57dcbceb45c9c71a9c9a336c7fa8c2e4f5af5a581b1a5cf7c3b77af69dd1e6b95200a7e762debd71ef2a1e636b0b817863ce36fbd753a202a41f2e42bdf32ca56161680dd6a0a33f6770d397df397fa096271b4adbf532575b3884ab472bc4f4645fa189f5da4193956c0066bd04686d5a9e936862a896b240b33f6f40812fa595fe8421ea976dcccf19aa424890c64fa5b82eea749bbe43b4306ea57e0eb29c5b12cfb07e77fe6fbb3fc7d693506cbc0011ecda777fb753b4ec7c796ed7ecf4b1ede78dc1f3fe31db5a7b2a47b26cb709b3aea3204d7e18d27989ec30003e7840c64d311d9e9151999bf20e29c79560bf83489304498ee14bf33746ddee710dfc3a94877cd411c41c8c57459845b9184b680db0b80a6e0fa4bc41ad3843cad8e39a7e1173877760f44b230505aabe918e0cb7c0989948b4fbccfae759588b98742fc00b9878808eb01a3a3763055007881cc55cdf68703168c42153061b6d413957b4c8ebb894072127901ce3ba09d626e7a4fa65ef6abd3dde42bb2b2f60983ca080a368f99ca55c4c838f04c531fc163d68e61bba5658232f3f1d4b37975f36935cdb7a950137dcbb0bb268c6b1eec3f63d2d27079cb5a68e1e2261631d2e90db167b3b3b0df31f7980e4cd35e3ca1bf9075fc94d6392664c1e19598bc1996fc46194b3a9ff6ce539bee6c7ceea9402f48d81d8f1a941a39e56d179fdff249844494e4506005b260c73fda5831440ce4363e980ff50087244035e3202c5e87283d12c1807f19244495aa29f25eaaf7f16ecfbd69eeb69f5d1cb5b8c60f8037873bf1eda80cc98e9a8ec9772a313f7aab21d056cf65afdab174b5a4e6beea611480fd3abb253eef8db2cfbd4a13869ad03e3e27c94fa1ad857d16ac553d0d1487902a7a47c41305df45056515af178a5403ca97ea6d95f78e5086ecac17e670dc74ef271b7a9dd576f6eb8c5e59ee28122f81090a4c43e254a6dfde0713402523db74b22f0a867abeda9e7e13a4960798cc38890dbca29d3acf312ed3ef8db571cb1bc22f5806639fe146641ab5f4f8765faefd1d72d2b4ced9f7507dea31b53b0b6626d2a59883bbb78937241d5ac07c6a7ff958b11eac1aedcda77410c2c012f46c50d7b6ae403138e4ce8a2f6d827e5e0feca3f92fa66151cd8b95b8879e8e506e3cec3950fb29f51c1d6d6b6e57239378c32515141391d1d6bfe6bee3f1a3202f346b16b286b06f1f0e6bc5a7515518f2f0339b42e0ac2351e03755f1a15d684691fed82d5e4a33d828eab42fd2f7d42d8015916583a79a8fb5b24cd41993a823284a2e430abb042f83d877599295389101c8659b4329c88bca8b538fc0db05017d8efe0861448257369c61357f61553b0b509b7cd6b872f361ae010d59d03e2212105aa312d663e9bf7c13b2e7daafcdff779548553529cb7b0be029e387521112347647fa3ae8b1203cc58356715605a52d9bddf05f6d88211d53e95c63b8d0b08a554c68f7502c270bce40294bdd546e3d0d3eb9024559023dd1875067c360c40d6a6b5ca0643bb2efd224ce4621a4471dfabbe42ddc428711bd906db7cf66b2a4bb8e8045706b1305e1026be8aa79ba94b84e242e8581727ee1c6a6bfe4dfe8963cb762612d6829e8378301bdc0055a079a8a3c16cce3a0878089bbf63bf642aa1ef8cad627c37ba467369ed7ff9b4b7a457864f6edec122925b317b6a653bcef7e2c1bfcf222c4d52b3cd57ab91f022a65da00313ad0f163ac2fb2cd98f6487f51508645e859210e4307c5182b71ba69ddf7c385322c5f817eb8fba21f8595893d8709a72cec63d0f09efe45ad78175b52e11f01c47f9adb2ac93bb43fb07010d5f187add1a318f89a45476cb872d51e6b2e853194351cff0b6a055ec8b9e2c400d39f44e388105221adf8a5f4c74f57c7a8e9249a1006ec148e2a69ece6c25093a15b2e795326b00ef700e8495c94dc9a4282ef83225085d1808f9b512926647cc5e5f7bebbf3e663852f367dcecfabf21b0ed6ef6b4f591a3a17bb283eafba64742e5933353a2314568bfbe9114f3dc7ed9180784ed5154fa39b0a343006926dd93555b9047bf969c9906408f9be64f45dffb9ebaeed5dd0d07d514244895452b94a33518cc673895f118bd623c423b94e0ca1f19c82a4adf6604b50bb0167ae230c5aaaf2893f2fb9915dbe0cd1e3c8d177310fb86f22b79b6c65c4087cd98c10c845cf4021c340c3a97c783fc03c236d94330b0cc25f4687cdff4a554ba95bdfdd005c7bc18618bff28b8bde25af09589f8ef27f543f0decffd296e6477190584fd40190684deda9364c67636699639324116e1392b8e9fb0e27ee04da511674b015f6fa92f20489b2249ce4346896dcf23abbae5574843af2cc14c5386ec0b1c71e56d65dc7b90af6e4f11965c43476032e6469a1b48623b1c5f2ddf17f81df06e5dcf02fe6dcca38e65e4a3c665907ea65208d51ba3e3375d1c37a840795940b8cdaa8fdf33a9b061286755ef22c89cd5a5c74631957f0cebc8822c1716179b4bf7b04f8babb7e77514dbf9fc9e3ddd8570cdd72135fb859bf27ddab83c2d14384d1a06ca9508e57acc0fbaf32582e8439e1387994b5a0efdbb0e0d94dfe5dca9ca6e61c7eacfa9927fc30a6a100796fa97e6ccc52412fee5dd95b0e89d7d3b06e27ef2d89725bfb73323c157d3599d9f6ceb499eb2c2534b0ace1c7fff615ba087b694dd8b0e184cee7543da849d696bf847040dd3b7443e05a8ae095b5274e833309fb4ac18ddfa5e4f994bf51c41076eb57623f484aa77353433351082f095bd7238b3f224e58bf37cdf09f915d2bd9649b75ba4e7adcef39afcfa9b24f4d0ed66d621828f310173ab0207ed0287091a1f28ae0e328eeda0e476b953994b4c059e843229f05b6f7caea4b93ab993a7beab8215d4166bd8c0b8858491229d54ae0673764f5e8823b506db8f37e78c9c2ab3ea0911dba3bed5b1d5c6b19c54382e8b1dd8e53e01f00629edfca3ad9c3e924bb30cd989856a286484f6fdbfdc43dab78c34a501c7640634faa128ae7f10e49624f4837bcd9bb173c1fcf18a80814296c25c9fc81d645625ebbd5690652dd20fbffb81e2f13e80dd9f8f359b2b221385bb7f7a2d1ea0dbfbddb82d6585276ad8bcb914669b0d6c054271929183a2bca83ef6fe6ebb6f378c0660570bd21a1d2bc5efc56502dc6f502506af0223c6f6518dd5d11f31de94006a3d68a98b793b0f50e40253d601caefc3117111c1c8c035f48482b44565dface496dd0bfacb7a04c12a4c05355d31135a44ef7f236120acaf41d60f05c774c04605d3388eb4a86844a217d31e19e234a359a8457718f438b2ee73886fc2092d1becc451183ffd72d46757243473cdf963563dcebb9abc6c9cf1d1c8cfb4c8a673163db7a3d0c4bbd1d50017aeeabb29ebce994f85686712a7b858ae8460c8cb5c0f74e9a2e6b04b8956c347a769734d8e4c51c8790af15c679c2f12460368dff18bb9d1a37d998e782d8a5b2d4f90beffee7614a60df96ceb8faca556dacc7d76cd358c4654fa2d6c937331116ac0c58c1f582faae5b1acdf0bc3f8069ac258cb728df21240ac8b3c002360cb410551ed206c910efc6279130be411f65ac400f8267475053b05c7db98e320b594cca49545953849221b5719f05dbcdf7ee0e9c9171203670473613b19bfaaaac460cb098460dfcbddfde4c111ea7b7893af5b8c85a792cc182cfb2109c5ec1822f03f43e745d8699e91e9c86eebd188a1fcd176a7392fab8022c35ecbbf32261c99253b3528e982af571319bf448c06218d039923d762056917a150eb7d9bf9cdfb6b2a7667b7114d8f37bda5946cf192a743a106b65d5b66833800881d6a9e5d731dda407a94d5aca1e2fb1c7e39ea364fe88893c153c9754da582ec261ba8799294d86103cfacd38a04390277b7e5c4171fcb92604d157b69f078a90ae9a2708565ba9ef00fb85f114d8d90512c855e0fa38dff9e6f8d465949abb53b291e06404854b8f02817a033596d203d077544f1d673142b287cbefa3294432d736fd2f63b0a7a25e8dd1cd6da2dc7698e68d2ce39ca0475dfdaf49bdf4923e632e36cca2e54220da5b698977e7eea565508ab466f35320f4a35e68c1414d450bd8d7f936f565e1ea986b4c0846d1e288e9e0353f8abff28677400ca7a9ae1aac0a53dd74c55cecc479c813314ddc748439ffeba94e763f4d8d7e93e1fe0fa13e76cf9cf4a3e1ceb686d8edca9c5b4d832b1a53a9c52274a96dc453c0f7cf891f7ede7d8285786e8430389a6ef67316b1496a553b1e6c169f9d756269814d2b93a5a4a0273b79f327a104fa9e946069cb4fd5fdb49111a8b0ebd1318d64a7c6543ddf0b821cf1735bb6a6136214ec31c1f93260754eb44731ca0976b31d5ab14debcc5eb977c1930817e2c2ec11ae6f8fc0f0a3448d11f5d3aa9a3fc57c370d6ab963e49f8f6efdbf0f9a80859ab0d7fceaac90f23683d5b076add1fadf2744c4428503b457399991095c0ca4a6d5f050cef123c974e8b842bea92335a266b8e9591dddab9f5b6f76e103ea580e4c762571622ec104a87d018ec0c521578a7ddc32f138c58b203360c0d00642397402e75beb905a87dd639447514b7bafdc40e10c29eaf6d2d76862dff1f632ac3b74d7a674155ce3ba956302a1bb7c39dd814634e1af9dbdb672154242dbbf853a5ba3ba1476c1fc32e365bbeb71e4757850014cbf0440f6e320e9bebcab3cfedad9c5e07499c5987244fce8ff45bb0d31e10a8db2cc57ea854a92346e9675379771fed7a5e66360cf197bf7d29781fefce5bb744a7da92b573c3232fcc652f3d63cbeae0a0b5137aed1f764adc3afc96f520b6f762734a223170e731869af7df52a1edce9580840e391b2872f8f492af7513e93750f06639ca87a0b741adad9fe565a84a9f8d70a7b54db1f044b001da9b210944317335cea08610c0457a6b89d2ee655d8276a5cad62c049b21fb33779c09fee4db7698d9c696803d48c2ce0b91cb53fa5b739246901c7c5920ea670bfba039e85d2a570995473ba11a857317fc26f20922a356ee28764b300c804216afce2718684aa8b70cce8efd0acc9c5f6ce6a928503180c8168d79f5a5e2fe4af02932694a9ac153000d8d677ed2a521761f530906be91f44e1d3a764f4197d01b65f6fd69a5bb1a75c585333282576e43ee397fa883a8b3566f2b2c0049baf1dcb728fa767a83c7ec90ca9a81b1d3aa6290e8e2d4069a95e25b43224933492d01ddb2c1d3f6618cc4b7666b075b011b943c9a767a3998612dbb14792eb8e24e15631286013afc6c610c268120082eee1e8de8f881bc04df55033e3d6d22d54718bdcb356d8e27b4cd11895cf9a3cda9139f54fa87e24c2386e39c7055694c0fd83f1f7132101e7b1f759d880d56c657585d9f06cd5b4fa942e83ee91b30b3ff45d98f53fb12bc27d4189f391775318cabb9bc7e90faea7131592acb2798cfbc1b68bb2475a426dcc56fa40bb27c0abac585985bde26cc5f3dd4b4985e62309312db9d0ac60431c13fa064c451024d2319d9780c0fee7022f7be69211b3d6b125133ee0fc32169d460167f6076a3966a7b09c93e8d72d1dd42ff844384d68e8b8f1e169ed402a48329bd6856798c09b47c9df4cc26831e279952b6015f3e78cef715ae616f0f352218d2532aa045ccaf9b44b514d55f6e6919432dc5badf1be2e3553d194124a03e855878f156d64ca4dd9b50d8d75db688f3d11be48ecdfe664beb92d31ab94c8d94b02b4e51212ce51bfab1413123f60ea9f971b30d91ba0332e2f206121a61a667086b2e055304fd24243a0052aa3b3c8217821dc09cf9c7b3296d2ced9b8f006269785370b4b1ec70d36a57581b440c17c10420463f37aafd864fee37e3a3aa94bca7f83fcdd4eb64d2ce9484da1b948da0808721a0a6481477123fce6c9fdebd2d1f373f7690fcb0de05c8be280acc8068215ad3ff5c2e1df24221f5a7634c401ab70327751ab5ad1fc4ca8fa8b8c1d97fb37a43bd58d3509382b40f00945c1e8fa78639a99fed3176d657ad8eef3db3c3d760de1dfc32d0c82ecb0a2c8dda6c6e320857768e3caf18b6f304054a2a5fe2e179690d8e0c7561c4fbb837b63b261431e80581863b20b132087e9afaefaf1709fb710af8a2c22b97c3cd735d9786cad809b963ca35afb4734099e0ebe370bd1994097d7b886585774300f8911b17fba7a4f22f0845f9450498530f2eb438051810221c4d0ea3bfb3fc5db1be13592d2601da9951d26801a5d5acb705e6b97134eee40d14ce563c1070aad30da130e7728561f73afac576f4bb9de21ef23ab88bd8d56f693b03c5f804a90bdcd9bb867ef7b4cdfcdee6235ddb522af4508b491075c16e705f2ab937724ab3e9657343fb500d6fe51aef269259374de1b20fac67ba9440290c27891f6bc114633716dfaeed8ccdb8f89d6c027e7f908c300da18973d132b27d6d7efadef95c4caa9789a3466157455fb69e472438c919d6e4a619f2505585a87fa13b9048cf41cbc72d964c65972e3d5424f89f47422ef4318c01458a57d8ed0e9daff09a98f2e1e930bcad242e68f302a5aeef7cbcf6c1eae5eb501d1766cdacfc1a294aab1438919f38c75d63d1718bed2ee182ac92e6a3165ab5738ba627154f1ec4c36cc4e99172930e7c336821fc2a891e5974b96a206ab5d5612414e8413d7ca6f4479c5e6514f96b97ea4ef97f9b512896cae1fab0ee98ea70b65323c7644c8faaaea4f828759d3cd148847be82656d739b320641936ba8edadd15ee48f233870662a4469eaa367a2186ca067681125a6a4bc0e14e49469ec1ec9048e47112e005c951af09e2eaad4763a8d95b3f64f1048e0fb3459e6cab6a5b571959d02c317b98fb35d47e0c235ace4b7e91fd5a73db891197aeca5604a5fc77dde480a269d4962cb6bc0b97c5f063e7b17bbb2a43b1061ca11f24e49fae7dc0e7dbd6d3640b16e36ff5705e3b9b14f3f8e0235c7f44c5b29878387c483c65150b82cadd98b07fe5016758efe658e8943faf6297e20a2fc857e42b53a9e01ed47a08a0a967dac869e5867a2f0fac5dbdd26c58996b1e640717d00459c1c53919f1750c722d657322a2d42afea2821159e8a29f242e0d878b60a74c8c209bbc755528a0a478300440997656158e6aeae5ceb5b72afdef001eecd522f01051ad2c6fbb786f56df131ab6146ede9f07aaeaceaa8b5af6572fecfdd76d6171cdbd0cdaf07d273de1fe3dc77f31220124ad9accc20c98c09d1a697fa8d6541b23aa441982a3b1992a597b57789ae491ff823f8a5d4b20957bd2342</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>⑧  经验整理类笔记</category>
      </categories>
      <tags>
        <tag>Methods</tag>
      </tags>
  </entry>
  <entry>
    <title>SCI EI 核心期刊以及计算机领域CCF会议等级分类文件</title>
    <url>/2022/03/17/58ef9be2b7d9/</url>
    <content><![CDATA[<h4 id="一sci">一、SCI：</h4>
<p>​ 美国《科学引文索引》，SCI(科学引文索引 )、EI(工程索引
)、ISTP(科技会议录索引 )
是世界著名的三大科技文献检索系统，是国际公认的进行科学统计与科学评价的主要检索工具，其中以SCI最为重要。</p>
<p>​
一般SCI<strong>侧重科学前沿理论</strong>，审核标准严格，发稿周期也比较长。</p>
<h4 id="二ei">二、EI：</h4>
<p>​ 《工程索引》（The Engineering Index,
简称EI）是供查阅<strong>工程技术领域文献</strong>的综合性情报检索刊物。</p>
<p>​ EI的主要特点是摘录质量较高，文摘直接按字顺排列，索引简便实用</p>
<h4 id="三核心期刊">三、核心期刊</h4>
<p>​
在国内简单地说，核心期刊是学术界通过一整套科学的方法，对于期刊质量进行跟踪评价，并以情报学理论为基础，将期刊进行分类定级，把最为重要的一级称之为核心期刊。</p>
<ul>
<li>（1）北京大学图书馆“中文核心期刊”，这个的认可度一般最高。</li>
<li>（2）南京大学“中文社会科学引文索引（CSSCI）来源期刊”。</li>
<li>（3）中国科学院文献情报中心“中国科学引文数据库（CSCD）来源期刊”。</li>
<li>（4）中国科学技术信息研究所“中国科技论文统计源期刊”（又称“中国科技核心期刊”）。</li>
<li>（5）中国社会科学院文献信息中心“中国人文社会科学核心期刊”。</li>
<li>（6）中国人文社会科学学报学会“中国人文社科学报核心期刊”。</li>
</ul>
<h4
id="四中国计算机学会ccf推荐中文科技期刊目录">四、中国计算机学会CCF推荐中文科技期刊目录</h4>
<p>​ <a
href="https://my-blog-fantast.oss-cn-hangzhou.aliyuncs.com/%E4%B8%AD%E5%9B%BD%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%BC%9A%E6%8E%A8%E8%8D%90%E4%B8%AD%E6%96%87%E7%A7%91%E6%8A%80%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95.pdf">点我下载
中国计算机学会推荐中文科技期刊目录PDF</a></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/1123qwdsa.jpg" /></p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/中国计算机学会推荐中文科技期刊目录(1)_页面_3.jpg"
alt="中国计算机学会推荐中文科技期刊目录(1)_页面_3" />
<figcaption
aria-hidden="true">中国计算机学会推荐中文科技期刊目录(1)_页面_3</figcaption>
</figure>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/中国计算机学会推荐中文科技期刊目录(1)_页面_4.jpg"
alt="中国计算机学会推荐中文科技期刊目录(1)_页面_4" />
<figcaption
aria-hidden="true">中国计算机学会推荐中文科技期刊目录(1)_页面_4</figcaption>
</figure>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/中国计算机学会推荐中文科技期刊目录(1)_页面_5.jpg"
alt="中国计算机学会推荐中文科技期刊目录(1)_页面_5" />
<figcaption
aria-hidden="true">中国计算机学会推荐中文科技期刊目录(1)_页面_5</figcaption>
</figure>
<h4
id="五中国计算机学会ccf推荐国际学术会议和期刊目录">五、中国计算机学会CCF推荐国际学术会议和期刊目录</h4>
<p>​ <a
href="https://my-blog-fantast.oss-cn-hangzhou.aliyuncs.com/%E4%B8%AD%E5%9B%BD%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%BC%9A%E6%8E%A8%E8%8D%90%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE%E5%92%8C%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95.pdf">点我下载
中国计算机学会推荐国际学术会议和期刊目录 PDF</a></p>
<p>参考：https://zhuanlan.zhihu.com/p/57932081</p>
]]></content>
      <categories>
        <category>⑧  经验整理类笔记</category>
      </categories>
  </entry>
  <entry>
    <title>字体生成效果评价指标</title>
    <url>/2022/03/16/827639831232/</url>
    <content><![CDATA[<h4
id="一intersection-over-unioniou">一、Intersection-Over-Union（IOU）</h4>
<p>​
计算两个矩形的交并比，通常在检测任务里面可以作为一个检测指标。往往可用于目标检测和语义分割。将预测框与ground
truth框之间的交集比上两者的并集。</p>
<p>​
应用到字体生成任务中，如下所示：img1和img2是参考字体图和生成字体图。由于生成的字体图像像素值很纯粹，所以我们认为
像素值&lt;127的为黑字部分，像素值&gt;=127的为白底部分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compute_iou</span>(<span class="params">img1, img2</span>):</span><br><span class="line">    img1_change = np.where(img1 &lt; <span class="number">127</span>, <span class="number">0</span>, -<span class="number">1</span>)  <span class="comment"># 黑字部分保留，白底部分变为-1，黑字部分统一为0</span></span><br><span class="line">    img2_change = np.where(img2 &lt; <span class="number">127</span>, <span class="number">0</span>, -<span class="number">2</span>)  <span class="comment"># 黑字部分保留，白底部分变为-2，黑字部分统一为0</span></span><br><span class="line">    black_num1 = img1_change[img1_change==<span class="number">0</span>].shape[<span class="number">0</span>] <span class="comment"># 黑字部分的像素数</span></span><br><span class="line">    black_num2 = img2_change[img2_change==<span class="number">0</span>].shape[<span class="number">0</span>] <span class="comment"># 黑字部分的像素数</span></span><br><span class="line">    intersection_num = img1_change[img1_change == img2_change].shape[<span class="number">0</span>] <span class="comment"># img1 和 img2 黑字部分交叉的像素数</span></span><br><span class="line">    total_num = black_num1 + black_num2 - intersection_num <span class="comment"># 总像素数（img1 和 img2 黑字部分并集的像素数）</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;compute_iou:&#x27;</span>, total_num, intersection_num, black_num1, black_num2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> intersection_num / total_num</span><br></pre></td></tr></table></figure>
<h4 id="二rmse">二、RMSE</h4>
<p>​ 均方根误差亦称标准误差, 用 真实值-预测值
然后平方之后求和平均,最后再开根号。 <span class="math display">\[
\sqrt{\frac{1}{m} \sum_{i=1}^m(y_i - \hat y_i)^2  }
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compute_rmse</span>(<span class="params">img1, img2</span>):</span><br><span class="line">    img1 = img1 / <span class="number">255</span></span><br><span class="line">    img2 = img2 / <span class="number">255</span></span><br><span class="line">    mse = np.mean((img1 - img2) ** <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> np.sqrt(mse)</span><br></pre></td></tr></table></figure>
<h4 id="三l1-loss">三、L1 Loss</h4>
<p><span class="math display">\[
\frac{1}{m} \sum_{i=1}^mabs(y_i - \hat y_i)
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compute_l1_loss</span>(<span class="params">img1, img2</span>):</span><br><span class="line">    img1 = img1 / <span class="number">255</span></span><br><span class="line">    img2 = img2 / <span class="number">255</span></span><br><span class="line">    <span class="keyword">return</span> np.mean(np.<span class="built_in">abs</span>(img1 - img2))</span><br></pre></td></tr></table></figure>
<h4 id="四structural-similarityssim">四、<strong>Structural
Similarity</strong>（SSIM）</h4>
<p>​
结构相似性，是一种衡量两幅图像相似度的指标。SSIM使用的两张图像中，一张为未经压缩的无失真图像，另一张为失真后的图像。</p>
<p>​ 给定两个图像x和y , 两张图像的结构相似性可按照以下方式求出：</p>
<p><img
src="https://bkimg.cdn.bcebos.com/formula/cdebeba369b6159f2e3fa5364412f4ff.svg" /></p>
<p>​ 其中<span class="math inline">\(u_x\)</span>是<span
class="math inline">\(x\)</span>的平均值，<span
class="math inline">\(u_y\)</span>是<span
class="math inline">\(y\)</span>的平均值，<span
class="math inline">\(\sigma_x\)</span>是x的方差，<span
class="math inline">\(\sigma_y\)</span>是y的方差，<span
class="math inline">\(\sigma_{xy}\)</span>是x和y的协方差，</p>
<p><span class="math inline">\(c_1=(k_1L)^2\)</span> 和<span
class="math inline">\(c_2=(k_2L)^2\)</span>是用来维持稳定的常数。<span
class="math inline">\(L\)</span>是像素值的动态范围。<span
class="math inline">\(k_1=0.01\)</span>,<span
class="math inline">\(k_2=0.03\)</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage.metrics <span class="keyword">import</span> structural_similarity</span><br><span class="line"></span><br><span class="line">structural_similarity(output_img, target_img)</span><br></pre></td></tr></table></figure>
<h4 id="五peak-signal-noise-ratio-psnr">五、Peak Signal Noise Ratio(
PSNR )</h4>
<p>​
峰值信噪比，是一种评价图像的客观标准，它具有局限性，一般是用于最大值信号和背景噪音之间的一个工程项目。在图像处理中，要对图像进行客观的评价，常常需要计算<em>PSNR。PSNR</em>是衡量图像失真或是噪声水平的客观标准。2个图像之间的PSNR值越大，则越相似。普遍基准为30dB，30dB以下的图像劣化较为明显。</p>
<p>​ 定义： <span class="math display">\[
PSNR = 10log_{10}(\frac{MAX^2}{MSE})
\]</span> ​ MAX表示图像颜色的最大数值，8bit图像最大取值为255</p>
<p>​ MSE为均方差，定义为如下内容： <span class="math display">\[
MSE = \frac{1}{mn}\sum^{n}_{i=1}\sum^{m}_{j=1}||K(i,j)-I(i,j)||^2
\]</span> ​
其中，<strong>I</strong>和<strong>K</strong>分辨是原始图像和处理后的图像，<strong><em>m*n</em></strong>为两图像的大小。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage.metrics <span class="keyword">import</span> peak_signal_noise_ratio</span><br><span class="line"></span><br><span class="line">peak_signal_noise_ratio(output_img, target_img)</span><br></pre></td></tr></table></figure>
<h4 id="六frechet-inception-distance-score-fid">六、Frechet Inception
Distance Score( FID )</h4>
<p>​ Frechet Inception 距离得分（Frechet Inception Distance
score，FID）是计算真实图像和生成图像的<strong>特征向量之间距离的一种度量</strong>。</p>
<p>​ FID
分数被用于评估由生成性对抗网络生成的图像的质量，较低的分数与较高质量的图像有很高的相关性。
<span class="math display">\[
FID = ||u_r - u_g||^2 + T_r(\sum_r + \sum_g = 2(\sum_r\sum_g)^{1/2})
\]</span> ​ <span class="math inline">\(u\)</span>为经验均值，<span
class="math inline">\(\sum\)</span> 为经验协方差，<span
class="math inline">\(T_r\)</span>为矩阵的迹，<span
class="math inline">\(r\)</span>代表真实数据集，<span
class="math inline">\(g\)</span>代表生成数据集。</p>
<p><strong>FID的计算过程为：</strong></p>
<ul>
<li><p>对目标数据集的N张图片使用InceptionV3生成N*2048的向量，取平均值，得到<span
class="math inline">\(u_r\)</span> 。</p></li>
<li><p>对生成的M张图片使用InceptionV3生成M*2048的向量，取平均得到<span
class="math inline">\(u_g\)</span>。</p></li>
<li><p>通过<span class="math inline">\(u_r\)</span> 和 <span
class="math inline">\(u_g\)</span> 得到 <span
class="math inline">\(\sum_r\)</span>和<span
class="math inline">\(\sum_g\)</span>最后得到FID。</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fid</span><br><span class="line"></span><br><span class="line">fid_value = fid.calculate_fid_given_paths([output_dir, target_dir], <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>FID优势：</p>
<blockquote>
<p>1、生成模型的训练集和 Inception V3 的训练集可以不同。 2、计算 FID
时同时用到了生成的数据和真实数据，比起 IS 来更灵活。可以理解成，IS
判断真实性与否，是把生成数据和 ImageNet 数据做比较，而 FID
是把生成数据和训练数据做比较，因此更 reasonable。 3、以优化 FID
为目标，不会产生对抗样本。因为优化的是 lantent space
feature，不是最终的输出图片，不会导致最终的生成图片失真。</p>
</blockquote>
<p>FID 问题：</p>
<blockquote>
<p>1、FID
只是某一层的特征的分布，是否足以衡量真实数据分布与生成数据分布的距离？同时，提出
FID
公式计算的是多元正态分布的距离，显然神经网络提取的特征并不是多元正态分布。
2、针对同一个生成模型，不同框架下预训练的 Inception V3 算出的 FID
差别是否可以忽略？ F3、ID
无法反映生成模型过拟合的情况，如果某个生成模型只是简单拷贝训练数据，FID
会非常小，认为这是一个完美的生成模型，因此，使用 FID
时同时也要通过别的手段证明生成模型没有过拟合。</p>
</blockquote>
<h4 id="七四象限评估">七、四象限评估：</h4>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/%7B58D5EE05-1CD3-1E12-45C6-0A5D78F53358%7D.png"
alt="四象限评估准则" />
<figcaption aria-hidden="true">四象限评估准则</figcaption>
</figure>
<p>​ <strong>D1：</strong>已知内容、已知风格</p>
<p>​ <strong>D2：</strong>未知内容、已知风格</p>
<p>​ <strong>D3：</strong>已知内容、未知风格</p>
<p>​ <strong>D4：</strong>未知内容、未知风格</p>
<p>参考：https://zhuanlan.zhihu.com/p/99375611</p>
]]></content>
      <categories>
        <category>①  项目笔记</category>
        <category>字体生成项目</category>
      </categories>
      <tags>
        <tag>Font Generation</tag>
        <tag>Evaluation</tag>
      </tags>
  </entry>
  <entry>
    <title>2.1 进程与线程的基本概念</title>
    <url>/2022/03/14/32aa5a2632ac/</url>
    <content><![CDATA[<p>笔记课程视频：https://www.bilibili.com/video/BV1YE411D7nH?p=12</p>
<h3 id="一进程的定义组成和组织方式">一、进程的定义、组成和组织方式</h3>
<h4 id="进程的由来">1、进程的由来：</h4>
<p>程序本身其实就是一个指令序列。</p>
<p>早期的计算机只支持单道程序，程序运行时，内存中会分配两块区域：</p>
<ul>
<li>程序段：程序的代码放在程序段内</li>
<li>数据段：程序运行过程处理的数据放在数据段内</li>
</ul>
<p>​ 引入多道程序技术后，内存中需要存放多道程序：</p>
<p>​
<strong>为方便操作系统管理，完成个程序并发执行</strong>，故而操作系统为每个运行的程序配置一个数据结构，被称为<strong>进程控制块（PCB）</strong>，用于描述进程的各种信息（比如该进程程序代码存放位置等）。</p>
<h4 id="进程的定义">2、进程的定义：</h4>
<p>​
<strong>PCB、程序段、数据段</strong>三部分构成了<strong>进程实体</strong>。<strong>所谓创建进程，实质上是创建进程实体中的PCB；</strong>而撤销进程，实质上是撤销进程实体中的PCB。</p>
<p>​ PCB是进程存在的唯一标志。</p>
<p>​
引入进程实体的概念后，可把进程定义为：<strong>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</strong>注：严格来说，进程实体和进程并不一样，进程实体是静态的，进程则是动态的。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220314212804178.png" style="zoom:50%;" /></p>
<h4 id="进程组成">3、进程组成：</h4>
<h5 id="进程由以下三部分组成">1）进程由以下三部分组成：</h5>
<ul>
<li>PCB：进程的管理者所需的数据都在PCB中</li>
<li>程序段：存放要执行的代码</li>
<li>数据段：存放程序运行过程中处理的各种数据</li>
</ul>
<h5 id="pcb结构体中包含如下内容">2）PCB结构体中包含如下内容：</h5>
<ul>
<li>进程描述信息
<ul>
<li>进程标识符PID</li>
<li>用户标识符UID</li>
</ul></li>
<li>进程控制和管理信息
<ul>
<li>进程当前状态</li>
<li>进程优先级</li>
</ul></li>
<li>资源分配清单
<ul>
<li>程序段指针</li>
<li>数据段指针</li>
<li>键盘、鼠标</li>
</ul></li>
<li>处理机相关信息
<ul>
<li>各种寄存器的值</li>
</ul></li>
</ul>
<h4 id="进程的组织多个进程间">4、进程的组织：（多个进程间）</h4>
<h5 id="链接方式">1）链接方式</h5>
<p>按照进程状态将PCB分为多个队列，操作系统持有指向各个队列的指针</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220314221020998.png" alt="进程组织的链接方式" style="zoom: 50%;" /></p>
<h5 id="索引方式">2）索引方式</h5>
<p>​
根据进程状态的不同，建立几张索引表，操作系统持有指向各个索引表的指针</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220314221055019.png" alt="进程组织的索引方式" style="zoom:50%;" /></p>
<h4 id="进程的特征">5、进程的特征：</h4>
<ul>
<li><strong>动态性（最基本特征）</strong>：进程是程序的一次执行过程，是动态地产生、变化和消亡的</li>
<li><strong>并发性：</strong>内存中有多个进程实体，各进程可并发执行</li>
<li><strong>独立性：</strong>进程是能独立运行、独立获得资源、独立接受调度的基本单位</li>
<li><strong>异步性：</strong>各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制"来解决异步问题。异步性可能会导致并发程序执行结果的不确定性。</li>
<li><strong>结构性：</strong>每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成</li>
</ul>
<h3 id="二进程的状态和转换">二、进程的状态和转换</h3>
<h4 id="进程的三种基本状态">1、进程的三种基本状态：</h4>
<h5
id="运行态占用cpu并在cpu上运行">1）运行态：占用CPU，并在CPU上运行。</h5>
<p>​
注意：单核处理机环境下，每一时刻最多见有一个进程处于运行态。（双核环境下可以同时有两个进程处于运</p>
<p>行态）。</p>
<h5
id="就绪态已经具备运行条件但由于没有空闲cpu而暂时不能运行">2）就绪态：已经具备运行条件，但由于没有空闲CPU，而暂时不能运行</h5>
<p>​
进程已经拥有了除处理机之外所有需要的资源，一旦获得处理机，即可立即进入运行态开始运行。
即：万事俱备，只欠CPU即：万事俱备，只欠CPU</p>
<h5
id="阻塞态因等待某一事件而暂时不能运行">3）阻塞态：因等待某一事件而暂时不能运行</h5>
<p>​
如：等待操作系统分配打印机、等待读磁盘操作的结果。CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将其他进程需要的资源分配到位，才能得到CPU的服务</p>
<h4 id="进程的另外两种状态">2、进程的另外两种状态：</h4>
<h5
id="创建态进程正在被创建操作系统为进程分配资源初始化pcb进程正在被创建操作系统为进程分配资源初始化pcb">1）创建态：进程正在被创建，操作系统为进程分配资源、初始化PCB进程正在被创建，操作系统为进程分配资源、初始化PCB</h5>
<p>​
操作系统需要完成创建进程。操作系统为该进程分配所需的内存空间等系统资源，并为其创建、初始化PCB（如：为进程分配PID）</p>
<h5
id="终止态进程正在从系统中撤销操作系统会回收进程拥有的资源撤销pcb进程正在从系统中撤销操作系统会回收进程拥有的资源撤销pcb">2）终止态：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB</h5>
<p>​
进程运行结束（或者由于bug导致进程无法继续执行下去，比如数组越界错误），需要撤销进程。操作系统需要完成撤销进程相关的工作。完成将分配给进程的资源回收，撤销进程PCB等工作</p>
<h4 id="进程状态的转换">2、进程状态的转换：</h4>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220314223023656.png"
alt="进程状态转换图" />
<figcaption aria-hidden="true">进程状态转换图</figcaption>
</figure>
<ul>
<li><p>运行态→阻塞态是一种进程自身做出的<strong>主动行为</strong></p></li>
<li><p>阻塞态→就绪态是不是进程自身能控制的，是一种<strong>被动行为</strong>。</p></li>
<li><p>注意：<strong>不能由阻塞态直接转换为运行态</strong>，<strong>也不能由就绪态直接转换为阻塞态</strong>（因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求）</p></li>
</ul>
<h3 id="三进程控制">三、进程控制</h3>
<h4 id="什么是进程控制">1、什么是进程控制：</h4>
<p>​
进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。</p>
<h4 id="如何实现进程控制">2、如何实现进程控制：</h4>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220314223828760.png" style="zoom:50%;" /></p>
<ul>
<li>创建进程：需要初始化PCB、分配系统资源</li>
<li>创建态→就绪态：需修改PCB内容和相应队列</li>
<li>就绪态→运行态：需恢复进程运行环境、修改PCB内容和相应队列</li>
<li>运行态→阻塞态：需保存进程运行环境、修改PCB内容和相应队列</li>
<li>阻塞态→就绪态：需修改PCB内容和相应队列。如果等待的是资源，则还需为进程分配系统资源</li>
<li>运行态→就绪态：（进程切换）需保存进程运行环境、修改PCB内容和相应队列</li>
<li>运行态→终止态：需回收进程拥有的资源，撤销PCB的资源，撤销PCB</li>
</ul>
<p>​
为了使得进程状态切换中，数据具有一致性（类似于事务的概念），用<strong>原语</strong>实现进程控制。原语的特点是执行期间不允许中断，只能一气呵成。</p>
<p><strong>这种不可被中断的操作即原子操作。</strong></p>
<p><strong>原语采用“关中断指令”和“开中断指令”实现，如下所示</strong>：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220314224013167.png" alt="" style="zoom: 67%;" /></p>
<p>​
当在关中断指令执行后，如果系统收到外部中断信号，此时会将该信号转至开中断指令结束后再进行处理，即再开中断指令执行结束后，才会启动中断处理程序。如此，原语部分的代码就不会被打断执行。</p>
<p>​
显然，<strong>关/开中断指令的权限非常大，必然是只允许在核心态下执行的特权指令</strong></p>
<p>​</p>
<h4 id="原语的具体操作">3、原语的具体操作：</h4>
<h5
id="进程控制会导致进程状态的转换无论哪个原语要做的无非三类事情">进程控制会导致进程状态的转换。无论哪个原语，要做的无非三类事情：</h5>
<ul>
<li>1.更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境）
<ul>
<li>a.所有的进程控制原语一定都会修改进程状态标志</li>
<li>b.剥夺当前运行进程的CPU使用权必然需要保存其运行环境</li>
<li>c.某进程开始运行前必然要恢复期运行环境</li>
</ul></li>
<li>2.将PCB插入合适的队列</li>
<li>3.分配/回收资源</li>
</ul>
<h5 id="创建原语无创建态就绪态">1）创建原语：（无→创建态→就绪态）</h5>
<p>申请空白PCB、为新进程分配所需资源、初始化PCB、将PCB插入就绪队列</p>
<h5 id="能够引起进程创建的事件如下">能够引起进程创建的事件如下：</h5>
<ul>
<li>用户登录：分时系统中，用户登录成功，系统会建立为其建立一个新的进程</li>
<li>作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程引起进程创建的事件
l引起进程创建的事件</li>
<li>提供服务：用户向操作系统提出某些请求时，会新建一个进程处理该请求</li>
<li>应用请求：由用户进程主动请求创建一个子进程</li>
</ul>
<h5
id="撤销原语就绪态阻塞态运行态终止态无">2）撤销原语：（就绪态/阻塞态/运行态→终止态→无）</h5>
<p>​
从PCB集合中找到终止进程的PCB，若进程正在运行，立即剥夺CPU，将CPU分配给其他进程。终止其所有子进程，将该进程拥有的所有资源归还给父进程或操作系统。删除PCB</p>
<h5 id="能够引起进程撤销的事件如下">能够引起进程撤销的事件如下：</h5>
<ul>
<li>正常结束</li>
<li>异常结束</li>
<li>外界干预</li>
</ul>
<h5 id="阻塞原语运行态阻塞态">3）阻塞原语：（运行态→阻塞态）</h5>
<p>​
找到要阻塞的进程对应的PCB，保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行，将PCB插入相应事件的等待队列。</p>
<p><strong>能够引起进程阻塞的事件如下：</strong></p>
<ul>
<li>需要等待系统分配某种资源</li>
<li>需要等待相互合作的其他进程完成工作</li>
</ul>
<h5 id="唤醒原语阻塞态运行态">4）唤醒原语：（阻塞态→运行态）</h5>
<p>​
在事件等待队列中找到PCB，将PCB从等待队列移除，设置进程为就绪态，将PCB插入就绪队列，等待被调度</p>
<p><strong>能够引起进程唤醒的事件如下：</strong></p>
<ul>
<li>正在等待的事件发生（因何事阻塞，就应当由何事唤醒，需与阻塞原语成对使用）</li>
</ul>
<h5
id="切换原语运行态阻塞态就绪态-或-就绪态运行态">5）切换原语：（运行态→阻塞态/就绪态
或 就绪态→运行态）</h5>
<p>​
将运行环境信息存入PCB，PCB移入相应队列。选择另一个进程执行，并更新其PCB，根据PCB恢复新进程所需的运行环境</p>
<p><strong>能够引起进程切换的事件如下：</strong></p>
<ul>
<li>当前进程时间片到</li>
<li>有更高优先级的进程到达</li>
<li>当前进程主动阻塞</li>
<li>当前进程终止</li>
</ul>
<h3 id="四进程通信">四、进程通信：</h3>
<h4 id="什么是进程通信">1、什么是进程通信？</h4>
<p>​
进程通信就是指进程之间的信息交换。进程是分配系统资源的单位（包括内存地址空间），因此<strong>各进程拥有的内存地址空间相互独立。</strong>进程1可以访问进程1的地址空间，但不能直接访问进程2的地址空间。</p>
<p>​
<strong>为了保证安全，一个进程不能直接访问另一个进程的地址空间，但是进程之间的信息交换是必须实现的，为了保证进程间的安全通信，操作系统提供了一些方法就是进程通信</strong></p>
<h4 id="进程通信共享存储-方法">2、进程通信——共享存储 方法</h4>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315171055164.png" alt="共享存储" style="zoom: 67%;" /></p>
<p>​
两个进程对共享空间的访问必须是互斥的（互斥访问通过操作系统提供的工具实现）。</p>
<p>​ 操作系统只负责提供共享空间和同步互斥工具（如P、V操作）</p>
<p>​ <strong>其又有两种方式</strong>：</p>
<ul>
<li><p>基于数据结构的共享</p>
<p>​
基于数据结构的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式<strong>速度慢、限制多，是一种低级通信方式</strong></p></li>
<li><p>基于存储区的共享</p>
<p>​
基于存储区的共享：在内存中画出一块共享存储区，<strong>数据的形式、存放位置都由进程控制，而不是操作系统。</strong>相比之下，这种共享方式<strong>速度更快，是一种高级通信方式。</strong></p></li>
</ul>
<h4 id="进程通信管道通信-方法">3、进程通信——管道通信 方法</h4>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315171447871.png"
alt="管道通信" />
<figcaption aria-hidden="true">管道通信</figcaption>
</figure>
<p>​
“管道”是指用于连接读写进程的一个共享文件，又名pipe程的一个共享文件，又名pipe
文件。其实就是<strong>在内存中开辟一个大小固定的缓冲区 </strong></p>
<ul>
<li>管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。</li>
<li>各个进程需要互斥的访问管道</li>
<li>数据以字符流的形式写入管道，<strong>当管道写满时，写进程的write（）系统调用将被阻塞</strong>，等待读进程将数据取走。<strong>当读进程将数据全部取走后，管道变空，此时读进程的read（）系统调用将被阻塞。</strong></li>
<li><strong>如果没写满，就不允许读。如果没读空，就不允许写。</strong></li>
<li><strong>数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情</strong></li>
</ul>
<h4 id="进程通信消息传递-方法">4、进程通信——消息传递 方法</h4>
<p>​
进程间的数据交换<strong>以格式化的消息（Message）为单位</strong>。进程通过操作系统提供的<strong>“发送消息/接收消息”两个原语进行数据交换</strong>。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315180227145.png" /></p>
<p>​
消息头包括：发送进程ID、接受进程ID、消息类型、消息长度等格式化的信息</p>
<p>​ 每个进程都会有一个消息缓冲队列：消息传递有以下两种方式：</p>
<ul>
<li>直接通信方式: 消息直接挂到接受进程的消息缓冲队列上
<ul>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315180138885.png" /></li>
</ul></li>
<li>间接通信方式：消息先发送到中间实体中
<ul>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315180217571.png" /></li>
</ul></li>
</ul>
<h3 id="五线程概念和多线程模型">五、线程概念和多线程模型：</h3>
<h4 id="什么是线程">1、什么是线程？</h4>
<p>​ 在传统的机制中，<strong>进程是程序执行流的最小单位。</strong></p>
<p>​
<strong>有的进程</strong>可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度。</p>
<p>​
一个进程中，被分为多个线程。CPU轮流为不同的线程服务。故而，引入线程后，<strong>线程是程序执行流的最小单位。</strong></p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315180730244.png" style="zoom:67%;" /></p>
<p>​</p>
<p><strong>官方定义：线程是一个基本的CPU执行单元，也是程序执行流的最小单位。</strong></p>
<p>​
引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务</p>
<p>​
引入线程后，<strong>进程只作为除CPU之外的系统资源的分配单元</strong>（如打印机、内存地址空间等都是分配给进程的），<strong>线程才是CPU的执行单元</strong>（而CPU是分配给不同的线程的）</p>
<p>​ <img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315181019487.png"
alt="引入线程后的变化" /></p>
<h4 id="线程的属性">2、线程的属性：</h4>
<ul>
<li>线程是处理机调度的单位</li>
<li>多CPU计算机中，各个线程可占用不同的CPU</li>
<li>每个线程都有一个线程ID、线程控制块（TCB）</li>
<li>线程也有就绪、阻塞、运行三种基本状态</li>
<li>线程几乎不拥有系统资源</li>
<li><strong>同一进程的不同线程间共享进程的资源（例如打印机等）</strong></li>
<li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li>
<li>同一进程中的线程切换，不会引起进程切换</li>
<li>不同进程中的线程切换，会引起进程切换</li>
<li>切换同进程内的线程，系统开销很小</li>
<li>切换进程，系统开销较大</li>
</ul>
<h4 id="线程的实现方式">3、线程的实现方式：</h4>
<h5 id="用户级线程">1）用户级线程：</h5>
<p>​ 用户级线程由应用程序通过线程库实现。</p>
<p>​
所有的线程管理工作都<strong>由应用程序负责（包括线程切换）</strong></p>
<p>​ 用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。</p>
<p>​
<strong>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。</strong>（用户级线程对用户不透明，对操作系统透明）</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315181528334.png" alt="用户级线程" style="zoom: 67%;" /></p>
<h5 id="内核级线程">2）内核级线程：</h5>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315181555209.png" alt="内核级线程" style="zoom:67%;" /></p>
<p>​ 核级线程的管理工作由操作系统内核完成。</p>
<p>​
线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。</p>
<h5 id="两者组合">3）两者组合：</h5>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315181640824.png" alt="" style="zoom:67%;" /></p>
<p>​
在同时支持用户级线程和内核级线程的系统中，可采用二者组合的方式：将n个用户级线程映射到m
个内核级线程上（n&gt;=m）</p>
<p>​
重点：<strong>操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。</strong></p>
<p>​
例如：左边这个模型中，该进程由两个内核级线程，三个用户级线程，在用户看来，这个进程中有三个线程。但即使该进程在一个4核处理机的计算机上运行，<strong>也最多只能被分配到两个核，最多只能有两个用户线程并行执行。</strong></p>
<h4 id="多线程模型">4、多线程模型：</h4>
<p>​
在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型”问题。</p>
<h5 id="多对一模型">1）多对一模型：</h5>
<p>​
多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315182055006.png" style="zoom:67%;" /></p>
<p>​
<strong>优点：</strong>用尸级线程的切换在用尸空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</p>
<p>​
<strong>缺点：</strong>当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</p>
<h5 id="一对一模型">2）一对一模型：</h5>
<p>​
一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315182003606.png" alt="一对一模型" style="zoom:67%;" /></p>
<p>​
<strong>优点</strong>：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</p>
<p>​
<strong>缺点</strong>：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</p>
<h5 id="多对多模型">3）多对多模型：</h5>
<p>​
n用户及线程映射到m个内核级线程（n&gt;=m）。每个用户进程对应m个内核级线程。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315182148042.png" style="zoom:67%;" /></p>
<p>​
克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p>
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>__call__方法</title>
    <url>/2022/03/12/6c6b30d1f672/</url>
    <content><![CDATA[<p>​
Python的一个特殊的实例方法<code>__call__</code>，功能类似于在类中重载()运算符，使得类实例对象可以像调用普通函数那样进行使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">    <span class="comment"># 定义__call__方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self,name,add</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;调用__call__()方法&quot;</span>,name,add)</span><br><span class="line">clangs = CLanguage()</span><br><span class="line">clangs(<span class="string">&quot;C test&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>通过在 CLanguage 类中实现<code>__call__</code>方法，使得 clangs
实例对象变为了可调用对象。</p>
]]></content>
      <categories>
        <category>⑤  编程语言类笔记</category>
        <category>Python基础扩充笔记</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch学习笔记11——torchvision图像数据预处理</title>
    <url>/2022/03/12/796f9da33963/</url>
    <content><![CDATA[<h3 id="一torchvision简介">一、TorchVision简介：</h3>
<p>torchvision 是Pytorch中专门用来处理图像的库。这个包中有四个大类。</p>
<ul>
<li><p>torchvision.datasets
包含了很多提前处理好的数据集：如COCO、ImageNet等</p></li>
<li><p>torchvision.models
包含了已经训练好的模型，可以加载后直接用：如AlexNet、VGG等</p></li>
<li><p>torchvision.transforms 包含一般的图像转换操作类
如归一化、展平</p></li>
<li><p>torchvision.utils</p></li>
</ul>
<h3 id="二transforms的一些函数">二、Transforms的一些函数：</h3>
<h4
id="transforms.normalizemeanstdinplacefalse">1、transforms.Normalize(mean,std,inplace=False)</h4>
<ul>
<li>mean:各通道的均值</li>
<li>std：各通道的标准差</li>
<li>inplace：是否原地操作</li>
</ul>
<p>一般可以如下传入mean和std:代表我要将数据归约化至如下的均值和方差的分布</p>
<p><code>mean = (0.5,0.5,0.5) std = (0.5,0.5,0.5)</code></p>
<p>该函数就是通过以下公式，对图像3个通道分别依据输入的mean和std进行归约化。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">x = (x - mean) / std</span><br></pre></td></tr></table></figure>
<p>最终得到新的数据。整体过程如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line">mean = (<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>) </span><br><span class="line">std = (<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>)`</span><br><span class="line">new_data = transforms.Normalize(mean, std)(data)</span><br></pre></td></tr></table></figure>
<p>可以看到：其实 transforms.Normalize(mean, std)
只是指定了一个函数，所以还可以如下操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line">mean = (<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>) </span><br><span class="line">std = (<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>)`</span><br><span class="line">normalize = transforms.Normalize(mean=mean, std=std)</span><br><span class="line">new_data = normalize(data)</span><br></pre></td></tr></table></figure>
<h4 id="transforms.totensor">2、transforms.ToTensor()</h4>
<p>该函数有两个功能：</p>
<ol type="1">
<li>是将输入的数据改变Shpae，图像数据本身是三维的： W，H，C
，该函数会将其变成 C，W，H的维度</li>
<li>将所有数除以255，将像素数据归一化到<code>[0,1]</code></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(data.shape)   <span class="comment">#（5，5，3）</span></span><br><span class="line">data = transforms.ToTensor()(data)</span><br><span class="line"><span class="built_in">print</span>(data.shape)	<span class="comment">#（3，5，5）</span></span><br></pre></td></tr></table></figure>
<p>和Normalize函数一样：也可以按照如下方法使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">toTensor = transforms.ToTensor()</span><br><span class="line">data = toTensor(data)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Pytorch系列笔记</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>1.1 操作系统概念与基础</title>
    <url>/2022/03/11/b7e4aac04426/</url>
    <content><![CDATA[<h3 id="一概念功能与目标">一、概念功能与目标</h3>
<h4 id="概念">1、概念</h4>
<p>操作系统（Operating
System，OS）是指控制和管理<strong>整个计算机系统的硬件和软件资源</strong>，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的<strong>系统软件</strong>。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220311205142106.png" style="zoom: 67%;" /></p>
<p>较为直观的例子：Windows的任务管理器</p>
<h4 id="功能与目标">2、功能与目标：</h4>
<h5 id="系统资源的管理者">1) 系统资源的管理者：</h5>
<p>提供4个功能：</p>
<ul>
<li>CPU管理</li>
<li>存储器管理（内存&amp;外存）</li>
<li>文件管理</li>
<li>硬件设备管理</li>
</ul>
<p>目标：安全 + 高效</p>
<h5
id="作为用户和计算机硬件之间的接口">2）作为用户和计算机硬件之间的接口：</h5>
<p>提供3个功能：</p>
<ul>
<li>命令接口
<ul>
<li>联机命令接口（交互式命令接口）：用户说一句，系统做一句。比如win中的<code>cmd</code>命令解释器</li>
<li>脱机命令接口（批处理命令接口）：用户说一堆，系统做一堆。win中的<code>*.bat</code>文件执行</li>
</ul></li>
<li>程序接口
<ul>
<li>如win中，程序员在程序中调用<code>*.dll</code>（该调用过程即为<strong>系统调用</strong>）可以实现某些功能。这类接口只能通过用户程序<strong>间接使用</strong></li>
</ul></li>
<li>GUI图形用户界面
<ul>
<li>删除文件：拖拽至回收站</li>
</ul></li>
</ul>
<h5 id="作为最接近硬件的层次">3） 作为最接近硬件的层次：</h5>
<p>需要实现堆硬件机器的拓展，没有任何软件支持的计算机称为<strong>裸机</strong>。</p>
<p>通常把覆盖了软件的机器成为<strong>扩充机器</strong>，又称之为<strong>虚拟机</strong></p>
<h3 id="二操作系统的特征">二、操作系统的特征</h3>
<h4 id="并发最基本的特征之一">1、并发（最基本的特征之一）</h4>
<p>​
指两个或多个事件在同一时间间隔内发生。<strong>这些事件宏观上是同时发生的，但微观上是交替发生的。</strong></p>
<p>​
操作系统的并发性指<strong>计算机系统中同时存在着多个运行着的程序</strong>。</p>
<p>​
一个单核处理机（CPU）同一时刻只能执行一个程序，因此<strong>操作系统会负责协调多个程序交替执行（这些程序微观上是交替执行的，但宏观上看起来就像在同时执行）</strong></p>
<p>​
我们现在的4核CPU处理器，意味着同一时刻可以有4个程序<strong>并行</strong>执行，但是操作系统的<strong>并发性</strong>必不可少。</p>
<h4 id="共享最基本的特征之二">2、共享（最基本的特征之二）</h4>
<p>​
资源共享，是指<strong>系统中的资源可供内存中多个并发执行的进程共同使用。</strong></p>
<ul>
<li>互斥共享方式：系统中的<strong>某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源。</strong>比如说：使用QQ和微信视频，<strong>同一时间段摄像头只能分配给其中一个进程。</strong></li>
<li>同时共享方式：系统中的某些资源，允许一个时间段内由多个进程<strong>“同时”</strong>对它们进行访问。比如说：使用QQ发送文件A，同时使用微信发送文件B。<strong>宏观上看，两边都在同时读取并发送文件，</strong>说明两个进程都在访问硬盘资源，从中读取数据。<strong>微观上看，两个进程是交替着访问硬盘的。</strong></li>
</ul>
<h4 id="虚拟">3、虚拟</h4>
<p>​
虚拟是指<strong>把一个物理上的实体变为若干个逻辑上的对应物</strong>：物理实体（前者）是实际存在的，而<strong>逻辑上对应物（后者）是用户感受到的。</strong></p>
<h5 id="虚拟技术">1）虚拟技术</h5>
<ul>
<li><p>空分复用技术：如虚拟存储器技术</p></li>
<li><p>时分复用技术：如虚拟处理器</p></li>
<li><p>问题1：GTA5需要4GB的运行内存，QQ需要256MB的内存，迅雷需要256MB的内存，网易云音乐需要256MB的内存……而我的电脑只有4GB内存，这些程序同时运行需要的内存远大于4GB，那么为什么它们还可以在我的电脑上同时运行呢？</p></li>
<li><p>答：这是虚拟存储器技术。实际只有4GB的内存，在用户看来似乎远远大于4GB。<strong>即空分复用技术</strong></p></li>
<li><p>问题2：既然一个程序需要被分配CPU才能正常执行，那么为什么单核CPU的电脑中能同时运行这么多个程序呢？</p></li>
<li><p>答：这是虚拟处理器技术。实际上只有一个单核CPU，在用户看来似乎有6个CPU在同时为自己服务。<strong>即时分复用技术</strong></p></li>
</ul>
<h4 id="异步">4、异步</h4>
<p>​
异步是指，在多道程序环境下，允许多个程序并发执行，<strong>但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，</strong>这就是进程的异步性。</p>
<h3 id="三操作系统的发展与分类">三、操作系统的发展与分类：</h3>
<h4 id="手工操作阶段">1、手工操作阶段：</h4>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313105737330.png"
alt="手工操作阶段" />
<figcaption aria-hidden="true">手工操作阶段</figcaption>
</figure>
<p><strong>主要缺点：</strong>用户独占全机、人机速度矛盾导致资源利用率极低</p>
<h4 id="批处理阶段">2、批处理阶段：</h4>
<h5 id="单道批处理系统">1）单道批处理系统</h5>
<p>​
引入脱机输入输出技术（用磁带完成），并由监督程序负责控制作业的输入输出。</p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313110520259.png"
alt="单道批处理系统" />
<figcaption aria-hidden="true">单道批处理系统</figcaption>
</figure>
<p><strong>主要优点：</strong>缓解了一定程度的人机速度矛盾，资源利用率有所提升。</p>
<p><strong>主要缺点：</strong>内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序。CPU有大量的时间是在空闲等待l/0完成。资源利用率依然很低。</p>
<h5 id="多道批处理系统">2）多道批处理系统</h5>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313110759912.png"
alt="多道批处理系统" />
<figcaption aria-hidden="true">多道批处理系统</figcaption>
</figure>
<p><strong>主要优点：</strong>多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源保持“忙碌”状态，系统吞吐量增大。</p>
<p><strong>主要缺点：</strong>用户响应时间长，没有人机交互功能（用户提交自己的作业（程序）之后就只能等待计算机处理完成，中间不能控制自己的作业执行）</p>
<h4 id="分时操作系统">3、分时操作系统：</h4>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313111132639.png"
alt="分时操作系统" />
<figcaption aria-hidden="true">分时操作系统</figcaption>
</figure>
<p>​
计算机以<strong>时间片</strong>（例如50ms）为单位<strong>轮流为各个用户/作业服务</strong>，各个用户可通过终端与计算机进行交互。</p>
<p><strong>王要优点：用户请求可以被即时响应，群决了人机交互问题。</strong>允许多个用尸同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</p>
<p><strong>主要缺点：</strong>不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的，循环地为每个用户作业服务一个时间片，<strong>不区分任务的紧急性</strong>。</p>
<h4 id="实时操作系统">4、实时操作系统：</h4>
<ul>
<li>硬实时系统：必须在绝对严格的规定时间内完成处理（如导弹控制系统、自动驾驶等）</li>
<li>软实时系统：能接受偶尔违反时间规定</li>
</ul>
<p>主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。</p>
<p>在实时操作系统的控制下，计算机系统接收到外部信号后<strong>及时进行处理</strong>，并且要在严格的时限内处理完事件。实时操作系统的主要特点是<strong>及时性和可靠性</strong></p>
<h4 id="其他操作系统">5、其他操作系统：</h4>
<ul>
<li>网络操作系统：是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信。（如：Windows
NT就是一种典型的网络操作系统，网站服务器就可以使用）</li>
<li>分布式操作系统：主要特点是<strong>分布性和并行性</strong>。系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务。</li>
<li>个人计算机操作系统：如WindowsXP、MacOs，方便个人使用。</li>
</ul>
<h3 id="四操作系统的运行机制">四、操作系统的运行机制：</h3>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313111750626.png"
alt="“指令”和&quot;代码&quot;的区别" />
<figcaption aria-hidden="true">“指令”和"代码"的区别</figcaption>
</figure>
<h4 id="两种指令">1、两种指令：</h4>
<h5 id="特权指令如内存清零指令不允许用户程序使用">1）
特权指令：如内存清零指令，不允许用户程序使用</h5>
<h5 id="非特权指令如普通的运算指令">2）
非特权指令：如普通的运算指令</h5>
<h4 id="两种处理器状态">2、两种处理器状态：</h4>
<p>用于判断当前是否可以执行特权指令</p>
<h5 id="用户态目态只能执行非特权指令">1）
用户态（目态）：只能执行非特权指令</h5>
<h5 id="核心态管态两种指令都可以执行">2）
核心态（管态）：两种指令都可以执行</h5>
<h4 id="两种程序">3、两种程序：</h4>
<h5 id="内核程序">1）内核程序：</h5>
<p>​
操作系统的内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态。</p>
<h5 id="应用程序">2）应用程序：</h5>
<p>​
为了保证系统能安全运行，普通应用程序只能执行非特权指令，运行在用户态</p>
<h3 id="五操作系统内核">五、操作系统内核：</h3>
<h4 id="内核总览示意图">1、内核总览示意图：</h4>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313112448980.png"
alt="计算机系统的层次结构" />
<figcaption aria-hidden="true">计算机系统的层次结构</figcaption>
</figure>
<p>​ <strong>原子性</strong>指该程序在开始执行后，中间不能被中断。</p>
<p>​
内核是计算机上配置的底层软件，是操作系统最基本、最核心的部分。实现操作系统内核功能的那些程序就是内核程序。</p>
<h4 id="操作系统的体系结构">2、操作系统的体系结构：</h4>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313112907278.png" /></p>
<h5 id="大内核">1） 大内核：</h5>
<p>将操作系统的主要功能模块都作为系统内核，运行在核心态</p>
<p>优点：高性能</p>
<p>缺点：内核代码庞大，结构混乱，难以维护</p>
<h5 id="微内核">2）微内核：</h5>
<p>只把最基本的功能保留在内核</p>
<p>优点：内核功能少，结构清晰，方便维护</p>
<p>缺点：需要频繁地在核心态和用户态之间切换，性能低</p>
<h3 id="六中断和异常">六、中断和异常：</h3>
<h4 id="中断机制的诞生缘由">1、中断机制的诞生缘由：</h4>
<p>​
早期计算机各个程序只能串行执行程序，系统资源利用率会较低。为了解决该问题，就发明了操作系统，引入中断机制，实现了多道程序的并发执行。</p>
<p><strong>本质</strong>：
发生中断，就意味着需要操作系统接入，进行管理.具体如下:</p>
<p>​
我们假设3个进程同时放入内存中进行执行,首先CPU执行进程1,一段时间后,CPU收到计时硬件发出的中断信号,就会切换至<strong>核心态</strong>,CPU知晓进程1的时间片已经用完了,就切换进程2运行.完成该系列操作后,CPU又会切换至<strong>用户态</strong>,然后开始运行进程2,在进程2运行过程中,进程2发出<strong>系统调用(内中断信号)</strong>,请求输出.<strong>(由于输入输出是特权指令,普通程序不能直接调用,只能通过向操作系统申请,即主动发出中断信号)</strong>,此时CPU将切换到<strong>核心态</strong>,<strong>由操作系统内核进行接管</strong>,负责执行输出内容,比如其让打印机IO设备开始工作,<strong>此时进程2就需要暂停运行等待IO完成,故而操作系统此时让进程3先运行</strong>.CPU重新切换为<strong>用户态,</strong>执行进程3.在CPU执行进程3的过程中,IO也在同步进行,当IO完成时,IO设备(打印机)就会向CPU发出中断信号,CPU收到IO设备发来的中断信号,又会切换至<strong>核心态</strong>,<strong>交由操作系统内核进行处理</strong>.此时,操作系统发现是进程2的IO结束了,就会让进程2恢复运行,CPU切换为用户态.进程2继续完成内容.</p>
<h4 id="中断的概念和作用">2、中断的概念和作用：</h4>
<ul>
<li>当中断发生时，CPU立即进入核心态</li>
<li>当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理</li>
<li>对于不同的中断信号，会进行不同的处理</li>
</ul>
<p>​
发生了中断，就意味着需要<strong>操作系统介入，开展管理工作。</strong>由于操作系统的管理工作（比如进程切换、分配I/O设备等）需要使用特权指令，因此CPU要从<strong>用户态转为核心态</strong>。<strong>中断可以使CPU从用户态切换为核心态，使操作系统获得计算机的控制权。</strong>
<strong>有了中断，才能实现多道程序并发执行。</strong></p>
<p><strong>用户态</strong>到<strong>核心态</strong>的切换是通过<strong>中断</strong>实现的，并且中断是唯一途径。</p>
<p><strong>核心态</strong>到<strong>用户态</strong>的切换是通过<strong>执行一个特权指令，将PSW标志位设置</strong>实现的。</p>
<h4 id="中断的分类">3、中断的分类:</h4>
<p>两者的本质区别：
信号的来源是CPU内部还是CPU外部。与当前的执行的指令是否有关</p>
<h5
id="内中断异常例外陷入-来源于cpu内部与当前执行的指令有关">1）内中断（异常、例外、陷入）：
来源于CPU内部，与当前执行的指令有关</h5>
<ul>
<li>指令中断：系统调用</li>
<li>强迫中断
<ul>
<li>硬件故障</li>
<li>软件中断（如整数除0）</li>
</ul></li>
</ul>
<h5
id="外中断来源于cpu外部与当前执行的指令无关">2）外中断：来源于CPU外部，与当前执行的指令无关</h5>
<ul>
<li>外设请求：I/0操作完成发出的中断信号</li>
<li>人工干预：用户强行终止一个进程</li>
</ul>
<p>另一种分类：</p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313130033093.png"
alt="另一种中断的分类" />
<figcaption aria-hidden="true">另一种中断的分类</figcaption>
</figure>
<h4 id="外中断的处理过程">4、外中断的处理过程：</h4>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313130249004.png"
alt="外中断的处理过程" />
<figcaption aria-hidden="true">外中断的处理过程</figcaption>
</figure>
<ul>
<li>Step1：执行完每个指令之后，CPU都要检查当前是否有外部中断信号</li>
<li>Step2：如果检测到外部中断信号，则需要保护被中断进程的CPU环境（如程序状态字PSW、程序计数器PC、各种通用寄存器)</li>
<li>Step3：根据中断信号类型转入相应的中断处理程序</li>
<li>Step 4：恢复原进程的CPU环境并退出中断，返回原进程继续往下执行</li>
</ul>
<h3 id="七系统调用">七、系统调用：</h3>
<h4 id="什么是系统调用">1、什么是系统调用：</h4>
<p>​
操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由<strong>一组系统调用组成</strong>。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313141435648.png" /></p>
<p>​
“系统调用”是<strong>操作系统提供给应用程序</strong>（程序员/编程人员)使用的接口，可以理解为一种<strong>可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务</strong>。</p>
<p>​</p>
<h4 id="系统调用有什么作用">2、系统调用有什么作用？</h4>
<p>​
<strong>应用程序通过系统调用请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。</strong></p>
<p><strong>系统调用</strong>会使得处理器从<strong>用户态</strong>进入<strong>核心态</strong>。</p>
<h4 id="系统调用分类">3、系统调用分类：</h4>
<p>​
系统调用相关处理涉及到对系统资源的管理、对进程的控制，这些功能需要执行一些特权指令才能完成，因此系统调用的相关处理需要在核心态下进行。</p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313142304849.png"
alt="系统调用分类" />
<figcaption aria-hidden="true">系统调用分类</figcaption>
</figure>
<h4 id="系统调用与库函数的区别">4、系统调用与库函数的区别：</h4>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313142453847.png" style="zoom:50%;" /></p>
<p>从下层至上层如下：</p>
<ul>
<li><strong>裸机</strong></li>
<li><strong>操作系统</strong>：向上提供系统调用</li>
<li><strong>编程语言</strong>：向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使上层进行系统调用更加方便。</li>
<li><strong>普通应用程序</strong>：可直接进行系统调用，也可使用库函数。</li>
</ul>
<p>注意：有的库函数涉及系统调用，有的不涉及</p>
<h4 id="系统调用背后的过程">5、系统调用背后的过程：</h4>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313142828536.png"
alt="系统调用背后的过程" />
<figcaption aria-hidden="true">系统调用背后的过程</figcaption>
</figure>
<p><code>int x</code>指令的参数x，指明了系统调用号。此处的int是interrupt的缩写，执行该指令后，权限就交给了操作系统来接管，切换至核心态处理系统调用相关代码。</p>
<p><strong>注意：</strong></p>
<p>1.陷入指令是在<strong>用户态执行的</strong>，执行陷入指令之后立即引发一个内中断，从而CPU进入核心态
2.<strong>发出系统调用请求是在用户态</strong>，而对系统调用的相应处理在核心态下进行
3.<strong>陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令</strong></p>
]]></content>
      <categories>
        <category>⑥  基础类笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>用Python搭建深度学习框架系列笔记5——逻辑回归中的损失函数节点</title>
    <url>/2022/03/02/c830e3a9e023/</url>
    <content><![CDATA[<h3 id="一感知机损失与对数损失">一、感知机损失与对数损失：</h3>
<h4 id="原理及利弊">1、原理及利弊</h4>
<p>​
<strong>感知机损失</strong>在原点处有一个硬转折，该点不可导。同时，在x大于0的区间范围内，其函数值一直为0，但这并不太好，虽然此部分的模型分类正确，但是我们希望模型能够更正确，也就是x越大越好。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_03_02_20_45_52_846.png" style="zoom: 50%;" /></p>
<p>​ 介于上述情况，引入了<strong>对数损失函数</strong>，<span
class="math inline">\(L(x) =
log(1+e^{-x})\)</span>，处处可导，且在x&gt;0的时候，x越大，函数值越接近0，作了一定的区分。也就是说，对不那么正确的情况施加了一定的惩罚。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_03_02_20_46_33_157.png" style="zoom:50%;" /></p>
<h4 id="代码实现">2、代码实现：</h4>
<h5 id="损失函数抽象类">1）损失函数抽象类：</h5>
<p>​
按照先前所述，损失函数也可以抽象为计算图中的一个节点，首先定义一个抽象类，继承Node类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LossFunction</span>(<span class="title class_ inherited__">Node</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    定义损失函数抽象类</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h5 id="实现感知机损失">2）实现感知机损失：</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PerceptionLoss</span>(<span class="title class_ inherited__">LossFunction</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    感知机损失，输入为正时为0，输入为负时为输入的相反数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compute</span>(<span class="params">self</span>): </span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(self.parents) == <span class="number">1</span>  <span class="comment"># 只接受一个父节点</span></span><br><span class="line">        </span><br><span class="line">        x = self.parents[<span class="number">0</span>].value </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 对父节点中每一个元素，执行上述操作</span></span><br><span class="line">        self.value = np.mat( np.where( x &gt;= <span class="number">0.0</span>, <span class="number">0.0</span>, -x ) )  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_jacobi</span>(<span class="params">self, parent</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        雅克比矩阵为对角阵，每个对角线元素对应一个父节点元素。若父节点元素大于0，则</span></span><br><span class="line"><span class="string">        相应对角线元素（偏导数）为0，否则为-1。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        diag = np.where(parent.value &gt;= <span class="number">0.0</span>, <span class="number">0.0</span>, -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> np.diag(diag.ravel())  </span><br><span class="line">    	<span class="comment"># ravel 函数将 多维数组 扁平化展开</span></span><br><span class="line">        <span class="comment"># np.diag(array) 中</span></span><br><span class="line">        <span class="comment"># array是一个1维数组时，结果形成一个以一维数组为对角线元素的矩阵</span></span><br><span class="line">        <span class="comment"># array是一个二维矩阵时，结果输出矩阵的对角线元素</span></span><br></pre></td></tr></table></figure>
<h5 id="实现对数损失类">3）实现对数损失类：</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LogLoss</span>(<span class="title class_ inherited__">LossFunction</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compute</span>(<span class="params">self</span>):  <span class="comment"># 根据父节点的值，计算该节点的值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(self.parents) == <span class="number">1</span>  <span class="comment"># 只接受一个父节点</span></span><br><span class="line"></span><br><span class="line">        x = self.parents[<span class="number">0</span>].value </span><br><span class="line"></span><br><span class="line">        self.value = np.log(<span class="number">1</span> + np.power(np.e, np.where(-x &gt; <span class="number">1e2</span>, <span class="number">1e2</span>, -x))) <span class="comment"># 对于父节点的每个元素都依据公式进行运算，为了防止溢出，对指数进行了截断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_jacobi</span>(<span class="params">self, parent</span>): <span class="comment"># 计算本节点对某个父节点的雅可比矩阵</span></span><br><span class="line"></span><br><span class="line">        x = parent.value</span><br><span class="line">        diag = -<span class="number">1</span> / (<span class="number">1</span> + np.power(np.e, np.where(x &gt; <span class="number">1e2</span>, <span class="number">1e2</span>, x))) <span class="comment"># 通过计算可以得到，其实就是对数损失的导数，放在对角线的每个元素上</span></span><br><span class="line">        <span class="keyword">return</span> np.diag(diag.ravel())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="二logistic函数">二、Logistic函数</h3>
<h4 id="原理及操作">1、原理及操作：</h4>
<p><span class="math display">\[
Logistic(x) = \frac{1}{1 + e^{-x}}
\]</span></p>
<p><img src="https://bkimg.cdn.bcebos.com/pic/f3d3572c11dfa9ec71464f3e60d0f703918fc1ab?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5/format,f_auto" style="zoom:50%;" /></p>
<p>​ 我们可以对模型的线性部分施加这个变换，来代替原先的阶跃函数。</p>
<h4 id="logistic操作节点实现">2、Logistic操作节点实现：</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logistic</span>(<span class="title class_ inherited__">Operator</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    对向量的分量施加Logistic函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compute</span>(<span class="params">self</span>):</span><br><span class="line">        x = self.parents[<span class="number">0</span>].value</span><br><span class="line">        <span class="comment"># 对父节点的每个分量施加Logistic</span></span><br><span class="line">        self.value = np.mat(</span><br><span class="line">            <span class="number">1.0</span> / (<span class="number">1.0</span> + np.power(np.e, np.where(-x &gt; <span class="number">1e2</span>, <span class="number">1e2</span>, -x))))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_jacobi</span>(<span class="params">self, parent</span>):</span><br><span class="line">        <span class="keyword">return</span> np.diag(np.mat(np.multiply(self.value, <span class="number">1</span> - self.value)).A1)  <span class="comment"># 这个计算依赖于Logistic函数对x的导数，在化简后其实就等于 Logistic(x) * (1-Logistic(x))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="三逻辑回归">三、逻辑回归：</h3>
<h4 id="二分类逻辑回归">1、二分类逻辑回归：</h4>
<p>​
当我们将先前的AdaLine模型的阶跃函数替换成Logistic函数，得到输出。并且对线性部分施加对数损失，就可以得到逻辑回归模型。</p>
<p>​
需要注意的是：由于我们的训练集男女标签为1/-1，但是使用Logistic函数输出的值是在0-1之间的，输出的内容是正类（男性）的概率值，而没有判定样本具体的类别。所以我们可以以0.5为阈值，进行判定。阈值大小也是可以根据具体情况自定义的。</p>
<p>​
<strong>故而，二分类逻辑回归模型只提供概率，选择阈值的决定权还是在人</strong></p>
<p>​ <strong>总结</strong>：</p>
<p>​ 用Logistic函数，得到<strong>最终的概率值输出</strong>。</p>
<p>​ 对线性部分施加<strong>对数损失，以用于训练</strong>。</p>
<h4 id="多分类逻辑回归">2、多分类逻辑回归：</h4>
<p>​
我们一般采用SoftMax来代替“硬”的Max函数，将所有值归约至0-1之间，进而进行概率值的输出</p>
<h5 id="softmax节点实现">SoftMax节点实现：</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SoftMax</span>(<span class="title class_ inherited__">Operator</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    SoftMax函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">softmax</span>(<span class="params">a</span>):</span><br><span class="line">        a[a &gt; <span class="number">1e2</span>] = <span class="number">1e2</span>  <span class="comment"># 防止指数过大</span></span><br><span class="line">        ep = np.power(np.e, a)</span><br><span class="line">        <span class="keyword">return</span> ep / np.<span class="built_in">sum</span>(ep)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compute</span>(<span class="params">self</span>):</span><br><span class="line">        self.value = SoftMax.softmax(self.parents[<span class="number">0</span>].value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_jacobi</span>(<span class="params">self, parent</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        我们不实现SoftMax节点的get_jacobi函数，        训练时，不会通过SoftMax节点进行反向传播</span></span><br><span class="line"><span class="string">        训练时使用CrossEntropyWithSoftMax节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&quot;Don&#x27;t use SoftMax&#x27;s get_jacobi&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>​
一般使用交叉熵，来衡量SoftMax输出的分布，与真实标签的分布是否相似，具体的公式见常见的损失函数章节。</p>
<figure>
<img
src="https://www.zhihu.com/equation?tex=H%28p%2Cq%29%3D-%5Csum_%7Bi%3D1%7D%5Enp%28x_i%29log%28q%28x_i%29%29"
alt="[公式]" />
<figcaption aria-hidden="true">[公式]</figcaption>
</figure>
<p>​ <span class="math inline">\(q(x_i)\)</span>是预测分布，<span
class="math inline">\(p(x_i)\)</span>是标签的分布。交叉熵是符合直觉得，当样本属于第i类的时候，只有<span
class="math inline">\(p(x_i)\)</span>为1，其他p的分量都为0，最小化交叉熵函数，其实就是在最大化<span
class="math inline">\(log(q(x_i))\)</span>这一项的值，也就是在最大化<span
class="math inline">\(q(x_i)\)</span>，及最大化模型输出的第i类概率。</p>
<h5 id="crossentropywithsoftmax-实现">CrossEntropyWithSoftMax
实现：</h5>
<p>​
在上面实现Softmax节点的时候，并没有实现get_jacobi方法，原因就是它的输出会和独热向量一起被送给交叉熵。计算交叉熵对于线性部分的雅可比矩阵，比计算对Softmax输出的雅可比矩阵会更容易。Pytorch框架中也是这么干的。将Softmax操作附在了CrossEntropy损失函数中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CrossEntropyWithSoftMax</span>(<span class="title class_ inherited__">LossFunction</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    对第一个父节点施加SoftMax之后，再以第二个父节点为标签One-Hot向量计算交叉熵</span></span><br><span class="line"><span class="string">    self.parents[0] 为logit向量，也就是线性部分</span></span><br><span class="line"><span class="string">    self.parents[1] 为One-Hot编码的向量标签</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compute</span>(<span class="params">self</span>):</span><br><span class="line">        prob = SoftMax.softmax(self.parents[<span class="number">0</span>].value)      </span><br><span class="line">        self.value = np.mat(</span><br><span class="line">            -np.<span class="built_in">sum</span>(np.multiply(self.parents[<span class="number">1</span>].value, np.log(prob + <span class="number">1e-10</span>))))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_jacobi</span>(<span class="params">self, parent</span>):</span><br><span class="line">        <span class="comment"># 这里存在重复计算，但为了代码清晰简洁，舍弃进一步优化</span></span><br><span class="line">        <span class="comment"># 推导见下，参考《用Python实现深度学习框架》</span></span><br><span class="line">        prob = SoftMax.softmax(self.parents[<span class="number">0</span>].value)</span><br><span class="line">        <span class="keyword">if</span> parent <span class="keyword">is</span> self.parents[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> (prob - self.parents[<span class="number">1</span>].value).T</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (-np.log(prob)).T</span><br></pre></td></tr></table></figure>
<h4
id="带交叉熵的多分类逻辑回归计算图示例">3、带交叉熵的多分类逻辑回归计算图示例：</h4>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/654F54B060F55AD5E7433929CC7A48B3.jpg" style="zoom: 25%;" /></p>
<p>​</p>
]]></content>
      <categories>
        <category>② 深度学习笔记</category>
        <category>Basic系列笔记</category>
        <category>Python搭建简易框架笔记</category>
      </categories>
      <tags>
        <tag>Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>用Python搭建深度学习框架系列笔记4——优化器类的代码实现（下）</title>
    <url>/2022/02/28/d9d77f183b68/</url>
    <content><![CDATA[<h4 id="六momentum冲量优化器的实现">六、Momentum冲量优化器的实现：</h4>
<h5 id="公式">1、公式：</h5>
<p>​
由于先前的梯度下降法的速度向量v只依赖于当前的梯度，而不参考历史梯度，很容易让优化器陷入Critical
Point中。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/6E1655AA36BAFF6E77328731A966D476.jpg" style="zoom:33%;" /></p>
<p>​ <span class="math inline">\(\beta\)</span> 为衰减系数，一般为0.9</p>
<h5 id="代码">2、代码：</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Momentum</span>(<span class="title class_ inherited__">Optimizer</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    冲量法</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, graph, target, learning_rate=<span class="number">0.01</span>, momentum=<span class="number">0.9</span></span>):</span><br><span class="line"></span><br><span class="line">        Optimizer.__init__(self, graph, target)</span><br><span class="line">        self.learning_rate = learning_rate</span><br><span class="line">        <span class="comment"># 衰减系数，默认为0.9</span></span><br><span class="line">        self.momentum = momentum</span><br><span class="line">        <span class="comment"># 积累历史速度的字典</span></span><br><span class="line">        self.v = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_update</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(node, Variable) <span class="keyword">and</span> node.trainable:</span><br><span class="line">                <span class="comment"># 取得该节点在当前批的平均梯度</span></span><br><span class="line">                gradient = self.get_gradient(node)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 该节点没有历史速度，也就是说如果是第一次对该节点更新梯度</span></span><br><span class="line">                <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> self.v:</span><br><span class="line">                    self.v[node] = - self.learning_rate * gradient</span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 如果该节点有历史速度</span></span><br><span class="line">                    <span class="comment"># 更新当前节点的速度</span></span><br><span class="line">                    self.v[node] = self.momentum * self.v[node] - self.learning_rate * gradient</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 利用计算所得的速度 更新变量节点的值</span></span><br><span class="line">                node.set_value(node.value + self.v[node])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="七adagrad优化器的实现">七、AdaGrad优化器的实现：</h4>
<h5 id="公式-1">1、公式：</h5>
<p>​
<strong>针对梯度的每个分量各自的历史，采用不同的学习率。</strong></p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/B02ADB3A208B90C7E30118C018E24361.jpg" style="zoom: 25%;" /></p>
<p>​ s 是
一个和梯度同维度的向量，<strong>其会在各个分量上累加历史梯度各个分量的平方</strong>。<strong>更新梯度时，求s各个分量的平方根,然后用学习率去除，得到自适应的一个向量，里面每个分量代表的就是各个分量对应的合适的学习率</strong>，将这个向量与梯度向量做内积，就可以得到一个合理的下降方向。从严格意义上来讲，这已经不是再向梯度的反方向下降了。<span
class="math inline">\(\epsilon\)</span>是用于防止除数为0.</p>
<p>​ <span class="math inline">\(\bigotimes\)</span>
代表向量内各个分量分别相乘，将会得到一个和原来向量维度一致的新向量</p>
<h5 id="代码-1">2、代码：</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AdaGrad</span>(<span class="title class_ inherited__">Optimizer</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    不同分量，自适应学习率</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, graph, target, learning_rate=<span class="number">0.01</span></span>):</span><br><span class="line"></span><br><span class="line">        Optimizer.__init__(self, graph, target)</span><br><span class="line">        self.learning_rate = learning_rate</span><br><span class="line">        <span class="comment"># 极小量，为了防止除数为0</span></span><br><span class="line">        self.epsilon = <span class="number">1e-10</span></span><br><span class="line">        <span class="comment"># 积累历史梯度向量的字典</span></span><br><span class="line">        self.s = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_update</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(node, Variable) <span class="keyword">and</span> node.trainable:</span><br><span class="line">                <span class="comment"># 取得该节点在当前批的平均梯度</span></span><br><span class="line">                gradient = self.get_gradient(node)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 该节点没有历史的向量s，也就是说如果是第一次对该节点更新梯度</span></span><br><span class="line">                <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> self.s:</span><br><span class="line">                    self.s[node] = np.power(gradient,<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 如果该节点有历史累积的向量s</span></span><br><span class="line">                    <span class="comment"># 更新当前节点的历史累积的s</span></span><br><span class="line">                    self.s[node] = self.s[node] + np.power(gradient,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 利用计算所得的速度 更新变量节点的值</span></span><br><span class="line">                node.set_value(node.value - self.learning_rate * gradient / (np.sqrt(self.s[node] + self.epsilon)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="八rmsprop优化器的实现">八、RMSProp优化器的实现：</h4>
<h5 id="公式-2">1、公式：</h5>
<p>​
AdaGrad累积了全部的历史梯度，而我们其实应该更多地考虑近期地历史梯度。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/35459FAB3F235381D94DED311CECB887.jpg" style="zoom:25%;" /></p>
<p>​ <span class="math inline">\(\beta\)</span> 为衰减系数，一般为0.9</p>
<h5 id="代码-2">2、代码：</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RMSProp</span>(<span class="title class_ inherited__">Optimizer</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    RMSProp优化器</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, graph, target, learning_rate=<span class="number">0.01</span>, beta=<span class="number">0.9</span></span>):</span><br><span class="line"></span><br><span class="line">        Optimizer.__init__(self, graph, target)</span><br><span class="line"></span><br><span class="line">        self.learning_rate = learning_rate</span><br><span class="line">        <span class="comment"># 极小量，为了防止除数为0</span></span><br><span class="line">        self.epsilon = <span class="number">1e-10</span></span><br><span class="line">        <span class="comment"># 衰减系数</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="number">0.0</span> &lt; beta &lt; <span class="number">1.0</span></span><br><span class="line">        self.beta = beta</span><br><span class="line">        <span class="comment"># 积累历史梯度向量的字典</span></span><br><span class="line">        self.s = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_update</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(node, Variable) <span class="keyword">and</span> node.trainable:</span><br><span class="line">                <span class="comment"># 取得该节点在当前批的平均梯度</span></span><br><span class="line">                gradient = self.get_gradient(node)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 滑动加权累积梯度各分量的平方和</span></span><br><span class="line">                <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> self.s:</span><br><span class="line">                    self.s[node] = np.power(gradient, <span class="number">2</span>) <span class="comment"># 注意此处不要乘系数</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.s[node] = self.beta * self.s[node] + (<span class="number">1</span> - self.beta) * np.power(gradient, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 更新变量节点的值</span></span><br><span class="line">                node.set_value(node.value - self.learning_rate *</span><br><span class="line">                               gradient / (np.sqrt(self.s[node] + self.epsilon)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="九adam优化器的实现">九、Adam优化器的实现：</h4>
<h5 id="公式-3">1、公式：</h5>
<p>​ 集大成者，结合冲量与RMSProp的思想：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/F34B46DEC057822E872DE8B45F0EDB3F.jpg" style="zoom:25%;" /></p>
<h5 id="代码-3">2、代码：</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Adam</span>(<span class="title class_ inherited__">Optimizer</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Adam优化器</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, graph, target, learning_rate=<span class="number">0.01</span>, beta1=<span class="number">0.9</span>,beta2=<span class="number">0.99</span></span>):</span><br><span class="line"></span><br><span class="line">        Optimizer.__init__(self, graph, target)</span><br><span class="line"></span><br><span class="line">        self.learning_rate = learning_rate</span><br><span class="line">        <span class="comment"># 极小量，为了防止除数为0</span></span><br><span class="line">        self.epsilon = <span class="number">1e-10</span></span><br><span class="line">        <span class="comment"># 衰减系数1</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="number">0.0</span> &lt; beta1 &lt; <span class="number">1.0</span></span><br><span class="line">        self.beta1 = beta1</span><br><span class="line">        <span class="comment"># 衰减系数2</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="number">0.0</span> &lt; beta2 &lt; <span class="number">1.0</span></span><br><span class="line">        self.beta2 = beta2</span><br><span class="line">        <span class="comment"># 积累历史梯度向量的字典</span></span><br><span class="line">        self.s = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 积累历史速度向量的字典</span></span><br><span class="line">        self.v = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_update</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(node, Variable) <span class="keyword">and</span> node.trainable:</span><br><span class="line">                <span class="comment"># 取得该节点在当前批的平均梯度</span></span><br><span class="line">                gradient = self.get_gradient(node)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 滑动加权累积梯度各分量的平方和</span></span><br><span class="line">                <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> self.s:</span><br><span class="line">                    self.s[node] = np.power(gradient, <span class="number">2</span>) <span class="comment"># 注意此处不要乘系数</span></span><br><span class="line">                    self.v[node] = gradient <span class="comment"># 注意此处不要乘系数</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 梯度累积</span></span><br><span class="line">                    self.v[node] = self.beta1 * self.v[node] + (<span class="number">1</span> - self.beta1) * gradient</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 各分量平方累积</span></span><br><span class="line">                    self.s[node] = self.beta2 * self.s[node] + (<span class="number">1</span> - self.beta2) * np.power(gradient, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 更新变量节点的值</span></span><br><span class="line">                node.set_value(node.value - self.learning_rate *</span><br><span class="line">                               self.v[node] / np.sqrt(self.s[node] + self.epsilon))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>② 深度学习笔记</category>
        <category>Basic系列笔记</category>
        <category>Python搭建简易框架笔记</category>
      </categories>
      <tags>
        <tag>Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>毕业相关事项</title>
    <url>/2022/02/26/84b3fb3c559e/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="f4fd8c92373b59f0b3b0c96c3d55909e77a6f7a1c9dc2c6e92c75a9f6da18a7f">f638d67e356a706b7b082748a96249a9c6215665973a817d195d1e1476666dda00dede9801ee74c82cd7a946d96afe739c132c3adadb052f1b3812d2e382bbb9b67d1a06443ab4b4344bdab2822da6341e5da18560a52307d2bd1f9203199afbad5f76870d7d90ee0f0f579250a59e5260dc5a69a54d8400868d9b23518d413782354b3de38bab4b3070fda0443c74e65d1fdbcd6cb6466819e1e93168ec312c4fc45b115b918b99551b1ea7fbda3ba7675bd17f0712586c6fb48ed4e4522899cf6be56698e6e1f00004f7f70c858b25d3b41d36161572cd320e2f6232bae716624033350494f9cc193f65faa159625292a29b7afd5cd77486f28ceae4c9035d6ffd80607299d466ace0cf92e56089e1ee5878a1263c7f259b50348a15c60b3982d3cdfaebc5fe0d11f14ed5991ff21076537d789bfa125cccf3c82551ebf5aa2d3b10df57217a159c5e276b836644d56e58133cf6d5e278b75a7b9cc3f8f8498870aaf85f59fb94fd1aa06e6b91fa760f3a6b5e70a097c72f992ca04bf747d5fb92a985ce681c4313f99538ee878ce6dc89084b9ba12f87982df89e63b9cb2bffa3a7974f3e482948898ae3f4c1afe83abb65561cb14bb39cbec8f0ebf718e74690c7d40d5af607579c5864f48ab515c41b21b82e600533d57a84ea3af5f5a8c22cf188f3e34b7aee8ab12053ab5bd63e4ef3511b940e664cb61c56f785f9a4dad81e476daaf2a2fc03bd044ee7b98dc2b5d48de761eb3aa785084463f89e641cbc0cec212fa103598fffc14266144ed478d41c1cb1df3b2485f94027ecb5a7bd318be6517a484adb9b27a3c3161ac4b58e399ef326bdfb99cf00f9480195ed1b794928dbd2a8042e74a68739cb005a58a4454f64c463e81c4f3ba5b59765f0ea4c1cb43f8cbf6669f10e12f5ccbaaa437f350d22f470f27705dbc7008d6bce5587ce521a3b90806f3462eb4e6d2cc87b7bacf42fea157d5095c98f8b470e3617a94891f67926661ebf4540ab818b5868a6347927738f2c2ec0a4eb54201ab8ab18c0902b548af3422f6545e575547fca4eb3150651ae5b0fe4b5abba8d33d2f1135e5214279211da0a18be5561e9591dd9ac55ad3a6afdd94070dffcbae9de477228c86f4178d4757c641fe0bfa920f95072f547874b7e10b74853918ec2de251d9e4f1a325db3e60609cc524c2ace7bed74c54db1d68f7a5e88806dfe0cc25d66d48e805f8ec737519c7048032a774133d583ca0624393ace813ddd78b06371c614c5a76658496e95e927780023dbcaab5aaec7d065509040cd57e4bcc282190e8d28512278576510209b75bd649b697991bf1ce439196c987577c70f68e9fddd057b92a68c93aca2a1e84e2cb061225fad1e46e707c1854b38a7c356bb02abf25fb70c6a5408b6831321f97820fd3e84ad7dd1c6e67f1cb41ccedfa41cf103506ca3d93262741619d2db8540b44124740d7c253166eded31aa7af34b807797254a8b745a1e6a466ea5e3700b98d5304106bf9c34b936cdeb3c0b5101192bf32dca35b499166c209e1dbda0d99ffbb3d4a153f2411c8d0e535204e71ee7f3414c1c0378e914d202733b2d670ccb60b24ce6f8b2f35ec80b33aa57aebf366e173338791027abf433dbbb4d921e99fd03929007bfcc267acbdd325cfe122ff1f294a639f34d49c964184121fbdb342c4c9d5149a57682aa275e0b92c271816bcf962f8e26dda8a85bb6f4fc4689f30cadf05f3404562e11852b551ead6f36a32d2c6ffb86ae3cc8033f8a8b1f908aa3ef3f850766b2ee3bf4d062139118d1453eb99a4165f2a5969223e62eb60821d2e88f6b3b9c41595bd5cf131aac537cba4a23a45d4ea995e63b50678b418be490cf61e2f3b377f9489c5ac2124692e73ef754a2f7a3b2c3a3dc9c041b48c3b6f082e7854d0741bc97fa425a45c8311b69b18eb3e1df457f6c073e24cda165ca90b4b13a4b10a71e3e664d835d2e5a5a2a7ba2d07f701c40706d43c2edf54a797e1e07dff8ec4a12aa01b1710df71a426e7e2544dcda7cb48d03528e4c15e5071e5c3acc6c8e91f83c88b52a168313dcfe6e0efeae1a6f363df83ac6c91d8e407bc5744a4880e6d435b73918ec29b3ef124bd33fbe031b05222025473e1a2155f633d831c7618f7c237dc9408b8fbb1e7d1c607de25c054d4e0fbc6b4ee9aa9b2857a547f09d54fc56e9a0486d43bd7d3b9ce19ee3c960fec8657a7b52cd8662b9939f84125451b386d97bb4a532c2a0c5f2aa47c9c3c020cd1d420335addb41b6988599574179188ad6ccd7125035efee0f1e098c46942b43569a14946ad4bbbd4df2c0d02093dc93f8b2f94a4101697048b7ab8237fad569806295475d5de8b127f70949eac403be478eb1b5183513c59517bae5cf6f84574aef7939c28d7cd635608f66bd7dbd3fdbfd3d97e9e3c3902a132be3a1039fd6609a1a088fdc8379a2068dbc311f207f73d8f2b039ad474e37fe0a48b49e3fb7a3ddcdaca9a041508263103dee9130c5c8838bdffe1e296c96c5ced3a38e9120e34d57156352b5c670be3911ad2a592c1582d793aafc3391d45150f4261b9f32fe60d19b3e2333b7d378c8a6a2ea0b9263c2fc4ce7caa2814554162032f1112b57de660a86f255d8aad7ef41d209f9a77380acdb967ce73d0cf664572c12a330642ffd86d86e74b52864dc59f440255c7b9a427776882e171649339af72ef8e10b33d19736ba5b76ef1e5a8abbe7d4fd7d44a6418e8940052d6504e605dc907aab67aa8b72a4bfcf231e3716d0ef998fd3762bf504e4b3349a7e791a8f3833e7b844bc5359d05bbb2e14afec119edc8567919d8f6ae498460dcd263769b6f43461a796961671480d182151381054a6b7eee1d6e3db786643e3be5ccbc6ae1770ee1eced38760996f0ab46f543f913494490461334190c05640ae034814ad17e12bbb2336c565604d1015065f6f06ad811c10584046a22aa83d1ba9fbe813f255ba84e0e59847685c8f2eb42058383fd79607d5c871006bfc8245e1851422484c4328c4203357c8c6d64b0f49ff86c74e98095b2c5524ad3b4f80ef7669f4f6d71de0486011b04103a364a5d936d9bf881501c12b9415f42526e2b0892c5f2b58e39c1179ecab1c853dfb0245ebb6f03f92c1528488dce3d03515d9caa3fce731f4088f544d2b5fb3c52d6a3a494d240608fe70f83dc481b3834dd14ab2bd0dba6afc0856d3febcf76fb0961fd382bdd13f15715a3fa4f2452ea36b4df7cfd52666afc9b8e9b71ed2dbff0cf16d65374357043b2bbaf506f03f0bd5d69eaac61efb5588633748075e58a17fff40126d09f767bfea0a85e910da74d4b1ab7c38ccf01a8f12a2ae8f3abda97bbb9f902b86de2e04880e1e02f8aa85d6f34e88366f7256400a8b0e1ca6a5dcdc06b98ba8856a8d067a86de038640afdff23da3187de48de0ab2b12586db6edd68e91ce37ebc859ce91b9d2cf69466cf61177199790b37534c07bacb235b75bfb5bbec2ae026e4186d422a82cb20f57242b77e6103fb100277daf1e5fb1caa10c472acd1bd1e96c75bafb9f19e4b6ec237ccce02b89e7ed5c77f298aa539e465a672bcbdba240363003e053778790a7f292356464adf298f377663ba77b422db6b1caf9f2630d66e0c0193971a0458c826a7aca3340cad8750deb09a8fc329f743edd1be49b1bac92e5fb071789afb8459fbd383802e9dd35aa5367ca0084cd27f6d3167e34db2388bc4e4d7e69eca4759f14b65389fdc7e370669f4550665d7cf49430900a1921fe7b00fe1db2734aed0c0885032fd0ace587055304e21d48878dbeb8e7d2b4489449413b76bdaa199149b845356122b778d927b6cab7dbc1c21259629233968aa84310bdd79a5a68b1564225edccb3cfe1cc6c0f61880d28f9e44ec106265146f7c7f1b6662295b571b106c8d4ac3ceab86ac2e1067117f638a6b2bb48561558de74c9fe5a972670ef6d76f874f75a2fa4f49401b50728d69b07cf88822bfa956af02ee79af5c325994838b0f9f02b266a906d7c23995e300704da2b3594b4542ec14de0cb9b25ed8ba0d8a3f18c9d312d023bad8c8adb578a87943ce0ead92e656147abca4131d49b98ff5748cf0584535c492399680d31cf95ca0d2ced155aaa3ac061dd3bbbdc135e92f9e144af55e1a097cbead27d35666aa85fb7dccfd8ad80c7018cb9b33b3d32d6b5cbc749a3eb4a7310378d24c4ce18a915a54cac6882b185c0960ef74304a0b31ad213190aac1dacadfeaeb94de7bad16b35b2d5ef450080ce41fe40d9883c184328082f8d0fbac86ca9d0c831566a61f23d34863ec0508a8af0edaa91730bbe0b7a92c000d1a301c147e7575a3a18132171ba4aa81933625d4c7048bf264f22c8c067bd870555536e79039f507bf88b46e3f9599f55f102488b9175d985e5e232441cb41dc50b96e68afea2970f03dce57bf8518434b06afb8c2738f735fd410e6c0335aa2fef05f7252674b68b14be6cdc2f7e17f4a927d1bfced4c1675dbce0411093523529d3300669f451764e5486f94e6053bc26b329fc4928214e25f715d1f70454fd30222e5e10e89c826ddf87c1b44255f60957999314c63ca9c21477793f14ebc47a0dc733b5b22df10641c7655d96d05dfc79ce152e8946fa61bdfceaa0d4f7b481c3c89204b715aaeab4c979af42a88debc938df60c1783c05a50f308ed177b4c958a548d2bb3cb09df4db798e2cde170588e58b5ee8c74d1b53bfae3054f15a1e02a1b9b0ee07f701f30744f83b3a084b238c67e5f4f0add7316fb96d067ca335d1528e165fd4f60f0df2053eceecbf734ea06063edc3e0a2709b71cb11e718a9b4e40ce5a2edebba9dbdfcd37c84cbee41dd527de2f901b1f093bef5e4725733e9ce896e14cd27e329a1e8237dc415e13b8c8ba004f8c4f7f685753e7aa49bc32ae779a46d9db680370572874b3e645fb7f017f1c5a8ca6eac80cfd9dc415cfab9b89d18620587086c526bb6b8caf1c700f53cc703dc6e56f6edb28729644d910dadf45a335a28a13d899b6512390a0678e6d81961f1c918a3eb3367e1dbce319dec385033efe392040af51cccb2ffb4575592de53b0ccbe1e007c4109e93d488003f441b1de3d4012478e36fee0caea84f8ba4cad62466776b98cf98a2742270047e202763ba6606014b1791efd64c317cd34d29d954330a5a49688d726218a63e42a701b07d3234e174c4d808e793609088389b94236562b0746bbb3a3bdac3a1d4472e97d9b99dcdc2cd8c388e6f886439e437244c55bc85504ce782947904ece20b2c0d185efa864089c8516f01eb0b40a4d38ed3acce59165be477c8ae25a6198e41448d83c600d2c39a040b1ad5cecddca71a188f40b80eeb85503b96304ee28deed0f193b50543e81262054013ed2253a59c2fc4e8aecc05ec35c49b2ed9a029f95387e6f6d4bed631855b00f2f360bbb8d4a98d488ce1926848ab5b03ad1388e76cd5d1584b1a59ee0334ff6f8eb6c1902766ae98eb2faf43ea47b4cd05b8969e56d5a3be67243ec197098e4c5a3d3e793f2919aef6901e73e3e99246017fceb6edf0bbddfa52378640e03a9c957033ce8d4e77415ab03ef401957f6790d6a451c64922edf8055c427f13b2ff2a26f6d09e3d1727406507aee1bf1348f59a36d1978fd30e7048c5a78e51c95ae08ea4500974ba34257659a73637a64b84228c602becf883268156620357df65fad017cf8587e6eecba3dc2a6fc9862a955baf26a8f435bf49ceabcfea697eea65648973cdaceba54ec52769fe65e1a46a5c8ef6c9e232213b5b0ed4ed4e65a8be8221af11f7e6bf2be9dbcbd71ec483c800349eea41356fb92baaa93c63adde1342e0f6527e4b19ffd7a4d1917b62767a6b40387f6858933a9ba0b792451e9e5ec74acff461c774d6bcd6ace0d359d389718addc363a00c118f5f478847d62a65a80af780b5ac9eb65ce741be6abaeeaabd571b0f239d6a6be2c49977e72716d87b0ff64c0add6f6fead94427beb5adbfeee40db01dfbd03bf0aa15de884a5b929e8e668ba10e580502a6c76a02b45366d1dde4b7cfd6f45e5af6f7827b4bea83766a9cf57839485e9811bf5a1dcb1e5c015428292fe3466fd49c84735bb6fd052cda617b17289c66a71d17724baf96315c7c982646d0a23a4ab87e82f3a8dbd9cf641a0d50a9ab9e08c22f5a582150383b0f33eef983a53c6d39c26fdd367b6a8c8b183d39726474abbf1cdea837bc18333075ac31871bcfe5381ad7195746cb6cb32265fda80dfcaa293962d6fe95965b5f3f13367326098b1385e623c82517767d2650160ab722262e8173a135e58ffe0fb6898c2497300c1f25db70d8788922e13424967f2af138005445e89ebc887b2808d55580e6bdcb9057b30fb75fe3ca7f08334720737121c465531cb6022881b6545bf2d3020446cd90dd76c1109f9ef1839b3d31f5a671f76197b36fd4ea4fc512ae2f6686217c32b0914a53e97c8abeab31d38f1a0775ba6660ceeb80462dacda323e5bfadd9f9e64877ded2377ef9efb5161ffc26affe457ad94b8861ad3d62a458a7a57e0b8e1dd6e9a00668b8e2959bd84eb11aaad34d246550d8745f1872beea87d5decc0667b33afc85411ea211f24f917002005a698948a53a8efc42fe28690cea48dd63eb9730c5e648962deac756f9a568ecea3484200e5fe9c3b0c0d5857ef6d997b4ac3e06ddef8109accf55e9839358e25aa276c35ae3316ec3b352ec1b6d1d650a416325cf0d586033bf07e869388b51904083703b2cdbc21c8c89ea834bc4cac0c3aabd1c92c7304304d09ba5dcf9340dfa85fc8f9d3798a401012690a82a44749461066a0f84f0f06c9e3efca72b45e73c43a179d72ff61c900ca1053df6f954e211bdd5154106e34dd4f43988ecc14fec63d70c907f50070d6191c9e8ea19206958e8fb734ad614a6f7dd3681cdbdd34ec6c9d6f9d566ad3eb0c11eff0aa147e3ec34e932724be8b433f704e312340f0494663d8a02fa82702cfb0ff1bfdad4c23c0b6459629f1845eefa9dc4be1a19da686f09e3d34cf8cb7aaf6539a4033972df7c7074cf2dbb647b3fd6dce2bb31acc87cf0a6c6d06ee7f89853061344e48f0402377c1c33a7a71bc8abe9c052caa49ed37228ae91ad53994bbbd070ebf1d8e67d94c51ebd042792a012f7d3e7cf7feabbd26e94cd7a099d05e08f16a66197336dff6abd5e3fd3095e5c5d1abd18e32c4b2e71ff1a1c36656638176c9b8e26841d4e4e2f245a258106762862e35baaa72ccd4dfadc90b62b7b3d41851a6b8e5333339cb21fdfa11105a3f5122ecaaa4e8f89f64ed9e5c22f4ef14601e8c5feeb4e8b0496543091dcd666a5b8476b34465aa89261737796e5bb5bf5eb44014becedd171eeee3149159720a39e12212644f5acb0d76e439085408ae7bc2809569cb1f8981f19901bebe119675e8787132e3539380b12a8243e261c7dd40c45248f015f7be2a72b1de650e81bdf9e7635750f65d715d83da796f6e02a420aad02d4040044ffaeeeb1fd20d8dbc1c0d37e30682d3cf7db6bda6ad2eaf0bbe99455316a26c41853bf20ca1a5bf84be2e1574c1774f5eb6bffcfc93d386df7aa289a9511039a3de05626c72dbe0cd1a6635907404b5fc73d5ebafad0a7984a5a8f5b7be05088cbcc4aab87d583f86d9731eccf25ae66e950fe6f09c924c56d7a2c10c2e28e9caa1c9bdc7d3471afba32137bad7797ba2ad0e43b772b301facb6b290f74afa718eb67900d492add18677d8c44a90d369f45baea1a551eeb4335ce6ad4c0de2e619d77387002a27b60014f3cfdc153efe1de50eb29d115b3ae6200592034157f51c31e1a832652f969c4bfe78c75b6c145a9c6c5b7f7fef21f6eb991ab936330b739fdc6ea738e2f41184a0c0969ac6943ebb3fe1d42155bfdcc3e18ab253ab95edea658bcf8e5336e26cb2e0e9b51f10116f701312e888f74f91dc46ad8d0fa46a09dfc9900bbc3db44e26ab1fbe65245579b055f5563baf600948039f82ad2ceda866ebc38492647435e70847ff68cbeb99f3c765f0ba0fdaef0216d7329d591bebbc70a56e718c8ee0abba67e01b9fe2019da2aed749b94fd836d4ec7b3897c2e3cdbea0d66c4903d94851c7ae254e7764aa4e3595afa307a2c2d752b317a113be0017b2493c57348addfd10809f5b3eca4fe4b1791c0eea5c376f1d40ddf9d2b0254d4bc2c2783a3aa14499ee440955bd7bdaf3dcb5eb8aa7d2b8a5a352e13d70ac30097032ec930f305cf66347ae1113d39aebb4550d45428e2bc03aa595fbeb65ce5d31dc9a0e63e76b479caf80e0152bbd100b65d04e8e093505b9c7fc37a78d537707e47b419615e96913b739ca46bc89a75228ac88ac9e2161382ddf453401172f38a43081c2afba41b35332958c364d595b1407ef310447a254989e4a4eb4fb069932f946fd10a69e141f1baa2a040579cc7ee6f8bf12c856a2b4bf852d11de6c81dce369741dd01fc90b881d58e3d972505c6eab82ec3771bd056ddac7d6d990194eed2e85e20d8bd2c9a7ed7030e222253e3b68d301c0fb5377e3c2353eec5195a2f84ec33e655f1a4c3c5dc8375608e40f2af8d904f16d75926c1698736ed4dc9fa538d8af3cef6de5fbf37c443e989408329b122a2be159e65e9023eea2b897c20170a5216c77587fae55a3d654d7bec84df708a7411e9a1bc3f2a5c7a5c7a0647dddb78f3daefe6f7b089c8ea27796d288451eb0148e24c74c568d803140b8b05a4054f9833e61bbdc87e1a1b4bba9e6fa24ccb1bfb0a41bab5edfd6de073d9ab1c61d595855b0ecfa20c765232da8f8fe218faa68ae854f04adeffe2c1988f0e067f1124e900e6f85dfd74864bf48a281386b413598b9589faf5d746fb445f7b19b1dbe75d5d9303120519dc576c5f09c137ffb97b1195ec973dd5a2229a180399ff9a843344bb87b0cd0263cbaa28e2a037da1a86467d9e36c86d4f18c82c4c53383173891c8931fb3bba65ddc675b4ee121be70bafcddd93f9ca85d5a3545a289001fe186b5507234830600d5d3ed8f124cfd61e1ca10af6cc0d826255044078129b87deca196929995940a8fca0c8074280b217c07c28f7df8e9203b2243aa7e781a8282fcbe12c196637981f42a811d0e3540771e4f0bc3fa070f139aa307915e622c04212b64b115260c8a719581c6023f58ba52ab9655e1f5c921c7865c03d4e1bae551105fc60fa2b006a5bbe42dd3e4250eaf6447f9c228128fd0bdf69945a11c2fb775c99cec9d3788feaccd13ac4b10cfb955b1f4197133a7ee4019d868673243f406bb7dee0bc096c48ed9092bfd5d3d0db4f7ac9705cf05e5aa5b259880fee683e0825839a9a8e8d95b1206a29cebb00e2035049b8a458f6f7de4960bc0e3f120a2aae1ef748e47db192e8302d795e1c5fefbe94ed206c2b6233bde039ecf36b13a3af7d1cf03e0c0d2b0bfb90e44a89e3c497c2052dd060265ec168c8ff1d2e75afe29ae2a047b1b3d1d8f90df053a918ad8bc6d4ff85cf5192c1cf8c3f81fa411da7203767b081fdf0b31373b79e977a04232cf7db20ad5b11cebf77f577134a40323dd36fd137e50a482cd663b8bdb7e93db0d01f8992d5b6b031ee2e196bfb2409ee576a6e884e28754fa1eef67b46f0491f1aa6ce2558f1650cab5bf37d433ef07338115e574749ce246410b3f31a1fe33bb458cff097fd18d0d2033ea860f0e3b703a1237d06edbb6477794c2f5efed936ba44813bc6c82a8a7ae62bb7bc448aa1f52078fa659719932c6073043ca37ac434c754e9e5dd454c8da68705a9a7dfe2095725358af51b258557369deef09a6034546b44e27addb11b7c2693e2f8b5455182eff9c8719a291cdce490afc2aad7aca8085986f664d84c89f2558a4da7e63f34150d71b9ebc567af0e6e4fb1a4628a80e051119776f37fe664e6cd87f12d3f4d15f7853a66c1a3fd163c577408e9d44c8f2ac57b3c932cac17c761d31eea7aea5a1977698399722a5dd1cd9e4c090139c3d81dad88f9255b16e9165dd792e408caf7f5ff0d9a4ff9fe08dceb3d47afd5f278e36269211d67c7d33a6f75843766a00df45c3dbda6c98fb4f626fcef61e4d34d23a492eb2654e3c1d6078dc263e6b86631a63a77e245b55d3a9423c227551662d731110b33c97b6e285e2f6b7f723adb42e8acfcf4b02356ae287e5771651d0f410c6443d7300a0b2046cf4117af76766dd6fb6daa72f5cf7ac68fd186bb226576357abb402845e3fe46c206764cbe2c66edf6b0789755eba9949d954a5925d931d41c017e65edbaec0f6b27bbbf2d1211778d5adc52263dd739567cd711012d7bcde7094fd43aa49ec3a8b032dd01293c6907d5e6f9ad41e75d01d4427bd2c91ff134b909c9590010326c5a6b763abac9942581812185a27ac0417d1cfb7d7a1f9489e20f0ad3012e3c042acf1f12d8c3fc53c3c72083d17cf119300036db3d32856c79f14c36344d81c0796f28d23b08399a43f44c2c98c91600e512145a88e4730a4164b39851b75b54d1067fcc0b39d13ffe4625e070ac3ce14066e209697ba47312d15bc7b1073b2699ec67a24d61062e070176d5c0d030475f97f62fc0c4333a86cff83a98077f0bb26765ec641b892eaae9c4df22d995b695e519af130f0aa77d80056653d68f99873c65bd06d2e227c147a00c84564b10e34bf13bbd57ba83c3e76a1321d57b3e900826c9515293ca5a8376faf4e9ceb0f425609e7d62b6be0c5c68d7ebe5b3ab04438fc59a1e109c87a4c86dbaf31a427a3a67adc1579153be356e30f38dc81fa90a817db8bae1f19339bce8125a8fedca5ee3eaff1b588a238ea1e2ff0067af9cdd9a8c64acb9311b87091f426b7f7332f8f5b3377d636c873ae8b788f59a90209a3dc466d424e0dbb6bdb668ca77c03437181c90e146d8306da3cf854c3b1700633c2bc2e34592ce5d073e7a8d2783bc2092a5f762c4c3c69a680a48425950429c2cf9831916744472138d911f2e4228073b8c75857535e30c0d7337bd7119e89566e0e7f633961dbd3032eb0b7a2714c1d4fe98d60bf63439ab98cdcf549da78a70dcd0d19015729faf53980fb5c69040e8b6dab61b975207caa9b8833f3346179a1ecb1e6ce404e3151ed1baeb632e3bb2767d28b03bb823d22f32c70baa429a228a863486a42056a8316d23c461ca0c210f13c9e00644e50030d209e44defe83cd2aebfdad60501a7b6d5a7940dd103169f71fef223cacf5c3e76936b76a50d27fb432f01b63d40059963dd97d175542d6463ff130d174e072551ef130be7ae4b0457315de71416dbbf75519f4585287b96aa0e6ec26e9d5c6e1cf337da5df181ddc91539112ca58bca5066d4c344c9a51cc660b3aac838b1219bdfa7dc15dfdb88ebd50875729bcb391728c8521ca8490421f430bcac679624e5ff1451acb3b18d32c95ef2fe5e54cb01151ebd258dba90b0ec7621d496e84f30d1bcdfb27ccfca5bd942dd49c5a879627544a1f4b5aa860305d357b53a94dcacc4c9e3eadcd3edb315e5189d71967bf60427d425f4ee97be1086e1321119fcd61953f8de13e916e9c13ff68a99bccff78a3c0cf1c156dfda2ef8b49dc47bd903d32cb60904bb9b6c4e00fc9ad3e7ea0765b4ef01da1f00718e783d3802f7ff97b7f8009df4712fbe5a8e340f798289749b60253b5b199858fb568f5d9f3aaa3a718cf8f13e26c032596b4e9ee8bf079f4eafde1f15e94c5bec04e95d2f048ffe9e215a6579b82c0287442f03aa6c893fa3d2d4e2c6a48908ecfeecc2097601bdf8ce2562af83be7f686a2a5c8eb43c83b8a8c4384614701269c66749478f747033e8a56ae19588a794a5277789335e087a3694f597453647fc8a89a5d795dfcab7494db0ce330ca686879e543de2b0999782c167215a0a2035a0072f7180f38bf54b310264bdd969312a73bc5677255eccbdf66049575fdf61021e274fd01f76088d21b71832bbb1a6c582351b4bdeef6d28c7a59685d40f42247eda1aa1c4b328ac9e5b86e5e7ac6844f3721ae3caf8ceb70ce25fe940e49c81aeb95d9f3ff59361f720546ffd8ff7371d8af9fe2eaa20101deb96af6c39aee5e6d078659d2506a123b75b511</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>⑩ 其他内容</category>
      </categories>
  </entry>
  <entry>
    <title>DFS系列——DFS多种形式变体整理</title>
    <url>/2022/02/26/3e00524469fb/</url>
    <content><![CDATA[<h4 id="剑指-offer-ii-080.-含有-k-个元素的组合"><a
href="https://leetcode-cn.com/problems/uUsW3B/">剑指 Offer II 080. 含有
k 个元素的组合</a></h4>
<p>​ 给定两个整数 <code>n</code> 和 <code>k</code>，返回
<code>1 ... n</code> 中所有可能的 <code>k</code> 个数的组合。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: n = 4, k = 2</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h5 id="解题思路">解题思路：</h5>
<p>​ 该题是最经典的无限制的DFS，注意剪枝来降低整体的时间复杂度。</p>
<h5 id="解题代码">解题代码：</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="built_in">permute</span>(tmp,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">permute</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;tmp,<span class="type">int</span> curr,<span class="type">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="comment">//curr代表当前 轮到的数字</span></span><br><span class="line">        <span class="comment">//count代表当前已经 放入集合中的数字个数</span></span><br><span class="line">        <span class="keyword">if</span>(count &gt; k) <span class="keyword">return</span>; <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(curr == n+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count == k)&#123;</span><br><span class="line">                <span class="comment">//这轮完结了，将tmp添加进入curr中</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历两种情况 ： 要不要这个数字</span></span><br><span class="line">        <span class="comment">//Case1: 要这个数字</span></span><br><span class="line">        tmp.<span class="built_in">push_back</span>(curr);</span><br><span class="line">        <span class="built_in">permute</span>(tmp,curr+<span class="number">1</span>,count+<span class="number">1</span>);</span><br><span class="line">        tmp.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Case2: 不要这个数字</span></span><br><span class="line">        <span class="built_in">permute</span>(tmp,curr+<span class="number">1</span>,count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-offer-ii-081.-允许重复选择元素的组合"><a
href="https://leetcode-cn.com/problems/Ygoe9J/">剑指 Offer II 081.
允许重复选择元素的组合</a></h4>
<p>​ 给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出
candidates 中所有可以使数字和为目标数 target 的唯一组合。</p>
<p>​ candidates
中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是不同的。</p>
<p>​ 对于给定的输入，保证和为 target 的唯一组合数少于 150 个。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: candidates = [2,3,6,7], target = 7</span><br><span class="line">输出: [[7],[2,2,3]]</span><br></pre></td></tr></table></figure>
<h5 id="解题思路-1">解题思路：</h5>
<p>​
相比于上一题而言，该题允许重复选择元素，大致框架类似，但是在DFS的过程中，分支的选项需要改变，同样也是选择当前元素和不选择当前元素两条分支，之前无论选不选当前元素，下一轮递归的时候都会去判断下一个元素，而在本题中，如果选择当前元素，那么下一轮递归还应该是本元素。</p>
<h5 id="解题代码-1">解题代码：</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">permute</span>(candidates,target,tmp,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">permute</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates,<span class="type">int</span> target,vector&lt;<span class="type">int</span>&gt; &amp;tmp,<span class="type">int</span> sum,<span class="type">int</span> curr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当前vector，当前sum</span></span><br><span class="line">        <span class="keyword">if</span>(curr &gt;= candidates.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Case1: 不选择当前元素：</span></span><br><span class="line">        <span class="built_in">permute</span>(candidates,target,tmp,sum,curr+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Case2: 选择当前元素：</span></span><br><span class="line">        <span class="keyword">if</span>(sum + candidates[curr] &gt; target) <span class="keyword">return</span>;</span><br><span class="line">        tmp.<span class="built_in">push_back</span>(candidates[curr]);</span><br><span class="line">        <span class="built_in">permute</span>(candidates,target,tmp,sum + candidates[curr],curr);</span><br><span class="line">        tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-offer-ii-082.-含有重复元素集合的组合"><a
href="https://leetcode-cn.com/problems/4sjJUc/">剑指 Offer II 082.
含有重复元素集合的组合</a></h4>
<p>​ 给定一个可能有重复数字的整数数组 candidates 和一个目标数 target
，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>​ candidates
中的每个数字在每个组合中只能使用一次，解集不能包含重复的组合。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">    [1,1,6],</span><br><span class="line">    [1,2,5],</span><br><span class="line">    [1,7],</span><br><span class="line">    [2,6]</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="解题思路-2">解题思路：</h5>
<p>​
本题跟上题不一样的点在于：本题每个元素都只能使用一次，但是可选的元素数组中会出现重复的元素，这也就意味着如果按照正常的DFS下来，是会出现重复的组合的。此处，我们按照如下思想来处理：</p>
<p>​ 我们先将它提供的整数数组进行排序，使其成为有序的数组。</p>
<p>​ 每一轮DFS的时候，记录上一轮有没有选择元素</p>
<ul>
<li><p>如果上一轮没有选择元素，并且当前元素和上一轮元素一样：那么该轮也只能选择
“不选择当前元素”，原因是如果两轮元素一致，"上一轮没选这一轮选了"，那么势必会和
"上一轮选了，这一轮不选"，这种情况产生重复。</p></li>
<li><p>如果上一轮选择了元素，那么该轮就可以正常操作：可以选择当前元素，也可以不选择当前元素。</p></li>
</ul>
<h5 id="解题代码-2">解题代码：</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">permute</span>(candidates,target,tmp,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">permute</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates,<span class="type">int</span> target,vector&lt;<span class="type">int</span>&gt; &amp;tmp,<span class="type">int</span> sum,<span class="type">int</span> curr,<span class="type">bool</span> choose)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当前vector，当前sum</span></span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curr &gt;= candidates.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(curr &gt;= <span class="number">1</span> &amp;&amp; candidates[curr] == candidates[curr<span class="number">-1</span>] &amp;&amp; !choose)&#123;</span><br><span class="line">            <span class="comment">//Case1: 不选择当前元素：</span></span><br><span class="line">            <span class="built_in">permute</span>(candidates,target,tmp,sum,curr+<span class="number">1</span>,<span class="literal">false</span>);  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//Case1: 不选择当前元素：</span></span><br><span class="line">            <span class="built_in">permute</span>(candidates,target,tmp,sum,curr+<span class="number">1</span>,<span class="literal">false</span>);  </span><br><span class="line"></span><br><span class="line">            <span class="comment">// Case2: 选择当前元素：</span></span><br><span class="line">            <span class="keyword">if</span>(sum + candidates[curr] &gt; target) <span class="keyword">return</span>;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(candidates[curr]);</span><br><span class="line">            <span class="built_in">permute</span>(candidates,target,tmp,sum + candidates[curr],curr+<span class="number">1</span>,<span class="literal">true</span>);</span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-offer-ii-083.-没有重复元素集合的全排列"><a
href="https://leetcode-cn.com/problems/VvJkup/">剑指 Offer II 083.
没有重复元素集合的全排列</a></h4>
<p>给定一个不含重复数字的整数数组 nums ，返回其 所有可能的全排列 。可以
按任意顺序 返回答案。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<pre><code>1 &lt;= nums.length &lt;= 6
-10 &lt;= nums[i] &lt;= 10
nums 中的所有整数 互不相同</code></pre>
<h5 id="解题思路-3">解题思路：</h5>
<p>​
本题跟直接求1-n这n个数的全排列是一样的思想，基本就是每一轮确定第curr个数是什么，如果<code>curr==nums.size()</code>就输出该种可能。并且我们需要一个<code>hasInclude[]</code>数组记录，某个数有没有被访问过。</p>
<h5 id="解题代码-3">解题代码：</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;<span class="type">bool</span>&gt; hasInclude;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            hasInclude.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,tmp,nums,hasInclude,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> curr,vector&lt;<span class="type">int</span>&gt;&amp; tmp,vector&lt;<span class="type">int</span>&gt;&amp; nums,vector&lt;<span class="type">bool</span>&gt; &amp;hasInclude,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="comment">//确定第curr个数是什么</span></span><br><span class="line">        <span class="keyword">if</span>(curr == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="comment">//代表到底了</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!hasInclude[i])&#123;</span><br><span class="line">                hasInclude[i] = <span class="literal">true</span>;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">dfs</span>(curr+<span class="number">1</span>,tmp,nums,hasInclude,res);</span><br><span class="line">                tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">                hasInclude[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-offer-ii-084.-含有重复元素集合的全排列"><a
href="https://leetcode-cn.com/problems/7p8L0Z/">剑指 Offer II 084.
含有重复元素集合的全排列</a></h4>
<p>给定一个可包含重复数字的整数集合 nums ，按任意顺序
返回它所有不重复的全排列。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure>
<h5 id="解题思路-4">解题思路：</h5>
<p>​
084这题相对于083而言，就像是082相对于081而言，多了一个重复元素。我们就需要排除重复的信息。一种朴素的想法是，用hash表记录每一个全排列的情况，然后每产生一个全排列就去Hash表里找有没有一样的，这是一种方法，但时间复杂度肯定较高。</p>
<p>​
比较优化的方法思想其实和082相似，也是需要先对数组进行排序，得到有序的nums.</p>
<p>​
我们在DFS的时候，如果当前元素和前面元素一样，并且前面的元素还没有被选择，那么该元素也不在本轮被选择。原因也和082一致，如果前面的元素没被选，而当前元素被选了，势必会和正常流程中，"前面元素选了，当前元素未选"的排列造成重复。所以只有当前面的元素已经被使用了，确定好位置了，后面的相同的元素才有机会被使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;<span class="type">bool</span>&gt; hasInclude;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            hasInclude.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,tmp,nums,hasInclude,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> curr,vector&lt;<span class="type">int</span>&gt;&amp; tmp,vector&lt;<span class="type">int</span>&gt;&amp; nums,vector&lt;<span class="type">bool</span>&gt; &amp;hasInclude,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="comment">//确定第curr个数是什么</span></span><br><span class="line">        <span class="keyword">if</span>(curr == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="comment">//代表到底了</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">1</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &amp;&amp; !hasInclude[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="comment">//前面元素和当前一样，并且前面的元素还没用掉，直接不选跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!hasInclude[i])&#123;</span><br><span class="line">                hasInclude[i] = <span class="literal">true</span>;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">dfs</span>(curr+<span class="number">1</span>,tmp,nums,hasInclude,res);</span><br><span class="line">                tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">                hasInclude[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-offer-ii-085.-生成匹配的括号"><a
href="https://leetcode-cn.com/problems/IDBivT/">剑指 Offer II 085.
生成匹配的括号</a></h4>
<p>正整数 <code>n</code>
代表生成括号的对数，请设计一个函数，用于能够生成所有可能的并且
<strong>有效的</strong> 括号组合。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure>
<h5 id="解题思路-5">解题思路：</h5>
<p>​
这是一道比较有趣的DFS的题目，DFS分支的条件比较难想，整体代码较为简单。</p>
<p>​
要想清楚，为什么此处我仅用两个Case就可以完成DFS分支的遍历，在最终输出的时候又做了哪些操作。</p>
<h5 id="解题代码-4">解题代码：</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string tmp;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,n,tmp,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> left_curr,<span class="type">int</span> right_curr,<span class="type">int</span> n,string tmp,vector&lt;string&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="comment">//left_curr当前加到第几个（了，right_curr 代表已经加了几个 ）</span></span><br><span class="line">        <span class="keyword">if</span>(left_curr == n)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=right_curr;i&lt;n;i++)&#123;</span><br><span class="line">                tmp += <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Case1: 仅加左括号</span></span><br><span class="line">        <span class="keyword">if</span>(left_curr &lt; n) <span class="built_in">dfs</span>(left_curr+<span class="number">1</span>,right_curr,n,tmp+<span class="string">&quot;(&quot;</span>,res);</span><br><span class="line">        <span class="comment">//Case2: 加一对右括号</span></span><br><span class="line">        <span class="keyword">if</span>(right_curr &lt; left_curr &amp;&amp; right_curr &lt; n) <span class="built_in">dfs</span>(left_curr,right_curr+<span class="number">1</span>,n,tmp+<span class="string">&quot;)&quot;</span>,res);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>DFS与BFS系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>图系列——重建序列</title>
    <url>/2022/02/26/16bfad4011e0/</url>
    <content><![CDATA[<h4 id="剑指-offer-ii-115.-重建序列"><a
href="https://leetcode-cn.com/problems/ur2n8P/">剑指 Offer II 115.
重建序列</a></h4>
<p>请判断原始的序列 org 是否可以从序列集 seqs 中唯一地 重建 。</p>
<p>序列 org 是 1 到 n 整数的排列，其中 1 ≤ n ≤ 10^4。重建 是指在序列集
seqs 中构建最短的公共超序列，即 seqs
中的任意序列都是该最短序列的子序列。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: org = [1,2,3], seqs = [[1,2],[1,3]]</span><br><span class="line">输出: false</span><br><span class="line">解释：[1,2,3] 不是可以被重建的唯一的序列，因为 [1,3,2] 也是一个合法的序列。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: org = [1,2,3], seqs = [[1,2]]</span><br><span class="line">输出: false</span><br><span class="line">解释：可以重建的序列只有 [1,2]。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: org = [1,2,3], seqs = [[1,2],[1,3],[2,3]]</span><br><span class="line">输出: true</span><br><span class="line">解释：序列 [1,2], [1,3] 和 [2,3] 可以被唯一地重建为原始的序列 [1,2,3]。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<pre><code>1 &lt;= n &lt;= 10^4
org 是数字 1 到 n 的一个排列
1 &lt;= segs[i].length &lt;= 10^5
seqs[i][j] 是 32 位有符号整数</code></pre>
<h5 id="解题思路">解题思路：</h5>
<p>​ 本题与<a
href="https://blog.fantast.top/2022/02/25/4e6244e39183/">[外星文字典](https://blog.fantast.top/2022/02/25/4e6244e39183/)</a>
相似，都是通过序列seqs获取拓扑排序信息，然后依据拓扑排序，观察是否与org一致，从而达到题目要求目的。具体可以参照官方思路，本题因为已经过了一刷测试点，仅在此记录</p>
<h5 id="解题代码">解题代码：</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">sequenceReconstruction</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; org, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; seqs)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = org.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 边集</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">edges</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 入度</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 记录seqs中的结点，可能有不在org里的这时候就要停了返回false</span></span><br><span class="line">        <span class="comment">// org 是一定是数字 1 到 n 的一个排列， 但seqs很自由</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nodes</span><span class="params">(n + <span class="number">1</span>)</span></span>; </span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; seq : seqs) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; seq.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="comment">// 不再org范围了</span></span><br><span class="line">                <span class="keyword">if</span> (seq[i] &lt; <span class="number">0</span> || seq[i] &gt; n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 记录出现结点数</span></span><br><span class="line">                <span class="keyword">if</span> (++nodes[seq[i]] == <span class="number">1</span>) cnt++;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                edges[seq[i - <span class="number">1</span>]].<span class="built_in">push_back</span>(seq[i]);</span><br><span class="line">                inDegree[seq[i]]++;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结点数不同</span></span><br><span class="line">        <span class="keyword">if</span> (cnt != n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 用队列和栈都可</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 队列中有2个以上结点，就有2种以上可能不唯一了</span></span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">size</span>() &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> node = q.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">if</span> (org[index] != node) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            index++;   </span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= edges[node].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--inDegree[edges[node][i - <span class="number">1</span>]] == <span class="number">0</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(edges[node][i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>图系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>graph</tag>
        <tag>topological sort</tag>
      </tags>
  </entry>
  <entry>
    <title>数组系列——值和下标之差都在给定范围内</title>
    <url>/2022/02/26/994b03ade281/</url>
    <content><![CDATA[<h4 id="剑指-offer-ii-057.-值和下标之差都在给定的范围内"><a
href="https://leetcode-cn.com/problems/7WqeDu/">剑指 Offer II 057.
值和下标之差都在给定的范围内</a></h4>
<p>​ 给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在
两个不同下标 i 和 j，使得 abs(nums[i] - nums[j]) &lt;= t ，同时又满足
abs(i - j) &lt;= k 。</p>
<p>​ 如果存在则返回 true，不存在返回 false。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,1], k = 3, t = 0</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,0,1,1], k = 1, t = 2</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,5,9,1,5,9], k = 2, t = 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<pre><code>0 &lt;= nums.length &lt;= 2 * 10^4
-2^31 &lt;= nums[i] &lt;= 2^31 - 1
0 &lt;= k &lt;= 10^4
0 &lt;= t &lt;= 2^31 - 1</code></pre>
<p>参考官方题解：https://leetcode-cn.com/problems/7WqeDu/solution/zhi-he-xia-biao-zhi-chai-du-zai-gei-ding-94ei/</p>
<p><strong>解题思路</strong>：</p>
<p>​
对于序列中每一个元素x左侧的最多k个元素而言，如果这k个元素中存在一个元素落在区间<code>[x-t,x+t]</code>中，那么就可以找到一对符合条件的元素。<strong>注意到对于两个相邻的元素而言，它们左侧的k个元素中有k-1个是重合的，所以可以考虑滑动窗口的思路，维护一个大小为k的滑动窗口，每次遍历到元素x的时候，滑动窗口中包含x前面的k个元素，我们只需要检查窗口中是否有元素满足要求即可。</strong></p>
<p>​
此时，问题就来了：<strong>如果使用队列维护滑动窗口内的元素，由于元素是无序的，我们只能对于每个元素都遍历一次队列来检查是否有元素符合条件。</strong>如果数组的长度为
n，则使用队列的时间复杂度为
O(nk)，这样跟暴力求解没有区别了。所以我们需要一个数据结构能够来用于维护滑动窗口，该容器需要满足：</p>
<ul>
<li>支持添加+删除元素</li>
<li>内部元素有序，我们可以快速判断是否有满足条件的元素。（具体而言，对于元素
x，当我们希望判断滑动窗口中是否存在某个数 y 落在区间
<code>[x - t, x + t]</code>中，只需要判断滑动窗口中所有大于等于 x−t
的元素中的最小元素是否小于等于 x+t 即可。</li>
</ul>
<p><strong>注意</strong></p>
<p>​ 如果当前有序集合中存在相同元素，那么此时程序将直接返回
true。因此本题中的有序集合无需处理相同元素的情况。</p>
<h5 id="官方解题代码">官方解题代码：</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; rec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = rec.<span class="built_in">lower_bound</span>(<span class="built_in">max</span>(nums[i], INT_MIN + t) - t);</span><br><span class="line">            <span class="keyword">if</span> (iter != rec.<span class="built_in">end</span>() &amp;&amp; *iter &lt;= <span class="built_in">min</span>(nums[i], INT_MAX - t) + t) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rec.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">                rec.<span class="built_in">erase</span>(nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/7WqeDu/solution/zhi-he-xia-biao-zhi-chai-du-zai-gei-ding-94ei/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>数组系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>图系列——外星文字典</title>
    <url>/2022/02/25/4e6244e39183/</url>
    <content><![CDATA[<h4 id="剑指-offer-ii-114.-外星文字典"><a
href="https://leetcode-cn.com/problems/Jf1JuT/">剑指 Offer II 114.
外星文字典</a></h4>
<p>现有一种使用英语字母的外星文语言，这门语言的字母顺序与英语顺序不同。</p>
<p>给定一个字符串列表 words ，作为这门语言的词典，words 中的字符串已经
按这门新语言的字母顺序进行了排序</p>
<p>请你根据该词典还原出此语言中已知的字母顺序，并 按字母递增顺序
排列。若不存在合法字母顺序，返回 ""
。若存在多种可能的合法字母顺序，返回其中 任意一种 顺序即可。</p>
<p>字符串 s 字典顺序小于 字符串 t 有两种情况：</p>
<ul>
<li>在第一个不同字母处，如果 s 中的字母在这门外星语言的字母顺序中位于 t
中字母之前，那么 s 的字典顺序小于 t 。</li>
<li>如果前面 min(s.length, t.length) 字母都相同，那么 s.length &lt;
t.length 时，s 的字典顺序也小于 t 。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：words = [&quot;wrt&quot;,&quot;wrf&quot;,&quot;er&quot;,&quot;ett&quot;,&quot;rftt&quot;]</span><br><span class="line">输出：&quot;wertf&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：words = [&quot;z&quot;,&quot;x&quot;]</span><br><span class="line">输出：&quot;zx&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：words = [&quot;z&quot;,&quot;x&quot;,&quot;z&quot;]</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：不存在合法字母顺序，因此返回 &quot;&quot; 。</span><br></pre></td></tr></table></figure>
<h5 id="解题思路"><strong>解题思路</strong>：</h5>
<p>​ 还是比较容易想到 建图 +
拓扑排序的。整体而言复杂度较高，但是思路应该比较清晰，主要过程就是分为两步：1、建图，从相邻的单词之间获取信息
2、拓扑排序，得到结果。</p>
<p>​
其中两个工具函数比较重要：<strong>一个是常见的transform函数</strong>，能够以O(1)的时间复杂度，用哈希表给每个字符赋予一个ID，方便后续进行拓扑排序。<strong>另一个就是getInfo函数</strong>，其接受两个字符串s1和s2，已知s1&lt;s2的情况下，返回一个<code>vector&lt;char&gt;</code>，第一位代表状态，第二三位代表其能够从中得到的字符字典序信息。具体见代码注释：</p>
<h5 id="解题代码"><strong>解题代码</strong>：</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; char2int;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">char</span>&gt; int2char;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">transform</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(char2int.<span class="built_in">find</span>(c) == char2int.<span class="built_in">end</span>())&#123;</span><br><span class="line">            char2int[c] = char2int.<span class="built_in">size</span>();</span><br><span class="line">            int2char[char2int.<span class="built_in">size</span>() - <span class="number">1</span>] = c;</span><br><span class="line">            <span class="keyword">return</span> char2int.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> char2int[c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">alienOrder</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(<span class="number">26</span>);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">isVisited</span><span class="params">(<span class="number">26</span>*<span class="number">26</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="comment">//先把所有字符添加进去</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;words.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;words[i].<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">                <span class="built_in">transform</span>(words[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构建图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;words.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            vector&lt;<span class="type">char</span>&gt; t = <span class="built_in">getInfo</span>(words[i],words[i+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(t[<span class="number">0</span>] == <span class="string">&#x27;2&#x27;</span>) <span class="keyword">continue</span>;  <span class="comment">// 仅长度不一样，无信息</span></span><br><span class="line">            <span class="keyword">if</span>(t[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; <span class="comment">//直接不需要后续的操作了，因为已经违反规则了</span></span><br><span class="line">            <span class="comment">// t[1] &lt; t[2] , 构建图 , t[1] -&gt; t[2]</span></span><br><span class="line">            <span class="type">int</span> idx1 = <span class="built_in">transform</span>(t[<span class="number">1</span>]);</span><br><span class="line">            <span class="type">int</span> idx2 = <span class="built_in">transform</span>(t[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">if</span>(!isVisited[idx1 * <span class="number">26</span> + idx2])&#123;  <span class="comment">//用于记录 idx1-&gt;idx2这个关系有没有添加过</span></span><br><span class="line">                isVisited[idx1 * <span class="number">26</span> + idx2] = <span class="literal">true</span>;</span><br><span class="line">                graph[idx1].<span class="built_in">push_back</span>(idx2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拓扑排序：</span></span><br><span class="line">        <span class="type">int</span> n = char2int.<span class="built_in">size</span>(); <span class="comment">// 节点个数</span></span><br><span class="line">        <span class="comment">// 如果图中有环，则不存在合理的情况 拓扑排序会失败。节点数不=n</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//遍历每一个节点，计算入度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;graph[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                inDegree[graph[i][j]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对于所有入度为0的节点入队列</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> curr = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            res += int2char[curr];</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;graph[curr].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                inDegree[graph[curr][j]]--;</span><br><span class="line">                <span class="keyword">if</span>(inDegree[graph[curr][j]] == <span class="number">0</span>) q.<span class="built_in">push</span>(graph[curr][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count == n) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">getInfo</span><span class="params">(string &amp;s1,string &amp;s2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 该函数用于返回从字符串s1&lt;s2这个信息中获得的有用信息，第一位为状态判断位，供函数调用者判断状态</span></span><br><span class="line">        <span class="comment">// 0 - 代表排序有误：该状态代表 s1比s2长，且公共部分内容相同，但是却判断s1&lt;s2，调用者遇到此状态上层可直接返回不合理即可。</span></span><br><span class="line">        <span class="comment">// 1 - 代表有可用信息: t[1] 在 t[2] 前面</span></span><br><span class="line">        <span class="comment">// 2 - 代表无可用信息，代表 s1&lt;s2 仅因为长度不同导致，无法获取字符的前后顺序</span></span><br><span class="line">        vector&lt;<span class="type">char</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> len1 = s1.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> len2 = s2.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> min_len = <span class="built_in">min</span>(len1,len2);</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;min_len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i] != s2[i])&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);   <span class="comment">//第一位为状态判断位 1-代表有可用信息</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(s1[i]);</span><br><span class="line">                res.<span class="built_in">push_back</span>(s2[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len1 &gt; len2 &amp;&amp; !flag)&#123;</span><br><span class="line">            <span class="comment">//如果s1比s2长，且在公共部分没找到内容的话，已经就不可能了</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>); <span class="comment">//第一位为状态判断位 0-代表有信息：这个信息告诉我们排序已经不可能了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len1 &lt;= len2 &amp;&amp; !flag)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="string">&#x27;2&#x27;</span>); <span class="comment">//第一位为状态判断位 2-代表无有用信息</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>图系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>graph</tag>
        <tag>topological sort</tag>
      </tags>
  </entry>
  <entry>
    <title>BFS系列——单词演变(困难)</title>
    <url>/2022/02/24/64f7eff00abc/</url>
    <content><![CDATA[<h4 id="剑指-offer-ii-108.-单词演变"><a
href="https://leetcode-cn.com/problems/om3reC/">剑指 Offer II 108.
单词演变</a></h4>
<p>在字典（单词列表） wordList 中，从单词 beginWord 和 endWord 的
转换序列 是一个按下述规格形成的序列：</p>
<pre><code>序列中第一个单词是 beginWord 。
序列中最后一个单词是 endWord 。
每次转换只能改变一个字母。
转换过程中的中间单词必须是字典 wordList 中的单词。</code></pre>
<p>​ 给定两个长度相同但内容不同的单词 beginWord 和 endWord 和一个字典
wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目
。如果不存在这样的转换序列，返回 0。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">输出：5</span><br><span class="line">解释：一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line">输出：0</span><br><span class="line">解释：endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<pre><code>1 &lt;= beginWord.length &lt;= 10
endWord.length == beginWord.length
1 &lt;= wordList.length &lt;= 5000
wordList[i].length == beginWord.length
beginWord、endWord 和 wordList[i] 由小写英文字母组成
beginWord != endWord
wordList 中的所有字符串 互不相同</code></pre>
<p>来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/om3reC
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="解题思路"><strong>解题思路</strong>：</h5>
<p>​
题目本身还是比较好理解的，最开始的思路也比较好想，就是将一个个单词赋予ID（使用Hash表），然后根据邻居关系建图，在知道起点与终点的情况下进行BFS即可。值得注意的点是：该题目作为一道困难的题目，时间限制卡的还是比较紧的。我们来看一下上述过程中可能耗费时间比较长的步骤：</p>
<ul>
<li>1、在建立图的时候，要判断单词与单词之间是不是邻居，就需要比较每个单词和每个单词是否只相差一个字母，时间复杂度为O(n^2
* C) , n为单词数量，C为单词长度。</li>
<li>2、在BFS搜索的时候，由于wordList长度上限为5000，整体来说还是比较大的一个图，需要耗费一定的时间。</li>
</ul>
<p>​
针对上述两个点，都有对应得优化算法，比较经典的就是用于替代单向BFS的<strong>双向BFS</strong>，可以大大缩短BFS的搜寻时间。<strong>我最开始就是做了双向BFS的优化，但是还是超时了。超时代码如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;string,<span class="type">int</span>&gt; str2int;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,string&gt; int2str;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">transform</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str2int.<span class="built_in">find</span>(str) == str2int.<span class="built_in">end</span>())&#123;</span><br><span class="line">            str2int[str] = str2int.<span class="built_in">size</span>();</span><br><span class="line">            int2str[str2int.<span class="built_in">size</span>()<span class="number">-1</span>] = str;</span><br><span class="line">            <span class="keyword">return</span> str2int.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> str2int[str];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNeighbor</span><span class="params">(<span class="type">int</span> idx1,<span class="type">int</span> idx2)</span></span>&#123;</span><br><span class="line">        string str1 = int2str[idx1];</span><br><span class="line">        string str2 = int2str[idx2];</span><br><span class="line">        <span class="keyword">if</span>(str1.<span class="built_in">length</span>() != str2.<span class="built_in">length</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;str1.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str1[i] != str2[i]) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ladderLength</span><span class="params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> begin = <span class="built_in">transform</span>(beginWord);</span><br><span class="line">        <span class="type">int</span> end = <span class="built_in">transform</span>(endWord);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;wordList.<span class="built_in">size</span>();i++) <span class="built_in">transform</span>(wordList[i]);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(str2int.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isNeighbor</span>(begin,end))&#123;</span><br><span class="line">            graph[begin].<span class="built_in">push_back</span>(end);</span><br><span class="line">            graph[end].<span class="built_in">push_back</span>(begin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构建图</span></span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;wordList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">//对于每个word均判断其和begin 或是 end是不是邻居，以及判断其和前面的wordList中的word是不是邻居</span></span><br><span class="line">            <span class="type">int</span> wordIdx = <span class="built_in">transform</span>(wordList[i]);</span><br><span class="line">            <span class="keyword">if</span>(wordIdx == end) flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(wordIdx == begin || wordIdx == end) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isNeighbor</span>(begin,wordIdx))&#123;</span><br><span class="line">                graph[begin].<span class="built_in">push_back</span>(wordIdx);</span><br><span class="line">                graph[wordIdx].<span class="built_in">push_back</span>(begin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isNeighbor</span>(end,wordIdx))&#123;</span><br><span class="line">                graph[end].<span class="built_in">push_back</span>(wordIdx);</span><br><span class="line">                graph[wordIdx].<span class="built_in">push_back</span>(end);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="type">int</span> wordIdx2 = <span class="built_in">transform</span>(wordList[j]);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">isNeighbor</span>(wordIdx2,wordIdx))&#123;</span><br><span class="line">                    graph[wordIdx2].<span class="built_in">push_back</span>(wordIdx);</span><br><span class="line">                    graph[wordIdx].<span class="built_in">push_back</span>(wordIdx2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果终点不在列表中，则直接返回0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出图代码，证明图构建正确</span></span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;graph.size();i++)&#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot; :&quot;;</span></span><br><span class="line">        <span class="comment">//     for(int j=0;j&lt;graph[i].size();j++)&#123;</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; graph[i][j] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//双向BFS</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(str2int.size())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(str2int.size())</span></span>;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q1; <span class="comment">//正向队列</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q2; <span class="comment">//逆向队列</span></span><br><span class="line">        q1.<span class="built_in">push</span>(begin);</span><br><span class="line">        q2.<span class="built_in">push</span>(end);</span><br><span class="line">        res[begin] = <span class="number">0</span>;</span><br><span class="line">        res[end] = <span class="number">0</span>;</span><br><span class="line">        vis[begin] = <span class="number">1</span>;</span><br><span class="line">        vis[end] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>() &amp;&amp; !q2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> idx;</span><br><span class="line">            <span class="type">bool</span> flag;</span><br><span class="line">            <span class="keyword">if</span>(q1.<span class="built_in">size</span>() &lt; q2.<span class="built_in">size</span>())&#123;  <span class="comment">// 正向BFS</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                idx = q1.<span class="built_in">front</span>();</span><br><span class="line">                q1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                idx = q2.<span class="built_in">front</span>();</span><br><span class="line">                q2.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;graph[idx].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="comment">//入队</span></span><br><span class="line">                <span class="keyword">if</span>(vis[graph[idx][i]] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//没访问过</span></span><br><span class="line">                    <span class="keyword">if</span>(flag) q1.<span class="built_in">push</span>(graph[idx][i]);</span><br><span class="line">                    <span class="keyword">else</span> q2.<span class="built_in">push</span>(graph[idx][i]);</span><br><span class="line">                    res[graph[idx][i]] = res[idx] + <span class="number">1</span>;</span><br><span class="line">                    vis[graph[idx][i]] = vis[idx];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(vis[graph[idx][i]]  + vis[idx] == <span class="number">3</span>)&#123;</span><br><span class="line">                        <span class="comment">//如果curr点和领居点的vst相加=3，意味着两者一个是正向搜索序列，一个是逆向搜索序列，相遇了，所以此时我们可以返回结果，不用继续下去了</span></span><br><span class="line">                        <span class="keyword">return</span> res[idx] + res[graph[idx][i]] + <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​
针对于另外一个可优化的点，其实先前博客中也记录过，针对于这种仅差一个字符的字符串相似的情况，我们叫做“字符串的广义邻居”，在该文章中提及过：<a
href="https://blog.fantast.top/2022/02/08/4ccc50ba5a4e">奇妙应用—字符串的广义邻居</a></p>
<p>​
在建图阶段，依据朴素的思路，就是像上面的代码一样枚举每一对单词的组合，判断它们是否恰好相差一个字符，以判断这两个单词对应的节点是否能够相连。但是这样效率太低，我们可以<strong>优化建图</strong>。</p>
<p>​ <strong>具体地，我们可以创建虚拟节点。对于单词
hit，我们创建三个虚拟节点<code>*it、h*t、hi*</code>，并让 hit
向这三个虚拟节点分别连一条边即可。如果一个单词能够转化为
hit，那么该单词必然会连接到这三个虚拟节点之一。对于每一个单词，我们枚举它连接到的虚拟节点，把该单词对应的
id 与这些虚拟节点对应的 id 相连即可。</strong></p>
<h5 id="解题代码"><strong>解题代码</strong>：</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;string,<span class="type">int</span>&gt; str2int;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,string&gt; int2str;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">transform</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str2int.<span class="built_in">find</span>(str) == str2int.<span class="built_in">end</span>())&#123;</span><br><span class="line">            str2int[str] = str2int.<span class="built_in">size</span>();</span><br><span class="line">            int2str[str2int.<span class="built_in">size</span>()<span class="number">-1</span>] = str;</span><br><span class="line">            <span class="keyword">return</span> str2int.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> str2int[str];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">constructNode</span><span class="params">(<span class="type">int</span> wordIdx, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;graph)</span></span>&#123;</span><br><span class="line">        <span class="comment">//构建字符串word的广义邻居（虚拟节点），让其和自己的真实节点相连</span></span><br><span class="line">        <span class="comment">//例如 word = dog ，那么构建广义邻居节点 *og,d*g,do*,让这三个节点和 dog节点相连</span></span><br><span class="line">        string word = int2str[wordIdx];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;word.<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">            <span class="comment">//将每一位变成*，形成虚拟节点,和当前节点连接</span></span><br><span class="line">            string tmp = word;</span><br><span class="line">            tmp[j] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            <span class="type">int</span> tmpIdx = <span class="built_in">transform</span>(tmp);</span><br><span class="line">            graph[tmpIdx].<span class="built_in">push_back</span>(wordIdx);</span><br><span class="line">            graph[wordIdx].<span class="built_in">push_back</span>(tmpIdx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ladderLength</span><span class="params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先将所有的原始字符串加入Hash表中</span></span><br><span class="line">        <span class="type">int</span> begin = <span class="built_in">transform</span>(beginWord);</span><br><span class="line">        <span class="type">int</span> end = <span class="built_in">transform</span>(endWord);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;wordList.<span class="built_in">size</span>();i++) <span class="built_in">transform</span>(wordList[i]);</span><br><span class="line">        <span class="comment">// 按照最坏情况分配空间</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(str2int.<span class="built_in">size</span>() * (wordList[<span class="number">0</span>].<span class="built_in">length</span>() + <span class="number">1</span>));   </span><br><span class="line">        <span class="comment">// 构建图，对于每一个节点，构建其的广义邻居以及自己的节点连接关系</span></span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">constructNode</span>(begin,graph);</span><br><span class="line">        <span class="built_in">constructNode</span>(end,graph);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;wordList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> wordIdx = <span class="built_in">transform</span>(wordList[i]); </span><br><span class="line">            <span class="keyword">if</span>(wordIdx == end) flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(wordIdx == begin || wordIdx == end) <span class="keyword">continue</span>;  <span class="comment">//如果是beginWord或endWord就不需要处理了，已经处理过</span></span><br><span class="line">            <span class="built_in">constructNode</span>(wordIdx,graph);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果终点不在列表中，则直接返回0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出图代码，证明图构建正确</span></span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;str2int.size();i++)&#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot;-&quot; &lt;&lt; int2str[i] &lt;&lt; &quot; :&quot;;</span></span><br><span class="line">        <span class="comment">//     for(int j=0;j&lt;graph[i].size();j++)&#123;</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; graph[i][j] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//双向BFS</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(str2int.size())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(str2int.size())</span></span>;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q1; <span class="comment">//正向队列</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q2; <span class="comment">//逆向队列</span></span><br><span class="line">        q1.<span class="built_in">push</span>(begin);</span><br><span class="line">        q2.<span class="built_in">push</span>(end);</span><br><span class="line">        res[begin] = <span class="number">0</span>;</span><br><span class="line">        res[end] = <span class="number">0</span>;</span><br><span class="line">        vis[begin] = <span class="number">1</span>;</span><br><span class="line">        vis[end] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>() &amp;&amp; !q2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> idx;</span><br><span class="line">            <span class="type">bool</span> flag;</span><br><span class="line">            <span class="keyword">if</span>(q1.<span class="built_in">size</span>() &lt; q2.<span class="built_in">size</span>())&#123;  <span class="comment">// 正向BFS</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                idx = q1.<span class="built_in">front</span>();</span><br><span class="line">                q1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                idx = q2.<span class="built_in">front</span>();</span><br><span class="line">                q2.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;graph[idx].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="comment">//入队</span></span><br><span class="line">                <span class="keyword">if</span>(vis[graph[idx][i]] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//没访问过</span></span><br><span class="line">                    <span class="keyword">if</span>(flag) q1.<span class="built_in">push</span>(graph[idx][i]);</span><br><span class="line">                    <span class="keyword">else</span> q2.<span class="built_in">push</span>(graph[idx][i]);</span><br><span class="line">                    res[graph[idx][i]] = res[idx] + <span class="number">1</span>;</span><br><span class="line">                    vis[graph[idx][i]] = vis[idx];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(vis[graph[idx][i]]  + vis[idx] == <span class="number">3</span>)&#123;</span><br><span class="line">                        <span class="comment">//如果curr点和领居点的vst相加=3，意味着两者一个是正向搜索序列，一个是逆向搜索序列，相遇了，所以此时我们可以返回结果，不用继续下去了</span></span><br><span class="line">                        <span class="built_in">return</span> (res[idx] + res[graph[idx][i]] + <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>DFS与BFS系列</category>
        <category>字符串系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>则观云资源需求与分析</title>
    <url>/2022/02/24/8386be03d737/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="76ac2659e004ed59782ee397a600aa20bb8af24e44d33018f62771cbe2be67cb">873f131ca1ff7e2c43970aa30a8cbe91558e1bd1b27fe5e295778a23f5da27616d05821cace9112a2c38b7c04f815fdea3db87b6c532f12ef5353821928ce95ac46291d124793317a1f1f9e02ad583463dbd72bc42dfcb0dde2aa116c317c374b95af43dc0935a8acaf6d034d929b1b7594462dcf6fa52d4553b14de2d3dd99ed228cb3d2e5ddb2cea98316778aa772cd83ab7e87ebed9e79d561e8c2d08ea9c772c8f4742340df6f79dd1cdbb791d210c7ce5f4884211e5b940ec8c656b7027e41ea2ad1a1e386fbafcfa867e3c42481cbffd2625585dbc8ff876aeaa3bb1e83190715509a26e82b181ca956fc1bb970be084d004e273fd7174ab5e80fda3aa6441155c036123dfaf0fbbadb785d3ae4a39e24b88d291bd90d685ff91aa5e51bacef096d31500d326ed103bec423ed816c9b85d1a4296e0e56b75d8cdff0ed7a15307554af020664fa0a3b97ebbfb0fe901633d6d9d95c698d0c4842acdb9cec6d34e039c7dfd0351b1c6ba8c8a80a3345774a61b73d32ecdc4fec8d8b334ae96b9584534c7b81222e1eeb80751fefa95fcef36c0b5a529e933c5975bef799fc32810f6a30f45ba28542fa11605bc0d6650fb4825e79f8a454aac2b8ffeddce2c7f07cc8c066e5457c3c38961dd2ac173d2205f1f3a85def6edb1e2a107e65d9ca8dba9e32dd4be0966852c7736737175561d52fd71c1b1318d871b7945395ad1f0934dc7e17ef6c303ccd0bfb00a10a36d9c555daa091ecf46515b91bd2b8dc30080b08357c434b5cdce5d837a49afabe31148aa9ffaffc3dff9ce4a1a7e01589bec84a378309ec9f0f8111825d1c3dbe49f2b0e22f070ea674211e0eeb8d058c2e04843a7ac71c8645995b60a6e1c56f81cfdeffd45472dd92020eb0e3a9cc1d4d3946eb97245349f32ce53fc656cd23be9438ea0a18ed5093423d8e793971edbef2895b2d3e737d4d049962d1f0e22e0dba93d8a455de38be61f7c4120e0b6551bc1241c9ec3cbb406cafadee50ef003313597f179bbfd94180914b471209f1bb77ea1dbed44f84c9dea53bb9198b546f21338efffa4eeda90aa07a9d1cc4943ae014eb2f2184705ded2178c956a2c088f900ec7ecc5525852345077c2da562caf3f81716437d7b0b5b4484d27d6b8bb7e10bd31fd1c1d83fee0724108a4915655cf08f2aa3cdc985cd26d6430f146b1bce6e5596ad8f5a2f4f41f896b7bedc5b1e26d0459c035c5627f7810bb292e8bd86e33d466719ff5e24b360882f0969b6ce415c64a304f9ed4c6d483a8966967dffa4b5be2726856cdabbd1bb9b2e940845b47efa58fc76e6a9b7782b3e3b0eb2e9e1bc016391b9b89a1a03085482ec219e49bd11add9e8fc434c0acb56fb205ae57720fb8145c0c8e39e7e2c203e3c39b13319f6920bc99341f94eae06375361cbbed9106331922a6501b3d7f79b6761635c50c4288e5698eba5f41777ef82880c93cc0ddfa9e934e791ec306590f2795aab6d4a188b9fe518b495326ab4fc61d887919e30854758eb31ef50af6e881087a1d73bee744281878161c291f15d9c86b91a8120d216386fb884cdc579216209cf5e316e70b9634fda05d89c687ecae2efb267b184f35c22aa444697e3d5d03ad446e4ded471aabea4352b77d51b186dbd62dedadc16af26aba33ab9acacb23419b64c1651efc33f0d2dfe8d60eb244ba4b3ec0a34269d34407b248b1ee494bf2cd5d84b9f8acab4528c645de22a88d9627b2b55269128bf3edacd8673134d7946a529255c85ab500798e94cb585449c88db0f1f6255b13e7b03e2fb626fbec759bd9adb8105668d44b9e8fff554b7b8518b20f14ce090549199af20de2cb7a3b5b69318b3530a7f4d7824d96adc51b73e7e7b5f9faf04f46e4593b21a786078f3915c5f23df41c42dabde0f9cc61597a15a911e45d5dde8e723a3618c53737b25b61cc24cd6d9f8c8b95ea357a5b5ccb03242be4a6bb8323f0cc6505b9b867efb44ddcf8c0719d5d5e4089f34114d585b3a5a0638511eefad7c97dbb808ec395a79848f8ebf410203503a0341f587f86b05289bfbed7b25d24f7eec8a367dbc7b72b539b8ec16e09ed4183c443d3e9e35706ca0adf491c33278f9b026afdf06ffc6ffbae81c9b9a04208e7e6c0cc7dc31e3b6c90e2c717ca9b4799efa9f2db1d42d88ed4d5e31cf069cff5cfc463edd778348af45ec342f11c9ea67c7c00318eae846d2dcc68967d91bf6cb8576c614ab5a6d993048ffb07f7f8f3f3bb4ae35fdc7014a1a81a7bef124697885eb7624d6971b7c13a6bd768a8c4d50e449f5cd42bbcecc357bf7eeab5e8ac9f99d7917cbf1faa272d129c3e1ca1365cbe20b57f9863b1aff4bf79500e3502cbd88731abfb32e5a1c2c069a85c409875c2e5ffadfbc7daa8a11b1d90ba9971cd44849bb0be924d1e0a08a2b3944c6876c6eef270f0bad92a3806b59da72a53db2be0f6a07a23b2f8417f14964dd017477af0067c9b7e15368a6af7c70825016f8fe0dfdce0f938c52dc517de4011ccb1cb968bd3ddb218ac17963659f4ec7bc326407d0116fb6bc02551e3318a037d233f3d7a277e972cf0cb34841e22d1cd5631c0abafe8e1bdbbbd5778ce139179ead8eac092b51ac197b7e18a042dd805b86d28d86b45a63f1ad02b6c4264e5fef657c3baaca3889c0e11752253573b725c1f541bfe1521dc6bfbc097ad4dd5fe49d66b10094de4d7f794d38501c37b0e5988f4ffa4c697a910c78c8d9e709c27e32fbb3432319dbf1fd41411e427acee6d4ad03f1dbd8d343a62b63183d7c26f2057fef8b90abf49a16dbe4c2fddd87fb6f06f0575b4a134f3bcd1add4e8cea176752534687fe258f76fba04c0ae539cb4b62bb7bc5894b065607cae163cd5de66b43bcf2f0fd16b303c9078bdbd2ba0fa3fdabf8ac5232d7da68ab99e841fbf01ee8e20f9bb0c0dcb9c5347e09b0d94a9c821db52eabb12919d5dc6d43511c74f92e5baf1513dd7ff68482610cd27535aaa47f13ccf6c14f657642d0123997428ce763d90b9fddf12fea7df6835485b07bf5ee51557ca1165c9e9460155962e6316bbd7ad7fcf535e4023619cef0cfa332e3888f09122e1e7608b472bec17296797c60be0e0cc21acb82e5e9d4990a1b77eae7a41f1ec8c079abddca71ac08c7234f062533132f33134ddde99be7e89fee1ccc62237ce42e0dfc3022fcc65cf14949d69d9835860edc235128fc659dce94f24be679bf84cbcd6c179cf6179a2283c68263524263c7c149e8ec772ec526814bb5decc3a20786104dbd4674c38905b814f32eafc0adfe38bc9c941978929050cebe35ce6945a60ebc3abd25bac9c3be76fdfea578f50e4a897d34fdcd9f672b4e4d85c6b6a5c8eab3cb576033a87a5251a309b56fb71a58afe9b407e77b6a7bb96a249fd01fcf1351c28fd86b9b0b8fd534a4a37d81e342cb97ee8e60b55d63733692c68b9a452a4e8cffd318874926eec00e4f92e256fde9395644c7c3c4d6d449473c5553a4b477459c9a3a039f290a56dfe5518be237606e436c7bf7054f9a001401c3db3a5911591a491c36fe6f3699279bfcb0b2e8365b7487206094236bfd8ed8adc83a76fb9eb9ca26619ea3e180a5aec0396a561ef289ae0f2b554668fd9a34d3668bc052436aebca3607fdae412ff0cbfbbf308123dfc061b1241f946ff0b3d83a144ed84a363d83700a97129d4dbef772590f9ba8b91d8309daeb04e9e4a2810805b3fb95131172020ce1f0c727340071e705c40ff01eb915a5f64916a04c64c5a28fec6d79c0d5309e76de05391c9972df1a3e7fe0c7372a8b73523dfd00995f1344636481df1df6c8b91ad3159d47dd644bd0990fab9b7380b432c96bec7da87d67f87c1c7d75704890e3b29ff6f177086f587549594d8816d4e88097ade43af4f18e736eb6d87b1a9b4490b3e9459eefa6139f1f512527b457e8feb17b0d27debbe1f5e1cbe31357b6382f5a7513a15f32c365570ba8cd79057000812df85b4db2207af47c7fd36234373c9eb9d6c8739d811a34ccdade79dcf3a1d0cae557d02255702dc516d0871b87a17476a034970dc8801b19184a010ab0fbeecc91bf5e51f090ebf00c35fc4b6ad04956295e7c8e38a6d3cb119fc3a8894bfea95bddde99d76ae328dbdd177e259feec22d5839139277ed5a9eea49ac7ed449f62eced2bbab7932221ff3a0206e95314821be108b003b7769aff1f6d78515f89c7212e52f7e236d99371eb738af770ef5b768b21061aee5c4a86c4433ca4124c2b8c37061a26c5b0d01aa8e706ff4d481311cf4592f13e98f2eb41bd581b60e34b2d589eea50b6dcef18d6ddcd6434f457911b8ffdf404406a2d6bc2e82b0e5ce0c8e65d1eeaf4063162720b8579d81717992e1d3bfedc6a4208b7826ae26955cbda1c4e80e582d435fba8a45b8cdc4691b342a50bd2f740fa3c79f4b9fde01d18ee5b04fd08ee2bb6ce8193bf7716ac1fbe2cc274bfb288e775cc582c3eab3f7d29565b9459f83941bfb1496d253bb30ddc7ed9dbcd34e7679c4960705f9bb8769e8494c994b5c0caef633284f297b1fe5818051e648a467c1812cfb802756c7b6c5ad78ca9834f03040f43fae9751997d54fd3a52b5576635d1ea89637e8d512a239d1c840770ee2de21c958c331a28a280dcd0d12d8de8447565ebbedc593aeea1756ea55bada512dc6c5bf72a6f451dfe1f016c83a7bf36f712894961b02c81d83111390be527eae9175d63e9082485a4644fcf8f8a2158b00800fc9705a08876f11dcbf4e7b0af55911daa9d120af1e9529e0da34c62e475b0eec367c61186ab71963cb22c022cfa332c0060c121c2d5b79c3ed225994ba286a581273144d3c279ac29041e389bef11571128848656c83e9b3e25108cbe87e29b836554f7af0be63bdedc9d11873a1563bf2ce89b27c5b6d5cfef33326592bfd60d623d5bd438dd5bc21cd48d715c66e04ba3fe9fec5928fa1ea78d6e8300e30b7d83b7c226f20367c57b3084e6cd163d2048668ad3b58a10bbac1f004c4bec91064b7c300435edaa7b9f7d4be4c9f2fd6000096e58bd91baaab082f3e1bbcf2c440106c06310232ebce4969d5de159c0df74f142a45462b3d337ddfb6d835ea8e431b5eed35b5f6c9e4e9e5472d7fa6d0079ae0d1c6ee0b50f6e9c1eff551ddc591abdce415c4999fffedd52e1132d882f7aa2f17f2d929f5697029c25a37c920aa586d3286017c99d93d9b3811f54906dbe7442f5ea4d77ffa40dbfabe7c573370da45201a13d206398ea972759d7e952a19aa2bf58c37f91f7adc543ef4f404c83b7779a9715a72312a81ea3066619b7aa1b50c95c317195bd94f9b7b6d15361ca9a99106a0bfcd73bf027847bdc12c4a3e34cbfb295ebcbde2969f1a39cdec19bef9d4b36026c2f16b3a92c1077558c632c4356707eea3d85ad04117e218efbf0b9d8334d7dafcff5933c081f561165c975d6f42c63359097f322146795be15fc24c4b4262f2e2fce03a18383dbd7a9bdc10e98c9b34627f1298b44ac761e586d64ebb04c336427a74366c476402a5b7a634163c797686c5c17a42ee0dd7f1627667183bb1ae1876e1b0a4ad06bd2dc21d42b1f4bd16bdd98e8e565bf64abb244df83c06bd34b06866e90801cb9e4e09d902f10f33dec45f544ae7ea9a491a4dfbd7d428d82d345c6f1a68f53c598612b6758ba1fb5603c662d66b74cc6811f641f55aecd9a18931395da2bc2e0f6d3354c4680c4e82ebefa255f4fc79d10123bc43dadb7744c43ca2aaeb8e1e67309767b057456766233505047e1006b61c3d8ccba06108792b0a111409d802edc1722c04c504c2c1fa2b2b6a96b153e33d9ba647d83cd070bbee89b8ec2e372e58cb6f8af186d8d4ba54d6dfc59c527c14d21c561ff949502947354172f5ce98a745f53da30be264b8316a85b55d5d7b48cafecfc1988e344618af05dedca1740ae428039cbcb4122237763d316f905914726dca50b8269a4856603672862c18c37b8018d7436f832172b2862f1993e7a1ed589dd53889fa5b65e8175a1478b3be91976915359383dd23d216b7a7dafcaadc16d34e7220a12858331bf9931980d0a33f3c87810d932fd96b608a8c3643a88d3b2f3dbdbc70eb53ba29661aea64aba76aa5122c614bf68768f33b3f53b8cb768259482b3b90ccd4e3ffa0d1a856dc344fdf3cf874536868b993a8acdab569ec1f2eacbef4ca1ca96707cbd0b4f48f6f1bb07c67bb2ad7d04bfbc91a505af7bb94688c883b0e0ea5868e2918181e5430aa06c99726cf5b7868cc6ca0df0f8d2f75cf7cf71239bb5cc7531e9cd586d0ac90551effbbe4a404cb8aec17b206ca3255e1ea96fa85bbd232b81c4da13e37b2f5588c2423420a7add6e084b1a850e9b8e9c83c9e35594bec93e64f958453483e2446cf1d0864582f05f854680bb76d4ae835956d1ef58185907657b986294382084342f9edad01a5ead90dea3ebab428570b3317a4b2d2e481c222f4d53f436be05f8e246014dc74fed3cc1118ca23dcf0b3f912f521e0e71765f40e36569a4afb2d51d9b8841d8bfb5b8a3cf03dd5ea7c38d7615f1a8bc93ec1210d0b99607c8f610147dd07006157daaefafe5220efc86921a077cf89ce247aff3fd76d6a94e3ca053411773c44e18ddb2cb3255d0920ef832713a9bbb5c88393ee9de1b6dfffb35ce65c88942231484dd7c0e1ce2b0f2edab27318cda671ef6ec4e84137d4963df16288095c289258d5e38b47832126ef38ef91b475a37f51cc4b7ed34b3c05dfdf1e2cd5d19596605d2a0c569d61f6001c5f817175f0a7b5b27164771e3ac6bd0b3759ab2801586a0df0f1c4e443c535fa90351344a556f09e8be35c95a82c6788f1df9a40d30c33f68a7b132f1095e91344cc57c54c8d34f8e2af1c3a6d1f36ab5372c3083767783ecb5bd6e5563baec8396dabc6fdd62443df25b18ae04cae0dd38440ccf6bc7d06312aa67452d9a15909754f9992fa8eac6efb62a9b2c44fa2a722b6269d79fe6127bba91a3736e017dd2f7cde74b85447a457c9ff5f27866e02e0b268de4f59d0823b98c1c6162d774bdd2cba6fbeb3fcfa4d95c94f8d1b5fd2ade22ca927a7d0bf814c7fd9a72e9ea25c3a9a3ad662264dbe8d98738f2ac6254a1cfddd41126d1371c9618afa68f23235c3008f1440266ae050c0f9a491b30637e84f6b4716ecff3c3c30cd0b1520c5d61cc522cdff55295d3430bdda35da3debad26eb9bed4a9fef7afaaa02a923aa968c6330b52091a64cdde774bebbca7ed3f2146d7bf6354d0b66e0504a7ee99a31985c034dff91b5b788d6584ad1293612cfa91f295e1709a5474574d9dc5b2446f2aebb86a39c9f3a05f41e4ff804d425dee52011f921ef96e3ad6840aaf47b7c3eb67b6a987b51cb8f7b8f40776a9bd17bfa70eba72c2e2552538789ab29e30aae6117a3360bf8cec0113fe384526a3673b4974ce4a0a6d19552c0ebd3f784fdb0b0af356353cc806e4dd9fba3b982b5e304e1e4ba5f9608475449b8f1472c6aba71a089c9fcc1b22844af8278bd676328333b720d89eb5339c21af4e8b41de9bc72c999cd788ba01e692525f1620b2abffca5d2b8b91330b7682b0b97fd4d3544df5ad68d9520ac19f264e2d50d7aff9652147ef3517f19cfd4d0da8e74dff44151e60dade3920ce368eb35553878dbecc863c10c04e0cbd681f03bb381a7cba6fa3079e9c0fc904a302cb27ba828a85f3bd83fd5b97a881492669cc6f9a1ab03dad6380fe6337d0aea8baa39f3dcfd2c63b6e08f269e2c42938c7d1da46b853f5266b581e6c2f8af8948d86da24e02ec417ca5f4a3ee01fb25891ab0ebea4e3e256b427f609eeafff33d9053d643494653d627433d1a9dc64eb07c3e48212b2dd6151c6a501eefaa7cb14d0a6b9f41a0a5d15ff2f90bdde8d2ee22bf2899f6375c8ac2f9df34b0a5792cebc811f9270f6be9e653bb659b1d27c64bade8f6534b47c92c1e17998c8e14b0930f3930a7894ee2aeda85dad6848109218bfc200cc8ef521f1e8e4ea8da3d73321909010f9da2818694aa7a55339ec4f0bcc1b2970f58f9f989bc9d9e219fa2da110276e79c290943958facff05de4d2c5dc27d804ba8a8d92b6a887aa8b50f8aa311bab29aaa0125e21fc1c5969477158749138994f48f8c230dfeaed090981dd2bfd5330459aa09be9d88313217272309b3870ffa231c83896d252aef3169421f34cf09405eab72001fc9cc6ab9dfa8c2aff2779922de632567ad96aa5ac4d9809df6edc6f73f573b1fb6f6ed2a72c15e177b864eb1b6d2f95cc85058bcfbfee68b4155e80cd73072312824f686006365b51526f96ddb05661470b0c2c81ba24a71f309eec9ab31629a07281d83433f3d20730fcc8da2b1948001279fc9c4ec644ef679c82db7be413aae6ea6fa9f55cd06e8c83586c7e3c9a003caf96d4ea2f46e73e26fdfc2624c076f5c5b3aee55d624dc56ec206a225b05f9744d75618ffe51a51170f0f215a4f0a064d28a55705bc9eed2b15cef40ee26862c0b6366cc2502dc5484adb81f6eeba7a8a23f3c29dfc2e3fba2a4a9c73155eb1ff18b1e182a84f273afea318677f9a6f0a8a6c4aff8d77ed89af0156461d28b752b1adb71ccef3bd4aaca3b55849cf25bd6c050848d07edb1751048029d252fa940bd49aed60bca7910ad3624b03dc994edcb1ad5cd7a83117abff90b151f8347417589041d56dc66cfb072960a13a7037d949e3482436627da29689a0f7ebce8bf78b5c10f2c05b049ba09721e9fd4788d3037493119002c9c3a22631da8ae1a084a2671c38b2d8492582f27e24a4d30072b6c7c9cfe2261ee419f47968b11868a9450d97c6373013f6d0d764619866e4a6e7a80077ebb0fad69d99503c43000413c3611881f7171e12f7910afce647eda7396524c1b8cdde1f458444edbb85babe23f3470210901f66f7ac3ccd1c4a21d1ce826171923766a8a9f510ba0a6b2d0738aa56fe45bd85b656c8cae569c077dbe0dc4cee6036f881aaa55d34f130e0df526df6b8399d129b5e111e5965b66f7e89c27d77fefedfbc82b221a9faf0a594c6f157717e4ba3c8fc9584fd70c0dd784d60521ce26d0f0ea81232650073358c64252a0eecbe4318b951ef48dd4c8be36ca5d00d29af1a85f1151443898de45565826f3a483d90af97295817a8872b91cf98411798b55a74b51c4dbe57f757f5b2c60326321e0c639d0167b88a849083df395e9f82ac9acd26c61482a643d1afd2ecfb37ac50407ed5c5e2315360e4ec52fd5540fa3b78058e16700ec91119cc173568af604b57d72aad86648f7754739efb609d3ff4bc1ccdccaa7a095bbd22bfbf78f53321b7c01777f03322d4bd96cb74a4adcc4503b700561247f32251d62ec6e7f86db21025e208da441d330fe0367d9e57df467b60f7b683333d3a2c9a88ce325e842b876fa879b865e863114ae412f4c105c100bb124081cac51800ec051d391ab730cc0edeaf5a7bbd542fd65251679b4f530e29371b3239a69e3e449dab904eb0dcadff839c7574bb143fe2c2db169d5c2aa0b70001c1ddb04328582afce3b0b7904d3187824e3aa78b7bd78f3f9cbfc3f2685c157aacf04cf450cd451a0c540a3907f0a1c5bd967282a94949ab494f0fd44cc37e12c5195116083b22c80c4f2b3a70237063d7f91e75454352048bcb048e258ae4fbc3a39db35341b1c615486bc4ea95b4d81e4776a4684fde6851ba261e70a540b418ee492225a41dc450c5049149f51eeb8d511e9126df1fa4c1477d5ea8ba04d05360c925c07a763db760a9ec4dfd7022c5a3d5ba9184e762cd4bba11ed36f6c19c6deb2d47ba7ae32f1f4146ced3ce12d87d576abf3026720644dd9b9bdba145a7449d541c7c5f661a7df84f7ca59a5ab77c609ac93883aef54175301e62d1fc56acda383275057405cdce1f80eb4a27da35d87e12945d581c60cbe0db626ce7f46ef03b174c2f5f41a8aea4a0c10ff9138eaed74b158d70977ae932a80a26742d51440a94aa6bf8775103f4cea90e61a52fd60f1bda88e63bcf486e63ca7105495a6e72ab6dfa1aefdd65e6ba1b6e41818575d7dfc8b1d724199301e33c30755ff75fe87faa654ddec5b191c7d7e244175728aac34a374cb537b4e0c0cc3d9c3b7ad492b66f72e6734b190e503b71b808f44f7afdf8dc0bb9d1f0dad124bc37fd2ed973eda248f89cf6bd79aee339849a9b00a1d43c5c46d6e957b6ff0de66de7a25cb8d55f75237611f4ffa813076bde39fa60261f79d2a70bfc1ee33f2148a6917cbdbb17c9dce2f1220d53c28f6ee290c95f7a4cc5316f07bf97997695dac7b0fc04209835e1541cd601141967e2ecb4d529119d6149162f4818e433f63546b7b93eca3dba477ddcd390269140de5ecbcfaf2909b0d298ca9c11f7421de0c45958b7202feef658380f0016582d7dba3e1da7dd8634b294a060ffa13a8f3182686eaecb4f7e03b360df32a11bcba158c3b18bb9145c1a23226c592be82b9d6bd829513540d6f1334ff70bbb3d15882439897c476e7deae4b9ef2ee1ffff7c1016155b745ee3bd6073dbfbadeab8e2e74a4f0f5ea118d562421fc74dc337afb0f8957a31dc0a3aef41cf72e6017f8988c8f0b053c641f46c784bce845d4a42bfa7247e0b6c2b3cebd6120501016111ab0f98368b8bba61d1a881cc45afc5e5cc178256f862222d2e34a32d9f3895f5a5229bb3db596add86756a1a866f3cd01455eba827bf2dbb064e07631e2447fca55a7eac379656830e5bc8f827e318b8f169e54fc</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>⑩ 其他内容</category>
      </categories>
  </entry>
  <entry>
    <title>动态规划——背包问题应用</title>
    <url>/2022/02/24/46f0b3257e29/</url>
    <content><![CDATA[<h4 id="剑指-offer-ii-102.-加减的目标值"><a
href="https://leetcode-cn.com/problems/YaVDxD/">剑指 Offer II 102.
加减的目标值</a></h4>
<p>给定一个正整数数组 nums 和一个整数 target 。</p>
<p>向数组中的每个整数前添加 '+' 或 '-'
，然后串联起所有整数，可以构造一个 表达式：</p>
<ul>
<li>例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-'
，然后串联起来得到表达式 "+2-1"</li>
</ul>
<p>返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式
的数目。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1,1,1], target = 3</span><br><span class="line">输出：5</span><br><span class="line">解释：一共有 5 种方法让最终目标和为 3.</span><br><span class="line">-1 + 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 - 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 - 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 - 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 + 1 - 1 = 3</span><br></pre></td></tr></table></figure>
<p><strong>提示</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">20</span></span><br><span class="line"><span class="number">0</span> &lt;= nums[i] &lt;= <span class="number">1000</span></span><br><span class="line"><span class="number">0</span> &lt;= <span class="built_in">sum</span>(nums[i]) &lt;= <span class="number">1000</span></span><br><span class="line"><span class="number">-1000</span> &lt;= target &lt;= <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<h5 id="解题思路"><strong>解题思路</strong>：</h5>
<p>​
在本题的背景下，<strong>一开始的错误思路：</strong>利用动态规划的思想，定义二维数组res，<code>res[i][j]</code>代表前<code>i</code>个数，按照题目所给规则，计算得到<code>target = j</code>的方法数目。然后状态转移方程如下
<code>res[i][j] = res[i-1][j-ele] + res[i-1][j+ele]</code>，<code>ele</code>是第<code>i</code>个元素。这个思路基于的思想就是：第<code>i</code>个元素，我们可以给它添加<code>+</code>或者<code>-</code>号，这样的话和为前<code>i</code>个元素计算得到<code>target</code>为<code>j</code>的方法数只有两种可能的路径，就是前<code>i-1</code>个元素。</p>
<p>​
但是代码写着写着，发现一个不太对的地方，那就是target目标是有可能负的，也就是说，我们需要初始化的<code>j</code>的维度需要代表从<code>-1000~target</code>，但是这样还不能解决问题，因为有可能<code>j-ele</code>是比<code>-1000</code>小的，小多少无从可知，所以我们就没有办法进行比较高效的动态规划。</p>
<p>​ <strong>正确思路</strong>：
我们可以将上述问题转化为，从前<code>i</code>个数字中，选取一定的数字，使得和为<code>j</code>，可能的方法数量。这个和上面的区别在于，我们不再考虑添加正负号，而是直接把上述问题转换为了一个背包问题。因为我们知道，如果正数和为<code>j</code>，那么剩余的负数和为<code>sum-j</code>，<code>sum</code>为<code>nums</code>数组中所有元素的和。那么最后只需要满足如下公式：<code>2 * j - sum = target</code>，就可以得到我们需要的对应方法的数量。也就是说，我们如果定义二维数组<code>res</code>，代表前<code>i</code>个数，选取一定数字，得到和为<code>j</code>的方法数目，那么我们最后<code>res[nums.size()][(sum + target) / 2]</code>即为我们所需要的答案。（注：如果<code>sum+target</code>是奇数，那么必定不存在任何一种方法）。</p>
<p>以下为动态规划的几个重要内容：</p>
<h5 id="动态规划思想"><strong>动态规划思想</strong>：</h5>
<pre><code>`res[i][j]`，代表前`i`个数，选取一定数字，得到和为`j`的方法数目</code></pre>
<h5 id="初始化状态"><strong>初始化状态</strong>：</h5>
<pre><code>`res[0][0-target] `都置为0，且 `res[0][0]` 置为 1</code></pre>
<h5 id="状态转移方程"><strong>状态转移方程</strong>：</h5>
<p>​
<code>res[i][j] = res[i-1][j] + res[i-1][j-ele] (if j - ele &gt;= 0)</code></p>
<p>​ <code>res[i][j] = res[i-1][j] (if j - ele &lt; 0)</code></p>
<p>​ <code>ele = nums[i-1]</code></p>
<h5 id="代码如下"><strong>代码如下</strong>：</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">if</span>((sum+target) % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> need_size = (sum + target) / <span class="number">2</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(nums.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(need_size+<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//初始化状态： res[0][0-target] 都置为0，且 res[0][0] 置为 1</span></span><br><span class="line">        <span class="comment">//状态转移： res[i][j] = res[i-1][j] + res[i-1][j-ele] 前提是 j-ele 存在</span></span><br><span class="line">        <span class="comment">//如果j-ele 不存在 res[i][j] = res[i-1][j] </span></span><br><span class="line">        res[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> ele = nums[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=need_size;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= ele)&#123;</span><br><span class="line">                    res[i][j] = res[i<span class="number">-1</span>][j] + res[i<span class="number">-1</span>][j-ele];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res[i][j] = res[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[nums.<span class="built_in">size</span>()][need_size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-offer-ii-103.-最少的硬币数目"><a
href="https://leetcode-cn.com/problems/gaM7Ch/">剑指 Offer II 103.
最少的硬币数目</a></h4>
<p>给定不同面额的硬币 coins 和一个总金额
amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回
-1。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：coins = [1, 2, 5], amount = 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure>
<h5 id="解题思路-1"><strong>解题思路</strong>：</h5>
<p>其实本题就是一道完全背包问题，稍加转换即可：</p>
<h5 id="定义"><strong>定义</strong>：</h5>
<pre><code>前`i`个硬币，构成金额`j`，所需要的最少的硬币个数为 `res[i][j]`</code></pre>
<h5 id="初始化状态-1"><strong>初始化状态</strong>：</h5>
<pre><code>`res[0][0-amount] = -1  res[0][0] = 0`</code></pre>
<h5 id="状态转移"><strong>状态转移</strong>：</h5>
<pre><code>`res[i][j] = min( res[i][j-ele] + 1 , res[i-1][j] )`</code></pre>
<p>需要注意的是，因为我们初始化不存在解的值为-1，所以在后续状态转移判定的时候，情况较多，具体见代码：</p>
<h5 id="解题代码">解题代码：</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 前i个硬币，构成金额j，所需要的最少的硬币个数为 res[i][j]</span></span><br><span class="line">        <span class="comment">// 初始化状态： res[0][0-amount] = -1  res[0][0] = 0</span></span><br><span class="line">        <span class="comment">// 状态转移： res[i][j] = min( res[i][j-ele] + 1 , res[i-1][j] )</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(coins.<span class="built_in">size</span>() + <span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(amount+<span class="number">1</span>,<span class="number">-1</span>));</span><br><span class="line">        res[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=coins.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> ele = coins[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=amount;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= ele)&#123;</span><br><span class="line">                    <span class="type">int</span> r1 = res[i<span class="number">-1</span>][j];</span><br><span class="line">                    <span class="type">int</span> r2 = res[i][j-ele];</span><br><span class="line">                    <span class="keyword">if</span>(r1 == <span class="number">-1</span> &amp;&amp; r2 != <span class="number">-1</span>)&#123;  <span class="comment">// r1 不存在 , r2 存在，那么参照r2 + 1</span></span><br><span class="line">                        res[i][j] = r2+<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(r1 != <span class="number">-1</span> &amp;&amp; r2 == <span class="number">-1</span>)&#123; <span class="comment">// r1 存在 , r2 不存在，那么参照 r1</span></span><br><span class="line">                        res[i][j] = r1; </span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(r1 != <span class="number">-1</span> &amp;&amp; r2 != <span class="number">-1</span>)&#123;  <span class="comment">// r1 存在 , r2 存在，那么参照min(r2+1,r1)</span></span><br><span class="line">                        res[i][j] = <span class="built_in">min</span>(r1,r2+<span class="number">1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;   <span class="comment">// r1 不存在 , r2 不存在，那么也不存在  = -1</span></span><br><span class="line">                        res[i][j] = <span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res[i][j] = res[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[coins.<span class="built_in">size</span>()][amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>动态规划系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>用Python搭建深度学习框架系列笔记3——优化器类的代码实现（上）</title>
    <url>/2022/02/23/c051c3782dfb/</url>
    <content><![CDATA[<p><strong>前言</strong>：
优化器的理论部分以及各种常见的优化器可以参见如下博客：<a
href="https://blog.fantast.top/2022/02/11/ced858ce48dc/">机器学习基础系列笔记16——常见的梯度下降优化器整理</a></p>
<p>本文所讲的是如何使用Python搭建优化器类，从而帮助实现整个机器学习的训练过程。</p>
<h4
id="一在不封装优化器的时候如何在计算图上执行梯度下降法">一、在不封装优化器的时候，如何在计算图上执行梯度下降法？</h4>
<p>当我们还没有明确提出优化器这个概念的时候，我们遵循如下过程去在计算图上执行梯度下降来优化损失函数：</p>
<ul>
<li>1）对结果节点的上游变量节点(Variable)赋值或初始化【包括输入向量节点和训练参数节点】</li>
<li>2）在结果节点上调用forward，计算出它的值，数据前向传播</li>
<li>3）在所有需要训练的变量节点( Variable, trainable = True
)上调用backward方法，梯度反向传播，计算出结果节点对该节点的雅可比矩阵。【仅包括训练参数节点】</li>
<li>4）根据变量节点的jacobi属性中的值，从变量节点的当前值中减去 用学习率
* 梯度的值即为更新后的值。</li>
<li>5）清除所有节点的value和jacobi属性，回到第2步</li>
</ul>
<h4 id="二优化器的封装">二、优化器的封装</h4>
<p>​
其实，优化器所实现的功能就是上述训练过程中对可训练的变量节点的值进行优化的过程。但是由于，可能存在各种多种多样的优化器，为了便于外层用户使用，代码的整洁，我们需要将优化器的功能封装起来，然后进行使用。</p>
<p>​ 抽象而言，整个更新计算图中变量的普适流程可以抽象为3步：</p>
<ul>
<li>调用Loss节点的Forward方法，这会递归调用所有上游节点的forward方法进行前向传播</li>
<li>对于计算图中需要更新的变量节点，利用Backward方法，计算出Loss节点对他们的雅可比矩阵</li>
<li>使用雅可比矩阵，根据梯度下降法更新参数节点。</li>
</ul>
<p>​
当然，在理论部分已经知道了，会有不同形式的梯度下降方法，那么在实现中，自然而然的解决方案就是：**将上述流程封装进入一个抽象类：Optimizer中，然后将不同的算法封装进不同的子类里面，实现各自个性化的部分。</p>
<h4 id="三优化器基类optimizer类">三、优化器基类（Optimizer类）：</h4>
<h5 id="part1构造函数">Part1：构造函数</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Optimizer</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    优化器基类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, graph, target, learning_rate=<span class="number">0.01</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        优化器的构造函数接受计算图对象，目标节点对象(往往就是Loss函数损失值节点，为了方便期间，该框架只支持优化一个目标节点，且我们暂时假设该目标节点最终结果为标量)以及学习率</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">isinstance</span>(target, Node) <span class="keyword">and</span> <span class="built_in">isinstance</span>(graph, Graph)</span><br><span class="line">        self.graph = graph</span><br><span class="line">        self.target = target</span><br><span class="line">        self.learning_rate = learning_rate</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 为每个参与训练的节点累加一个Mini Batch的全部样本的梯度（具体作用见后）</span></span><br><span class="line">        self.acc_gradient = <span class="built_in">dict</span>()</span><br><span class="line">        self.acc_no = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h5 id="part2核心函数">Part2：核心函数</h5>
<h6 id="核心函数1forward_backward">核心函数1：forward_backward()</h6>
<p>​
该函数抽象了先前我们所说的优化器普适流程中的前两步，完成前向传播计算结果节点target的值，然后遍历所有的计算图中的节点，找到那些<strong>需要训练的变量节点</strong>，然后对它们执行backward，求出结果节点对这些变量节点的雅可比矩阵。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward_backward</span>(<span class="params">self</span>):</span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       前向传播计算结果节点的值并反向传播计算结果节点对各个节点的雅可比矩阵</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment"># 清除计算图中所有节点的雅可比矩阵</span></span><br><span class="line">       self.graph.clear_jacobi()</span><br><span class="line"></span><br><span class="line">       <span class="comment"># 前向传播计算结果节点</span></span><br><span class="line">       self.target.forward()</span><br><span class="line"></span><br><span class="line">       <span class="comment"># 反向传播计算雅可比矩阵</span></span><br><span class="line">       <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes:</span><br><span class="line">           <span class="keyword">if</span> <span class="built_in">isinstance</span>(node, Variable) <span class="keyword">and</span> node.trainable:</span><br><span class="line">               node.backward(self.target)</span><br><span class="line"></span><br><span class="line">               <span class="comment"># 我们会得到 目标节点对参数节点的雅可比矩阵，将其转置以后即为目标节点对某变量节点的梯度</span></span><br><span class="line">               <span class="comment"># 目标节点（如果是标量的话）对节点值的雅可比是一个行向量，其转置是梯度（列向量）</span></span><br><span class="line">               <span class="comment"># 这里将梯度reshape成与节点值相同的形状，好对节点值进行更新。</span></span><br><span class="line">               <span class="comment"># node 节点的 shape 应当是一个矩阵，矩阵中元素为 N 个。</span></span><br><span class="line">               <span class="comment"># 从 目标节点 对 node 节点的雅可比矩阵相当于是 N维 -》 1维的变换</span></span><br><span class="line">               <span class="comment"># 故而 jacobi 的 shape 应该是 1 * N 维，所以要将其Reshape成Node节点形状，才方便对Node节点中的各个值进行梯度的累加。</span></span><br><span class="line">               gradient = node.jacobi.T.reshape(node.shape())</span><br><span class="line">               <span class="comment"># 如果该节点不在acc_gradient里面，就新建一个key-value</span></span><br><span class="line">               <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> self.acc_gradient:</span><br><span class="line">                   self.acc_gradient[node] = gradient</span><br><span class="line">               <span class="keyword">else</span>: <span class="comment"># 如果该节点已经在acc_gradient里面，就将梯度进行一个累加</span></span><br><span class="line">                   self.acc_gradient[node] += gradient</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="核心函数2update">核心函数2：update()：</h6>
<p>​
该函数封装了优化过程的第三步，参数更新。在Optimizer类中，update方法调用_update这个抽象方法，其具体的方法由具体的子类覆写。执行完参数的更新以后，我们需要将先前累积的梯度给清零。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, var_gradients=<span class="literal">None</span></span>):</span><br><span class="line"><span class="comment"># 该部分作用暂时还未解释，用于分布式训练，该处暂时无用，可以忽略</span></span><br><span class="line">      <span class="keyword">if</span> var_gradients <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">          self.apply_gradients(var_gradients)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># 执行更新</span></span><br><span class="line">      self._update()</span><br><span class="line"></span><br><span class="line">      <span class="comment"># 清除累加梯度</span></span><br><span class="line">      self.acc_gradient.clear()</span><br><span class="line">      self.acc_no = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">  @abc.abstractmethod</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">_update</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      抽象方法，执行具体的梯度更新算法，由子类实现</span></span><br><span class="line"><span class="string">      &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="part3入口函数">Part3：入口函数：</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">one_step</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算并累加样本的梯度</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    self.forward_backward()</span><br><span class="line">    self.acc_no += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="part4-其他辅助函数">Part4: 其他辅助函数：</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">apply_gradients</span>(<span class="params">self, node_gradients_dict, summarize=<span class="literal">False</span>, acc_no=<span class="literal">None</span></span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	此处暂时先不提这个函数，用于分布式训练</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">get_gradient</span>(<span class="params">self, node</span>):</span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       返回样本的平均梯度</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       <span class="keyword">assert</span> node <span class="keyword">in</span> self.acc_gradient</span><br><span class="line">       <span class="keyword">return</span> self.acc_gradient[node] / self.acc_no</span><br></pre></td></tr></table></figure>
<h4 id="四bgd和sgd和mbgd的数学表达">四、BGD和SGD和MBGD的数学表达：</h4>
<h5 id="bgd">1、BGD</h5>
<p>​
计算所有样本的平均损失值对参数的梯度，由于求梯度的过程是线性运算，所以<strong>所有样本的平均损失值对参数的梯度就等于每个样本的损失值对参数的梯度的平均：如下公式所示</strong>
<span class="math display">\[
\grad(\frac{1}{N}\sum_{i=1}^Nloss{(w|x_i)} ) = \frac{1}{N}\sum_{i=1}^N
\grad(loss{(w|x_i)} )
\]</span> ​
所以，在实现中，我们可以以此计算出训练集中每个样本的损失值对参数的梯度，然后再求这些梯度的平均值。这也是为什么在Optimizer的基类中，我们需要设置<code>self.acc_gradient</code>用于累加每个样本的梯度，然后设置<code>self.acc_no</code>记录累加的样本的数量。</p>
<h5 id="sgd">2、 SGD</h5>
<p>​ 每计算一个样本的损失值，然后就进行参数的更新。</p>
<h5 id="mbgd">3、MBGD</h5>
<p>​ 以一部分样本的损失之进行计算。</p>
<h5 id="总结">总结：</h5>
<p>​
所以，其实针对于以上三种，在代码实现泛化的时候，我们可以用批大小来进行泛化。batch
size = 1即为SGD，反之极端为BDG。在代码中，其实就是 调用
<code>batch_size</code> 次
<code>one_step()</code>函数，然后等到一个Batch的样本梯度累加结束后，再调用<code>update</code>函数即可，<code>update</code>函数会调用子类的<code>_update</code>函数，子类的<code>_update</code>函数中，会调用<code>get_gradient</code>函数，来得到样本的平均梯度然后进行处理。</p>
<h4
id="五matrixslow优化器mbgd实现-其他框架实现方式">五、MatrixSlow优化器MBGD实现
&amp; 其他框架实现方式：</h4>
<h5 id="优化器mbgd实现">1、 优化器MBGD实现</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GradientDescent</span>(<span class="title class_ inherited__">Optimizer</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    梯度下降优化器</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, graph, target, learning_rate=<span class="number">0.01</span></span>):</span><br><span class="line"></span><br><span class="line">        Optimizer.__init__(self, graph, target)</span><br><span class="line">        self.learning_rate = learning_rate</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_update</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        朴素梯度下降法</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(node, Variable) <span class="keyword">and</span> node.trainable:</span><br><span class="line">                <span class="comment"># 取得该节点在当前批的平均梯度</span></span><br><span class="line">                gradient = self.get_gradient(node)</span><br><span class="line">                <span class="comment"># 用朴素梯度下降法更新变量节点的值</span></span><br><span class="line">                node.set_value(node.value - self.learning_rate * gradient)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​
按照上述非常简单好理解的代码实现，我们可以将整一个优化训练代码的过程简化如下：就是像上一段中描述的那样，调用
<code>batch_size</code> 次
<code>one_step()</code>函数，然后等到一个Batch的样本梯度累加结束后，再调用<code>update</code>函数即可，<code>update</code>函数会调用子类的<code>_update</code>函数，子类的<code>_update</code>函数中，会调用<code>get_gradient</code>函数，来得到样本的平均梯度然后进行处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">optimizer = ms.optimizer.Adam(ms.default_graph, loss, learning_rate)</span><br><span class="line"></span><br><span class="line">mini_batch_size = <span class="number">8</span></span><br><span class="line">cur_batch_size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练执行50个epoch</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历训练集中的样本</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(train_set)):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 取第i个样本的前4列（除最后一列的所有列），构造3x1矩阵对象</span></span><br><span class="line">        features = np.mat(train_set[i, :-<span class="number">1</span>]).T</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 取第i个样本的最后一列，是该样本的性别标签（1男，-1女），构造1x1矩阵对象</span></span><br><span class="line">        l = np.mat(train_set[i, -<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将特征赋给x节点，将标签赋给label节点</span></span><br><span class="line">        x.set_value(features)</span><br><span class="line">        label.set_value(l)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 优化器执行一次前向传播和一次后向传播</span></span><br><span class="line">        optimizer.one_step()</span><br><span class="line">        cur_batch_size += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 当积累到一个mini batch的时候，完成一次参数更新</span></span><br><span class="line">        <span class="keyword">if</span> (cur_batch_size == mini_batch_size):</span><br><span class="line">            optimizer.update()</span><br><span class="line">            cur_batch_size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每个epoch结束后评价模型的正确率</span></span><br><span class="line">    pred = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历训练集，计算当前模型对每个样本的预测值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(train_set)):</span><br><span class="line"></span><br><span class="line">        features = np.mat(train_set[i, :-<span class="number">1</span>]).T</span><br><span class="line">        x.set_value(features)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在模型的predict节点上执行前向传播</span></span><br><span class="line">        predict.forward()</span><br><span class="line">        pred.append(predict.value[<span class="number">0</span>, <span class="number">0</span>])  <span class="comment"># 模型的预测结果：1男，0女</span></span><br><span class="line"></span><br><span class="line">    pred = np.array(pred) * <span class="number">2</span> - <span class="number">1</span>  <span class="comment"># 将1/0结果转化成1/-1结果，好与训练标签的约定一致</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断预测结果与样本标签相同的数量与训练集总数量之比，即模型预测的正确率</span></span><br><span class="line">    accuracy = (train_set[:, -<span class="number">1</span>] == pred).astype(np.<span class="built_in">int</span>).<span class="built_in">sum</span>() / <span class="built_in">len</span>(train_set)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印当前epoch数和模型在训练集上的正确率</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;epoch: &#123;:d&#125;, accuracy: &#123;:.3f&#125;&quot;</span>.<span class="built_in">format</span>(epoch + <span class="number">1</span>, accuracy))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="其他框架对于minibatch的实现方式">2、
其他框架对于MiniBatch的实现方式：</h5>
<p>​
其实，上述MatrixSlow实现MiniBatch梯度计算的方式，并不是工业上最佳的。但是我认为是在学习的过程中比较好的方式。其把
MiniBatch样本和计算图完全分隔开，概念很清晰。<strong>那么在一些工业级的框架中，一般是怎么做的呢？</strong></p>
<p>​
在其他一些框架中（比如<strong>Pytorch</strong>），可能会用一个变量节点来存储整批样本，<strong>比如样本为n维向量，批大小维m，那么就用一个<span
class="math inline">\(m \times
n\)</span>的矩阵来存储。</strong>后续计算节点的计算都是对存储数据矩阵的每一行进行的，<strong>然后这一整批的数据都会在计算图里像前面流动，直到损失值节点</strong></p>
<p>​ 总结来说，就是以下几步：</p>
<ul>
<li>添加一个维度，用一个变量节点存储整个minibatch的样本</li>
<li>前向传播对整个batch的样本计算</li>
<li>以平均损失值节点为目标节点</li>
<li>以平均损失之节点对参数的梯度更新参数。</li>
</ul>
<p>​
这样子的好处在于什么呢？<strong>这种方法所进行计算的性能更好，可以在高效率的利用GPU的并行计算能力，并且能够支持高阶的张量。</strong></p>
<p>​
以下代码是书中，对于先前的AdaLine的寻阿联例子，如果使用工业框架的方法，应当是如何训练的，给出了一个示例（没有进行封装）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">&#x27;../..&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matrixslow <span class="keyword">as</span> ms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造训练集</span></span><br><span class="line">male_heights = np.random.normal(<span class="number">171</span>, <span class="number">6</span>, <span class="number">500</span>)</span><br><span class="line">female_heights = np.random.normal(<span class="number">158</span>, <span class="number">5</span>, <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">male_weights = np.random.normal(<span class="number">70</span>, <span class="number">10</span>, <span class="number">500</span>)</span><br><span class="line">female_weights = np.random.normal(<span class="number">57</span>, <span class="number">8</span>, <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">male_bfrs = np.random.normal(<span class="number">16</span>, <span class="number">2</span>, <span class="number">500</span>)</span><br><span class="line">female_bfrs = np.random.normal(<span class="number">22</span>, <span class="number">2</span>, <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">male_labels = [<span class="number">1</span>] * <span class="number">500</span></span><br><span class="line">female_labels = [-<span class="number">1</span>] * <span class="number">500</span></span><br><span class="line"></span><br><span class="line">train_set = np.array([np.concatenate((male_heights, female_heights)),</span><br><span class="line">                      np.concatenate((male_weights, female_weights)),</span><br><span class="line">                      np.concatenate((male_bfrs, female_bfrs)),</span><br><span class="line">                      np.concatenate((male_labels, female_labels))]).T</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机打乱样本顺序</span></span><br><span class="line">np.random.shuffle(train_set)</span><br><span class="line"><span class="comment"># 批大小</span></span><br><span class="line">batch_size = <span class="number">10</span></span><br><span class="line"><span class="comment"># batch_size x 3矩阵，每行保存一个样本，整个节点保存一个mini batch的样本</span></span><br><span class="line">X = ms.core.Variable(dim=(batch_size, <span class="number">3</span>), init=<span class="literal">False</span>, trainable=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 保存一个mini batch的样本的类别标签</span></span><br><span class="line">label = ms.core.Variable(dim=(batch_size, <span class="number">1</span>), init=<span class="literal">False</span>, trainable=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 权值向量，3x1矩阵</span></span><br><span class="line">w = ms.core.Variable(dim=(<span class="number">3</span>, <span class="number">1</span>), init=<span class="literal">True</span>, trainable=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 阈值</span></span><br><span class="line">b = ms.core.Variable(dim=(<span class="number">1</span>, <span class="number">1</span>), init=<span class="literal">True</span>, trainable=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 全1向量，维数是batch_size，不可训练</span></span><br><span class="line">ones = ms.core.Variable(dim=(batch_size, <span class="number">1</span>), init=<span class="literal">False</span>, trainable=<span class="literal">False</span>)</span><br><span class="line">ones.set_value(np.mat(np.ones(batch_size)).T)</span><br><span class="line"><span class="comment"># 用阈值（标量）乘以全1向量</span></span><br><span class="line">bias = ms.ops.ScalarMultiply(b, ones)</span><br><span class="line"><span class="comment"># 对一个mini batch的样本计算输出</span></span><br><span class="line">output = ms.ops.Add(ms.ops.MatMul(X, w), bias)</span><br><span class="line">predict = ms.ops.Step(output)</span><br><span class="line"><span class="comment"># 一个mini batch的样本的损失函数</span></span><br><span class="line">loss = ms.ops.loss.PerceptionLoss(ms.ops.Multiply(label, output))</span><br><span class="line"><span class="comment"># 一个mini batch的平均损失</span></span><br><span class="line">B =  ms.core.Variable(dim=(<span class="number">1</span>, batch_size), init=<span class="literal">False</span>, trainable=<span class="literal">False</span>)</span><br><span class="line">B.set_value(<span class="number">1</span> / batch_size * np.mat(np.ones(batch_size)))</span><br><span class="line">mean_loss = ms.ops.MatMul(B, loss)</span><br><span class="line"><span class="comment"># 学习率</span></span><br><span class="line">learning_rate = <span class="number">0.0001</span></span><br><span class="line"><span class="comment"># 训练，这个步骤之后没啥区别</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">    <span class="comment"># 遍历训练集中的样本</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> np.arange(<span class="number">0</span>, <span class="built_in">len</span>(train_set), batch_size):</span><br><span class="line">        <span class="comment"># 取一个mini batch的样本的特征</span></span><br><span class="line">        features = np.mat(train_set[i:i + batch_size, :-<span class="number">1</span>])</span><br><span class="line">        <span class="comment"># 取一个mini batch的样本的标签</span></span><br><span class="line">        l = np.mat(train_set[i:i + batch_size, -<span class="number">1</span>]).T</span><br><span class="line">        <span class="comment"># 将特征赋给X节点，将标签赋给label节点</span></span><br><span class="line">        X.set_value(features)</span><br><span class="line">        label.set_value(l)</span><br><span class="line">        <span class="comment"># 在平均损失节点上执行前向传播</span></span><br><span class="line">        mean_loss.forward()</span><br><span class="line">        <span class="comment"># 在参数节点上执行反向传播</span></span><br><span class="line">        w.backward(mean_loss)</span><br><span class="line">        b.backward(mean_loss)</span><br><span class="line">        <span class="comment"># 更新参数</span></span><br><span class="line">        w.set_value(w.value - learning_rate * w.jacobi.T.reshape(w.shape()))</span><br><span class="line">        b.set_value(b.value - learning_rate * b.jacobi.T.reshape(b.shape()))</span><br><span class="line">        ms.default_graph.clear_jacobi()</span><br><span class="line">    <span class="comment"># 每个epoch结束后评价模型的正确率</span></span><br><span class="line">    pred = []</span><br><span class="line">    <span class="comment"># 遍历训练集，计算当前模型对每个样本的预测值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> np.arange(<span class="number">0</span>, <span class="built_in">len</span>(train_set), batch_size):</span><br><span class="line">        features = np.mat(train_set[i:i + batch_size, :-<span class="number">1</span>])</span><br><span class="line">        X.set_value(features)</span><br><span class="line">        <span class="comment"># 在模型的predict节点上执行前向传播</span></span><br><span class="line">        predict.forward()</span><br><span class="line">        <span class="comment"># 当前模型对一个mini batch的样本的预测结果</span></span><br><span class="line">        pred.extend(predict.value.A.ravel())</span><br><span class="line">    pred = np.array(pred) * <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">    accuracy = (train_set[:, -<span class="number">1</span>] == pred).astype(np.<span class="built_in">int</span>).<span class="built_in">sum</span>() / <span class="built_in">len</span>(train_set)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;epoch: &#123;:d&#125;, accuracy: &#123;:.3f&#125;&quot;</span>.<span class="built_in">format</span>(epoch + <span class="number">1</span>, accuracy))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>② 深度学习笔记</category>
        <category>Basic系列笔记</category>
        <category>Python搭建简易框架笔记</category>
      </categories>
      <tags>
        <tag>Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>用Python搭建深度学习框架系列笔记2——计算图、前向传播、反向传播与自动微分的代码实现</title>
    <url>/2022/02/22/6bfa5496ebc4/</url>
    <content><![CDATA[<p>​
首先，我们看完上一节的理论以后，应该需要知晓在上述过程中，我们需要在代码中实现的最核心的节点相关的类如下所示，我们以以下这张经典的计算图来分析：</p>
<p>​
其中，存储整个图我们需要一个类，<strong>也就是计算图类</strong>，然后图中又有许多类型的节点，第一种类型的节点是<strong>变量节点</strong>，也就是x、w这种，是无父节点的，第二种类型是<strong>Op操作符节点</strong>，也就是+、x这种节点，剩下的就是普通的中间节点。故而我们需要实现的类如下所示：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_10_15_03_30_21.png" /></p>
<p>​</p>
<ul>
<li><strong>Node类（基类-非抽象类）</strong>
<ul>
<li>普通中间节点（直接使用Node类即可）</li>
<li>变量节点（继承Node类，无父节点，构造函数接受变量的形状，是否初始化以及是否参与训练的标识）</li>
<li><strong>Op操作符节点（继承Node类，抽象类，然后根据不同的运算符定义类来继承它，其他运算符类需要实现两个方法：compute
和
get_jacobi，</strong>分别用于<strong>根据父节点的值计算本节点的值</strong>，以及<strong>计算本节点对某个父节点的雅可比矩阵</strong>）。</li>
</ul></li>
<li><strong>Graph计算图类</strong></li>
</ul>
<p>接下来，我们来一一看它们的实现代码：</p>
<h3 id="graph计算图类-一些基本函数">1、Graph计算图类
（一些基本函数）</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算图类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.nodes = []  <span class="comment"># 计算图内的节点的列表</span></span><br><span class="line">        self.name_scope = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_node</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        添加节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.nodes.append(node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">clear_jacobi</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        清除图中全部节点的雅可比矩阵</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.nodes:</span><br><span class="line">            node.clear_jacobi()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reset_value</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        重置图中全部节点的值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.nodes:</span><br><span class="line">            node.reset_value(<span class="literal">False</span>)  <span class="comment"># 每个节点不递归清除自己的子节点的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">node_count</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.nodes)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 全局默认计算图</span></span><br><span class="line">default_graph = Graph()</span><br></pre></td></tr></table></figure>
<h3 id="node类基类---非抽象类">2、Node类（基类 - 非抽象类）</h3>
<ul>
<li><strong>Part1：构造函数</strong>
<ul>
<li>此部分较好理解，做一些初始化，将节点添加到计算图的list里，然后将该节点添加到父节点的子节点列表中。</li>
<li>需要注意的是：构造函数需要传入两个参数，第一个参数是父节点列表，第二个参数是一些参数列表</li>
</ul></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算图节点类基类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *parents, **kargs</span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算图对象，默认为全局对象default_graph</span></span><br><span class="line">        self.kargs = kargs</span><br><span class="line">        self.graph = kargs.get(<span class="string">&#x27;graph&#x27;</span>, default_graph) <span class="comment"># 节点所属的计算图，默认为 全局计算图default_graph</span></span><br><span class="line">        self.need_save = kargs.get(<span class="string">&#x27;need_save&#x27;</span>, <span class="literal">True</span>)  <span class="comment"># 是否需要被保存</span></span><br><span class="line">        self.gen_node_name(**kargs)     <span class="comment"># 依据参数生成节点名称，节点名称在模型保存和导入时会用到</span></span><br><span class="line"></span><br><span class="line">        self.parents = <span class="built_in">list</span>(parents)  <span class="comment"># 父节点列表</span></span><br><span class="line">        self.children = []  <span class="comment"># 子节点列表</span></span><br><span class="line">        self.value = <span class="literal">None</span>  <span class="comment"># 本节点的值，Numpy的Matrix类</span></span><br><span class="line">        self.jacobi = <span class="literal">None</span>  <span class="comment"># 结果节点对本节点的雅可比矩阵</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将本节点添加到父节点的子节点列表中</span></span><br><span class="line">        <span class="keyword">for</span> parent <span class="keyword">in</span> self.parents:</span><br><span class="line">            parent.children.append(self)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将本节点添加到计算图中</span></span><br><span class="line">        self.graph.add_node(self)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Part2: 常见函数</strong>:
<ul>
<li>此部分也是Node类中一些基本的工具型函数，其中gen_node_name就是在构造函数中生成节点名称用的。</li>
<li>dimension 和 shape 函数是用来返回节点值的维度的</li>
<li>reset_value 递归重置该节点 + 该节点下游的节点的值</li>
</ul></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_parents</span>(<span class="params">self</span>):</span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       获取本节点的父节点</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       <span class="keyword">return</span> self.parents</span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">get_children</span>(<span class="params">self</span>):</span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       获取本节点的子节点</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       <span class="keyword">return</span> self.children</span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">gen_node_name</span>(<span class="params">self, **kargs</span>):</span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       生成节点名称，如果用户不指定，则根据节点类型生成类似于&quot;MatMul:3&quot;的节点名，</span></span><br><span class="line"><span class="string">       如果指定了name_scope，则生成类似&quot;Hidden/MatMul:3&quot;的节点名</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       self.name = kargs.get(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;&#123;&#125;:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">           self.__class__.__name__, self.graph.node_count()))</span><br><span class="line">       <span class="keyword">if</span> self.graph.name_scope:</span><br><span class="line">           self.name = <span class="string">&#x27;&#123;&#125;/&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.graph.name_scope, self.name)</span><br><span class="line">       <span class="keyword">def</span> <span class="title function_">clear_jacobi</span>(<span class="params">self</span>):</span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       清空结果节点对本节点的雅可比矩阵</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       self.jacobi = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">dimension</span>(<span class="params">self</span>):</span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       返回本节点的值展平成向量后的维数</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       <span class="keyword">return</span> self.value.shape[<span class="number">0</span>] * self.value.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">shape</span>(<span class="params">self</span>):</span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       返回本节点的值作为矩阵的形状：（行数，列数）</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       <span class="keyword">return</span> self.value.shape</span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">reset_value</span>(<span class="params">self, recursive=<span class="literal">True</span></span>):</span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       重置本节点的值，并递归重置本节点的下游节点的值。（因为如果本节点的值被重置了，所有下游子节点的值也就都失去了意义，下游子节点的值是依赖于该节点进行计算的）</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">       self.value = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> recursive:</span><br><span class="line">           <span class="keyword">for</span> child <span class="keyword">in</span> self.children:</span><br><span class="line">               child.reset_value()</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Part3：虚函数</strong>：
<ul>
<li>这两个函数，是等会儿
操作符节点需要重载的函数内容，在forward和backword中有用到。</li>
</ul></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@abc.abstractmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    抽象方法，根据父节点的值计算本节点的值，用于前向传播中计算该节点的值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@abc.abstractmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_jacobi</span>(<span class="params">self, parent</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    抽象方法，计算本节点对某个父节点的雅可比矩阵的计算，因为计算父节点的雅可比矩阵可能需要该父节点以及其他父节点的值，所以只能够在子节点中完成。父节点调用子节点的getjacobi方法，就可以得到子节点对自己的雅可比矩阵。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Part4：核心函数</strong>：
<ul>
<li>forward() 和 backward() 函数,
都是以递归的形式进行计算，请注意这边的两个函数的含义和pytorch库中的同名函数含义相差较大，不要搞混。</li>
</ul></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      前向传播计算本节点的值，若父节点的值未被计算，则递归调用父节点的forward方法</span></span><br><span class="line"><span class="string">      &quot;&quot;&quot;</span></span><br><span class="line">      <span class="keyword">for</span> node <span class="keyword">in</span> self.parents:</span><br><span class="line">          <span class="keyword">if</span> node.value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">              node.forward()</span><br><span class="line"><span class="comment"># 递归完成，所有父节点的值都就位了，调用子类已经覆写好的compute函数，根据父节点的值计算该节点值，例如如果该节点是 + 号 类节点，compute函数中，就会书写将所有的父节点的值相加的过程。</span></span><br><span class="line">      self.compute()</span><br><span class="line">	</span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  属性jacobi用于保存最终结果对自己的雅可比矩阵，在代码一开始先判断自己的jacobi属性是否为None,如果不是说明最终结果对自己的雅可比矩阵已经计算过了（因为一次反向传播中，某个节点可能被多次访问）。</span></span><br><span class="line"><span class="string">  result参数传进来的是最终的结果节点。</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self, result</span>):</span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      反向传播，计算结果节点对本节点的雅可比矩阵</span></span><br><span class="line"><span class="string">      &quot;&quot;&quot;</span></span><br><span class="line">      <span class="keyword">if</span> self.jacobi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">          <span class="keyword">if</span> self <span class="keyword">is</span> result:  <span class="comment"># 如果本节点自身就是最终的结果节点</span></span><br><span class="line">              self.jacobi = np.mat(np.eye(self.dimension()))  <span class="comment">#构造一个维度正确的单位矩阵即可</span></span><br><span class="line">          <span class="keyword">else</span>:   <span class="comment"># 如果本节点不是最终的结果节点，而是正常的一个节点</span></span><br><span class="line">              self.jacobi = np.mat(  <span class="comment"># 先构造一个维度正确的全为0的矩阵，作为之后的累加器</span></span><br><span class="line">                  np.zeros((result.dimension(), self.dimension())))</span><br><span class="line">		<span class="comment"># 然后遍历所有子节点</span></span><br><span class="line">              <span class="keyword">for</span> child <span class="keyword">in</span> self.get_children():</span><br><span class="line">                   <span class="comment"># 如果子节点的值不为空，说明它在本次的计算路径上，因为对于某些复杂的计算图而言，有些节点可能不在某次前向传播的计算路径上，它们是无关的节点。</span></span><br><span class="line">                  <span class="keyword">if</span> child.value <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                      <span class="comment"># 递归调用child的backward()方法，得到最终结果对子节点的雅可比，再乘上 子节点对该节点的雅可比，就得到了最终结果对该节点的雅可比，将其累加到之前初始化好的全为0的矩阵中。</span></span><br><span class="line">                      self.jacobi += child.backward(result) * child.get_jacobi(self)</span><br><span class="line"><span class="comment"># 返回雅可比矩阵即可</span></span><br><span class="line">      <span class="keyword">return</span> self.jacobi</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="变量节点继承自node类">3、变量节点（继承自Node类）：</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Variable</span>(<span class="title class_ inherited__">Node</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    变量节点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, dim, init=<span class="literal">False</span>, trainable=<span class="literal">True</span>, **kargs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        变量节点没有父节点，构造函数接受变量的形状，是否初始化以及是否参与训练的标识</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        Node.__init__(self,  **kargs)</span><br><span class="line">        self.dim = dim</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果需要初始化，则以正态分布随机初始化变量的值</span></span><br><span class="line">        <span class="comment"># 像保存样本和标签的节点不用初始化，而保存参数的节点需要初始化</span></span><br><span class="line">        <span class="keyword">if</span> init:</span><br><span class="line">            self.value = np.mat(np.random.normal(<span class="number">0</span>, <span class="number">0.001</span>, self.dim))</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 变量节点是否参与训练，比如样本和标签不参与训练，可以不计算它们的雅可比矩阵，而参数参与训练，就需要计算雅可比矩阵。</span></span><br><span class="line">        self.trainable = trainable</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_value</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        为变量赋值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 判定赋值的值matrix 是不是和dim一致</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">isinstance</span>(value, np.matrix) <span class="keyword">and</span> value.shape == self.dim</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先重置该节点及所有下游节点的值，然后再对该节点进行赋值</span></span><br><span class="line">        self.reset_value()</span><br><span class="line">        self.value = value</span><br></pre></td></tr></table></figure>
<h3
id="运算符操作子节点继承自node类需要覆写compute和get_jacobi两个函数">4、运算符操作子节点（继承自Node类，需要覆写compute和get_jacobi两个函数）</h3>
<p>抽象类如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Operator</span>(<span class="title class_ inherited__">Node</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    定义操作符抽象类</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h5 id="定义-add-操作符">1） 定义 Add 操作符：</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Add</span>(<span class="title class_ inherited__">Operator</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    （多个）矩阵加法</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">	<span class="comment">## 根据父节点的值计算本节点的值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compute</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># assert len(self.parents) == 2 and self.parents[0].shape() == self.parents[1].shape()</span></span><br><span class="line">        self.value = np.mat(np.zeros(self.parents[<span class="number">0</span>].shape()))</span><br><span class="line">		<span class="comment"># 把所有的父节点的值相加，就是正向传播计算的值</span></span><br><span class="line">        <span class="keyword">for</span> parent <span class="keyword">in</span> self.parents:</span><br><span class="line">            self.value += parent.value</span><br><span class="line">            </span><br><span class="line">	<span class="comment">## 计算本节点对某个父节点的雅可比矩阵的计算</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_jacobi</span>(<span class="params">self, parent</span>):</span><br><span class="line">        <span class="keyword">return</span> np.mat(np.eye(self.dimension()))  <span class="comment"># 矩阵之和对其中任一个矩阵的雅可比矩阵是单位矩阵</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">## 比如说： 父节点为矩阵 A，B(维度为 3 * 2)，子节点为矩阵 A + B（维度为3 * 2）</span></span><br><span class="line"><span class="comment">## 子节点为 Add操作符节点</span></span><br><span class="line"><span class="comment">## 那么这样一个映射函数就是 6维向量 -》映射到-》 6维向量 的映射函数</span></span><br><span class="line"><span class="comment">## A 展平 [ a1 a2 a3 a4 a5 a6 ] B 展平 [ b1 b2 b3 b4 b5 b6]  均为6维向量</span></span><br><span class="line"><span class="comment">## A+B 展平 [a1+b1 a2+b2 a3+b3 a4+b4 a5+b5 a6+b6] 6维向量</span></span><br><span class="line"><span class="comment">## 最终得到的雅可比矩阵是 6 * 6 的单位阵</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   [d(a1+b1)/d(a1) d(a1+b1)/d(a2) d(a1+b1)/d(a3) d(a1+b1)/d(a4) d(a1+b1)/d(a5) d(a1+b1)/d(a6)  ]</span></span><br><span class="line"><span class="string">   [d(a2+b2)/d(a1) d(a2+b2)/d(a2) d(a2+b2)/d(a3) d(a2+b2)/d(a4) d(a2+b2)/d(a5) d(a2+b2)/d(a6)  ]</span></span><br><span class="line"><span class="string">    	……………………………………………………………………………………………………………………………………………………………………………………………………………………</span></span><br><span class="line"><span class="string">        ……………………………………………………………………………………………………………………………………………………………………………………………………………………</span></span><br><span class="line"><span class="string">        ……………………………………………………………………………………………………………………………………………………………………………………………………………………</span></span><br><span class="line"><span class="string">   [d(a6+b6)/d(a1) d(a6+b6)/d(a2) d(a6+b6)/d(a3) d(a6+b6)/d(a4) d(a6+b6)/d(a5) d(a6+b6)/d(a6)  ]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   [1 0 0 0 0 0]</span></span><br><span class="line"><span class="string">   [0 1 0 0 0 0]</span></span><br><span class="line"><span class="string">   [0 0 1 0 0 0]</span></span><br><span class="line"><span class="string">   [0 0 0 1 0 0]</span></span><br><span class="line"><span class="string">   [0 0 0 0 1 0]</span></span><br><span class="line"><span class="string">   [0 0 0 0 0 1]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="定义-matmul-操作符">2） 定义 Matmul 操作符：</h5>
<p>推导如下：</p>
<ul>
<li><p>定义矩阵A： 形状为 M x N</p></li>
<li><p>定义矩阵B： 形状为 N x K</p></li>
<li><p>矩阵乘法得到的结果C： 形状为 M X K</p></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/92352E558AF386F3CEFAE57985019633.jpg" /></p>
<p>​ 我们先求解<strong>矩阵C对矩阵A的雅可比矩阵</strong>：</p>
<p>​
我们将矩阵乘法视为多到多映射，如下：以左矩阵A为自变量，以右矩阵B为常量，将矩阵A视为
<span class="math inline">\(M \times N\)</span>
维的向量，将映射的结果矩阵C视为 <span class="math inline">\(M \times
K\)</span> 维的向量。如下所示：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/202202271a.png" style="zoom: 50%;" /></p>
<p>​ 最终获得的雅可比矩阵的第一行，就是C矩阵的第1个元素，分别对A 的 MN
个元素求导：得到的如下所示：C的第一个分量对A的第一行元素的偏导数就是B的第一列，对A其余元素的偏导数是0，所以雅可比矩阵的第一行如下：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/F9061B9E26F869EA36F4575B07A65B27.jpg" style="zoom: 25%;" /></p>
<p>​ 第二行同理，如下所示：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/BD69F402E360C2A1B6CCD85DF5881C28.jpg" style="zoom:25%;" /></p>
<p>​
一直到雅可比矩阵的第K行，都是这样的规律。然后接下去雅可比矩阵的K+1行是这样的：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/7FFCABE5A3D35DAAD995E76633F94DDE.jpg" style="zoom:25%;" /></p>
<p>​
我们会发现一个规律，如下所示，也就是最终的结论：C对A的雅可比矩阵如下所示：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/15BB5E4AF6FBE51D7701F361B7BE64FE.jpg" /></p>
<p>​ <span class="math inline">\(B^T 是 B的转置\)</span>，我们把 m 个
形状为 <span class="math inline">\(K \times N\)</span> 的<span
class="math inline">\(B^T\)</span>矩阵放在对角线上，得到一个 <span
class="math inline">\(MK \times MN\)</span> 的矩阵。</p>
<p>​</p>
<p>​ 然后来看<strong>矩阵C对矩阵B的雅可比矩阵</strong>：</p>
<p>​
同样我们将矩阵乘法视为多到多映射，如下：以左矩阵A为常量，以右矩阵B为自变量，将矩阵B视为
<span class="math inline">\(N \times K\)</span>
维的向量，将映射的结果矩阵C视为 <span class="math inline">\(M \times
K\)</span> 维的向量。如下所示：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/2022020272258.png" style="zoom:33%;" /></p>
<p>​ 这是一个NK维向量，C对B的雅可比矩阵是<span class="math inline">\(MK
\times NK\)</span>
的矩阵。C的第一个分量对B的第1列元素的偏导数就是A的第一行，所以雅可比矩阵的第1行如下：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/C165EA4E4C9DE67CF1EE6AF9551DB327.jpg" style="zoom: 33%;" /></p>
<p>​ 雅可比矩阵的第2行如下：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/B504A835005C3AAF0BA61984E976F3F9.jpg" style="zoom: 33%;" /></p>
<p>​
这一行中每个长度维k的段的第2个元素是A的第1行的对应元素，其余元素维0.以此类推，雅可比矩阵的前k行是一个<span
class="math inline">\(k \times
NK\)</span>的矩阵，包含横着排列的N个对角阵。整个雅可比矩阵由M个这样的矩阵竖着摞在一起构成。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/64F57EE82EDE412BA304CD345F290E57.jpg" style="zoom:50%;" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MatMul</span>(<span class="title class_ inherited__">Operator</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    矩阵乘法</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compute</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(self.parents) == <span class="number">2</span> <span class="keyword">and</span> self.parents[<span class="number">0</span>].shape()[</span><br><span class="line">            <span class="number">1</span>] == self.parents[<span class="number">1</span>].shape()[<span class="number">0</span>]</span><br><span class="line">        self.value = self.parents[<span class="number">0</span>].value * self.parents[<span class="number">1</span>].value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_jacobi</span>(<span class="params">self, parent</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        将矩阵乘法视作映射，求映射对参与计算的矩阵的雅克比矩阵。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        zeros = np.mat(np.zeros((self.dimension(), parent.dimension())))</span><br><span class="line">        <span class="keyword">if</span> parent <span class="keyword">is</span> self.parents[<span class="number">0</span>]:  <span class="comment"># C对A的雅可比矩阵</span></span><br><span class="line">            <span class="keyword">return</span> fill_diagonal(zeros, self.parents[<span class="number">1</span>].value.T)</span><br><span class="line">        <span class="keyword">else</span>:	<span class="comment"># C对B的雅可比矩阵</span></span><br><span class="line">            jacobi = fill_diagonal(zeros, self.parents[<span class="number">0</span>].value)</span><br><span class="line">            row_sort = np.arange(self.dimension()).reshape(</span><br><span class="line">                self.shape()[::-<span class="number">1</span>]).T.ravel()</span><br><span class="line">            col_sort = np.arange(parent.dimension()).reshape(</span><br><span class="line">                parent.shape()[::-<span class="number">1</span>]).T.ravel()</span><br><span class="line">            <span class="keyword">return</span> jacobi[row_sort, :][:, col_sort]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="定义-relu-操作符">3） <strong>定义 ReLU 操作符：</strong></h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReLU</span>(<span class="title class_ inherited__">Operator</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    对矩阵的元素施加ReLU函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    nslope = <span class="number">0.1</span>  <span class="comment"># 负半轴的斜率</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compute</span>(<span class="params">self</span>):</span><br><span class="line">        self.value = np.mat(np.where(</span><br><span class="line">            self.parents[<span class="number">0</span>].value &gt; <span class="number">0.0</span>,</span><br><span class="line">            self.parents[<span class="number">0</span>].value,</span><br><span class="line">            self.nslope * self.parents[<span class="number">0</span>].value)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_jacobi</span>(<span class="params">self, parent</span>):</span><br><span class="line">        <span class="keyword">return</span> np.diag(np.where(self.parents[<span class="number">0</span>].value.A1 &gt; <span class="number">0.0</span>, <span class="number">1.0</span>, self.nslope))</span><br></pre></td></tr></table></figure>
<p><strong>参考资料：</strong></p>
<p>代码实现参考：https://github.com/zc911/MatrixSlow</p>
<p>1、《用python实现深度学习框架》张觉非、陈震</p>
]]></content>
      <categories>
        <category>② 深度学习笔记</category>
        <category>Basic系列笔记</category>
        <category>Python搭建简易框架笔记</category>
      </categories>
      <tags>
        <tag>Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>BFS系列——开密码锁</title>
    <url>/2022/02/22/2c663a313e31/</url>
    <content><![CDATA[<h4 id="剑指-offer-ii-109.-开密码锁"><a
href="https://leetcode-cn.com/problems/zlDJc7/">剑指 Offer II 109.
开密码锁</a></h4>
<p>​ 一个密码锁由 4 个环形拨轮组成，每个拨轮都有 10 个数字： '0', '1',
'2', '3', '4', '5', '6', '7', '8', '9' 。每个拨轮可以自由旋转：例如把
'9' 变为 '0'，'0' 变为 '9' 。每次旋转都只能旋转一个拨轮的一位数字。</p>
<p>​ 锁的初始数字为 '0000' ，一个代表四个拨轮的数字的字符串。</p>
<p>​ 列表 deadends
包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p>
<p>​ 字符串 target
代表可以解锁的数字，请给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回
-1 。</p>
<ul>
<li>示例 1:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释： 可能的移动序列为 &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;。</span><br><span class="line">注意 &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; 这样的序列是不能解锁的，因为当拨动到 &quot;0102&quot; 时这个锁就会被锁定。</span><br></pre></td></tr></table></figure>
<h5 id="解题思路1单向bfs"><strong>解题思路1：单向BFS</strong>：</h5>
<p>​
本题可以采用BFS搜索进行求解，但是由于每一个数字，其对应的领居有高达8个，再不断的扩展的过程中，搜索的空间会非常大，就会导致比较大的复杂度。在本题的BFS过程中，需要注意的是，还有死亡数字列表，一种方案是我们可以使用哈希表存储死亡数字，在每次遍历获取邻居的时候，判断是否为死亡数字，如果为死亡数字，那么就不将其考虑在内。这样子需要多出一定的空间和时间来进行处理。</p>
<p>​
其实，我们可以不需要额外的空间来进行处理。因为在BFS的过程中，我们会记录哪些节点被访问过，就不要重复入队，故而，只需要提前将所有的死亡数字，都设定为已经被访问过，那么就不会被考虑在内。</p>
<h5 id="解题代码1"><strong>解题代码1</strong>：</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">openLock</span><span class="params">(vector&lt;string&gt;&amp; deadends, string target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构建hash表，方便进行查询</span></span><br><span class="line">        unordered_map&lt;string,<span class="type">int</span>&gt; dead;</span><br><span class="line">        unordered_map&lt;string,<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;deadends.<span class="built_in">size</span>();i++) dead[deadends[i]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(dead.<span class="built_in">find</span>(<span class="string">&quot;0000&quot;</span>) != dead.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">        <span class="comment">//开启广度优先搜索</span></span><br><span class="line">        queue&lt;string&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">        res[<span class="string">&quot;0000&quot;</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            string curr = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">//将curr的16个领居全部进入队列，并更新结果表，(如果存在dead点，则不进入队列)</span></span><br><span class="line">            vector&lt;string&gt; neighbor = <span class="built_in">getNeighbor</span>(curr);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;neighbor.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dead.<span class="built_in">find</span>(neighbor[i]) != dead.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(res.<span class="built_in">find</span>(neighbor[i]) == res.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(neighbor[i]);</span><br><span class="line">                    res[neighbor[i]] = res[curr] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">find</span>(target) == res.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> res[target];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">getNeighbor</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            string tmp = str;</span><br><span class="line">            <span class="keyword">if</span>(tmp[i] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                tmp[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                tmp[i] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp[i] == <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                tmp[i] = <span class="string">&#x27;8&#x27;</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                tmp[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp[i] = tmp[i] + <span class="number">1</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                tmp[i] = tmp[i] - <span class="number">2</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-02-22%20下午2.31.38.png" /></p>
<p>​ 此方法花费的执行用时和内存消耗都是下下选。</p>
<h5 id="解题思路2双向bfs"><strong>解题思路2：双向BFS</strong>：</h5>
<p>​
双向bfs适用于知道起点和终点的状态下使用，从起点和终点两个方向开始进行搜索，可以非常大的提高单个bfs的搜索效率</p>
<p>​
同样，实现也是通过队列的方式，可以设置两个队列，一个队列保存从起点开始搜索的状态，另一个队列用来保存从终点开始搜索的状态，如果某一个状态下出现相交的情况，那么就出现了答案，用一张图来进行说明如下所示：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/jevyd2TPC7FX6GA.png" alt="jevyd2TPC7FX6GA" style="zoom: 33%;" /></p>
<p>​
具体如何实现判断相遇，见如下的代码：我们构建vis，代表某个字符串的位置是否被访问过。这个在单向的BFS中，我们不需要设置，因为我们可以通过res这个Hash表有没有某个元素来进行判断，实际上此处的vis起到的也并不是判断有没有被访问过的作用（后面代码还是通过res中有没有某个元素来判断的），此处的vis最大的作用是记录某个节点是被正向搜索访问过，还是被反向搜索访问过，如果被正向访问过设置为1，被反向搜索访问过设置为2。</p>
<p>​
同时，在每一遍while中，我们扩展<strong>较小的搜索队列</strong>，并利用flag记录扩展的是前向还是反向。如果在遍历某一轮的领居的过程中，发现：curr点和领居点的vst相加=3，意味着两者一个是正向搜索序列，一个是逆向搜索序列，相遇了，所以此时我们可以返回结果，不用继续下去了。</p>
<h5 id="解题代码2">解题代码2：</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">openLock</span><span class="params">(vector&lt;string&gt;&amp; deadends, string target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构建hash表，方便进行查询结果</span></span><br><span class="line">        unordered_map&lt;string,<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="comment">//构建vis，代表某个字符串的位置是否被访问过 被正向访问过为1，被反向搜索访问过为2</span></span><br><span class="line">        unordered_map&lt;string,<span class="type">int</span>&gt; vis;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;deadends.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            res[deadends[i]] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">find</span>(<span class="string">&quot;0000&quot;</span>) != res.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">        <span class="keyword">if</span>(target == <span class="string">&quot;0000&quot;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//开启广度优先搜索</span></span><br><span class="line">        queue&lt;string&gt; q1;  <span class="comment">//前向搜索序列</span></span><br><span class="line">        queue&lt;string&gt; q2;  <span class="comment">//反向搜索序列</span></span><br><span class="line">        q1.<span class="built_in">push</span>(<span class="string">&quot;0000&quot;</span>);   <span class="comment">//前向搜索初始化</span></span><br><span class="line">        q2.<span class="built_in">push</span>(target);   <span class="comment">//反向搜索初始化</span></span><br><span class="line">        res[<span class="string">&quot;0000&quot;</span>] = <span class="number">0</span>;   <span class="comment">//前向搜索初始化</span></span><br><span class="line">        res[target] = <span class="number">0</span>;   <span class="comment">//反向搜索初始化</span></span><br><span class="line">        vis[<span class="string">&quot;0000&quot;</span>] = <span class="number">1</span>;	 <span class="comment">//前向搜索初始化</span></span><br><span class="line">        vis[target] = <span class="number">2</span>;	 <span class="comment">//反向搜索初始化</span></span><br><span class="line">        <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>() &amp;&amp; !q2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">//在每一遍while中，我们扩展 较小的搜索队列,利用flag记录扩展的是前向还是反向</span></span><br><span class="line">            string curr;</span><br><span class="line">            <span class="type">bool</span> flag;</span><br><span class="line">            <span class="keyword">if</span>(q1.<span class="built_in">size</span>() &lt; q2.<span class="built_in">size</span>())&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                curr = q1.<span class="built_in">front</span>();</span><br><span class="line">                q1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                curr = q2.<span class="built_in">front</span>();</span><br><span class="line">                q2.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将curr的16个领居全部进入队列，并更新结果表，(如果存在dead点，则不进入队列)</span></span><br><span class="line">            vector&lt;string&gt; neighbor = <span class="built_in">getNeighbor</span>(curr);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;neighbor.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(res.<span class="built_in">find</span>(neighbor[i]) == res.<span class="built_in">end</span>())&#123; <span class="comment">//如果这个领居点从来没被访问过 </span></span><br><span class="line">                    <span class="keyword">if</span>(flag) q1.<span class="built_in">push</span>(neighbor[i]);</span><br><span class="line">                    <span class="keyword">else</span> q2.<span class="built_in">push</span>(neighbor[i]);</span><br><span class="line">                    res[neighbor[i]] = res[curr] + <span class="number">1</span>;</span><br><span class="line">                    vis[neighbor[i]] = vis[curr];  <span class="comment">//继承当前访问的队列编号，1为正向，2为反向</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;  <span class="comment">//如果这个领居点被访问过：</span></span><br><span class="line">                    <span class="keyword">if</span>(vis[neighbor[i]] + vis[curr] == <span class="number">3</span>)&#123;</span><br><span class="line">                        <span class="comment">//如果curr点和领居点的vst相加=3，意味着两者一个是正向搜索序列，一个是逆向搜索序列，相遇了，所以此时我们可以返回结果，不用继续下去了</span></span><br><span class="line">                        <span class="keyword">return</span> res[curr] + res[neighbor[i]] + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">getNeighbor</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            string tmp = str;</span><br><span class="line">            <span class="keyword">if</span>(tmp[i] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                tmp[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                tmp[i] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp[i] == <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                tmp[i] = <span class="string">&#x27;8&#x27;</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                tmp[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp[i] = tmp[i] + <span class="number">1</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                tmp[i] = tmp[i] - <span class="number">2</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-02-22%20下午2.30.39.png" /></p>
<p>可以看到，使用双向BFS比先前的单向BFS节省了非常多的时间与空间复杂度。</p>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>DFS与BFS系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>DFS系列——最长递增路径</title>
    <url>/2022/02/22/cd538be761a4/</url>
    <content><![CDATA[<h4 id="剑指-offer-ii-112.-最长递增路径"><a
href="https://leetcode-cn.com/problems/fpTFWP/">剑指 Offer II 112.
最长递增路径</a></h4>
<p>​ 给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。</p>
<p>​ 对于每个单元格，你可以往上，下，左，右四个方向移动。 不能 在 对角线
方向上移动或移动到 边界外（即不允许环绕）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[9,9,4],[6,6,8],[2,1,1]]</span><br><span class="line">输出：4 </span><br><span class="line">解释：最长递增路径为 [1, 2, 6, 9]。</span><br></pre></td></tr></table></figure>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/grid1.jpg" /></p>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[3,4,5],[3,2,6],[2,2,1]]</span><br><span class="line">输出：4 </span><br><span class="line">解释：最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。</span><br></pre></td></tr></table></figure>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/tmp-grid.jpg" /></p>
<p>参考：https://leetcode-cn.com/problems/fpTFWP/solution/zui-chang-di-zeng-lu-jing-by-leetcode-so-1chr/</p>
<h5
id="解题思路1dfs进阶记忆化深度优先搜索">解题思路1：DFS进阶—记忆化深度优先搜索：</h5>
<p>​
拿到题目以后，将其看作一个图，然后从一个单元格开始进行深度优先搜索，即可找到从该单元格开始的最长递增路径。对每个单元格分别进行深度优先搜索之后，即可得到矩阵中的最长递增路径的长度。这是一个非常朴素且好用的办法，但是仔细想一下以后，时间复杂度肯定是指数级的，会超出时间限制，所以需要优化。</p>
<p>​
常见的优化方式，就是<strong>记忆化深度优先搜索</strong>，思路如下：</p>
<p>​
<strong>朴素深度优先搜索的时间复杂度过高的原因是进行了大量的重复计算，同一个单元格会被访问多次，每次访问都要重新计算。由于同一个单元格对应的最长递增路径的长度是固定不变的，因此可以使用记忆化的方法进行优化</strong>。用矩阵
<code>res</code>作为缓存矩阵，已经计算过的单元格的结果存储到缓存矩阵中。</p>
<p>​ 使用记忆化深度优先搜索，当访问到一个单元格<code>(i,j)</code>时，如果
<code>res[i][j] != 0</code>，说明该单元格的结果已经计算过，则直接从缓存中读取结果，如果
<code>res[i][j] == 0</code>，说明该单元格的结果尚未被计算过，则进行搜索，并将计算得到的结果存入缓存中。</p>
<p>​
遍历完矩阵中的所有单元格之后，即可得到矩阵中的最长递增路径的长度。</p>
<h5 id="解题代码1">解题代码1：</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dirs = &#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;; <span class="comment">//四个邻居坐标</span></span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestIncreasingPath</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">                <span class="type">int</span> dis = <span class="built_in">dfs</span>(i,j,matrix,res);</span><br><span class="line">                <span class="keyword">if</span>(dis &gt; max) max = dis;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> column,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//如果已经计算过该点的值，我们直接返回(相比于传统的DFS，其实就多了这一步)</span></span><br><span class="line">        <span class="keyword">if</span> (res[row][column] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res[row][column];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果该点的值没有计算过，先将该点的值 +1，代表路径长度为1.</span></span><br><span class="line">        ++res[row][column];</span><br><span class="line">        <span class="comment">//遍历4个周围的邻居，进行递归，深度优先遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> new_row = row + dirs[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> new_column = column + dirs[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (new_row &gt;= <span class="number">0</span> &amp;&amp; new_row &lt; m &amp;&amp; </span><br><span class="line">                new_column &gt;= <span class="number">0</span> &amp;&amp; new_column &lt; n &amp;&amp; </span><br><span class="line">                matrix[new_row][new_column] &gt; matrix[row][column]        <span class="comment">//如果周围比该点大，则进行深度遍历</span></span><br><span class="line">            )&#123;</span><br><span class="line">                <span class="comment">//最终的结果 为当前的最长递增路径 和 周围邻居的最长路径 + 1，两者中大的那个值</span></span><br><span class="line">                res[row][column] = <span class="built_in">max</span>(res[row][column], <span class="built_in">dfs</span>(new_row, new_column,matrix, res) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[row][column];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="解题思路2动态规划拓扑排序">解题思路2：动态规划（拓扑排序）</h5>
<p>​
一开始，我看到此题，没有想到去优化DFS，而是直接转到了动态规划的思路上，刚开始觉得这题如果使用动态规划非常方便，每个节点它的最长递增路径，无非就是周围的邻居中，选一个最长递增路径最大，并且比自己值大的节点
+
1，就可以了，即<code>res[i][j]=max&#123;res[x][y]&#125;+1 (其中(x,y)与(i,j)在矩阵中相邻且matrix[x][y] &gt; matrix[i][j])</code>。</p>
<p>​
事实确实是这样，但是没想到此题如果使用动态规划，关键问题并不是状态转移方程，而是初始化条件和如何去进行状态转移.按照通常的思路,我想到了从左上角向右下角遍历,此时仅考虑左边和上面的点,然后从右下角至左上角遍历,此时仅考虑右边和下面的点,这样子由于缓存的关系相当于也考虑了周围的四个邻居,类似于<a
href="https://blog.fantast.top/2022/02/21/80b7b127a404/">图系列——矩阵中的距离</a>这道题目的动态规划方法,代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestIncreasingPath</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="comment">//从左上角向右下角遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="type">int</span> ele = matrix[i][j];</span><br><span class="line">                <span class="comment">//检查邻居的值，如果左边和上面的值符合递增效果，则叠加</span></span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//检查上方</span></span><br><span class="line">                    <span class="type">int</span> ele_up = matrix[i<span class="number">-1</span>][j];</span><br><span class="line">                    <span class="keyword">if</span>(ele_up &gt; ele) res[i][j] = <span class="built_in">max</span>(res[i][j] , res[i<span class="number">-1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//检查左方</span></span><br><span class="line">                    <span class="type">int</span> ele_left = matrix[i][j<span class="number">-1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(ele_left &gt; ele) res[i][j] =  <span class="built_in">max</span>(res[i][j] ,res[i][j<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=m<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-1</span>;j&gt;=e;j--)&#123;</span><br><span class="line">                <span class="type">int</span> ele = matrix[i][j];</span><br><span class="line">                <span class="comment">//检查邻居的值，如果左边和上面的值符合递增效果，则叠加</span></span><br><span class="line">                <span class="keyword">if</span>(i!=m<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="comment">//检查下方</span></span><br><span class="line">                    <span class="type">int</span> ele_down = matrix[i+<span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">if</span>(ele_down &gt; ele) res[i][j] =  <span class="built_in">max</span>(res[i][j] ,res[i+<span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j!=n<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="comment">//检查右方</span></span><br><span class="line">                    <span class="type">int</span> ele_right = matrix[i][j+<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(ele_right &gt; ele ) res[i][j] =  <span class="built_in">max</span>(res[i][j] ,res[i][j+<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(res[i][j] &gt; max) max = res[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​
<strong>但这个题目这样子做是会出问题的,具体出问题的原因我也搞清楚了,大致是因为某个元素更新后,会导致先前已经通过该元素更新的元素变得无效,但是思考了很久,至今还是没有完全想通,为什么<矩阵中的距离>这道题目可以用这种方式递归,而该题目无法用这种形式递归</strong></p>
<p>​
<strong>我们先看正确方法:这题的关键在于如何定义初始化状态和计算流程:</strong></p>
<p>​
动态规划除了状态定义和状态转移方程，还需要考虑边界情况。这里的边界情况是什么呢？</p>
<p>​
如果一个单元格的值比它的所有相邻单元格的值都要大，那么这个单元格对应的最长递增路径是
1，这就是边界条件。这个边界条件并不直观，而是<strong>需要根据矩阵中的每个单元格的值找到作为边界条件的单元格</strong>。</p>
<p>​
仍然使用方法一的思想，将矩阵看成一个有向图，计算每个单元格对应的出度，即有多少条边从该单元格出发。对于作为边界条件的单元格，该单元格的值比所有的相邻单元格的值都要大，因此作为边界条件的单元格的出度都是
0。</p>
<p>​ <strong>基于出度的概念，可以使用拓扑排序求解。从所有出度为 0
的单元格开始广度优先搜索，每一轮搜索都会遍历当前层的所有单元格，更新其余单元格的出度，并将出度变为
0
的单元格加入下一层搜索。当搜索结束时，搜索的总层数即为矩阵中的最长递增路径的长度。</strong></p>
<h5 id="解题代码2官方代码">解题代码2(官方代码):</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> rows, columns;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestIncreasingPath</span><span class="params">(vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rows = matrix.<span class="built_in">size</span>();</span><br><span class="line">        columns = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> outdegrees = vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; (rows, vector &lt;<span class="type">int</span>&gt; (columns));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; columns; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                    <span class="type">int</span> newRow = i + dirs[k][<span class="number">0</span>], newColumn = j + dirs[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (newRow &gt;= <span class="number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= <span class="number">0</span> &amp;&amp; newColumn &lt; columns &amp;&amp; matrix[newRow][newColumn] &gt; matrix[i][j]) &#123;</span><br><span class="line">                        ++outdegrees[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue &lt; pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; columns; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (outdegrees[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> cell = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> row = cell.first, column = cell.second;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                    <span class="type">int</span> newRow = row + dirs[k][<span class="number">0</span>], newColumn = column + dirs[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (newRow &gt;= <span class="number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= <span class="number">0</span> &amp;&amp; newColumn &lt; columns &amp;&amp; matrix[newRow][newColumn] &lt; matrix[row][column]) &#123;</span><br><span class="line">                        --outdegrees[newRow][newColumn];</span><br><span class="line">                        <span class="keyword">if</span> (outdegrees[newRow][newColumn] == <span class="number">0</span>) &#123;</span><br><span class="line">                            q.<span class="built_in">push</span>(&#123;newRow, newColumn&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/fpTFWP/solution/zui-chang-di-zeng-lu-jing-by-leetcode-so-1chr/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>DFS与BFS系列</category>
        <category>动态规划系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>DFS</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>图系列——多余的边（DSU应用）</title>
    <url>/2022/02/21/0f9e9b187c29/</url>
    <content><![CDATA[<h4 id="剑指-offer-ii-118.-多余的边"><a
href="https://leetcode-cn.com/problems/7LpjUW/">剑指 Offer II 118.
多余的边</a></h4>
<p>​ 树可以看成是一个连通且 无环 的 无向 图。</p>
<p>​ 给定往一棵 n 个节点 (节点值 1～n)
的树中添加一条边后的图。添加的边的两个顶点包含在 1 到 n
中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 n
的二维数组 edges ，edges[i] = [ai, bi] 表示图中在 ai 和 bi
之间存在一条边。</p>
<p>​ 请找出一条可以删去的边，删除后可使得剩余部分是一个有着 n
个节点的树。如果有多个答案，则返回数组 edges 中最后出现的边。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/1626676174-hOEVUL-image.png" style="zoom: 50%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: edges = [[1,2],[1,3],[2,3]]</span><br><span class="line">输出: [2,3]</span><br></pre></td></tr></table></figure>
<h5 id="解题思路"><strong>解题思路</strong>：</h5>
<p>​
一开始，我的思路是找到一种方法，能够判断一个图有无环。毫无疑问，我们可以使用拓扑排序去进行这个思路，但是这样子的话，对于每删掉一条边就要进行一次拓扑排序来判断，时间复杂度无疑是比较高的。</p>
<p>​
这个时候，查看官方解答，原来这类题目还可以使用<strong>并查集</strong>来做：</p>
<p>​
初始时，每个节点都属于不同的连通分量。遍历每一条边，判断这条边连接的两个顶点是否属于相同的连通分量。</p>
<ul>
<li>如果两个顶点属于不同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间不连通，因此当前的边不会导致环出现，合并这两个顶点的连通分量。</li>
<li>如果两个顶点属于相同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间已经连通，因此当前的边导致环出现，为多余的边，将当前的边作为答案返回。</li>
</ul>
<h5 id="解题代码"><strong>解题代码</strong>：</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">root</span><span class="params">(<span class="number">1001</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i =<span class="number">0</span>;i&lt;edges.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">bool</span> res = <span class="built_in">unionTwo</span>(edges[i][<span class="number">0</span>],edges[i][<span class="number">1</span>],root);</span><br><span class="line">            <span class="keyword">if</span>(!res) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edges[i]; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRoot</span><span class="params">(<span class="type">int</span> index,vector&lt;<span class="type">int</span>&gt; &amp;root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root[index] != <span class="number">-1</span>)&#123;</span><br><span class="line">            index = root[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">unionTwo</span><span class="params">(<span class="type">int</span> index1,<span class="type">int</span> index2,vector&lt;<span class="type">int</span>&gt; &amp;root)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> root1 = <span class="built_in">getRoot</span>(index1,root);</span><br><span class="line">        <span class="type">int</span> root2 = <span class="built_in">getRoot</span>(index2,root);</span><br><span class="line">        <span class="keyword">if</span>(root1 != root2)&#123;</span><br><span class="line">            root[root1] = root2;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>图系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>graph</tag>
        <tag>DSU</tag>
      </tags>
  </entry>
  <entry>
    <title>图系列——矩阵中的距离</title>
    <url>/2022/02/21/80b7b127a404/</url>
    <content><![CDATA[<h4 id="剑指-offer-ii-107.-矩阵中的距离"><a
href="https://leetcode-cn.com/problems/2bCMpM/">剑指 Offer II 107.
矩阵中的距离</a></h4>
<p>​ 给定一个由 0 和 1 组成的矩阵 mat
，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的
0 的距离。</p>
<p>​ 两个相邻元素间的距离为 1 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/1626667201-NCWmuP-image.png" alt="img" style="zoom: 50%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：mat = [[0,0,0],[0,1,0],[0,0,0]]</span><br><span class="line">输出：[[0,0,0],[0,1,0],[0,0,0]]</span><br></pre></td></tr></table></figure>
<h5 id="解题思路1多源bfs"><strong>解题思路1:多源BFS</strong></h5>
<p>​
一开始看这题，应当能够较快的反应使用BFS进行解答，但核心的问题在于，如果使用传统
的BFS进行解答，起点是任意一个节点，终点为任意一个值为0的节点，我们需要做很多遍BFS才能够解决问题。</p>
<p>​
故而，本题中所涉及到的是一个叫做<strong>多源BFS</strong>的方法，其实多源的BFS和单源BFS非常相似，在上述问题中，整体思路如下：首先我们遍历整个矩阵，将所有的值为0的节点得出结果，并加入到队列中去。我们采用逆向思维的方法，将这些值为0的节点全部放入队列中，且这些值为0的节点对应的结果距离也为0，后续经由它们扩散得到的别的点的距离，是在它们的距离0的基础上逐渐进行叠加的，直到扩散至全图范围，我们的多源BFS也就完成了。</p>
<p>​
有一个可能会令人担忧的问题：那就是如果某一个点一开始被遍历到，设定好值以后，后面再作为别人的领居北遍历到的时候，会不会要设定的值比之前设定的值小呢？这是不可能的，因为我们采用的是BFS，一层层像波纹一样向外扩散，后遍历到的设定的值，必定大于或等于先前设定的值。所以不需要担心。</p>
<h5 id="解题代码"><strong>解题代码：</strong></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; neighbor = &#123; &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125; &#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">updateMatrix</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat) &#123;</span><br><span class="line">        <span class="type">int</span> m = mat.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">-1</span>)); <span class="comment">//初始化为-1，代表未访问过的点</span></span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="comment">// 初始化那些0的点，res也应当为0，将他们入队</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mat[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;i,j&#125;);</span><br><span class="line">                    res[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> x = q.<span class="built_in">front</span>().first;</span><br><span class="line">            <span class="type">int</span> y = q.<span class="built_in">front</span>().second;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                <span class="type">int</span> new_x = x + neighbor[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> new_y = y + neighbor[i][<span class="number">1</span>];</span><br><span class="line">              	<span class="comment">//如果节点不合法，或者节点已经访问过了，直接跳过</span></span><br><span class="line">                <span class="keyword">if</span>(new_x &lt; <span class="number">0</span> || new_x &gt;= m || new_y &lt; <span class="number">0</span> || new_y &gt;= n || res[new_x][new_y] != <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">              	<span class="comment">//计算res，push进入</span></span><br><span class="line">                res[new_x][new_y] = res[x][y] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;new_x,new_y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="解题思路2动态规划"><strong>解题思路2:动态规划</strong></h5>
<p>​ <strong>采用DP，状态转移方程如下：</strong> <span
class="math display">\[
f(i,j) =  1 + min(\ f(i − 1, j),\  f(i, j − 1),\ f(i + 1, j), \ f(i, j +
1) \ \ )\ \ \ \ \  if (matrix[i][j] == 1)
\]</span></p>
<p><span class="math display">\[
f(i,j)=  0 \ \ \ \ \ \   if (matrix[i][j] == 0)
\]</span></p>
<p>​
此时，我们需要注意，按照上述状态转移方程，我们好像没有一个办法遍历<code>i，j</code>，能够保证满足，在计算<span
class="math inline">\(f(i,j)\)</span>前，我们一定已经获知了<span
class="math inline">\(f(i-1,j)\)</span> 和<span
class="math inline">\(f(i+1,j)\)</span> 和<span
class="math inline">\(f(i,j-1)\)</span> 和<span
class="math inline">\(f(i,j+1)\)</span>这四个节点的状态。所以，我们需要分两步来进行计算遍历，先从左上角往右下角计算一遍，计算的时候仅考虑
<span class="math inline">\(f(i-1,j)\)</span> 和<span
class="math inline">\(f(i,j-1)\)</span>
这两个节点。再从右下角往左上角计算一遍，计算的时候仅考虑 <span
class="math inline">\(f(i+1,j)\)</span> 和<span
class="math inline">\(f(i,j+1)\)</span>
这两个节点。由于在前面一遍遍历中，会将结果存在<span
class="math inline">\(f(i,j)\)</span>中，再第二轮遍历的时候，只要将那两个节点和当前节点比较，就相当于完成了和上一轮遍历中的两个节点比较。故而能够达到和上述状态转移方程一致的效果，具体请看代码：</p>
<h5 id="解题代码-1"><strong>解题代码：</strong></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">updateMatrix</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat) &#123;</span><br><span class="line">        <span class="type">int</span> m = mat.<span class="built_in">size</span>(), n = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) </span><br><span class="line">                dp[i][j] = mat[i][j] == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1e7</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从左上角开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">mibn</span>(dp[i][j], dp[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从右下角开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; m) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i + <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>DFS与BFS系列</category>
        <category>动态规划系列</category>
        <category>图系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>BFS</tag>
        <tag>dynamic programming</tag>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划——排列的数目</title>
    <url>/2022/02/21/9ee9d017b9d4/</url>
    <content><![CDATA[<h4 id="剑指-offer-ii-104.-排列的数目"><a
href="https://leetcode-cn.com/problems/D0F0SV/">剑指 Offer II 104.
排列的数目</a></h4>
<p>​ 给定一个由 不同 正整数组成的数组 nums ，和一个目标整数 target 。请从
nums 中找出并返回总和为 target
的元素组合的个数。数组中的数字可以在一次排列中出现任意次，但是顺序不同的序列被视作不同的组合。</p>
<p>​ 题目数据保证答案符合 32 位整数范围。</p>
<ul>
<li>示例 1：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3], target = 4</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">所有可能的组合为：</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<pre><code>1 &lt;= nums.length &lt;= 200
1 &lt;= nums[i] &lt;= 1000
nums 中的所有元素 互不相同
1 &lt;= target &lt;= 1000</code></pre>
<h5 id="解题思路"><strong>解题思路</strong>：</h5>
<p>参考官方解答：
https://leetcode-cn.com/problems/D0F0SV/solution/pai-lie-de-shu-mu-by-leetcode-solution-og7w/</p>
<p>​
该题目中，比较棘手的问题，是我们需要计算排列数目，一开始看到题目，还是想着背包问题的解法，被背包问题局限死了思路，总想着先计算组合数目，再计算排列数目，但后来发现并不是很合理，如果需要这样子的话，我不仅需要记录组合的数目，我还要计算每一组组合是什么，以便后续根据其内容计算排列数目。</p>
<p>​
其实，跳出整一个背包问题的思路，我们采用动态规划的思想去思考：假设我们定义<code>res[i][j]</code>为前<code>i</code>个元素，达到<code>target=j</code>所有的排列数目，然后去思考转移方程，好像没法做，因为其并不能考虑排列，而是考虑的组合数目。故而正确的思路应当如下：</p>
<h5 id="定义"><strong>定义</strong>：</h5>
<pre><code>`res[target]`为达到目标整数target，可以出现的排列个数</code></pre>
<h5 id="初始化"><strong>初始化</strong>：</h5>
<pre><code>`res[0] = 1`，因为，要想达到目标整数0，只有一种排列方式，就是什么都不选。毕竟每一个元素都大于0.</code></pre>
<h5 id="状态转移分析"><strong>状态转移分析</strong>：</h5>
<pre><code>状态转移较为麻烦，对于`res[i]`而言，如何通过子问题的解来进行计算目标为`i`时候的排列数呢？</code></pre>
<p>​
对于一个排列而言，肯定存在最后一个数，我们假定最后这个数为<code>num</code>,这个数肯定是<code>nums</code>中的一个。那么这个排列前面的这些数，它们的和就是<code>i - num</code>，也就是说<code>res[i-num]</code>所记录的排列数量，其中的每个排列，加上最后那个数num，会形成一个新的排列，这个排列就是满足<code>target = i</code>中的一个排列，所以<code>res[i] = res[i-num]</code>，这对吗？这不完全对！我们的<code>res[i]</code>的来源可不仅仅一个num，之前说了我们假定最后这个数为<code>num</code>，其实最后这个数可以是<code>nums</code>中的任意一个数，也就是说，我们要遍历<code>nums</code>中的所有数，看某一个数能不能作为最后一个数（只要num
&lt;=
i即可），如果能，那么<code>res[i] += res[i-num]</code>。最终，<code>res[i]</code>应该是一系列的数值加和得到的结果。</p>
<h5 id="状态转移方程"><strong>状态转移方程</strong>：</h5>
<p>​
<code>res[i] = sum&#123; res[i-num] for each num in nums &#125; ( num &lt;= i)</code></p>
<h5 id="解题代码"><strong>解题代码</strong>：</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(target+<span class="number">1</span>)</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=target;i++)&#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="type">int</span> num = nums[j];</span><br><span class="line">                <span class="keyword">if</span>(num &lt;= i)&#123;</span><br><span class="line">                    tmp += res[i-num];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="进阶问题"><strong>进阶问题：</strong></h5>
<pre><code>如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？</code></pre>
<h5 id="解答"><strong>解答</strong>：</h5>
<pre><code>如果给定的数组中含有负数，则会导致出现无限长度的排列。</code></pre>
<p>​ 例如，假设数组 nums 中含有正整数 a 和负整数 −b（其中
a&gt;0,b&gt;0,−b&lt;0），则有 a×b+(−b)×a=0，对于任意一个元素之和等于
target 的排列，在该排列的后面添加 b 个 a 和 a 个 −b
之后，得到的新排列的元素之和仍然等于
target，而且还可以在新排列的后面继续 b 个 a 和 a 个
−b。因此只要存在元素之和等于 target
的排列，就能构造出无限长度的排列。</p>
<p>​
如果允许负数出现，则必须限制排列的最大长度，避免出现无限长度的排列，才能计算排列数</p>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>动态规划系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划——经典背包问题及扩展</title>
    <url>/2022/02/21/8eca8d666ea6/</url>
    <content><![CDATA[<h3 id="一背包问题简介">一、背包问题简介</h3>
<p>​
背包问题其实分很多种，此类问题的一般描述为：能否选择若干物品，使它们刚好放满一个容量为
t 的背包。在该篇博文中，我对其进行了详细的梳理。</p>
<ul>
<li><p>若每种物品可以选择拿一部分，则为<strong>分数背包问题</strong>，可以使用贪婪解决。</p></li>
<li><p>若每种物品只有一个，只能拿或者不拿，则为<strong>0-1背包问题</strong>，贪婪无法得到最优解，需用DP。</p></li>
<li><p>若每个物品的个数有限，则为<strong>多重背包问题</strong>；</p></li>
<li><p>若每个物品的个数无限，则为<strong>完全背包问题</strong>。</p></li>
</ul>
<h3 id="二分数背包问题">二、分数背包问题：</h3>
<p>​
分数背包问题思路非常简单，采用贪婪的思路，我们只需要先计算每一种物品，它的性价比，然后进行排序，拿性价比高的物品，直到背包被装满即可。
<span class="math display">\[
性价比 = 物品总价值 / 物品总体积
\]</span></p>
<h3 id="三0-1背包问题">三、0-1背包问题：</h3>
<h4 id="题目描述">题目描述：</h4>
<p>​
一共有N件物品，第i（i从1开始）件物品的重量为w[i]，价值为v[i]。在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？</p>
<h4 id="分析">分析：</h4>
<p>​
如果采用暴力穷举的方式，每件物品都存在装入和不装入两种情况，所以总的时间复杂度是O(2^N)，这是不可接受的。而使用动态规划可以将复杂度降至O(NW)。我们的<strong>目标是书包内物品的总价值，而变量是物品和书包的限重</strong>，所以我们可有如下解决方案</p>
<ul>
<li><p>定义规则如下：</p>
<ul>
<li><code>dp[i][j]</code>
表示将前i件物品装进限重为j的背包可以获得的最大价值,其中
<code>0&lt;=i&lt;=N, 0&lt;=j&lt;=W</code></li>
</ul></li>
<li><p>初始化状态：</p>
<ul>
<li>将<code>dp[0][0...W]</code>初始化为0，表示将前0个物品（即没有物品）装入书包的最大价值为0。</li>
</ul></li>
<li><p>状态转移方程：</p>
<ul>
<li><p>当 i &gt; 0 时<code>dp[i][j]</code> 有两种情况：</p>
<ol type="1">
<li>不装入第i件物品，即<code>dp[i-1][j]</code> ；</li>
<li>装入第 i 件物品（前提是能装下），即
<code>dp[i−1][j−w[i]] + v[i]</code>。</li>
</ol></li>
<li><p>``` dp[i][j] = max(dp[i−1][j], dp[i−1][j−w[i]]+v[i])        if( j
&gt;= w[i] ) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    从上述方程中，我们知晓`dp[i][j]`的值只与`dp[i-1][0,...,j-1]`有关，就可以开始书写动态规划代码，</span><br><span class="line"></span><br><span class="line">    第 i 件物品装入或者不装入而获得的最大价值完全可以由前面 i-1 件物品的最大价值决定，暴力枚举忽略了这个事实</span><br><span class="line"></span><br><span class="line">- 核心代码：</span><br><span class="line"></span><br><span class="line">  ```C++</span><br><span class="line">  for(int i=0;i&lt;n;i++)</span><br><span class="line">  	for(int j=0;j&lt;W;j++)</span><br><span class="line">  		dp[i][j] = max(dp[i−1][j], dp[i−1][j−w[i]]+v[i])</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
</ul>
<h4 id="题目示例">题目示例：</h4>
<p>​ <a href="https://leetcode-cn.com/problems/YaVDxD/">剑指 Offer II
102. 加减的目标值</a></p>
<h3 id="四完全背包问题">四、完全背包问题：</h3>
<h4 id="题目描述-1">题目描述：</h4>
<p>​ 完全背包（unbounded knapsack
problem）与01背包不同就是每种物品可以有无限多个：一共有N种物品，每种物品有无限多个，第i（i从1开始）种物品的重量为w[i]，价值为v[i]。在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？</p>
<h4 id="分析思路1">分析思路1：</h4>
<p>​
大体的规则与初始化状态都和0-1背包问题一致，在状态转移方程处有所区别：</p>
<ul>
<li><p>定义规则如下：</p>
<ul>
<li><code>dp[i][j]</code>
表示将前i件物品装进限重为j的背包可以获得的最大价值,其中
<code>0&lt;=i&lt;=N, 0&lt;=j&lt;=W</code></li>
</ul></li>
<li><p>初始化状态：</p>
<ul>
<li>将<code>dp[0][0...W]</code>初始化为0，表示将前0个物品（即没有物品）装入书包的最大价值为0。</li>
</ul></li>
<li><p>状态转移方程：</p>
<ul>
<li><p>当 i &gt; 0 时<code>dp[i][j]</code> 有两种情况：</p>
<ol type="1">
<li>不装入第i件物品，即<code>dp[i-1][j]</code> ；</li>
<li>装入第i种物品，此时和0-1背包不太一样，因为每种物品有无限个（但注意书包限重是有限的），所以此时不应该转移到<code>dp[i−1][j−w[i]]</code>而应该转移到<code>dp[i][j−w[i]]</code>，即装入第
i种商品后还可以再继续装入第i种商品。</li>
</ol></li>
<li><p>``` dp[i][j] = max(dp[i−1][j], dp[i][j−w[i]]+v[i]) if( j &gt;=
w[i] ) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  从上述方程中，我们知晓`dp[i][j]`的值只与`dp[i-1][0,...,j-1]`有关，就可以开始书写动态规划代码，</span><br><span class="line"></span><br><span class="line">  此解法时间复杂度为O(NW)</span><br><span class="line"></span><br><span class="line">- 伪代码：</span><br><span class="line"></span><br></pre></td></tr></table></figure> for(int i=0;i&lt;n;i++) for(int j=0;j&lt;W;j++)
dp[i][j] = max(dp[i−1][j], dp[i][j−w[i]]+v[i]) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 分析思路2：</span><br><span class="line"></span><br><span class="line">​	我们从装入第 `i `种物品多少件出发，0-1背包只有两种情况即取0件和取1件，而这里是取0件、1件、2件...直到超过限重（k &gt; j/w[i]），所以状态转移方程为：</span><br><span class="line"></span><br><span class="line">- 定义规则如下：与0-1相同</span><br><span class="line">  - `dp[i][j]` 表示将前i件物品装进限重为j的背包可以获得的最大价值,其中  `0&lt;=i&lt;=N, 0&lt;=j&lt;=W`</span><br><span class="line"></span><br><span class="line">- 初始化状态：与0-1相同</span><br><span class="line"></span><br><span class="line">  - 将`dp[0][0...W]`初始化为0，表示将前0个物品（即没有物品）装入书包的最大价值为0。</span><br><span class="line"></span><br><span class="line">- 状态转移方程：</span><br><span class="line"></span><br><span class="line">  - ```text</span><br><span class="line">    # k为装入第i种物品的件数, k &lt;= j/w[i]</span><br><span class="line">    dp[i][j] = max&#123;(dp[i-1][j − k*w[i]] + k*v[i]) for every k&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上述方程中，我们知晓<code>dp[i][j]</code>的值只与<code>dp[i-1][0,...,j-1]</code>有关，就可以开始书写动态规划代码</p></li>
</ul></li>
<li><p>伪代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;W;j++)</span><br><span class="line">        <span class="keyword">for</span>（<span class="type">int</span> k = <span class="number">0</span>;k&lt;j/w[i];k++)  <span class="comment">// j / w[i] 为可以装进的最大数目</span></span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j−k*w[i]]+k*v[i])</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="题目示例-1">题目示例：</h4>
<p>​ <a href="https://leetcode-cn.com/problems/gaM7Ch/">剑指 Offer II
103. 最少的硬币数目</a></p>
<h3 id="五多重背包问题">五、多重背包问题：</h3>
<h4 id="题目描述-2">题目描述：</h4>
<p>​ 多重背包（bounded knapsack
problem）与前面不同就是<strong>每种物品是有限个</strong>：一共有N种物品，第i（i从1开始）种物品的数量为n[i]，重量为w[i]，价值为v[i]。在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？</p>
<h4 id="分析-1">分析：</h4>
<p>​
大体的规则与初始化状态都和完全背包的分析2角度一致，就是在状态转移方程处的k的大小有了一个更高的限制。</p>
<ul>
<li><p>定义规则如下：</p>
<ul>
<li><code>dp[i][j]</code>
表示将前i件物品装进限重为j的背包可以获得的最大价值,其中
<code>0&lt;=i&lt;=N, 0&lt;=j&lt;=W</code></li>
</ul></li>
<li><p>初始化状态：</p>
<ul>
<li>将<code>dp[0][0...W]</code>初始化为0，表示将前0个物品（即没有物品）装入书包的最大价值为0。</li>
</ul></li>
<li><p>状态转移方程：</p>
<ul>
<li>```text # k为装入第i种物品的件数, k &lt;= min(n[i], j/w[i]) dp[i][j]
= max{(dp[i-1][j − k*w[i]] + k*v[i]) for every k} <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  从上述方程中，我们知晓`dp[i][j]`的值只与`dp[i-1][0,...,j-1]`有关，就可以开始书写动态规划代码，</span><br><span class="line"></span><br><span class="line">- 伪代码：</span><br><span class="line"></span><br><span class="line">  ```C++</span><br><span class="line">  for(int i=0;i&lt;n;i++)</span><br><span class="line">  	for(int j=0;j&lt;W;j++)</span><br><span class="line">          for（int k = 0;k&lt;min(n[i], j/w[i]);k++)  // min(n[i], j/w[i]) 为可以装进的背包的最大数目</span><br><span class="line">              dp[i][j] = max(dp[i-1][j], dp[i-1][j−k*w[i]]+k*v[i])</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3 id="六备注">六、备注：</h3>
<p>​
上述所有的算法，由于状态转移方程的特殊性，所以其实在空间复杂度上是可以进行优化的，我们可以使用<strong>滚动数组</strong>的方法来进行优化，就比如最普通的0-1问题，使用滚动数组优化后，我们可以仅用一个一维数组来存储结果，丢掉原先二维数组的第1个维度。</p>
<p>​
但是需要注意的是，在对j遍历的时候，必须逆向枚举，这是为了防止上一层循环的<code>dp[0,...,j-1]</code>被覆盖。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">0</span>,...,W] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>,...,N</span><br><span class="line">    <span class="keyword">for</span> j = W,...,w[i] <span class="comment">// 必须逆向枚举!!!</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j−w[i]]+v[i])</span><br></pre></td></tr></table></figure>
<p>参考：<strong>https://zhuanlan.zhihu.com/p/93857890</strong></p>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>动态规划系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dynamic programming</tag>
        <tag>knapsack problem</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串交织问题</title>
    <url>/2022/02/21/f178664086c4/</url>
    <content><![CDATA[<h4 id="剑指-offer-ii-096.-字符串交织"><a
href="https://leetcode-cn.com/problems/IY6buf/">剑指 Offer II 096.
字符串交织</a></h4>
<p>给定三个字符串 s1、s2、s3，请判断 s3 能不能由 s1 和 s2 交织（交错）
组成。</p>
<p>两个字符串 s 和 t 交织
的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：</p>
<pre><code>s = s1 + s2 + ... + sn
t = t1 + t2 + ... + tm
|n - m| &lt;= 1
交织 是 s1 + t1 + s2 + t2 + s3 + t3 + ... 或者 t1 + s1 + t2 + s2 + t3 + s3 + ...</code></pre>
<p>提示：a + b 意味着字符串 a 和 b 连接。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<h5 id="解题思路1"><strong>解题思路1</strong>：</h5>
<p>​
该题其实可以使用非常方便的回溯法思想进行解题，利用递归的形式：我们定义三个指针i，j，k，分别指向三个字符串，如果s1[i]
== s3[k]，那么递归处理(i+1,j,k+1)。同理，如果s2[j] ==
s3[k]，那么递归处理(i,j+1,k+1)。递归边界是：如果i，j，k都到达了字符串的最后，就代表能够完成字符串交织。</p>
<h5 id="代码如下"><strong>代码如下：</strong></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isInterleave</span><span class="params">(string s1, string s2, string s3)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">backtrace</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,s1,s2,s3);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrace</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> k,string &amp;s1, string &amp;s2, string &amp;s3)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == s1.<span class="built_in">length</span>() &amp;&amp; j == s2.<span class="built_in">length</span>() &amp;&amp; k == s3.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;s1.<span class="built_in">length</span>() &amp;&amp; s1[i] == s3[k]) <span class="built_in">backtrace</span>(i+<span class="number">1</span>,j,k+<span class="number">1</span>,s1,s2,s3);</span><br><span class="line">        <span class="keyword">if</span>(j&lt;s2.<span class="built_in">length</span>() &amp;&amp; s2[j] == s3[k]) <span class="built_in">backtrace</span>(i,j+<span class="number">1</span>,k+<span class="number">1</span>,s1,s2,s3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此时，会出现一个严重的问题，对于一些较长的序列来说，会通不过，运行超时。这是因为，这个回溯法，在分支进行的过程中，是很容易出现非常多的分支，并且会容易递归很多次的。所以，对于一些已经递归过的i，j，k结果，我们需要直接让它返回，不要继续递归计算，也就是对回溯法进行剪枝的操作。</p>
<h5 id="优化代码如下"><strong>优化代码如下：</strong></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isInterleave</span><span class="params">(string s1, string s2, string s3)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m; </span><br><span class="line">        <span class="built_in">backtrace</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,s1,s2,s3,m);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrace</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> k,string &amp;s1, string &amp;s2, string &amp;s3,unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &amp;m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == s1.<span class="built_in">length</span>() &amp;&amp; j == s2.<span class="built_in">length</span>() &amp;&amp; k == s3.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> checkpoint = i * <span class="number">100</span> + j * <span class="number">10</span> + k;</span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">find</span>(checkpoint) != m.<span class="built_in">end</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> m[checkpoint] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;s1.<span class="built_in">length</span>() &amp;&amp; s1[i] == s3[k]) <span class="built_in">backtrace</span>(i+<span class="number">1</span>,j,k+<span class="number">1</span>,s1,s2,s3,m);</span><br><span class="line">        <span class="keyword">if</span>(j&lt;s2.<span class="built_in">length</span>() &amp;&amp; s2[j] == s3[k]) <span class="built_in">backtrace</span>(i,j+<span class="number">1</span>,k+<span class="number">1</span>,s1,s2,s3,m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-02-21%20下午2.48.28.png" /></p>
<h5
id="解题思路2dynamic-programming-动态规划"><strong>解题思路2：Dynamic
Programming 动态规划</strong></h5>
<p><strong>参考题解：</strong>https://leetcode-cn.com/problems/IY6buf/solution/jian-zhi-offerguan-jie-de-ge-ren-li-jie-gpspb/</p>
<p>https://leetcode-cn.com/problems/IY6buf/solution/jian-zhi-offer-2-mian-shi-ti-96-shu-zhon-5kc7/</p>
<p>​
可以把题目进行一定的等效转换。约定从s1和s2中按从头到尾的顺序，依次取出一个字符（每次可以从s1中取，也可以从s2中取），加入字符串s3中，这样s3一定是s1和s2交错组成的结果。</p>
<p>​
那么问题就转换为在按顺序取的情况下，s1的前i个字符和s2的前jjj个字符是否能构成s3的前i+j个字符？</p>
<h6
id="状态转移方程用fij表示s10i和s20j能否组成s30ij1"><strong>状态转移方程</strong>：用f(i,j)表示s1[0:i]和s2[0:j]能否组成s3[0:i+j+1]</h6>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if s3[i+j+1] == s1[i]</span><br><span class="line">    f(i,j) = f(i-1,j)</span><br><span class="line">if s3[i+j+1] == s2[j]</span><br><span class="line">    f(i,j) = f(i,j-1)</span><br><span class="line">if s3[i+j+1] == s1[i] == s2[j]</span><br><span class="line">    f(i,j) = f(i-1,j) || f(i,j-1)</span><br></pre></td></tr></table></figure>
<h6
id="状态转移方程的原理-对于字符串s30ij1的最后一个字符"><strong>状态转移方程的原理:</strong>
对于字符串s3[0:i+j+1]的最后一个字符：</h6>
<ul>
<li>如果该字符等于s1最后一个字符，原问题变为子问题1：
s3[0:i+j]是否可以由s1[0:i-1]与s2[0:j]构成；</li>
<li>如果该字符等于s2最后一个字符，原问题变为子问题2：
s3[0:i+j]可以由s1[0:i]与s2[0:j-1]构成。</li>
<li>如果该字符等于s2最后一个字符，也等于s1最后一个字符，那么子问题1和子问题2中任何一个成立，都可以推出原问题成立</li>
</ul>
<p><strong>其余注意初始状态即可</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isInterleave</span><span class="params">(string s1, string s2, string s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.<span class="built_in">size</span>() + s2.<span class="built_in">size</span>() != s3.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(s1.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(s2.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; s2.<span class="built_in">size</span>() &amp;&amp; s2[j] == s3[j]; ++j) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>() &amp;&amp; s1[i] == s3[i]; ++i) &#123;</span><br><span class="line">            dp[i + <span class="number">1</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; s2.<span class="built_in">size</span>(); ++j) &#123; </span><br><span class="line">                <span class="type">char</span> ch1 = s1[i];</span><br><span class="line">                <span class="type">char</span> ch2 = s2[j];</span><br><span class="line">                <span class="type">char</span> ch3 = s3[i + j + <span class="number">1</span>];</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = ((ch1 == ch3) &amp;&amp; dp[i][j + <span class="number">1</span>]) || ((ch2 == ch3) &amp;&amp; dp[i + <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[s1.<span class="built_in">size</span>()][s2.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>动态规划系列</category>
        <category>字符串系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dynamic programming</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>数组系列——最长斐波那契数列</title>
    <url>/2022/02/21/aa9aa6191741/</url>
    <content><![CDATA[<h4 id="剑指-offer-ii-093.-最长斐波那契数列"><a
href="https://leetcode-cn.com/problems/Q91FMA/">剑指 Offer II 093.
最长斐波那契数列</a></h4>
<p>如果序列 X_1, X_2, ..., X_n 满足下列条件，就说它是 斐波那契式
的：</p>
<pre><code>n &gt;= 3
对于所有 i + 2 &lt;= n，都有 X_i + X_&#123;i+1&#125; = X_&#123;i+2&#125;</code></pre>
<p>给定一个严格递增的正整数数组形成序列 arr ，找到 arr
中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: arr = [1,2,3,4,5,6,7,8]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 最长的斐波那契式子序列为 [1,2,3,5,8] 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: arr = [1,3,7,11,12,14,18]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。</span><br></pre></td></tr></table></figure>
<h5 id="解题思路"><strong>解题思路</strong>：</h5>
<p>​
本题在LeetCode上，大多采用动态规划的方法解决，我借鉴了部分思路后，发现其实可以用与动态规划时间复杂度类似的算法解决。如下所示：</p>
<p>​
<strong>对于一个斐波那契数列来说，其性质给它带来了一个非常重要特性：也就是我们只要知道斐波那契数列中的最后两个数，或者前两个数，亦或者中间的任意的连续的两个数，我们就能够确定一整个斐波那契数列的元素</strong></p>
<p>​
举例而言，我们知道一个斐波那契数列中，有两个连续的数为5，8，那么整个斐波那契数列前面可能拥有的数为3，再前面可能的数为2，再前面可能的数为1。反之，再后面的数为13，再后面的数为21，等等。</p>
<p>​
之所以称之为可能的数，是因为我们并不知道斐波那契数列的长度，所以可能不存在这些数。放到这道题目中，我们可以用两个指针，i和j，遍历arr中所有的元素，例如：当i=2，j=4的时候，我们就假设arr[i]和arr[j]是斐波那契数列的最后两个数，然后循环的向前计算，观察arr中是否有满足条件的前面的数。</p>
<p>​
遍历整个数列的时间复杂度为O(n^2)，而查找arr中是否有满足条件的数，我们可以使用Hash表来完成，先再代码开始处，用O(n)的时间，进行插入，后续查找都只需要O(1)的时间。</p>
<h5 id="解题代码"><strong>解题代码</strong>：</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">      	<span class="comment">//构建hash表，以便后续查找</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            m[arr[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//遍历i，j，计算以arr[i]和arr[j]为最后两个元素的斐波那契数列的长度</span></span><br><span class="line">        <span class="type">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="type">int</span> res = <span class="built_in">calculateMaxLen</span>(arr[i],arr[j],m);</span><br><span class="line">                <span class="keyword">if</span>( res &gt; maxLen)&#123;</span><br><span class="line">                    maxLen = res;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculateMaxLen</span><span class="params">(<span class="type">int</span> ele1,<span class="type">int</span> ele2,unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &amp;m)</span></span>&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果找不到的话，退出循环</span></span><br><span class="line">            <span class="keyword">if</span>(ele2 - ele1 &gt;= ele1) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(m.<span class="built_in">find</span>(ele2-ele1) == m.<span class="built_in">end</span>()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果找到了,迭代：继续循环</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="type">int</span> tmp = ele2-ele1;</span><br><span class="line">                ele2 = ele1;</span><br><span class="line">                ele1 = tmp;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>数组系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划——最少回文分割问题（待更新）</title>
    <url>/2022/02/18/52df1a6e55af/</url>
    <content><![CDATA[<h4 id="剑指-offer-ii-094.-最少回文分割"><a
href="https://leetcode-cn.com/problems/omKAoA/">剑指 Offer II 094.
最少回文分割</a></h4>
<p>给定一个字符串 <code>s</code>，请将 <code>s</code>
分割成一些子串，使每个子串都是回文串。</p>
<p>返回符合要求的 <strong>最少分割次数</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aab&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：只需一次分割就可将 s 分割成 [&quot;aa&quot;,&quot;b&quot;] 这样两个回文子串。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a&quot;</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<h5 id="解题思路"><strong>解题思路</strong>：</h5>
<p>​ 其内部其实含有两个DP子问题：</p>
<ul>
<li>1、字符串所有的子串，它们是不是回文串。即 s[i, j]
这一段是不是回文字符串</li>
<li>2、如何分割能够有最少的分割次数</li>
</ul>
<h5 id="子问题1"><strong>子问题1：</strong></h5>
<p>​ 我们用一个二维数组 isPalindrome
来进行记录，初始化为false。按照len长度进行遍历：状态转移方程如下所示：
<span class="math display">\[
s[i][j] = true  \ \ \ \ \ (len = 1)
\]</span></p>
<p><span class="math display">\[
s[i][j] = (s[i] == s[j])  \ \ \ \ \ (len = 2)
\]</span></p>
<p><span class="math display">\[
s[i][j] = (s[i] == s[j] \ \ \ \&amp;\&amp; \ \ \
isPalindrome[i+1][j-1])  \ \ \ \ (len &gt; 2)
\]</span></p>
<h5 id="代码1">代码1：</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line"><span class="comment">// 初始化全false</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">isPalindrome</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line"><span class="comment">// 长度为1的是回文串</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) isPalindrome[i][i] = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 从长度为2的子串开始枚举[left, right]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; ++len)&#123;</span><br><span class="line">    <span class="comment">// 左端点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> left = <span class="number">0</span>; left + len &lt;= n; ++left) &#123;</span><br><span class="line">        <span class="comment">// 右端点</span></span><br><span class="line">        <span class="type">int</span> right = left + len - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 长度为2就是这俩是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">2</span>) isPalindrome[left][right] = (s[left] == s[right]);</span><br><span class="line">        <span class="comment">// 长度大于2, 端点相同的同时，内侧也要是回文</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">2</span>) isPalindrome[left][right] = (s[left] == s[right]) &amp;&amp; isPalindrome[left + <span class="number">1</span>][right - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="子问题2"><strong>子问题2：</strong></h5>
<p>​ 我们用一维数组存储，字符串从「起点字符」到「第 i
个字符」组成的子串，最少需要多少分割次数。<code>dp[i]</code> 为将
<code>[0,i]</code>
这一段字符分割为若干回文串的最小分割次数，状态转移方程如下：</p>
<ul>
<li><p>从「起点字符」到「第 i 个字符」能形成回文串。那么最小分割次数为
0，此时有 <code>dp[i] = 0</code>； <span class="math display">\[
dp[i] = 0 \ \ \ \ \ ( isPalindrome[0][i] == true)
\]</span></p></li>
<li><p>从「起点字符」到「第 i
个字符」不能形成回文串。此时我们需要枚举左端点<code>l</code>，如果<code>[l, i]</code>
这一段是回文串的话，那么有 <code>dp[i] = dp[l- 1] + 1</code> (
满足回文要求的左端点位置 l 可能有很多个，取最小</p></li>
</ul>
<p><span class="math display">\[
dp[i] = min(dp[l_0-1],dp[l_1-1],……,dp[l_{i} - 1]  ) + 1 \ \ \ (
isPalindrome[0][i] == false)(l_i = i)
\]</span></p>
<h5 id="代码2">代码2：</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// n = s.length()</span></span><br><span class="line"><span class="comment">//2、res[i]代表从「起点字符」到「第 i 个字符」组成的子串要分割成回文串最少的分割次数</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(isPalindrome[<span class="number">0</span>][i]) res[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> min = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;=i;l++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPalindrome[l][i] &amp;&amp; res[l<span class="number">-1</span>] &lt; min)&#123;</span><br><span class="line">                min = res[l<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i] = min + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="总解题代码">总解题代码：</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCut</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、需要预先知道 i - j 的字符串是不是回文串 ( i &lt; j) </span></span><br><span class="line">        <span class="comment">//isPalindrome[i][j] 代表 i - j 子串</span></span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="comment">// 初始化全false</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">isPalindrome</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="comment">// 长度为1的是回文串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) isPalindrome[i][i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 从长度为2的子串开始枚举[left, right]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; ++len)&#123;</span><br><span class="line">            <span class="comment">// 左端点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> left = <span class="number">0</span>; left + len &lt;= n; ++left) &#123;</span><br><span class="line">                <span class="comment">// 右端点</span></span><br><span class="line">                <span class="type">int</span> right = left + len - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 长度为2就是这俩是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">2</span>) isPalindrome[left][right] = (s[left] == s[right]);</span><br><span class="line">                <span class="comment">// 长度大于2, 端点相同的同时，内侧也要是回文</span></span><br><span class="line">                <span class="keyword">if</span> (len &gt; <span class="number">2</span>) isPalindrome[left][right] = (s[left] == s[right]) &amp;&amp; isPalindrome[left + <span class="number">1</span>][right - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2、res[i]代表从「起点字符」到「第 i 个字符」组成的子串要分割成回文串最少的分割次数</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPalindrome[<span class="number">0</span>][i]) res[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> min = <span class="number">1e9</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;=i;l++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(isPalindrome[l][i] &amp;&amp; res[l<span class="number">-1</span>] &lt; min)&#123;</span><br><span class="line">                        min = res[l<span class="number">-1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                res[i] = min + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>动态规划系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划——房屋偷盗问题</title>
    <url>/2022/02/17/d13b71a5983a/</url>
    <content><![CDATA[<h4 id="剑指-offer-ii-089.-房屋偷盗"><a
href="https://leetcode-cn.com/problems/Gu0c2T/">剑指 Offer II 089.
房屋偷盗</a></h4>
<p>​
一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响小偷偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>​ 给定一个代表每个房屋存放金额的非负整数数组 nums ，请计算
不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br></pre></td></tr></table></figure>
<h5 id="解题思路"><strong>解题思路</strong>：</h5>
<p>​
从纯解题的角度而言，本题是可以采用DFS进行的，但是使用DFS会超时，我们需要时间复杂度更为简单的算法。动态规划就起到了比较大的作用：</p>
<h5 id="定义">定义：</h5>
<p>​ 设动态规划列表 dp ，dp[i] 代表前 i
个房子在满足条件下的能偷盗到的最高金额。</p>
<h5 id="状态转移方程">状态转移方程：</h5>
<p><span class="math display">\[
dp[n+1]=max(dp[n],dp[n−1]+num)
\]</span> ​ 其中，<span class="math inline">\(dp[n]\)</span>
来源于：我们不抢第n+1个房子。</p>
<p>​ 其中，<span class="math inline">\(dp[n−1]+num[n+1]\)</span>
来源于：我们抢当前的房子，这样的话第n个房子就不能再抢了，所以我们只要加上前n-1个房子能抢到的最大金额即可。</p>
<h5 id="解题代码"><strong>解题代码</strong>：</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxNum</span><span class="params">(nums.size()+<span class="number">1</span>)</span></span>;</span><br><span class="line">        maxNum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        maxNum[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            maxNum[i] = <span class="built_in">max</span>(maxNum[i<span class="number">-1</span>],maxNum[i<span class="number">-2</span>] + nums[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxNum[nums.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-offer-ii-090.-环形房屋偷盗"><a
href="https://leetcode-cn.com/problems/PzWKhm/">剑指 Offer II 090.
环形房屋偷盗</a></h4>
<p>一个专业的小偷，计划偷窃一个环形街道上沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都
围成一圈
，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警
。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组 nums ，请计算
在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,3,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure>
<h5 id="解题思路-1"><strong>解题思路</strong>：</h5>
<p>​ 与上题其实大体一致，只不过需要转一个脑筋急转弯：</p>
<p>​
环状排列意味着第一个房子和最后一个房子中只能选择一个偷盗，因此可以把此环状排列房间问题约化为两个单排排列房间子问题：</p>
<ul>
<li><p>在不偷盗第一个房子的情况下（即 nums[1:]），最大金额是 p1
；</p></li>
<li><p>在不偷盗最后一个房子的情况下（即 nums[:n−1]），最大金额是 p2
。</p></li>
<li><p>综合偷盗最大金额： 为以上两种情况的较大值，即
max(p1,p2)。</p></li>
</ul>
<h5 id="解题代码-1">解题代码：</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp1</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp2</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="comment">//dp1 不把nums[0]计算入</span></span><br><span class="line">        dp1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp1[<span class="number">1</span>] = nums[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//dp2 不把nums[nums.size()-1]计算入</span></span><br><span class="line">        dp2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp2[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dp1[i] = <span class="built_in">max</span>(dp1[i<span class="number">-1</span>],dp1[i<span class="number">-2</span>] + nums[i]);</span><br><span class="line">            dp2[i] = <span class="built_in">max</span>(dp2[i<span class="number">-1</span>],dp2[i<span class="number">-2</span>] + nums[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp1[nums.<span class="built_in">size</span>()<span class="number">-1</span>],dp2[nums.<span class="built_in">size</span>()<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>动态规划系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划——经典最长公共子序列问题</title>
    <url>/2022/02/16/513d3a9242d5/</url>
    <content><![CDATA[<h4 id="剑指-offer-ii-095.-最长公共子序列"><a
href="https://leetcode-cn.com/problems/qJnOS7/">剑指 Offer II 095.
最长公共子序列</a></h4>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列
的长度。如果不存在 公共子序列 ，返回 0 。一个字符串的 子序列
是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<ul>
<li>例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde"
的子序列。</li>
</ul>
<p>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>
<ul>
<li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li>
</ul>
<h5 id="解题思路"><strong>解题思路</strong>：</h5>
<p>​ 最长公共子序列问题是典型的二维动态规划问题。</p>
<p>​ 我们设定一个二维数组 res, <span
class="math inline">\(res[i][j]\)</span>
代表text1的前i个字符和text2的前j个字符的最长公共子序列。当i =
0或j=0时，均初始化为0，然后我们写出递归表达式： <span
class="math display">\[
res[i][j] = res[i-1][j-1] + 1  \ \ \ \ \ (if \ \ \ \ text1[i-1] ==
text2[j-1])
\]</span></p>
<p><span class="math display">\[
res[i][j] = max(res[i-1][j],res[i][j-1])  \ \ \ \ \ (if \ \ \ \
text1[i-1] != text2[j-1])
\]</span></p>
<p>​ 然后按照动态规划规则，进行循环求解即可。</p>
<h5 id="解题代码"><strong>解题代码</strong>：</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len_1 = text1.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> len_2 = text2.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(len_1 + <span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(len_2 + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len_1;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=len_2;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    res[i][j] = res[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>; </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res[i][j] = <span class="built_in">max</span>(res[i<span class="number">-1</span>][j] , res[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[len_1][len_2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>C++代码技巧注意</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化二维数组的方法</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>​</p>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>动态规划系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习基础系列笔记18——常见的位置编码Position Encoding方法</title>
    <url>/2022/02/15/c20d8f810e24/</url>
    <content><![CDATA[<h3 id="一固定的绝对位置编码">一、固定的绝对位置编码：</h3>
<p>​
在Transformer中使用的就是绝对位置编码，我们会将输入的序列首先通过Linear
Embedding的形式，编码成 $ n d_{model}$ 的形式，<span
class="math inline">\(n\)</span> 代表token的数量，<span
class="math inline">\(d_{model}\)</span> 代表一个token的维度。</p>
<p>​
然后我们会生成位置编码，绝对位置编码是固定值，其能够支持较长的序列，我们假设支持最长的序列长度为5000，那么就应当先生成一个维度为
$ 5000 d_{model}$ 的矩阵，具体公式如下：（不唯一）</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220215094001163.png" /></p>
<p>​ 使用如上所述的公式，代表不同频率的正弦和余弦函数进行表示：pos代表
第1个维度，也就是5000那个维度， i代表<span
class="math inline">\(d_{model}\)</span>那个维度，对于一个固定的<span
class="math inline">\(i\)</span>而言，我们会发现，其就是关于pos的正弦或余弦函数，对于不同的i而言，就是不同的频率而已。这样子预先计算好一个
$ 5000 d_{model}$ 的矩阵以后：</p>
<p>​ 等到要使用了，我们检测到token的数量是n，那么就直接取前整个矩阵的前 $
n d_{model}$切片就可以，然后与序列的Linear Embedding相加即可。</p>
<h3
id="二可学习的绝对位置编码-learned-positional-embedding">二、可学习的绝对位置编码
Learned Positional Embedding：</h3>
<p>​ <strong>直接对不同的位置随机初始化一个postion
embedding</strong>，加到word
embedding上输入模型，<strong>作为参数进行训练。</strong>使用Learned
Positional
Embedding编码，位置之间没有约束关系，我们只能期待它隐式地学到，是否有更合理的方法能够显示的让模型理解位置的相对关系呢？见后：</p>
<h3 id="三相对位置编码-rpe">三、相对位置编码 RPE：</h3>
<p>​ 在Swin
Transformer中，使用的就是相对位置编码，使用绝对位置编码，不同位置对应的positional
embedding固然不同，但是位置1和位置2的距离比位置3和位置10的距离更近，位置1和位置2与位置3和位置4都只相差1，这些关于位置的相对含义模型能够通过绝对位置编码get到吗？并不太行。</p>
<p>​ 在Swin
Transformer中，这种相对位置编码在计算Attention的时候进行应用：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115120718204.png" /></p>
<p>​
相对位置偏差是怎么确定的呢？如下所示，假设我们的特征图是左侧的2*2的格子，下方是我们熟知的绝对位置索引，相对位置索引如右侧上面一排所示，其实就是当前计算格子的绝对位置索引减去其他格子的绝对位置索引。然后将四个像素的相对位置索引展开后拼接在一起形成一个新的矩阵。这个矩阵就是二维的相对位置索引矩阵。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/iiioio.png" />
在作者的源码中，其使用的是1维的的相对位置索引矩阵，我们不能简单的将x,y相加，不然可能导致不同位置的相对位置索引一致，导致出现问题。所以作者在源码中经过了一个简单处理。我们先把所有的行列标加上M-1，然后再将行标乘2M-1，然后再将行列标相加，得到的矩阵。</p>
<p>​ 然后我们需要把Relative Position Index通过一张Bias
Table映射成relative position
bias才是用于计算Self-Attention最终用于计算的Bias值，也就是公式里的矩阵B。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115120814669.png" /></p>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Basic系列笔记</category>
      </categories>
      <tags>
        <tag>Position Encoding</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习基础系列笔记17——常见的Loss损失函数整理</title>
    <url>/2022/02/11/a5a0c2a08899/</url>
    <content><![CDATA[<h3
id="一多类别分类任务常用损失信息熵交叉熵相对熵的概念与应用">一、多类别分类任务常用损失：信息熵、交叉熵、相对熵的概念与应用</h3>
<h4 id="信息熵">1、信息熵</h4>
<ol type="1">
<li>随机变量 <span class="math inline">\(x\)</span> 的自信息
(self-information)，描述的是随机变量的某个事件发生所带来的信息量。</li>
</ol>
<p>​ <span class="math inline">\(I(x) = -log(p(x))\)</span></p>
<ol start="2" type="1">
<li><strong>信息熵</strong>即所有信息量的期望,其中<span
class="math inline">\(n\)</span>为事件的所有可能性。</li>
</ol>
<figure>
<img
src="https://www.zhihu.com/equation?tex=H%28X%29%3D%E2%88%92%E2%88%91_xp%28x%29log%28p%28x%29%29%3D%E2%88%92%E2%88%91_%7Bi%3D1%7D%5Enp%28x_i%29log%28p%28x_i%29%29"
alt="[公式]" />
<figcaption aria-hidden="true">[公式]</figcaption>
</figure>
<h4 id="相对熵">2、相对熵</h4>
<p>​ KL散度，如果对于同一个随机变量x有两个单独的概率分布 <span
class="math inline">\(p(x)\)</span>和 <span
class="math inline">\(q(x)\)</span>，可以使用相对熵来衡量这两个分布的差异。</p>
<figure>
<img
src="https://www.zhihu.com/equation?tex=D_%7BKL%7D%28p%7C%7Cq%29%3D%5Csum_%7Bi%3D1%7D%5Enp%28x_i%29log%28%5Cfrac%7Bp%28x_i%29%7D%7Bq%28x_i%29%7D%29"
alt="[公式]" />
<figcaption aria-hidden="true">[公式]</figcaption>
</figure>
<p>​
K-L散度其实是<strong>数据的原始分布p和近似分布q之间的对数差值的期望</strong>。</p>
<p>​ K-L散度<strong>并非距离，其不满足对称性</strong>，即 $D_{KL}(p||q) $
<span class="math inline">\(!=\)</span> $D_{KL}(q||p) $</p>
<h4 id="交叉熵">3、交叉熵：</h4>
<figure>
<img
src="https://www.zhihu.com/equation?tex=H%28p%2Cq%29%3D-%5Csum_%7Bi%3D1%7D%5Enp%28x_i%29log%28q%28x_i%29%29"
alt="[公式]" />
<figcaption aria-hidden="true">[公式]</figcaption>
</figure>
<p>​ 在机器学习中，往往用 <span class="math inline">\(p(x)\)</span>
用来描述<strong>真实分布</strong>， <span
class="math inline">\(q(x)\)</span>
用来描述模型<strong>预测的分布</strong>。</p>
<p>​
计算损失，理应使用相对熵来计算概率分布的差异，然而由相对熵推导出的结果看：</p>
<p>​ 由于信息熵描述的是消除 p (即真实分布)
的不确定性所需信息量的度量，所以其值应该是最小的、固定的。那么：<strong>优化相对熵也就是优化交叉熵，所以在机器学习中使用交叉熵就可以了</strong></p>
<h4 id="为什么使用交叉熵">4、为什么使用交叉熵：</h4>
<p>​
在机器学习中，我们希望模型在训练数据上学到的<strong>预测数据分布</strong>与<strong>真实数据分布</strong>越相近越好，上面讲过了，用相对熵，但是为了简便计算使用交叉熵就可以了。</p>
<p>在二分类中，交叉熵损失函数如下：<span
class="math inline">\(y\)</span>是实际标签，<span
class="math inline">\(\hat y\)</span>
是预测值z经过sigmoid函数之后的预测概率。</p>
<figure>
<img
src="https://www.zhihu.com/equation?tex=L%3D-%5Bylog+\hat+y%2B(1-y)log+(1-\hat+y)%5D"
alt="[公式]" />
<figcaption aria-hidden="true">[公式]</figcaption>
</figure>
<p>Sigmoid函数如下：</p>
<figure>
<img
src="https://www.zhihu.com/equation?tex=\sigma(z)+%3D+\frac%7B1%7D%7B1%2Be%5E%7B-z%7D%7D"
alt="[公式]" />
<figcaption aria-hidden="true">[公式]</figcaption>
</figure>
<p>​
交叉熵损失函数一般用来代替均方差损失函数与sigmoid激活函数的组合：对于sigmoid函数，当
<span class="math inline">\(x\)</span>
的取值越大或越小，函数曲线变得越平缓，意味着导数<span
class="math inline">\(\sigma(x)&#39;\)</span>
越趋近于0。以单个样本的梯度下降为例子：</p>
<figure>
<img src="https://www.zhihu.com/equation?tex=z%3D+wx%2Bb"
alt="[公式]" />
<figcaption aria-hidden="true">[公式]</figcaption>
</figure>
<figure>
<img
src="https://www.zhihu.com/equation?tex=\hat%7By%7D%3D+a+%3D\sigma(z)"
alt="[公式]" />
<figcaption aria-hidden="true">[公式]</figcaption>
</figure>
<figure>
<img
src="https://www.zhihu.com/equation?tex=L_1(y%2Ca)%3D\frac%7B1%7D%7B2%7D(y-a)%5E2"
alt="[公式]" />
<figcaption aria-hidden="true">[公式]</figcaption>
</figure>
<figure>
<img
src="https://www.zhihu.com/equation?tex=L_2%28y%2Ca%29%3D-%28ylog%28a%29%2B%281-y%29log%281-a%29%29"
alt="[公式]" />
<figcaption aria-hidden="true">[公式]</figcaption>
</figure>
<p>​
前两个公式是前向传播过程中线性的部分，和非线性的部分。L1是MSE损失函数，L2是交叉熵损失函数。然后我们分别用L1和L2对参数w和b，利用链式法则求解梯度。</p>
<figure>
<img
src="https://www.zhihu.com/equation?tex=\frac%7B\partial+L_1(y%2Ca)%7D%7B\partial+w%7D%3D-%7Cy-\sigma(z)%7C\sigma&#39;(z)x"
alt="[公式]" />
<figcaption aria-hidden="true">[公式]</figcaption>
</figure>
<figure>
<img
src="https://www.zhihu.com/equation?tex=\frac%7B\partial+L_1(y%2Ca)%7D%7B\partial+b%7D%3D-%7Cy-\sigma(z)%7C\sigma&#39;(z)"
alt="[公式]" />
<figcaption aria-hidden="true">[公式]</figcaption>
</figure>
<figure>
<img
src="https://www.zhihu.com/equation?tex=\frac%7B\partial+L_2(y%2Ca)%7D%7B\partial+w%7D%3Dx%5B\sigma(z)-y%5D"
alt="[公式]" />
<figcaption aria-hidden="true">[公式]</figcaption>
</figure>
<figure>
<img
src="https://www.zhihu.com/equation?tex=\frac%7B\partial+L_2(y%2Ca)%7D%7B\partial+b%7D%3D\sigma(z)-y"
alt="[公式]" />
<figcaption aria-hidden="true">[公式]</figcaption>
</figure>
<p>​
可以看出，<strong>均方差</strong>对参数的偏导的结果都<strong>乘了sigmoid的导数</strong>
<span class="math inline">\(\sigma(z)&#39;\)</span>
，而之前看图发现sigmoid导数在其变量值很大或很小时趋近于0，所以偏导数很有可能接近于0。反观<strong>交叉熵</strong>对参数的偏导就<strong>没有sigmoid导数</strong>，所以不存在这个问题。<strong>这就是选择交叉熵而不选择均方差的原因。</strong></p>
<p><strong>分类任务的学习过程：</strong></p>
<p>​
用神经网络最后一层输出的情况，来看一眼整个模型预测、获得损失和学习的流程：</p>
<ol type="1">
<li>神经网络最后一层得到每个类别的得分<strong>scores（也叫logits）</strong>；</li>
<li>该得分经过<strong>sigmoid(或softmax)函数</strong>获得概率输出；</li>
<li>模型预测的类别概率输出与真实类别的one
hot形式进行交叉熵损失函数的计算。</li>
</ol>
<h3 id="二多标签分类任务">二、多标签分类任务：</h3>
<p>​
在多标签分类任务中，一般采用<strong>sigmoid</strong>作为输出层的激活函数，使用
binary_crossentropy（二分类交叉熵损失函数）作为损失函数. <span
class="math display">\[
\sigma(x) = \frac{1}{1 + e^{-x}}
\]</span> ​ 其中<span class="math inline">\(a\)</span>表示使用 sigmoid
函数激活输出层对应的神经元，<strong>此时最后一层的输出就不能看成一个分布了，因为加起来不为
1，现在把输出层每个神经元看作是一个二项分布，
这相当于将一个多标签问题转化为了在每个标签上的二分类问题。</strong></p>
<p>​ <img
src="https://www.zhihu.com/equation?tex=L_2(y%2Ca)%3D-(ylog(a)%2B(1-y)log(1-a))"
alt="[公式]" /></p>
<p>​ 计算一个样本各个标签的损失，然后取平均值，得到最后的损失。</p>
<h3 id="三回归任务常用损失">三、回归任务常用损失：</h3>
<h4 id="l1-loss-平均绝对误差">1、L1 Loss 平均绝对误差</h4>
<p>​ <strong>目标变量和预测变量之间绝对差值之和</strong></p>
<p>​ MAE曲线连续，但是在<em>y</em>−<em>f</em>(<em>x</em>)=0处不可导。而且
MAE
大部分情况下梯度都是相等的，这意味着即使对于小的损失值，其梯度也是大的。这不利于函数的收敛和模型的学习。但是，无论对于什么样的输入值，都有着稳定的梯度，不会导致梯度爆炸问题，具有较为稳健性的解。</p>
<p>​
MAE有个优点就是，对于离群点不那么敏感。因为MAE计算的是误差<em>y</em>−<em>f</em>(<em>x</em>)
的绝对值，对于任意大小的差值，其惩罚都是固定的。<strong>针对带有离群点的数据，MAE的效果要好于MSE。</strong></p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_12_11_35_15_642.png" style="zoom:50%;" /></p>
<h4 id="l2-loss-均方误差mse">3、L2 Loss 均方误差MSE</h4>
<p>​
MSE的函数曲线光滑、连续，处处可导，便于使用梯度下降算法，是一种常用的损失函数。
而且，随着误差的减小，梯度也在减小，这有利于收敛，即使使用固定的学习速率，也能较快的收敛到最小值。</p>
<p>​ 当<span class="math inline">\(y\)</span>和<span
class="math inline">\(f(x)\)</span>也就是真实值和预测值的差值大于1时，会放大误差；而当差值小于1时，则会缩小误差，这是平方运算决定的。MSE对于较大的误差（&gt;1）给予较大的惩罚，较小的误差（&lt;1）给予较小的惩罚。也就是说，<strong>对离群点比较敏感，受其影响较大。</strong></p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_12_11_35_12_56.png" style="zoom:50%;" /></p>
<h4 id="smooth-l1-loss">3、Smooth L1 Loss</h4>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_12_12_04_33_822.png" style="zoom: 50%;" /></p>
<p>​
从下图种中可以看出，该函数实际是一个分段函数，既解决了L1不光滑的问题，也解决了L2容易产生梯度爆炸的问题。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_12_12_05_00_718.png" style="zoom:50%;" /></p>
<p><strong>Smooth L1的优点</strong></p>
<ul>
<li>相比于L1损失函数，可以收敛得更快。</li>
<li>相比于L2损失函数，对离群点、异常值不敏感，梯度变化相对更小，训练时不容易跑飞。</li>
</ul>
<p><strong>参考：</strong></p>
<p>https://zhuanlan.zhihu.com/p/35709485</p>
<p>https://www.zhihu.com/question/336677048/answer/761385679</p>
<p>https://www.cnblogs.com/wangguchangqing/p/12021638.html</p>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Basic系列笔记</category>
      </categories>
      <tags>
        <tag>Loss Function</tag>
      </tags>
  </entry>
  <entry>
    <title>博文复习日志1</title>
    <url>/2022/02/11/de2db590f015/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="510eea55a138ddcfaa7527f655548aaa2fe2db09ca94499a108f39697717d0e2">0b64cd3abe5b0a0a039a37d86c66d75eaeb9cde5c6dadc3c6d4d424e956e68e5859de93c067c256c245d75df485065102f6e2903c24acc225d3947c06b46eb863dd4b5852f98aab38803012f003c6c5ce6fff79afb10e1792ca7214d925987e0c717d406814885b789fb91e2e91f62e79489c1eb338c6615f677769d830ccf190fb9bbb686abd703322115c45664a457c7196ebc5128f0dbc61fa90adc2470af75105015c70e866cf9e65b8431b286f91724aada9a9fd5965d62719e3af60032aa7a2f77ed452eac7ab39f33c601c5d6de7df46cb4de25570ccbf95f141c0967a7b34c72683919d199358e5f05f83fc8af0d4a187180a67e0dfe958e0af9d66d33ab8d086e02df177e615e8042752039b5aa8ebbbf03fd595157a16f93e9d8aa7f0b856ccb5a1ec0ac5a77b1362d12bdc9c4ff39d2127ba4fa1a34736ed266b04fafccd0a982584b7e617ef2c7abee5c2cc4fbc96fa0391fe18bb0613a55fbdf669e91b681e570f01a34cd9e83067c84610cd0b34a48d675bcea762f0ae2ffdc3f3c513c6c7b618e16d08072651ad57ab1f24229ef211069fb21f88763d652ad1c34e048bc1f0ebc1ec29fb005a9ff0b02c6514c5903c63507ab30dc113c45c52d85ab6eb261bd57f2409a2b268dde3bd908f5195e3dbae14f58c038feffa9573febbff48309bb68ca7ef9866514f3bed93ee17a8eb8541fd909e71c9ed14c7aff0002dce95e6e3e1c35cc9944e3f52f289db4d9edfad48c297672d13a67000ac344cc7e43dbab585aa36eb271d0f2676f323a77210618bbbcbbe77036b202ad3557a478b20bf1d957c11bf1f4755a670d328e354cf9a7b8d1f7be8bd2af133e7818646806fa1b26642b878905ab6006b5d9fed921becfdcf7fcb711e0e9e01718cc6968a1ed0a24ad7f1e86fdbd3772cb0136199ae59835fea1bed728e7cb936edebd10b4e5de66928aaf6d24769ee34fb0f636c6a01cd5abfdddf11e9787c3ea134ce3c2f7ea34e481864c730aebe7cdf8c2c038a8a6b7dbdf9d7a274cb6caabd213fa36facc846b81a4373eca73b54d52adea63fbab125d2ebfc4ed828a7209dd043f764c9fe9d8303d85aca6a8980113479cb9199a87b029e2ed40da4a3bf3de90bfa1aa3c8f8302b71d9724793627f062846c54cce0de7388f11c3c14f8409cb15170d03d7a926b3bbec814d6271b4311dd68d5dc672ce65b660a299fb7f585540a3cc25ae8d3f38b813b41b7be646ff6d5c8cc3fc83530a636d1f1777069213f38668c754c4519a739c146b979221042759ce9e2d49738007fb30c0b835235d81f300001f0dfcd032974170d531d242371217636480fcc486c1fab1b415046c0823ff1d13f75dea0b25d121549fe5c852522d8deaf1a215523c79867303c9585c3bcb4316ba2d273b3b82cc07ed305f2c0ffdd6f9b21ad4e1fb537eb4256b0ad0b2fe5becb1430f8ac70a4c989205eba642055b9ad2722300eb1d66574140ecfe0158f0a659638a2bac74f1b58a0fec425ed37923567a1d8debeef1b7a8b0396bfd1249b0d8382c6bae1cc1623f30ef62b1bacc5f6a7852a8997fa35e460e1cd99bd2929c858767c47a1ad9fabd0e84195caea1cfa378e7446b8cac82dc2194bc803aebb59c149f0a390f11b5c7038d9899e8d988e1cebf9ea708c4d70a941d07bd7079db953245cab2d77e73fc61f561659c49be685be08c3f345dc642169b4057cd09b8371d4113017e7e7a24bbcd7a10f9a3f30ab73d1fdf38eb3a6ee7b421e57ced7d390e62f09c79a5e31df52bae6dc6d11d9bf9d2ce85ba980acd276df21adeb0b278494f2f4fb14d02a126fe2ea8e9881939d022817a5a11e52e7d7f7e7ac4d31bee1458b9bd0f5e30803fbf094951af3a9ed088d92606512f845800ada2e863ef0eef8289a4d274431aff1c5bb72efd3813da6b7a1b6f7945ad86b2ad0359bad468a33b743c620d0a3a1714ba5abaec0527e6186ca1928d86831ef3c1115894fe3a4cc3b465f18fc101e24da8bced645a36ab666e50e6dcf8419e7eb17007966a07081ec298f5a7f33031a07f0bf3a8b86c62896af6a4f8b7d44352f7c934ff948d48be2ceb36a8effb5145673e9f79c91bfe6c7034bbe8b123d8763a83307a9b0e3eb84db5ab7de79fd4ac8dd3d97035408dcf0b53b9c8ab429582600c17cd4cb1ac25bffcfd54200c54b0546dac30031640fd18b61541fab8b2a3d2dce9201b529753ab3a3c19f05780b173b332dd0d095e58590f87e31841e32cfa7c5c3c2b7a372c99a2273d9b249fa004d08835a5856e1d96d68952b88d7caa4bfb0490b9a9c803c40102ace5b9f962acb9e800e353ff558476666bf2134ca3377a9fb41f6f51663b6e24c2e87cb8c7b32f688f60120e29bffb497ccbebdf92613427d50fe4eaced4f16340c63fb8274607d07bd242d7ff76062020145f6eb5021a6ec77719945a8b5f5f79e2e9a02d8296ed824a5d8b61a9ebdfdbe70a984bab86da09a6c1e062657b062f93d4d01fd64a96bdba437d7cc9508f3fdcdf5492ea243c61286a94aebe4a29c6f50e33c31def76e68705a614c1c5fd41954ae56a2b1538ab2513140e8d7dc7d1ec68f315c8ae3d7c1430c232b90c0485a398328ce8bc18c008fea0d1997a2ffeeeb472172d96e31d4bc50544e8f70d49dcb14239b18a0ce8187653f25ab568794df9d071352ad02f5efccc8dc835b6c680812f29566f3a7aca77bbb099bb75ae9bc79eb8a5112c7451e84f1cb4f7d1778e17fa8428d27eed9aa609c38f8eb8ee74fb2361a1ce207b1520074ebbaa74a29f5dbbff9aa9b982480f09cf722d4a417aad58257ca58863ec8ec6408dd8648e4bab954050bba11ec88c14b72810b3506acc6ee2e40fe787f8e2811625ec33de6e8d358493730a3cad081232a89c1287f23fa3a057970cb729dc3f481490bf055e5c5a7217863ecfb6124ef2fc4c29900fee3339fb2db6220020cf41702d030d72b51830c714117f1fb113908c3797cad2a31bb8689fa23e35abe41165206b4e680c246eb0ce133e1ee296018ef45dee04d9619ef335705d32dd73434bfc914a2b3973902cafd1ba2b7072b9ccaa8ad5dedc2d415003724fcd1ef9e0908c9b6c5a14c08af1b2cc4da694ea47ccc1cc1551e52f57d2a6a25a5bbebd7513c9158e05a1cc814a2f5baac9da21901a5e02ce643594bf2c0bd17c6057e81aff12070e8683dada0b33153587511077d0c99bcc7c805c993da667e133247a752cf1f69686b502a4e0029247bf9f6671bc88a65b846cb505e11b9d7d9fbb26bba3e9864a2e66ce9df357da60789e99e44f2bfdb4d19912c4f1e622bd072e8ece534a2eb12e98905e7674ff3b9cf286d9aac52fdef6438ee316d97dc36c80b59520903d7674a9db47a25c3ef958d10d6045bcdad0223021f1f43564411bcba78d6917376189fe1b04f853e9a09c9a27db34f01316c6aa399db0e83879ba9b3736200247690ee42ed29c62e719059348ee21cab2c88ecc5a1637dc1a13a146ad5ce4eb45c97c5a2f47099d7bc87d59c32f7bba580f7024c3620844a79bf4fc0a71433d5f78a5796cc1644f6aa18173f00574d99599ab23821230e656c800976d2b6b2bfb5f2fdd2b7d03099904bf014a7dc52c25a9b66ca7372aed5334888994c73e066c03eb0b474f8cf1cb7c600699a0d3066bfe796acb42a66637d3cbd3d3ed279872bf573e3d4607e4c6abd0cb2679fba8f38b307d734742c53e962131770637534ac3995cb61cc48d729c89f14009ed2f417e823cbffa2fc56110c7444200335535b93fb87378c1c066dbabb362faddf42469a3de3fe4c758b0ddca98c4b5f6861084178b02165981415148dfb5188cd2a7660075343ddb0fbda94e9799e67eb81e73c4228792766626158f70a0d3d3f1a99cc58aacea149f915a587882fbd4581d600b7a1161da017a0d43e104315582c2b5fa933582974dfb152a988d4fe5e8977bca460bc7d2606d54a15cca0ad4e8a6b0506806d31d530d2beb9aa99736cfe40e0617ae4fad7a819d39b35dc8336fc9e1b062dd9d1151b52662f3679f3f75fdc00338ee9a67530a00476d097a144eafddc6d3d65298e3ccedf0cb7d810c224b035719d50f6ec52be5efeca3904ab35f95d93c7f98c63eee85e97a0467e7167ff9bbf9902f43e41ba789fcc226e48fa1edf2c76f4afd47ff178ddc52691d3b5124c3cc2adb2f158e1e3e12931fe97cb94eac39fcd99684e042bf5f4842c67029e961be42100c9d0d588dab0cfabb1967a55792204b4e32cd5cb3b8607061e0a30f4d1d97c2fe200ad3488dc069f92a8e36c874fe2d75e52ae5470c537cf6c689f39c1c68f16b853b14f817559a2cfd009eda941896b0dc763b7432f866e40cd92719e62127790c4701d5220cb5e9ca76ce00c935923e0aa96a25930d40fff980a9aad6f412df6348e11fc021c3e13705d7b400a80279263a85cea7d872e700bfcae563c0dae8ed03cfd89116d053716279a48d5989a9cf2684f8c47e3d8012a2e915448d3278acd5404f45d7aea96c6c7c7913c4123ba2392ed493d174ca3e9ac1c2c25221967f4e08920e26ed9385ae3ad52c38b521bf5f8c5d56c89facc98096448242034a16a15e78e131ea1fd65f80f685d96b42daf8771d089efd0e5cdb3bba887728812d09e8f5938f93278a1d3a930857e1d34f6ac92efa30cdbf4346958c33d7c2db9ec2bf449f1591d9b17d2fe4f898dad4c22057bf1660e253e6640ba1ded3ff3d3f8c73891a9c24ede191fcd77f0d69488661d6fe48dd4a2ec1306a61a7e0deac9140e293569308971882c7564234a9cfb4f20bf76a49ee2c216b146a36fc502136901e9bbab73f8ac76612d4a446967ebfbd89dd3bd08afbcb662096cc02c7b938069d1f4ecf30da93e3696645fbe895032e6f47f7f42cfd790e6eb4d0c18ef6ef8617a7ff0917b7851e0325b0cc15acb5f884332e15593679478bbab283ddafa64cdddf5c025cf548319f6b81f1f045993a5c85f17728482fad39f233981ebcfce0b7d779924179787640afdc669b5a91ccfc5b0153dfdabbe5d34e947a4a081f58e52a91c2d5dcbc686b2a8cfcc8970c6ce66f67f42446e75bc7c296190e2fd7b038588da20d9713b011ef24294bd4cbc2cccb5f852a570709c3622b8536bd28998058aec29f351d623b6f2ade8b01c915cd2caccb21711ed89e76c5c56d63a2191567c6a136fb63d9825c37f47fee8ea4d3f071fb23f1b8357ce4b78f52f635aa77e475001da56d03de8f76d53c4f02ac804522fcc606b6d07585a483feb379172e75806205b2c3e4b8bc5c4d026a0258adec1bb1b49e2bce71e25199d854f78acf2a50b963179be149508b95fb98f2e72ffa567e96f6ca31a11c0d242a038249b3e6e17d64d200540b92db22bd94daa61c9a545560d24f831a861bcfac0608af37b663f014979a4410d5b8a2291e18db418d7d600a30e077117a2620a78950fd970923117cd676ca85f5281035f0c2484b4b7693dcd5c45447b3a87ba6889a69d6babf81a6ec5985dce5773492f18cf50d5c65847fd4315393d932ca3751a53870c9e5cbc0a9b05c7464a1130ea6701f056a22ebd79b5b2e6e51409ba767eaccb368a3908318c2be547468d0d0dba068362c9a16d1210c294139854204948637637ebc475775ace6a8beb2771d5c763aab6efaf6a6aaaa6d50e299681b0b72bf7278c054a1f1e05f409845ad445fe6712c52e81abf15f1acc0c3dd768b936f9b15776d824d64a03f259d49bdf8fc2806cc9d2e311a2a66dd7331620f77f6a92c95132b4ff0ba1d190270ac2b282bf97870a545f0fd1afd42016241b72dd2fe91de01ff8b7b627a32d57df858168bcbd51099ad3b03a72bf82d6f8c54f0387105f6c50c1fdd430b185fcee5f9f78a43d46f2f529523a94885955a490aba8700c6403bf6026976ee87bc351cb2e3029f6ee5849f6c3e6f2bececba8629ec503c6dae4d717ceffd5a54f099d38ea818719026570cb62edd0ae0c040af7852401ca74b04b6b84dc3ad3c66dd94216845840957fb6af2d16596b02017929c0ae609752e29039081c44c0395e68fbde8b661288a643dd20b52b57ca5a35352fd5c69d56bdefef8cd26db5224f7023f68ec7261564f1aaf41d264e7743b993b40fb15ae21cf764f0afe7235facc1f45b1a81d2ebf6c2d556f41394b93b3abc0ea633a02dbdcbaf99d884f5ec8bcc5095fb98f0fffaece2bf462f4e66a5414085fe86dac5a11f745a911443b2539595a338e9584295b2243d6c2228170c753bd5c207c5f0a217cec293393c3ac623dda61532e37cbdd6d30169bf9e5d62e9253ecb5fcc26422ecb0fbfe1a520e6f3e1bda0139ae59656be95a2add3fb795989eb68f4ad6957b7348e003b3da4359cc09f3ed5e871c34da8d89049d07d44381b4f91567ea4f13016513b01f77e1cf45c0bb50c9b5796dbb1c6bef7d161870c06ee5978abf9236cb7afe6cdd24443269314db877b7a33822fb9f28e97db47e3d39eafc923726cb0eae3ea2c05b4aac7cf81d75eb98e51d571e3c02ce778f731bac5070dff5adf5cd0acd92bbe5495a717e05cd7a8587d08342a8a43b8dfecf051d89ee357ad1bc5de21d0b317b1e16252d620c698a993f36a294f72cf27543208d0cfd505fb67dcca69b01aa9f0549ee8799108330230c8b7b6509e14460ecd0be180dcfba5923b3f1bf86b0e963efac6b97eb7c3207e830f2e29d31ed63f410a13b75ef6db5e497219dfadc7479c07f76792074d9fd5c9f04a0098ffaebd565e751c553ef11c069e64788ec35843c105f51488cc9bd295488988f803e4da77f50b52dab4007f995f3c072ac8561a798d771db01b18c3108ca3709bbde9a8f0f0e38617e24f7892ae7f7e0ca60c00a2fdbb40c037e859ae15fcdbe6d8abe3fb8a1d04106209e268c423c4e21320b81a08495399a6ea89a88cdd55fd1d13d1b9df14896d2349e1cfce610d88820e9d00bcfbdf5f814832e9bff21cbfa8761f6c334e5488184dddf9c495ae7aa2abd22b22fdf44114992b3e57a6b1ebaccbd3c4a455fadeaf23b603b0428a6aee9aebb24f36995c9fe6f7b584f061122254aadabc139ad21a385421c748d57f3d0b2ff9d1b482fe42b7fc373c135f1da2ca8abc8b8e474cf5dcc52278a67bd119463b546eeb85d53bf318e50067111be34bd12101c82c6081c9ff529bfdf34a82ad12113a18b98f97eb21717779875cec7a17e61c2f59ba7a70fbbe2fe6d1b6b84bca0cc6a78caaf365f90df71186a7721a988e1b24346c5963c3cf006b5e379494046300cece890a87e4182834ce8521d859fcb65b9aaa572958730bc31720b5b20fa30a10c2cddc88f0c89a410b72a69d8a9282bbc0ab5ce5bedd75a6a1a780a02b1f299f496e83cb40811e0641b0eb2392cd014a4bae063b7294d1a849908caf1c37af3f09c29ea1506abfb340ea1b6f36a0cd3795bbe81b9b3bb361bd146b15612eeec1d086053894ef48662c13dd6e70da8bb5c811bc06ca92224e68745f7c10d329bfce33c1e968ff6a266d5091f07d21458691399b5068fb8e75106f48e373d66b401d777f1290d73c64cd39e99373a808d7c0844adbbfcd9fcbb684d2f0382992fdf9e2cf358fd0bd0d5891333aae35a8736cfd3fa60f2d27cc40ffb2ce4e0c90353aebc7f47cfa614ee3a6e99fe7e3becb7c7f205d49d9fdf811ef160f3965f5915c16ebb884de6d1f4d0f989da62612569e3617df2deaa5cb2bf4239a40adbcf78d33899f728f1dd27f5f2490625fee178236a60ba37ba7416c9e26b2af133f59911f45acf2ce979bbd4bac2d10126f5aa0a0b27ed18899664b0061760dff5806eb08abb3632126cd0b7a3e41eae9d28fe413ce227da923851eb34c4f3092a5f56d12a777b8e06cf8323a0233032314ccd75c3f27a701c0d548b75b52c2827c3bdc25ea03be44073370a81df9c545664719df8b8628ead9134403290b84b4a7eb30baf0af7934783325bbcd6ffeb0fe93ad93f36ee9bc3a7046b09c3bf0be7d33b700fa9daca63dcaf6a4f4c5d40a294efc2c8c6c89206f82ec023614e7ea41a7e2754933cade8679ab072f520ce6d174e18f40e62d8a622bd288206debcb0a59191e5296705739c478c01841cf6fe7ae03e6380b78c46e8e63254d230ddac885ab5115b7794bff2f04814ded973f15d087e137bcab7951cf86b6af8e1d4cf40fb01089f195f8da31bd0123d9fd20db8d19718481b292d125d90c6dedeb92d1f0c1cbb300e624024fd5bfd9b572492e37ab365412c4b489789ccc588a60704326408241c87c389bbfaeefe4718bdd7429e28295789a8eda580b5b04e9335a8c8d96fc41b48bdb0fdf2ba9f744cf8c321aaab68db506572c4b12bb23f17cdd5a0112cd2620db356d6b4b8e8c5875e6c1492354a5d958b474ee663f649b218a6be1f7c657c680467e28ac6e24942d3b883a1a72f68799df0eda486c5fc7dc4a9aa7cde4697041fd6b9e2b2223b82af3a6d056dc62d016f43d1c5e17afd0a43fcd79388e43b60dc692b5573ef8711b3ffc1f41ce019ae75debe10a43a827c2bf6848aeba454b2e76be9ee25c1b8800f9f22f15c9cb428eb0d997fd52895098d13b73060dbb19e80b08899b85db50b75f447bbae5b705ecd56c7181cd0a72a2eb</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>⑪ 博文复习日志</category>
      </categories>
      <tags>
        <tag>Review</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习基础系列笔记16——常见的梯度下降优化器整理</title>
    <url>/2022/02/11/ced858ce48dc/</url>
    <content><![CDATA[<h4 id="一批量梯度下降法bgd">一、批量梯度下降法BGD：</h4>
<p>​
更新每一参数都用所有样本去进行更新，在下面例子中，总共有n个参数，m个样本，我们如果想要更新参数$
_j$
，就需要遍历所有的m个训练样本，然后将所有的梯度累加起来取平均，然后再进行更新。</p>
<p>​ <img
src="https://pic2.zhimg.com/80/v2-890e5ab2843f3b22467a5e6aeef58b59_720w.png" /></p>
<h4 id="二随机梯度下降法sgd">二、随机梯度下降法SGD：</h4>
<p>​
由于BGD每跟新一个参数的时候，要用到所有的样本数，所以训练速度会随着样本数量的增加而变得非常缓慢。随机梯度下降正是为了解决这个办法而提出的。它是<strong>利用每个样本的损失函数</strong>对θ求偏导得到对应的梯度，来更新θ：</p>
<p><img
src="https://pic1.zhimg.com/80/v2-65566b643790ca6c89919fd970f34e2c_720w.png" /></p>
<p>​
随机梯度下降是通过每个样本来迭代更新一次，对比上面的批量梯度下降，迭代一次需要用到所有训练样本（<strong>往往如今真实问题训练数据都是非常巨大</strong>），一次迭代不可能最优，如果迭代10次的话就需要遍历训练样本10次。<strong>但是，SGD伴随的一个问题是噪音较BGD要多，使得SGD并不是每次迭代都向着整体最优化方向。</strong></p>
<p>​ 但是可以并行化计算。</p>
<h4
id="三min-batch小批量梯度下降法-mbgd">三、<strong>min-batch</strong>小批量梯度下降法
MBGD：</h4>
<p>​ 我们假设每次更新参数的时候用到的样本数为10个</p>
<p><img
src="https://pic2.zhimg.com/80/v2-9d473c89948f1ddc8c4f294c55123f59_720w.png" /></p>
<p>​
<strong>随机取batch个样本，</strong>而不是1个样本，然后对参数进行更新即可。</p>
<h4 id="四冲量优化器momentum">四、冲量优化器（Momentum）</h4>
<p>​ 在Gradient Descent +
Momentum的算法如下：最开始第一步和原来的一样，从<span
class="math inline">\(\theta^0\)</span>开始计算梯度，然后沿着梯度反方向移动下降，达到<span
class="math inline">\(\theta^1\)</span>时，此时和原先就会发生不同了，其现在的移动会结合前一步的movement（即<span
class="math inline">\(m^1\)</span>）以及当前点的梯度<span
class="math inline">\(g^1\)</span>，计算出一个新的下降方向<span
class="math inline">\(m^2\)</span>，然后进行更新。如图所示：<span
class="math inline">\(m^2\)</span>是由 <span
class="math inline">\(m^1\)</span>和 <span
class="math inline">\(-g^1\)</span>两个向量相加所得到的。从公式上来讲就是$m^1
- g^1 $，两者都有自己的参数，来控制影响整个梯度下降方向的比例。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114113022761.png" style="zoom:50%;" /></p>
<h4 id="五adagrad优化器auto-learning-rate">五、AdaGrad优化器（Auto
Learning Rate）</h4>
<p>​ 如果Loss函数在某个方向上比较平坦,梯度比较小，那么我们希望Learning
Rate比较大，快速的走过这一片平坦的区域。如果在某个方向上比较陡峭，我们希望Learning
Rate比较小.</p>
<p>​ 将原来的学习率η修改成 $ <span class="math inline">\(,
这个\)</span>_{it}$既跟参数相关又跟训练步骤（不同点所在的梯度）相关。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220121170754841.png" /></p>
<p>​
以下是σ的计算方式，通过计算每次更新得到的参数空间所在点的梯度的Norm值的平方的平均，即RMS来计算每步中σ。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114113547513.png" alt="image-20220114113547513" style="zoom:25%;" /></p>
<h4 id="六rmsprop优化器">六、RMSProp优化器</h4>
<p>​ <strong>AdaGrad的进阶版本：</strong></p>
<p>​
它在计算每一步的σ的时候，结合了上一步的σ以及该步的梯度g，同时还有一个超参数α，可以进行调整。如果我们调整α比较大的话，代表其参考当前的梯度较多，也就是说如果梯度突然产生较大变化，其就能快速的反应过来，对LearningRate进行快速的调整。相较于前RMS所有先前的梯度都平均权值考虑的做法，这一做法能够更快速的对梯度的变化进行响应。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114113634056.png" alt="image-20220114113634056" style="zoom:25%;" /></p>
<h4 id="七adam优化器">七、Adam优化器：</h4>
<p>​ 综合了RMSProp和Momentum技术的优化</p>
<p>​ Adam可以理解为加了Momentum 的 RMSprop</p>
<p><img
src="C:\Users\14012\Desktop\d50735fae6cd7b891692d4d0b34087a1d8330e56.jpeg" /></p>
<p>参考资料：https://zhuanlan.zhihu.com/p/25765735</p>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Basic系列笔记</category>
      </categories>
      <tags>
        <tag>Gradient Descent</tag>
        <tag>Optimizer</tag>
      </tags>
  </entry>
  <entry>
    <title>科研方法经验整理帖（待更新）</title>
    <url>/2022/02/11/47deca447e0d/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="52e0d6af68aa399f453af69bc8ee38d063a1c48e167e817e4e57135420d84aa4">0b64cd3abe5b0a0a039a37d86c66d75e6ec8e220ebc13f2625638343d94e3b654708d242507cfe6c32d1c8eaaeb7ce715ba6f5bf94402f27c710f076b984cdf666814bfd0feddd6bef4230c9b5fc5ef63e0abe1d8a0e076522fdf5d47543cb4a31cdb81d6f51075c9c431920495d752565dc8362a2dd4159a90cd1ddc842263881d6551575f2ddf84b0e16eae3070efee31f714363128f2ed57b4daf59d6993581f3d3e232d9f9e0e557255c6333fda79be78b77d10db6f09464976c5bc7fffba2524a64aa1aa741cdb2378fb38f145d7ce56e3d3d0854c256441055ac06c43f3a6478ea5f16ffba691bd8ff66ca371bfe48fb7166cc7b818aea63c9a77f0d9c6a8527a9d912e90bdb1e31a5bee8acf9af1e955e693460377f6d2937a35f54aef7260b4770e3418929728897786d982b27227b8565d377edf1686ff3d4941ef69929b9ed7ed143ab15b84f24c4a9f4499be4bcf618b113d9a1e8725628d5efe944fd49feabeb6bae8ca77f71f6cbcb597ae7aa7de63f64c306bb27737fa1de9601d194cfd19c8b9c2ddd4eb5d850715f733449606462b97e6ed11ec2d87eeb467531325b372b785ec61302fdec37595bb877fbe933b62dfd5042fcb8e48c7567ddefa9c1d58d4f2794d3f5fed7099d680e3d7aeba7ad8197f9bc9f8deacefcfe414a3e85ac4af741f7e1a7a4f17b78a02b69181a17d128000dd406bd69181fb5eb86d06efbd3dafe8548ac7d24288e2a04ff53740072ee4d8853fd2891bfcb560c20822c6e22932d1520e9f44eeb60d49f52068a95800e6baf3bd7c751eac99abf92d31f2a3ccf5e5c444f32e653728233734f63946e3c25048044e68b84cc1d041f08e88f35cdfe33217045fb9cb640337f5d920e2e968e8c62c7889c70607cbbab5bc6b156c122a1214246ff2b7d2f5c96a97a92ff76b639790f763d3536a76e4074250909d7973b68c949efabaa69d22a513a8fce553eb2b11b39b6257e9e25ea62b75da91193e40fc6e707c3eab91067238a239b0629e872da5b2b060cf3c439de3218741a5077089a37024a311745b8a73dbeddf49d44f5dd53a8529fb1d3a4ad13430e63c947b67146fe51461385de5c6d85534a8772019745d90059c564073ace9085d33e011d9161e76601d3bf98e4911b7b6b24ef29429166070ce2e51e310ce7c27ec786874fd9aaf27b405d9102605236c3c714a42aab6aadd8eb2013e3247050367d7bdd5423c0b93fc819f370a38720c5d54bf866d00bf35766734ab30a81f2810e78295704be3df366aeb5a59879728a9eb61ca49f9b9178c9a18c3b11af6d1a15f8681e4921d48bc6e9f39fcb71659434da686bfcf1b81446971bdfa6580774490b842c61e6edfa66f6ca757e76dfd45528e1e727a46456f48fb54feeeb989857db9b63c345c43780848ee61b71893a20f4b5064ea75229d0dcc4a449ef89a8053cd88e2a269f19b5edca3a470be909d49f88f4eb22b1a57f4b997f5d2e0e0ee073538e082b51144f3969b125bd57b386942ca8c1df2b3e8f0ee9b19739492246d084aa5ca2f5470a233b71c5aaaf9df3117b5adbed4023c989a0277e93a1f9ea2c26ec57bca927e160f093499757e5d1db2a138a8d7f20002babab72f0b0582d77258769292c370708a82566b62ca43cd0dda08cb8753f61fc91dc7e95f6ae61f6facf21347eb2956ee958a90c44f1958c73d02eb2dc00fc73d3dfa0aded237e174d7c1e1637ad9399987e7490e0ee9b370b96b3d9af61fc96f83b5d1d7b75838b972e0797bd216a4b1195d7cc6c9ab60e7cd9fe1a2b1c34ae558c822a95b8b541027fdec951ad1b8e926665fa1afc38ec68cd67777208dc32277fcd3b12affb5197552a91b46f57462b279a3aec5a9cfa92fa09900bc095bb76fc4c34c212f17401b6e877bb4f7d5d30fad9b0521ccade41a20da56daa07e854a644bbcd49ce2539aa64480b369862c17f14a9f37348108e58b89492409601ec4e06fa8beda7c62361cfe08755cbe8683c368a46fa1f4fc5f96fd8b5be33884a8cac3fdee4e314bb63c95d580ab30d0f6f52bb3da5f82a7eb639e28fc9e6756a71aed62f6211c8bbf877b0bc17904c5062d43db83fc95b824ba7d324d143f03e8149e320a65369b8f9f0b89c98fbdba572760fa6f085cdeb039d8b5aaf10059f4f186c86043bfc654870728ab1619cd8ac00f029fc7a73622841292a2c250efb1df17fc58c36eb9daa430cab4afd59c9c7776792df472689baec804b5444b16ac62fcf6b826fbb9d7fd273327e4583e19f6c11f1cf0bd8b9add833e73851b9336fbc585809e92900fab8b3545848e32316ee2a45ab7e479b0a808cf62cbb45e0893e2248ab362597cc1c78b409cfbbf110d980ab23d3d815e8a5b1ce315ef70b2697aa75eb77c304c8928df767132ade22ca354b76635e9af9737de79e1829fa36f433b403ea3e0144b297211523c9dc4b7fed9031cb34221ad77dea7a2fb75de29f605db0affb677388d60a596ac774efb4c64c72ebc103ad06b7b28f1e38b97f2366579ca285323f88dc013955c541528e1a8315937fa833d3ce5ce9ecac9b6b06a2b804d5cda780bfadd48fe647d2bc2e5b7e460d6a0c2a44814e65de03752e805c8ab5f376518da542d5238624739ba6c5cb258c6aefb46f06ceb4d052995ffb447f0d35baa493d691525e7c1465663f78a2375fcbf7e175f8431e3125fcce2b195dfe2ffe78665f6381ffc49f73a1f9f1d8a82f4533dc3f7bb02706dcce291c11f5bb7bee9860e378b6271c2d5d1f34cfd181a3392ce45a32c8f64bee70abfeb1f9bef6b17c2b6f6b6040edfad5aa99ae5981d0350e318ac973052be534b70961a6ecb548077bf38385a84d07a798c1bf90bb7d743598a18566b3ae52b591393571212ea32fd0340fc05fb2ad472d1b66b429b2324c524b60ea2623b1f6114d9ce4fc11245a5be0779e27dae8477b05c241f9dc2e348d25611249d1034ece36c99f0d736e9fd146b6a6023d882123b34d2a600a8f624cb5a6129fe2e5ba4006740006ab5b6e47388cfebb4f728febede6c0c421298406ee234437f93015690c6f65c7699fa9f60d23e09ab2a882456ebf7e35a3c003dadcbb93471e9c15a0ce2bd469a457fa6e0bbc2c8360342a598561e40c771cb287a457a2869201349a8dd31261c2b4e76fc399be0b9e59fc35a3d07ee1a6179ddb2368224376c476b230313ce36c6a5d5c35674b79118101c72b019b892e14ff3873fb2a06ba70076a649ced3d1c948d4bfe2efc2e5e3bac602f63f733750b6b48f9afe07105125ebfce3da84abcb55465ea73737f757056eb15be28aa4d7ca2c1b1086435ab5670bf9f3a6bd7ad401e26ab08bd2211295f7bdb90c3c85c34f23d1f5aa89131bc4941bea348cd8a69be403f95ecc82d2d9614e57fc2e3eacdaf7a7514994ac6358f1a4999d356bf4d0bbe95ea4dbfe6e44cd67538dfc035ea3f3540ecfbf22b4ad7a30f3a9143411c5b4121b4a8f52690e74404481f8b42a5adb8589c5a1e48ff0ca1bf2ac34553e7acb1f66a27f0762dab49b92921163c04c9dd62a4a54b40015e04727dd15008970f64ed1a8f3c124bb7296695565d917cc4eb7f7b750969ea32e81e4de494c9cfb87225099fb0cbb5299a9ad070d1585bfdd5ec1d4663d2f473e3fa734d28e903b83e7472ecde12430050e38ea247c6aca26b063e817763176ea7330035614bc8299982caea549f486cca66b09baefde932e42f6f8ececc91d7af5e5e464b962673ad75b04a85956caf4ffec3069e9177a92f0b198837044f1b76aa028d2e51c537b8ccf3c258cd68cc47cd94dd77947ab539f08fd31695636a11b9270fbb01aa20b9c22b5f04aeb53d4bcb1c9f43d66fe1bdd25e56526e38edfcb016f346deeb909b2196d0b3be023f8878473c87e4f8cb336c5a18618df315523d63b814ddfc7517ed68c1a0a6ab0fc8e77ec20a3669db530ba83aacb5eddd94e27e49603b46727945ce910085cdbace008120ac1115cbcb87b3e55c5bea65e9ebf709884b1ab6970ed9b0426e31c3910ddfb3b7c8bdf02e2d7d2aa60d2aac33e5976b69f30a27e1a67f3d7c9120c33d0b6d4369ceeab622156a3708b5a6fbca46c41f2acac1baaeb9f4025aa11bb13b28ea9f0f037a1243e94549e2952690f8f0c06e3606d0176ac407546dd65bbb81f223345fa333b98788e7d7f32d8b0b755e9a6111f5f10221985080b3adb426b7d3e8fff1118c69cc97ea7b8a6a157538d7b4b8c6f9f6605652928dd2d0ce5d10046f95404cd734b71fc7c9c19dead789ebdc5450b0c9ab9ba6738e435db1cecfd41f7f39186dcef08ca3f6eb49ecda2524a50c95e1dc7cb8a6771eb3f5aabc62c1a5bdc51f1efbabd1145ffa5bbc9429779a0714dda1be3b3989f59b45ecf7b580fe6010f5dd69918a16ba253eac16beb904481a9586d23a0cf00f9a6ca60d6999a7465e923bfb1c6c354c5bebfdf1cfcce3bd1fe919eaa5b66efbbc9e0e80932c3afa86972624560cd1008788f8917c8f7395109a4497ec73b9648512b5fd9270f8f60b40410c1ae521fadaebbf28867f5dbfa0b2131c2ee989a6c2b53336efd8dbc0577df5e9ab8fa1e55de2b5d0a06979fbf69362b03fadd72e98bd102d93364156092c3e7403754278a88f7b52133118f0c0446d38be2e2850ab1e4db56367f4ba717b772e74368b1df532dd3064c886f462e285cfa8424195f9ed8bf04058e181afdf76ee4c95d815bfe814a78bf8e1c9116da0bfe6fd04a3d891891ee2d6e21b9a5d62fae1cff6cb4b800dbd0f95570fa07668e3d6811916efffaceaa6c42fc4e36c9a5aff716c8ec7a0e72bcfa000f3d3457fa498d3d81c1362f5617cbb1e33c8ac489984aa35e63d1bee2e006c6bc68869279a267eae27ca6fa5b7e1b257243086d253fdbbd9b68c798882999e0aa458f51772ebd5bbe6e37c9850fa66b6345a1caf827a89be66b94f0db8981303a299ebc4cce3e8e3f5b354d6f47f04ebd4c51df0e044b06595905d47f46be57d5a94559ba91c362428c3f5c0108daf37dacd36457497b2e9966258e3e7950c49a3bd5e5af0d55860c620d7d3a14011c9af3195bedeae5008a9ed1a5636a2540c8e2c90e36d86caffe39c19f21a16ec3d6de93fe86951886d00e91271a2f0dc834c19a280e3cbbba8f49ba9db2898619851ec187a82a5392f7a69001c95c87c0df77a705d37f2cb246cb8e573acc5f13ad7acfea3f0048e844a881ba25318addd6d7e2c34b053d67902a3127d5c148f3127e5141d21b1aeeb0d44ac4110e602af90475ed6b6b7b7012649c67d00fc90739a1a2b9e2643f20084a5b551baa13dacb4b56808a4aec64e8173e035e988c199a5650257b8a3e08ce28b37df563eeb93d051755a638cb67daa7fd7fa34ae4c2a6133d3a7e91e6bd3508bfd20e6cb6790f803b0c5c61f4f0300d0ed11dda89abb14f83ab969a2b159f55c2a72dccce1017aa3d5710ac853ea33f7df9ad11c74a131f21c54b810f8021872f0e56014a555cbededd96a236f4c1ae0d5f698ef88ba62afc4e6f6d5c68684f0f653d43c0b67a738f6d2ed71d309b289e91451d31f41c1df78608df7b02b9c54f2f50c0494fe641ded850deed738e3fb3f73c59865581b41e085eec17decf2511b8df6b79d6530ebae77b8aab0521c87354e7231efaac7d268a772fe93c8e2f795864dcacb776a79f134739d7f8ad51c300cf7d0a0df77619fc4ca40cfc66c0a001948876f5ec52c3a69892c09361fb18659c073b5ba2b25324ce1ee51688d318d094134699469a8b5eeafd637ee260bdd703e3f8fab7faa0d83f6a174f29f15a0c95225dd042f28a7f6ca68f67420af7dd9a7378626327a3d98fd794540ae0afb7a5bc5685dac57c4dbfa68af9da564cc8ed432b78f4a6953e8a7d774d780c7e7fe21f152848f1fa1c77d301f6e2d87d9880f25e13f6ee130d023c61584f9b5677192f46701527c60aa4929123bd4ca485a926c38cad0161f68978afc56c4405308deb2bc08ef23e1349d50e0777760d6f57ddbc0ddd59a92b615089c9e058ea78c38a4358ddcb68ad43eebbd7a5c5afb2569cde2ed3e6900230bd352ad18a3a1606a8aac4e0925b4ffe0fd82be14bc0f6143b7b3d9898b819b4b463cfc2423a1101598f5df1f8f77cc45fe926658136ce5dd82b4263213fb6aef27c4490011ed01425f9c715dbb0f946618ed7a526a7058ed2f9ba7481f419817d03e5d23d72817235ff190f3fba32ca0666d9cf2b87345dae6e9c3a289a474954b3b3301ca6f706eabd84a1a409be753f1c70f52997ff429e87bc0c6f759d8fae675d9ace62de5dbeac10c2ea0069fbbc7d49f553e4607c0f54455e0039d37b9f79ec16d3bbc3dc7164c7849c8d35f1cc0f17ef3abb1f6db62b22384f6e9c50be7e85a2d528d014eb69e356a0453263e78dc39088c390875d304913b9e9b429d57a8c644b4a04f4c07e94403fa5edbe5e0052c101409691db34a76f198293130b0f192f06d3acb6af9bd57ee25d29f3768a8a72ec6a32fc777c72eac3db2b39219bbd542f3189ab6559a19d6c17813a622edcde574ef800140b0b2e3555d07c11d9c78d9cf169779dbd451eaa5fc5c50b7d8b3b55063ab715549d1bb37635d7cb5c0f1cf92a810b8bd6f3f7cf5b628da5b53ea6544409bb229658d6a4407021d5ce09ae3ec2b003f13c5856cdb780257a68c172d9ec7b16269afd6d32dd2b7e3bab38bf646edeeefa8cf0948019bedcb93a528bc0e8236ff8e7b784f85a477a99b4b3180ece736ed420071085fae12c5e7a1ce22dfbae57baf92bf14068033fcd6cfce1323d4144195ec9451445a71bb82acde57fd5f7397d1222ae96a2a0cb8a18359098846d50730dd6270479774d624b4edc97d68b05fe21756c92fcdcbf24241e0aac15460378d2468a5cb9b4a962d421f202a9ecee0404c0572a578f923f106385042c67be1db7d9218bfc59d8d6c9589e482f65c93d6a8dcb3d1d7905f94634c38056926bc13427b155a925a2695496f23139d3b5698e1a1c921927cf9c827887efe695b672588ff40b1a8e46b415c0a16c98844f272b32b2790b3ced41591653c5f41fa10022b56083d2844f62e19181e9bb59810c181e28451ad7ae99663cd11dce08c323006ae23e06a5d89a9e852e70a82948c68a3095c780b21a1e3ca480bf56dc90daf4b85e2d5165f5ae0bad84642f3abd51c695bc57e9de2487c6fd2148e183fb8454dc85a22a3b53c9bea05a51e77f10c0125cdebc8331187c1b42f97a31e4a074775709cb9b4362fbf5a289d1cb400236446170573858eb7ce5fec91fa799761a5405a21116c41a19cc0921faee1b340fadadfb38a4828c12db9ad285395b9eb89a1308956a2d65bd29b790eba11733e7f0c4671a30da0d08dbf16fd2645c4fa529b67ccbb7959b7b6bae22887e7301c8577232bdb61ab803caf1238600ccf88846d18ceef5b5ae3b271c12968575c17cd69d46d8ce594e40d2d77db7dae17e978578ac3aaf834132d53ed57332d6ebeac458f233eefeae1d0e9335f6e03f7968b504934b7fa2e53260f65c254183d7f54cd3f2e632d3cfba52cd6af0bd2359d83cbee5320a46b01cacd3bc8099c5937356da3f7e79f31820e0466dd9c84a4e7e94f3c73da3a481b67a26706897e6013d42ab4afc73dc94d220fa051b1f9413e68d3a1c5bd5392c9b1003eea3d8ab13504a597a63bf9fa5d90015d316998f65cc50366e3dd3389fea94499ee80f735f9b878d7444f12dec0e04cf8aed9c1ed415eac6d049dc8ce856f66ad5d8834f71052f46e5a8e0b16f72adf9fa62ea51d8676e1de674e2898f87ad9d4031956a0daab50fa8d10b9548fc6934ac99fea0e3b48a7c4eefd6668716666f799c2e992c555a2552694958a5ca8e12c97c1edced1c86053801414816798865b0af6edaab2c36e6f20477d92de1089b58d92f0ec0c6fee4ff6a0580978ef2e1b798b8d78e1b7132600f26885b5011bfaa373685e2699d97edfe571599563d14b17c035c13f2dfdce1700b006db3c5f7673750179193d5087e033a0ae98adaaa173b47bfa9b70a558ec9efc6ee473997eb3d1b3e7573c5dba2567325716050068058eff88a6a744eb99cf19845e8fb6e3f44fb4fb41fca36c16342bdef939b9ad4e50e2485038eb469e50bc375a22bb2eadef56d846abd97c4814cab978db4a38bfc7449031d404354b954e443e50ec614db5a81898cdc33bd3a8ac2794205000f851cdb86eeeb9b4a897135f7eafb36feb91c4d5d10acadc2d960210786a810eef7acac9becb4d68004776e636391f35678e9561ffcbe64535857c9e15d9a82b4ea7ae5283ce7f90802396244f4f0351ec1e005f50b94079269533559fba4342d416106dbb15d8cd557e236732027ec352b584bbe30c91e4e7e5d9e7936c8d83e3cdba18d98a425eeb8a0239a85735149eae6bd390231402cba08d03334d898c56bc89d87a3287eca112313e20f22ffb6db1f5d6f294fcbb4755fcc790b61926c0ab11cce0c77aea9f4d8e9069346f01f3dde291577378b35bcf9d2ccb9ae6a704581c2cf1f306ea040a04857b9277933cefaca68f82eaff21e8c540bcd9299b7a25046fb776da5b21f99067d88bc55d4aa550e25768f84ccc0a2e505d8bef729db697dc9fc11296d29bba8ebc4c8949a7b164ea7da0c4b0adc6a2022f24279a4250782a80db6cf5d8e8498bc637cafb00856dbad71d9eb76a0c18f866e63a34d7f64420990f442242ab6fe2b5b2ca605880a49d4195c5b7c9e5cf595f37a35bb4bc5ad930c7dda5dccdf2110552a47276f855baee4e5df5ed4334d7912f7b625bee246273ab452c88192667d9e69b41878b9a023b8bf7913042de6f0be3da076b4e8089b1a3ba60a313ae660e2ad25251c64b6e4836a6b59f7d412d772899b2fbf8ca5961d03d3fea3a54526c941920cb1caf559785bd719402589b542f91a1a7b1f7fdb4d0709e215863856d05c9a5544b8edd3719cb338e8c0386d3056dc2eb8eec628aab92be8173315949dd42eca89e9f5f536b7c3f11a176b17cc30140571c97fa7bf087eab44d438ccf246a11e59a280851e4b9623f6edefe8c52b65613ba8cb5daa292d85007fd49a7fd31ea29b2f69c1589c93bdf1cae5374ec0c18e39774185623efc0fe213a3867797070b458b98ccf5b2fddf0cb7381c6cdd4e233a4da9de7f25c5d49c38b1986a39b858f1540da8b9326a8da2acdad0326038b07b22277491427986947b67ce9322088179ef463f7cf0aae87019b42525b0db54ed8b0a05b77961ad55d0bedfecf576c703b6f112433d270ee561616ef1b2c07ae95ec221daf89c6b7b5079b0bac7791e8ab6a325cb2de12aa432cc9bb87b8e4cfae130f1afcfcf544eacc9725a5f9d61109a4caee45865eba5ae7f9328b1abf4e98f8</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>⑧  经验整理类笔记</category>
      </categories>
      <tags>
        <tag>Methods</tag>
      </tags>
  </entry>
  <entry>
    <title>Python搭建深度学习框架系列笔记1——计算图、梯度下降、反向传播、自动微分的理论部分</title>
    <url>/2022/02/10/f5cccb7aefe2/</url>
    <content><![CDATA[<h3 id="一深度学习训练逻辑框架梳理">一、深度学习训练逻辑框架梳理：</h3>
<p>​
我们以解决一个简单的问题的深度学习训练逻辑为例，梳理一下在框架内部发生的整体步骤：</p>
<ul>
<li>1、构建模型函数
F（此步其实就是对应着用户传入的<strong>构建的深度学习模型model，深度学习模型model中又可能含有许多层layer</strong>）</li>
<li>2、确定损失函数 L
（用户传入的损失函数，常见的有交叉熵、L1、L2等损失函数，还可能是混合损失函数）</li>
<li>3、依据 F 和 L 构建<strong>计算图 Graph</strong>（ 框架内部完成
）</li>
<li>4、在each update中，干如下两件事情
<ul>
<li>将输入的数据，<strong>根据计算图</strong>进行前向传播计算，得到Loss值</li>
<li><strong>根据计算图</strong>，进行反向传播计算，获得 损失函数L 对
模型参数 w 的
梯度向量（具体采用的技术就是<strong>自动微分</strong>）</li>
</ul></li>
<li>5、将 梯度向量信息与 每个模型参数w 信息
传入<strong>优化器</strong>中，更新参数，然后回到步骤4，循环往复。（优化器往往也是框架在内部提前写好的，几个比较通用的优化器：Adam，Adagrad等）</li>
</ul>
<p><strong>注意</strong>：实际上，如果对于一些简单的模型函数，比如 wx +
b ,
我们是可以不定义计算图的，只要我们人工的实现了该模型的forward函数，以及该模型的backward函数，框架应当就会在前向传播和反向传播的过程中，调用这两个函数来进行计算。</p>
<p>​
那么，计算图和自动微分的作用是什么呢？我们知道，在pytorch中，我们在一个模型中只需要定义forward函数即可，是不需要定义backward函数的，那么模型又应当怎么去定义反向传播的过程呢？这个时候就是计算图和自动微分起作用了。因为现在的模型函数F都非常复杂，人工求导是不现实的，所以我们就需要依据前向传播过程和损失函数，构建计算图，然后依据自动微分技术，用反向传播的形式，计算损失函数L
对 模型参数 w，最终实现梯度下降优化。</p>
<h3
id="二计算图反向传播自动微分详解">二、计算图、反向传播、自动微分详解：</h3>
<h4 id="最基本的计算图">1、最基本的计算图：</h4>
<p>​ 计算图是用来描述运算的有向无环图，有两个主要元素：节点 (Node) 和边
(Edge)。节点表示数据，如向量、矩阵、张量。边表示运算，如加减乘除卷积等。计算图中节点有不同的类型，不同类型的节点执行不同的计算。</p>
<p><img src="https://pic2.zhimg.com/80/v2-464ea7ee4475f3c7f08c389f65fd3e89_1440w.jpg" alt="img" style="zoom:50%;" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">w = torch.tensor([<span class="number">1.</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line">x = torch.tensor([<span class="number">2.</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># y=(x+w)*(w+1)</span></span><br><span class="line">a = torch.add(w, x)     <span class="comment"># retain_grad()</span></span><br><span class="line">b = torch.add(w, <span class="number">1</span>)</span><br><span class="line">y = torch.mul(a, b)</span><br><span class="line"><span class="comment"># y 求导</span></span><br><span class="line">y.backward()</span><br><span class="line"><span class="comment"># 打印 w 的梯度，就是 y 对 w 的导数</span></span><br><span class="line"><span class="built_in">print</span>(w.grad)</span><br></pre></td></tr></table></figure>
<p>​ 在上面的例子中，x 和 w
是叶子节点，其他所有节点都依赖于叶子节点。叶子节点的概念主要是为了节省内存，<strong>在计算图中的一轮反向传播结束之后，非叶子节点的梯度是会被释放的。</strong></p>
<p>代码示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看叶子结点</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;is_leaf:\n&quot;</span>, w.is_leaf, x.is_leaf, a.is_leaf, b.is_leaf, y.is_leaf)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看梯度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;gradient:\n&quot;</span>, w.grad, x.grad, a.grad, b.grad, y.grad)</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">is_leaf:</span><br><span class="line"> True True False False False</span><br><span class="line">gradient:</span><br><span class="line"> tensor([5.]) tensor([2.]) None None None</span><br></pre></td></tr></table></figure>
<h4 id="计算图中的一些基本概念">2、计算图中的一些基本概念：</h4>
<h5 id="变量节点">1）变量节点：</h5>
<p>​
这些节点没有父节点，它们的值不是计算出来的，而是被赋予的。具体到模型中，一般会是模型的输入、参数或者标签。</p>
<h5 id="内积节点">2）内积节点：</h5>
<p>​
由于节点的值既可以是一个数，也可以是一个向量。内积节点就是将两个父节点视为向量，然后计算两个父节点的内积。</p>
<h5 id="前向传播">3）前向传播：</h5>
<p>​
输入信息被赋予变量节点，沿着网络向前流动，最终流动到所要计算的结果节点，这就是计算图的前向传播过程。</p>
<h4 id="区分静态图和动态图">3、区分静态图和动态图：</h4>
<p>​ PyTorch 采用的是动态图机制 (Dynamic Computational Graph)，而
Tensorflow 采用的是静态图机制 (Static Computational Graph)。</p>
<ul>
<li><p><strong>动态图</strong>是运算和搭建同时进行，也就是可以先计算前面的节点的值，再根据这些值搭建后面的计算图。优点是灵活，易调节，易调试</p></li>
<li><p><strong>静态图</strong>是先搭建图，然后再输入数据进行运算。优点是高效，因为静态计算是通过先定义后运行的方式，之后再次运行的时候就不再需要重新构建计算图，所以速度会比动态图更快。但是不灵活。TensorFlow
每次运行的时候图都是一样的，是不能够改变的</p></li>
</ul>
<p>​
所以，其实在pytorch中，比如你定义的一个继承自nn.Module的网络类中，你会重载这个类的forward函数，然后在网络训练运行的过程中，其就会根据你的forward里面张量的计算过程来搭建动态的计算图，并且依据此计算图，在反向传播的时候使用自动微分计算梯度。</p>
<h4 id="方向导数和梯度">4、方向导数和梯度</h4>
<h5 id="方向导数">1）方向导数：</h5>
<p>​
方向导数的本质是一个数值，简单来说其定义为：<strong>一个函数沿指定方向的变化率。</strong>其最核心的两个要点是：</p>
<ul>
<li>函数</li>
<li>指定方向</li>
</ul>
<p>​
当我们拥有一个函数，并且确定好一个方向以后，就可以计算得到该方向的方向导数，是一个数值。从下图中一个最简单的一维函数来看：</p>
<p><img src="C:\Users\14012\Desktop\屏幕捕获_2022_02_26_21_49_36_307.png" style="zoom:50%;" /></p>
<p>​
我们指定E点，现在指定EC、EB、EA、ED四个方向，<strong>我们来看一下各自方向的方向导数，ED方向的方向导数最小，因为它是切线方向，且是朝下的，也就是说函数在该点往ED方向的变化率负方向最大，也就是值最小。之后依次是EA、EB、EC。ED的反方向DE，就是该点各个方向导数中，最大的那一个。</strong></p>
<h5 id="梯度">2) 梯度：</h5>
<p>​
梯度与方向导数是有本质区别的，梯度其实是一个向量，其定义为：一个函数对于其自变量分别求偏导数，这些偏导数所组成的向量就是函数的梯度。</p>
<h5 id="梯度与方向导数的关系">3）梯度与方向导数的关系：</h5>
<p>​
<strong>函数在某点的梯度是这样一个向量，它的方向与取得最大方向导数的方向一致，而它的模为方向导数的最大值。</strong>
这个其实是比较直观能够去理解的一个维度：具体证明此处不涉及。</p>
<h4 id="梯度下降">5、梯度下降：</h4>
<p>​ 对于一个具有参数 <strong>w </strong>=（w1,w2,w3）和 b
的计算图，我们可以把所有参数看作一个大向量（<strong>w</strong>,b），然后以（<strong>w</strong>,b）为自变量，以损失值为函数值。求梯度就是求损失之对每个参数的偏导数，为了求这些偏导数，我们可以<strong>单独把每个参数节点视为自变量，求损失值对该节点的梯度</strong>（具体怎么求，见反向传播和自动微分方法）。</p>
<h4 id="什么是反向传播和自动微分">6、什么是反向传播和自动微分？</h4>
<h5 id="训练时自动微分在哪里应用">1）训练时自动微分在哪里应用？</h5>
<p>​
自动微分用于反向传播的过程中，依据计算图计算<strong>损失函数对参数的梯度</strong>。在Pytorch常见的训练步骤中，应当就是封装在
.backward() 函数中的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">batch_loss = criterion(outputs, labels) <span class="comment"># 通过损失函数，计算本次损失值</span></span><br><span class="line">batch_loss.backward()  <span class="comment"># 损失反向传播，计算梯度</span></span><br></pre></td></tr></table></figure>
<p>​ 举一个更简单明了的例子：考虑最简单的一层神经网络，输入 x，参数 w 和
b，以及一些损失函数。 它可以通过以下方式在 PyTorch 中定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x = torch.ones(<span class="number">5</span>)  <span class="comment"># input tensor</span></span><br><span class="line">y = torch.zeros(<span class="number">3</span>)  <span class="comment"># expected output</span></span><br><span class="line">w = torch.randn(<span class="number">5</span>, <span class="number">3</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">z = torch.matmul(x, w)+b</span><br><span class="line">loss = torch.nn.functional.binary_cross_entropy_with_logits(z, y)</span><br></pre></td></tr></table></figure>
<p>pytorch在上述运算进行的过程中，就会搭建好如下的计算图。</p>
<figure>
<img src="https://pytorch.org/tutorials/_images/comp-graph.png"
alt="avatar" />
<figcaption aria-hidden="true">avatar</figcaption>
</figure>
<p>​ 然后，调用如下函数,即可计算梯度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss.backward() // 计算梯度</span><br><span class="line"><span class="built_in">print</span>(w.grad)</span><br><span class="line"><span class="built_in">print</span>(b.grad)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[0.2175, 0.0032, 0.1359],</span></span><br><span class="line"><span class="string">        [0.2175, 0.0032, 0.1359],</span></span><br><span class="line"><span class="string">        [0.2175, 0.0032, 0.1359],</span></span><br><span class="line"><span class="string">        [0.2175, 0.0032, 0.1359],</span></span><br><span class="line"><span class="string">        [0.2175, 0.0032, 0.1359]])</span></span><br><span class="line"><span class="string">tensor([0.2175, 0.0032, 0.1359])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>​ Pytorch
这边其实实际上隐藏了非常多的内部细节，从外表函数调用来看，根本看不到计算图、自动微分的逻辑，这是因为Pytorch都已经将其封装在了底层中。实际上，Pytorch的计算图是什么时候搭建的呢？其就是在每一个Tensor张量参与计算的时候进行搭建的：</p>
<p>例如，执行如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z = torch.matmul(x, w)+b</span><br></pre></td></tr></table></figure>
<p>计算图中，关于x、w、b、z节点之间的DAG就已经搭建好了</p>
<p>再当执行如下代码的时候：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss = torch.nn.functional.binary_cross_entropy_with_logits(z, y)</span><br></pre></td></tr></table></figure>
<p>​ Pytorch又将loss和z、y的节点关系加入计算图中了。</p>
<p>​ 同时，截至此时，x,y,w,z,loss
的值都已经计算出来了，也就是说已经完成了一遍前向传播，这时候这些值都被记录在这一个个Tensor中。（下图是torch.Tensor内部的成员变量，我们可以看到，其内部是记录了非常多东西的，前向传播的值就是记录在Tensor.data中，也就是其表现出来的值）</p>
<p><img
src="https://pic2.zhimg.com/80/v2-3bc1ff0ab920582a3491111b81a32fe5_1440w.jpg" /></p>
<p>然后当我们在外层调用如下函数的时候:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss.backward()</span><br></pre></td></tr></table></figure>
<p>​ Pytorch
内部实际上就是开始反向传播，利用自动微分引擎，链式法则计算loss对参数w的梯度值。对于我们人而言，是如下的一个过程：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/dsa98uyc89dsahkj.jpg" style="zoom:33%;" /></p>
<p>​
那么，这个时候我们就需要思考了，对于电脑来说我们根本没有告诉它，loss对参数w的导数怎么求啊？即使是按照上述靠链式法则去求，但是我们也没告诉它链式法则中的每一项的导数是什么（比如说loss对z的导数，z对w的导数），那怎么求呢？其实，这个时候Pytorch内部就是利用其带的自动微分引擎，去解析函数，然后进行计算的。从外层看来，我们只知道只要设定一些参数，调用backward()函数，就能够获得loss对某个参数w的梯度，外层完全不用关心内部的事情。我们再详细的先拓展一下反向传播的具体数学原理，随后会记录自动微分。</p>
<h5 id="反向传播的数学原理扩展">2）反向传播的数学原理扩展：</h5>
<p>​
反向传播写成上面的链式传播导数的形式十分好理解，但是不仅仅是上述这样子。我们应该需要知道，上面我们都默认所有的字母都只是一个常量，而不是一个变量，就比如说
w 是一个值， x
也仅是一个值，这些节点，我们通常称之为变量节点，它们没有父节点，它们的值不是被计算出来的，而是被赋予的。但其实，节点的值可以是一个数，也可以是一个向量，我们可以用一个节点保存输入向量(x1,x2,x3)，再用一个节点保存权值向量(w1,w2,w3)。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_10_15_03_30_21.png" /></p>
<p>那么也就是说，其实<strong>计算图中每一个节点都是多个值到多个值的映射，也就是向量
到向量的映射，自变量是父节点，因变量是子节点。</strong>虽然一个子节点可能拥有多个父节点，但是我们在计算子节点对某一个父节点的梯度的时候，可以把其他的父节点视为常量。</p>
<p>​ 举例如下：比如我们从<strong>n维向量( w
)，计算出m维向量的映射就可以视为m个标量函数</strong>：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/3FFA54BF58ADB73E2AB2959E12132F27.jpg" alt="img" style="zoom:33%;" /></p>
<p>​ 我们可以知道，每一个<span class="math inline">\(f_i(w)\)</span>对
<span class="math inline">\(w\)</span>来说，应该都有一个梯度 <span
class="math inline">\(\nabla f_i(w)\)</span>
,而每一个梯度都是一个n维向量（因为自变量是n维向量）。</p>
<p>​ 以m个梯度作为行，每个梯度都是一个n维向量：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/C3DB7AD3158C70B1352C05AB2B03B655.jpg" style="zoom:33%;" /></p>
<p>​ 这个<span class="math inline">\(J_f(w)\)</span> 叫做映射 <span
class="math inline">\(f(w)\)</span>在 w 处的雅可比矩阵。因为<span
class="math inline">\(f(w)\)</span>是从n维到m维的映射，所以<strong>雅可比矩阵是一个$
m n<span
class="math inline">\(的矩阵，它的每一行分别是\)</span>f(w)<span
class="math inline">\(的每一个分量\)</span>f_{i}(w)<span
class="math inline">\(在\)</span>w$处的梯度向量的转置。</strong></p>
<p>​
故而，我们知道，<strong>对于计算图中的每一对父子节点，都可以计算出子节点对父节点的映射的雅可比矩阵。
雅克比矩阵其实也就是映射的每个分量对输入向量的每个分量的偏导数。</strong></p>
<p>​ 在上述图2-1中的内积节点x = (x1,x2,x3) ， w =
(w1,w2,w3)，它们的子节点 对 他们的映射，就是一个
n维(n=3)到1维的映射，故而，子节点到父节点的雅可比矩阵应当是 $ 1
n$矩阵。</p>
<p>​
<strong>至此为止，我们已经能够知晓计算图中每一对父子节点的雅可比矩阵怎么求解了，可是，我们最终要求的是损失函数对参数w的雅可比矩阵</strong>。仍然如2-1所示，w节点是h节点的祖先，它必须要经过
内积节点、+节点、*节点后，才会最终到达h节点。
这个时候，我们就可以利用链式法则：
复合映射的雅可比矩阵式组成复合映射的多个映射的雅可比矩阵的乘积。</p>
<p>​ 即复合映射<span class="math inline">\(f(g(h(w))\)</span>
在w处的雅可比矩阵是 <span class="math inline">\(J_f\)</span> 、<span
class="math inline">\(J_g\)</span> 、<span
class="math inline">\(J_h\)</span>三个雅可比矩阵的乘积。</p>
<p>​
（我们先假设一个父节点只有一个子节点）<strong>那么所谓反向传播：就是从计算图中作为结果的节点开始，依次从后向前，每个节点都将
“结果对自己的雅可比矩阵” 和 “自己对父节点的雅可比矩阵”
传给自己的父节点，然后这个父节点再将 “结果节点对自己的雅可比矩阵” 和
“自己对父节点的雅可比矩阵”
传给父节点，再前面的父节点会将两矩阵相乘，得到 “结果对自己的雅可比矩阵”
，一直这样子到我们的 变量节点</strong>。</p>
<p>​
所以“反向传播”传播的是结果节点对自己的雅可比矩阵，同时也将自己对父节点的雅可比矩阵传给父节点。父节点将这两个矩阵相乘，就得到最终结果对自己的雅可比矩阵。</p>
<p>​
接下来就剩最后一个问题了，<strong>如果一个父节点有多个子节点，它应该如何得到结果对自己的雅可比矩阵呢？</strong>在数学上能够证明，其实就是先按照上述方法，将<strong>结果节点
对 各个子结点的雅可比矩阵 和
各个子节点对父节点的雅可比矩阵分别相乘，然后再相加即可 得到
结果节点对父节点的雅可比矩阵</strong>。如下所示：</p>
<p><span class="math display">\[
J_f = \Sigma_s J_{rs}J_{sf}
\]</span> ​ <span
class="math inline">\(J_f\)</span>是最终结果节点对父节点f
的雅可比矩阵。</p>
<p>​ <span
class="math inline">\(J_{rs}\)</span>是最终结果节点对某个子节点s的雅可比矩阵。</p>
<p>​ <span
class="math inline">\(J_{sf}\)</span>是某个子节点对父节点f的雅可比矩阵。</p>
<p>【附：<strong>最开始的时候，结果节点对自己的雅可比矩阵是啥？
回答：是一个单位矩阵，即对角线元素为1，其余元素都为0</strong>】</p>
<p>​ 具体的代码实现，见下一节中的Node类的backward方法的实现。</p>
<h5 id="自动微分的工作原理解析">3）自动微分的工作原理解析：</h5>
<p>​
在上述描述的反向传播过程中，我们有一个核心的地方还没有细说，那就是如何让计算机计算
一对子节点和父节点
它们之间的雅可比矩阵，也就是它们之间的导数关系，如何计算？【此处留有陷阱，请继续往下看】</p>
<p>​ 让计算机实现微分功能有以下几种微分方式，</p>
<ul>
<li>手工计算出微分，然后编码进代码中</li>
<li>数值微分 (numerical differentiation)</li>
<li>符号微分 (symbolic differentiation)</li>
<li>自动微分</li>
</ul>
<figure>
<img
src="https://pic4.zhimg.com/80/v2-4c305dc170d7a165aec1b5d7017828c7_1440w.jpg"
alt="四种微分方式的对比。 手工微分、符号微分、 自动微分得出的都是精确解， 而数值微分得出的只是近似解。" />
<figcaption aria-hidden="true">四种微分方式的对比。 手工微分、符号微分、
自动微分得出的都是精确解， 而数值微分得出的只是近似解。</figcaption>
</figure>
<p>我们简单的先介绍以下前三种方式，然后再着重介绍自动微分：</p>
<ul>
<li><p><strong>手工编码</strong>：故名思意，自己计算函数的导数然后编码入计算机代码中。</p></li>
<li><p><strong>数值差分</strong>，其分为两种方式—前向差分、中心差分</p></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_10_17_31_03_38.png" /></p>
<p>​ 一般我们使用中心差分来对神经网络的反向传播进行
<strong>梯度检验</strong>， 前向差分很少使用， 因为前向差分的误差是
<span class="math inline">\(O(h)\)</span> , 而中心差分的误差是 <span
class="math inline">\(O(h^2)\)</span> , 使用泰勒公式将上面的 <span
class="math inline">\(f(x+h)\)</span> 和<span
class="math inline">\(f(x-h)\)</span>展开，就能得出前向差分和中心差分的误差</p>
<ul>
<li><p><strong>符号微分：</strong></p>
<p>​
类似于我们人的手工计算，它是计算机根据规则进行微分的方式。符号微分的明显的缺陷是容易产生
<strong>表达式膨胀</strong> (expression swell)。</p>
<figure>
<img
src="https://pic3.zhimg.com/80/v2-fb2923b77c6a8cbed2716e58e44f191e_1440w.jpg"
alt="符号微分的微分结果不一定是最简的形式" />
<figcaption
aria-hidden="true">符号微分的微分结果不一定是最简的形式</figcaption>
</figure></li>
<li><p><strong>自动微分：</strong></p>
<p>​
自动微分将符号微分法应用于最基本的算子，比如常数，幂函数，指数函数，对数函数，三角函数等，然后代入数值，保留中间结果，最后再应用于整个函数。因此它应用相当灵活，可以做到完全向用户隐藏微分求解过程，由于它只对基本函数或常数运用符号微分法则。</p>
<p>​
自动微分有前向模式和反向模式两种，<strong>当输出的维度大于输入的时候，适宜使用前向模式微分；当输出维度远远小于输入的时候，适宜使用反向模式微分。</strong>一般在神经网络中使用的都是反向模式。因为神经网路的输入通常
&gt;&gt; 输出，</p>
<p>​
细节上来说，自动微分是将复合函数分解为输出量（根节点）和一系列的输入量（叶子节点）及基本函数（中间节点），构成一个计算图（Computational
Graph），并以此计算任意两个节点间的梯度：</p>
<ul>
<li>加法法则：任意两个节点间的梯度为它们两节点之间所有路径的偏微分之和；</li>
<li>链式法则：一条路径的偏微分为路径上各相邻节点间偏微分的连乘。</li>
</ul></li>
</ul>
<p>​
<strong>看到这里，会觉得很熟悉，诶等等！这不就是反向传播干的事情吗，一摸一样！</strong>然后我就发现自己一开始理解错概念了，我一开始以为反向传播过程中计算一对父节点和子节点的雅可比矩阵
这边的过程用的是自动微分，其他都是反向传播的过程，其实从某种意义上来说，反向传播就是在计算自动微分的过程，而计算一对子节点和父节点它们之间的雅可比矩阵，其实就已经是分解到最基本的算子了。在后面的代码实现环节，会更清楚明了一些。</p>
<p>​
总结一下，计算图的变量节点被赋值或初始化后，在结果节点（比如损失值节点）上调用
前向传播
，递归计算路径上各个节点的值，信息沿着计算图向前传播，最终得到结果节点的值。之后，在需要更新的节点上调用
反向传播
方法，该方法会递归计算<strong>结果节点对路径上各个节点的雅可比矩阵，信息反向传播</strong>。如果有多个节点需要更新，比如权值向量节点和偏置节点，就在这些节点上分别调用
反向传播
方法。<strong>由于中间节点的雅可比矩阵（如果已经被计算）已经保存在了
节点的 jacobi 属性中，所以在多个节点上多次调用其 反向传播
方法时并不会增加额外的计算负担。</strong>这其实就是“反向传播”的精髓，它执行的无非就是复杂复合映射的求导链式法则，保存中间结果，从而以空间换时间。具体的内容会在下一节的实现中详解</p>
<p><strong>参考资料：</strong></p>
<p>代码实现参考：https://github.com/zc911/MatrixSlow</p>
<p>1、《用python实现深度学习框架》张觉非、陈震</p>
<p>2、https://zhuanlan.zhihu.com/p/191648279</p>
<p>3、https://zhuanlan.zhihu.com/p/61103504</p>
<p>4、https://blog.csdn.net/aws3217150/article/details/70214422</p>
<p>5、https://zhuanlan.zhihu.com/p/53506221</p>
]]></content>
      <categories>
        <category>② 深度学习笔记</category>
        <category>Basic系列笔记</category>
        <category>Python搭建简易框架笔记</category>
      </categories>
      <tags>
        <tag>Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>奇妙应用——字符串比较中广义邻居的应用</title>
    <url>/2022/02/08/4ccc50ba5a4e/</url>
    <content><![CDATA[<h4 id="剑指-offer-ii-064.-神奇的字典"><a
href="https://leetcode-cn.com/problems/US1pGT/">剑指 Offer II 064.
神奇的字典</a></h4>
<p>​ 设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 互不相同
。
如果给出一个单词，请判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于已构建的神奇字典中。</p>
<p>实现 MagicDictionary 类：</p>
<ul>
<li>MagicDictionary() 初始化对象</li>
<li>void buildDict(String[] dictionary) 使用字符串数组 dictionary
设定该数据结构，dictionary 中的字符串互不相同</li>
<li>bool search(String searchWord) 给定一个字符串 searchWord
，判定能否只将字符串中 一个
字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回
true ；否则，返回 false 。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">inputs = [&quot;MagicDictionary&quot;, &quot;buildDict&quot;, &quot;search&quot;, &quot;search&quot;, &quot;search&quot;, &quot;search&quot;]</span><br><span class="line">inputs = [[], [[&quot;hello&quot;, &quot;leetcode&quot;]], [&quot;hello&quot;], [&quot;hhllo&quot;], [&quot;hell&quot;], [&quot;leetcoded&quot;]]</span><br><span class="line">输出</span><br><span class="line">[null, null, false, true, false, false]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">MagicDictionary magicDictionary = new MagicDictionary();</span><br><span class="line">magicDictionary.buildDict([&quot;hello&quot;, &quot;leetcode&quot;]);</span><br><span class="line">magicDictionary.search(&quot;hello&quot;); // 返回 False</span><br><span class="line">magicDictionary.search(&quot;hhllo&quot;); // 将第二个 &#x27;h&#x27; 替换为 &#x27;e&#x27; 可以匹配 &quot;hello&quot; ，所以返回 True</span><br><span class="line">magicDictionary.search(&quot;hell&quot;); // 返回 False</span><br><span class="line">magicDictionary.search(&quot;leetcoded&quot;); // 返回 False</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<pre><code>1 &lt;= dictionary.length &lt;= 100
1 &lt;= dictionary[i].length &lt;= 100
dictionary[i] 仅由小写英文字母组成
dictionary 中的所有字符串 互不相同
1 &lt;= searchWord.length &lt;= 100
searchWord 仅由小写英文字母组成
buildDict 仅在 search 之前调用一次
最多调用 100 次 search</code></pre>
<h5 id="解题思路"><strong>解题思路</strong>：</h5>
<p>​
一开始看到这道题，想到前缀树，但是经过尝试，发现前缀树没法使用，判定两个字符串只差1个字符，非常非常绕，并且当如下情况出现时，会发生错误：</p>
<p>​
<strong>例如：字典中存在hello,hallo。我们查找hello，我的前缀树算法因为找到了完全匹配的hello，就会返回false，而忽略了字典中存在的hallo。</strong></p>
<p>​
然后，我们发现，如果想要采用先前的方法，用一个vector(26)来统计字符串字符出现的个数，然后利用相差1个字符来进行判定也不可行，当如下情况出现时，会发生错误：</p>
<p>​
<strong>例如：字典中存在hello,我们查找llohh，在vector统计中，两者确实只在h的个数上有不同，但是问题是两个单词顺序完全不一样，vector统计会将单词的顺序信息丢失。</strong></p>
<p><strong>故而：这题需要一个全新的概念叫做 广义邻居：</strong></p>
<p><strong>思路引用</strong>：https://leetcode-cn.com/problems/US1pGT/solution/offerii064shen-qi-de-zi-dian-by-logilong-4hmn/</p>
<p><strong>广义邻居：</strong>也就是一字只差的单词，比如说【*pple,
a*ple, ap*le, app*e, appl*】，这几个单词互为广义邻居。</p>
<p>然后，我们这道题就可以按照如下的步骤进行求解：</p>
<ul>
<li><p>初始化字典： 生成字典中所有单词的广义邻居，例如 apple
就生成上述五个广义邻居。将所有字典词的广义邻居都以
<code>&lt;广义邻居，个数&gt;</code> 保存到
<code>HashMap</code>。</p></li>
<li><p>查找：当我们需要在字典中查找是否有一个单词和 word
只有一字只差，那不就是查找第二步中 HashMap 中是否存在 word
的广义邻居吗？这时候我们就只要生成 word 所有的广义邻居，然后在 HashMap
中查找是否存在其中的一个就可以了。</p></li>
</ul>
<p><strong>关键疑问</strong>：为什么需要记录所有字典词的广义邻居数量？</p>
<p>​
<strong>这是为了防止字典中出现和查找词一摸一样的词，如果出现上述情况，则会找到符合条件的广义邻居，但是其实并不是邻居，而是它自己！</strong></p>
<p>所以，刚才的查找不是很完整，<strong>完整正确的查找应当如下</strong>：</p>
<p>​ 生成待查找词 word 的所有广义邻居。每个广义邻居都到 HashMap
中查找出现的次数，根据出现次数分为3种情况。</p>
<ul>
<li>广义邻居数 &gt; 1
，则说明字典中肯定存在两个不同的字符，这两个字符互为广义邻居，且和查找字符也是广义邻居，由于字典中的单词是不重复的，所以此时满足条件。</li>
<li>广义邻居数 == 1 ,
说明字典中可能存在一个广义邻居，也可能存在查找字符串本身，如果是广义邻居就满足条件，如果是查找字符串本身的话就不符合条件。</li>
<li>广义邻居数 == 0 ,
说明不存在广义邻居，则继续遍历下一个广义邻居。</li>
</ul>
<h5 id="代码如下"><strong>代码如下</strong>：</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MagicDictionary</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;string,<span class="type">int</span>&gt; neighbors;</span><br><span class="line">    unordered_map&lt;string,<span class="type">int</span>&gt; dictionary;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MagicDictionary</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">generateNeighbors</span><span class="params">(string word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;word.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            string new_word = word;</span><br><span class="line">            new_word[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(neighbors.<span class="built_in">find</span>(new_word) == neighbors.<span class="built_in">end</span>()) neighbors[new_word] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> neighbors[new_word]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildDict</span><span class="params">(vector&lt;string&gt; dictionary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;dictionary.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="built_in">generateNeighbors</span>(dictionary[i]);</span><br><span class="line">            <span class="keyword">this</span>-&gt;dictionary[dictionary[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string searchWord)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> res = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;searchWord.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            string new_word = searchWord;</span><br><span class="line">            new_word[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(neighbors.<span class="built_in">find</span>(new_word) == neighbors.<span class="built_in">end</span>())&#123;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(neighbors[new_word] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//可能存在广义邻居，需要看searchWord在不在dictionary种</span></span><br><span class="line">                <span class="keyword">if</span>(dictionary.<span class="built_in">find</span>(searchWord) == dictionary.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    res = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(neighbors[new_word] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                res = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MagicDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MagicDictionary* obj = new MagicDictionary();</span></span><br><span class="line"><span class="comment"> * obj-&gt;buildDict(dictionary);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(searchWord);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>字符串系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 优先队列 PriorityQueue 容器使用</title>
    <url>/2022/02/08/945d3241b7fc/</url>
    <content><![CDATA[<p><strong>定义</strong>：<code>priority_queue&lt;Type, Container, Functional&gt;</code></p>
<p>​ Type 就是数据类型，Container
就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用
list。STL里面默认用的是vector），Functional
就是比较的方式，当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，<strong>默认是大顶堆</strong></p>
<ul>
<li>1、一般情况：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//升序队列</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//降序队列</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt;q;</span><br></pre></td></tr></table></figure>
<ul>
<li>2、如果内部的元素是Pair的话，其也自带了比较函数,比较规则是先比较第一个元素，第一个相等比较第二个。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; a;</span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">2</span>, <span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>3、内部为自定义元素：一个是通过重载自定义struct的 &lt; 规则</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tmp1</span> <span class="comment">//运算符重载&lt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">tmp1</span>(<span class="type">int</span> a) &#123;x = a;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> tmp1&amp; a) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; a.x; <span class="comment">//大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">tmp1 <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">tmp1 <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">tmp1 <span class="title">c</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">priority_queue&lt;tmp1&gt; d;</span><br></pre></td></tr></table></figure>
<ul>
<li>另一个方法是通过定义一个比较类：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 优先队列存放 Node* 时优先级的比较方法 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Compare_Node_Pointer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* Node::priority 大的优先 */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(Node* &amp;a, Node* &amp;b)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;priority &lt; b-&gt;priority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用法 */</span></span><br><span class="line">std::priority_queue&lt;Node*, std::vector&lt;Node*&gt;, Compare_Node_Pointer&gt; my_queue;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-offer-ii-061.-和最小的-k-个数对"><a
href="https://leetcode-cn.com/problems/qn8gGX/">剑指 Offer II 061.
和最小的 k 个数对</a></h4>
<p><strong>题目描述</strong>：</p>
<p>​ 给定两个以升序排列的整数数组 nums1 和 nums2 , 以及一个整数 k
。定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2
。请找到和最小的 k 个数对 (u1,v1), (u2,v2) ... (uk,vk) 。</p>
<p><strong>解题思路</strong>：</p>
<p>​ 遍历nums1 和 nums2
，然后将所有的组合push进入自定义的优先队列中，然后按照顺序，出队前k个元素或将队列出空即可。但是这样子的话，时间复杂度会达到O(mn)，也就是nums1和nums2的长度的乘积。其实，因为提供的数组是有序序列，所以我们只需要进队列
nums1的前k个和nums2的前k个的组合，也就是O(K^2)即可。</p>
<p><strong>解题代码</strong>：（熟悉priority queue的操作）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> v1;</span><br><span class="line">    <span class="type">int</span> v2;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> v1,<span class="type">int</span> v2)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;v1 = v1;</span><br><span class="line">        <span class="keyword">this</span>-&gt;v2 = v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NodeCompare</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(Node* &amp;a,Node* &amp;b)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;v1 + a-&gt;v2 &gt; b-&gt;v1 + b-&gt;v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">kSmallestPairs</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> k) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        priority_queue&lt;Node*,vector&lt;Node*&gt;,NodeCompare&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;k &amp;&amp; i&lt;nums1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;k &amp;&amp; j&lt;nums2.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                Node* tmp = <span class="keyword">new</span> <span class="built_in">Node</span>(nums1[i],nums2[j]);</span><br><span class="line">                q.<span class="built_in">push</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(k-- &amp;&amp; q.<span class="built_in">size</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">            Node* tmp = q.<span class="built_in">top</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(&#123;tmp-&gt;v1,tmp-&gt;v2&#125;);</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>堆栈系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>priority queue</tag>
      </tags>
  </entry>
  <entry>
    <title>奇妙应用——&quot;动态数据流+第k大的数值&quot;相关问题优化</title>
    <url>/2022/02/08/42903a1f937a/</url>
    <content><![CDATA[<h4 id="剑指-offer-ii-059.-数据流的第-k-大数值"><a
href="https://leetcode-cn.com/problems/jBjn9C/">剑指 Offer II 059.
数据流的第 K 大数值</a></h4>
<h5 id="题目描述"><strong>题目描述</strong>：</h5>
<p>​ 设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k
大元素，不是第 k 个不同的元素。</p>
<p>​ 请实现 KthLargest 类：</p>
<pre><code>KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。
int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。</code></pre>
<h5 id="解题思路"><strong>解题思路</strong>：</h5>
<p>​
我对于这类没有设计类实现的题目，数据结构的敏感度不够高，基本上想起来都只能用最暴力的方法去解决。此题目，我一开始是想要在内部维护一个Vector，但是我发现，维护有序向量的成本太高了，虽然通过了测试点，但是时间复杂度等方面可以优化的内容实在太多了。</p>
<h5 id="优化思路"><strong>优化思路</strong>：</h5>
<p>​ 比较重要重要的信息点是
<strong>动态插入</strong>、<strong>第K大</strong>，这两个关键信息，应当能够导向一个动态的数据结构，也就是优先队列——堆。可以维护一个优先队列（最小堆），然后在其内维护最大的K个元素。这样的话，每次插入完需要返回第K大的元素的时候，直接返回堆顶的元素（堆顶的元素是堆中最小的那个元素，但是是所有数组中第K大的那个元素）即可。</p>
<p>​ 故而，在单次插入的操作中，我们首先将元素 val
加入到优先队列中。如果此时优先队列的大小大于
k，我们需要将优先队列的队头元素弹出，以保证优先队列的大小为 k。</p>
<h5 id="解题代码">解题代码：</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KthLargest</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="built_in">KthLargest</span>(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">             <span class="built_in">add</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​</p>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>堆栈系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>priority queue</tag>
      </tags>
  </entry>
  <entry>
    <title>奇妙应用——日程表类的设计优化思想</title>
    <url>/2022/02/08/e026aa44c5a7/</url>
    <content><![CDATA[<h4 id="剑指-offer-ii-058.-日程表"><a
href="https://leetcode-cn.com/problems/fi9suh/">剑指 Offer II 058.
日程表</a></h4>
<h5 id="题目描述"><strong>题目描述</strong>：</h5>
<p>​ 请实现一个 MyCalendar
类来存放你的日程安排。如果要添加的时间内没有其他安排，则可以存储这个新的日程安排。</p>
<p>​ MyCalendar 有一个 book(int start, int end)方法。它意味着在 start 到
end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end),
实数 x 的范围为， start &lt;= x &lt; end。</p>
<p>​
当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生重复预订。</p>
<p>​ 每次调用
MyCalendar.book方法时，如果可以将日程安排成功添加到日历中而不会导致重复预订，返回
true。否则，返回 false 并且不要将该日程安排添加到日历中。</p>
<p>​ 请按照以下步骤调用 MyCalendar 类: MyCalendar cal = new MyCalendar();
MyCalendar.book(start, end)</p>
<p>提示：</p>
<pre><code>每个测试用例，调用 MyCalendar.book 函数最多不超过 1000次。
0 &lt;= start &lt; end &lt;= 109</code></pre>
<h5 id="我的解题思路"><strong>我的解题思路</strong>：</h5>
<pre><code>一开始看到每个测试用例，调用.book函数不超过1000次，我就使用了较为暴力的算法，使用成员变量记录先前所有的日程，然后新来一个日程以后，去判断和先前的有没有区间重复，代码如下：</code></pre>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCalendar</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; calendar;</span><br><span class="line">    <span class="built_in">MyCalendar</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkIsCollision</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;calendar.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> tmp_start = calendar[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> tmp_end = calendar[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(!(start &gt;= tmp_end || end &lt;= tmp_start))&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">book</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">checkIsCollision</span>(start,end))&#123;</span><br><span class="line">            calendar.<span class="built_in">push_back</span>(&#123;start,end&#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCalendar object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyCalendar* obj = new MyCalendar();</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;book(start,end);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h5 id="优化思路"><strong>优化思路</strong>：</h5>
<pre><code>按照上述方法做的话，其实是比较浪费时间的，因为每新来一个日程，我们就需要去和先前所有的日程比较，从理论上来说，大部分的比较都是无效比较，我们其实只需要和最近的两个区间进行比较就可以了，因为已知先前的日程都是不重叠的，所以我们每次只需要查询最近的时间段的前后，看看起止时间有无冲突即可。</code></pre>
<p>​
此时，我们会想，那我们不是需要维护日程vector，让它变得有序就可以了。思路没错！但是我们可以不用vector了，直接使用map。map是有序的key-value键值对，底层使用红黑树建立，更加方便而且高效。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCalendar</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; calendar;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyCalendar</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">book</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = calendar.<span class="built_in">lower_bound</span>(start);</span><br><span class="line">        <span class="comment">//第一个大于等于插入元素的时间段。这个时间段的起始时间不能小于插入时间的终止时间</span></span><br><span class="line">        <span class="keyword">if</span>(iter != calendar.<span class="built_in">end</span>() &amp;&amp; iter-&gt;first &lt; end)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//迭代器往前走一步就是小于等于当前时间段的最大时间段。这个时间段的终止时间不能大于插入的起始时间</span></span><br><span class="line">        <span class="keyword">if</span>(iter != calendar.<span class="built_in">begin</span>() &amp;&amp; (--iter)-&gt;second &gt; start)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        calendar[start] = end;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>参考：https://leetcode-cn.com/problems/fi9suh/solution/c-hong-hei-shu-map058-ri-cheng-biao-by-d-f7q9/</p>
<p>附录：</p>
<ul>
<li>map中的lower_bound和upper_bound函数：
<ul>
<li>map::lower_bound(key): 返回map中第一个大于或等于key的迭代器指针</li>
<li>map::upper_bound(key): 返回map中第一个大于key的迭代器指针</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>容器设计系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>red black tree</tag>
      </tags>
  </entry>
  <entry>
    <title>奇妙应用——求解直方图最大矩形面积 &amp;&amp; 矩阵中最大的矩形求解</title>
    <url>/2022/02/08/faff2c35214a/</url>
    <content><![CDATA[<h4 id="剑指-offer-ii-039.-直方图最大矩形面积"><a
href="https://leetcode-cn.com/problems/0ynMMM/">剑指 Offer II 039.
直方图最大矩形面积</a></h4>
<h5 id="题目描述"><strong>题目描述</strong>：</h5>
<pre><code>给定非负整数数组 `heights` ，数组中的数字用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 `1` 。求在该柱状图中，能够勾勒出来的矩形的最大面积。</code></pre>
<p><strong>示例1</strong>：<img
src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg"
alt="img" /></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入：heights = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：最大的矩形为图中红色区域，面积为 <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>题解参考：https://leetcode-cn.com/problems/0ynMMM/solution/jian-zhi-offer-2-mian-shi-ti-39-shu-zhon-qzaw/</p>
<h5 id="解题思路"><strong>解题思路</strong>：</h5>
<pre><code>本题如果采用暴搜的方法，O(n^2)复杂度，是比较简单易懂的，但是时间耗费太长，会超时。所以此篇博客要记录的是一个叫做 **“单调栈”**的解决方案：</code></pre>
<ul>
<li><p><strong>基本思想</strong>：<strong>保证存在栈中的柱子的高度是递增的。</strong>基础操作为，从左往右扫描数组内的柱子高度，若当前柱高大于栈顶柱高，那么该柱子下标入栈；反之，将栈顶柱子出栈，并计算栈顶的柱子高度为顶高的最高矩阵面积，直至可入栈。</p></li>
<li><p><strong>核心问题</strong>：如何确定以栈顶柱子高为顶的最大矩阵面积呢？</p>
<ul>
<li>该矩阵的宽度一定是，<strong>从栈顶柱子的两边出发直到遇到比该柱高矮的柱子所夹成的宽度</strong>。因为单调栈中保存的柱高是递增的，所以<strong>栈中位于栈顶柱子前面的柱子一定比栈顶柱子矮，同样当前扫描到的柱子也矮于位于栈顶的柱子</strong>，所以顶柱子为顶的最高矩阵的宽度就确定了，那么面积也就确定了。</li>
</ul></li>
<li><p><strong>操作示例</strong>：下面以 [2, 1, 5, 6, 2, 3]
为例说明，过程如图所示</p>
<ul>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/1629450891-DTWpaG-image.png" /></li>
<li>可以发现，最后栈中除了为了处理方便而加入的初始化的 -1 以外，还有 1,
4, 5 三个元素，说明以 1, 2, 3
柱高为顶的最大矩阵还未计算。这时候只要多想一步，它们未被计算是因为还未出现比它们矮的柱子。若假设最后再加入一个高度为
0 的柱高，那么栈中除了 -1
以外，所有的元素都会出栈，那么所有的柱子均被计算，计算完毕，继续的过程如下</li>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/1629451413-pOKglw-image.png" /></li>
</ul></li>
<li><p><strong>解题代码</strong>：</p>
<ul>
<li>以下代码是理解了上述所说以后书写的，和上述所说的细节部分有所不同，它是先往栈里面push了一个-1，保证栈不会空。而我没有这么干，我是在pop完了以后，在计算宽度的时候，会判断栈空了没有，如果空了则
new_top_idx = -1 ，如果没空就是 s.top();</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        heights.<span class="built_in">push_back</span>(<span class="number">0</span>);  <span class="comment">//先在最后加一个高度为0的柱子，方便后续操作</span></span><br><span class="line">        s.<span class="built_in">push</span>(<span class="number">0</span>); <span class="comment">//先把第一个元素push进去</span></span><br><span class="line">        <span class="type">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;heights.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> top_idx = s.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">while</span>(heights[i] &lt; heights[top_idx])&#123;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> new_top_idx = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>();</span><br><span class="line">                <span class="comment">//计算pop出去的这个元素，maxValue</span></span><br><span class="line">                maxValue = <span class="built_in">max</span>(maxValue,heights[top_idx] * (i - new_top_idx - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span>(s.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">                top_idx = s.<span class="built_in">top</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="剑指-offer-ii-040.-矩阵中最大的矩形"><a
href="https://leetcode-cn.com/problems/PLYXKQ/">剑指 Offer II 040.
矩阵中最大的矩形</a></h4>
<h5 id="题目描述-1"><strong>题目描述</strong>：</h5>
<p>给定一个由 0 和 1 组成的矩阵 matrix ，找出只包含 1
的最大矩形，并返回其面积。</p>
<p>注意：此题 matrix 输入格式为一维 01 字符串数组。</p>
<p><strong>示例</strong>：<img
src="https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg"
alt="img" /></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入：matrix = [<span class="string">&quot;10100&quot;</span>,<span class="string">&quot;10111&quot;</span>,<span class="string">&quot;11111&quot;</span>,<span class="string">&quot;10010&quot;</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：最大矩形如上图所示。</span><br></pre></td></tr></table></figure>
<h5 id="解题思路-1"><strong>解题思路</strong>：</h5>
<p>​ 本题可以用结合上一题的思路进行求解：</p>
<p>​
<strong>我们循环每一行，将每一行都看作是上一题中的一系列直方图。然后，某行某位置的高度，如果该位置是1，那么它的高度是上一行的该对应位置的直方图的高度+1.如果该位置是0，则该位置的直方图高度就直接清0.</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//即利用一个数组rectangular来记录直方图高度</span></span><br><span class="line"><span class="comment">//遍历每一行每一个位置，更新rectangular中的数值</span></span><br><span class="line"><span class="comment">//然后调用上一题中的方法，进行求解</span></span><br><span class="line"><span class="keyword">if</span>(nums[j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line"> 	rectangular[j]++;</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> 	rectangular[j]=<span class="number">0</span>;<span class="comment">//这一行的某个字符为“0”，那就矩形高度清0</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>解题代码</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        heights.<span class="built_in">push_back</span>(<span class="number">0</span>);  <span class="comment">//先在最后加一个高度为0的柱子，方便后续操作</span></span><br><span class="line">        s.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;heights.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> top_idx = s.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">while</span>(heights[i] &lt; heights[top_idx])&#123;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> new_top_idx = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>();</span><br><span class="line">                <span class="comment">//计算pop出去的这个元素，maxValue</span></span><br><span class="line">                maxValue = <span class="built_in">max</span>(maxValue,heights[top_idx] * (i - new_top_idx - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span>(s.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">                top_idx = s.<span class="built_in">top</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalRectangle</span><span class="params">(vector&lt;string&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; rectangular;</span><br><span class="line">        <span class="type">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;matrix.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            string row = matrix[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;row.<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) rectangular.<span class="built_in">push_back</span>(row[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(row[j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                        rectangular[j]++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        rectangular[j]=<span class="number">0</span>;<span class="comment">//这一行的某个字符为“0”，那就矩形高度清0</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新好了以后，计算改行的maxValue</span></span><br><span class="line">            maxValue = <span class="built_in">max</span>(maxValue,<span class="built_in">largestRectangleArea</span>(rectangular));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>堆栈系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>树系列——二叉树的序列化与反序列化（如何更好的用线性方式记录二叉树的结构）</title>
    <url>/2022/02/07/5f449aa44840/</url>
    <content><![CDATA[<h4 id="剑指-offer-ii-048.-序列化与反序列化二叉树"><a
href="https://leetcode-cn.com/problems/h54YBf/">剑指 Offer II 048.
序列化与反序列化二叉树</a></h4>
<h5 id="题目描述"><strong>题目描述</strong>：</h5>
<p>​
序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<p>​ 请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 /
反序列化算法执行逻辑，只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<h5 id="解题思路"><strong>解题思路</strong>：</h5>
<p>​
我们都很清楚，<strong>一个前序序列（后序/层序序列）+中序序列可以确定恢复一颗二叉树结构。</strong>在这个题目里的话，我一开始的思路是记录前序+
中序序列，将它们变成字符串，然后反序列化的时候，再通过前序和中序序列重构即可。思路整体而言也较为清晰，但是当我写完所有代码的时候，发现了一个令人窒息的问题：</p>
<p>​
<strong>这个题目中树节点的值是可能重复的</strong>，这就会导致如果只记录节点的值，树的重构是会出问题的。如果，需要克服这个问题，我们还要给每个节点加上index，并且利用一个hash表记录节点index和值的对应关系。这是比较麻烦的。</p>
<p>​
此Blog就是为了记录另一种解题思路：<strong>在特定条件下，我们可以仅凭借树的前序序列就能够确定恢复一颗唯一的二叉树</strong>。</p>
<p>​
<strong>如果想要达到上面的效果，那么我们的前序遍历序列是需要记录为Null的节点的，示例如下</strong>：</p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg" alt="img" style="zoom:33%;" /></p>
<p>​ 对于上述二叉树，普通的前序序列应当为:</p>
<p>​ <strong>1 2 3 4 5 </strong></p>
<p>​ 而如果我们想要用来恢复树结构，前序序列应当为：</p>
<p>​ <strong>1 2 None None 3 4 None None 5 None None</strong></p>
<p>​
具体如何操作，以及如何恢复见如下代码：先序遍历和正常的类似，只不过如果碰到了为NULL的节点，我们不是直接return，而是会将其记录入序列中。</p>
<p>​
在重建操作中，我们将序列存入一个队列中操作较为方便，然后如果碰到None就返回NULL，否则就新建一个节点，利用递归的形式，确定左右子树节点，然后返回新建节点。最终就能完成一整颗树的重建。这种方法从时间复杂度和代码复杂度上都优于前一种通过两个序列进行重建的方法。但是局限就是，前序遍历得到的序列需要是你自己形成的“特殊”的前序遍历序列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* root,string &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            res += <span class="string">&quot;None,&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += <span class="built_in">to_string</span>(root-&gt;val) + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        <span class="built_in">preOrder</span>(root-&gt;left,res);</span><br><span class="line">        <span class="built_in">preOrder</span>(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//需要一棵树的前序(P) + 中序遍历序列(I)才能够进行重构</span></span><br><span class="line">        <span class="built_in">preOrder</span>(root,str);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">preOrderReverse</span><span class="params">(queue&lt;string&gt; &amp;q)</span></span>&#123;</span><br><span class="line">        string tmp = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(tmp == <span class="string">&quot;None&quot;</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(tmp));</span><br><span class="line">        root-&gt;left = <span class="built_in">preOrderReverse</span>(q);</span><br><span class="line">        root-&gt;right =<span class="built_in">preOrderReverse</span>(q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 先把string转成序列的形式</span></span><br><span class="line">        queue&lt;string&gt; q;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;data.<span class="built_in">length</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">// i = 0 是第一个数字的起始位置，i = data.lenth()-1 是 I前面那个逗号的位置</span></span><br><span class="line">            string tmp_str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span>(data[i]!=<span class="string">&#x27;,&#x27;</span>)&#123;</span><br><span class="line">                tmp_str += data[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            q.<span class="built_in">push</span>(tmp_str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//然后再通过序列重建树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">preOrderReverse</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>树系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>树系列——当二叉树需要以层为单位计算时层序遍历的优化版本</title>
    <url>/2022/02/06/36f0ee63db4b/</url>
    <content><![CDATA[<h4 id="剑指-offer-ii-045.-二叉树最底层最左边的值"><a
href="https://leetcode-cn.com/problems/LwUNpT/">剑指 Offer II 045.
二叉树最底层最左边的值</a></h4>
<h5 id="题目描述"><strong>题目描述</strong>：</h5>
<p>​ 给定一个二叉树的 <strong>根节点</strong>
<code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong>
节点的值。假设二叉树中至少有一个节点。具体信息请点击链接查看。</p>
<h5 id="题目解答"><strong>题目解答</strong>：</h5>
<p>​
思路是很简单的，一个层序遍历，然后最后一层层序遍历的第一个值返回即可，但是整个过程中还是有很多步骤可以优化的。以最简单的思想来讲，我们需要先来一遍层序遍历，确定总共有多少层，然后再来一遍层序遍历，当知道到最后一层的第一个节点的时候记录返回。但是其实可以只用一次层序遍历完成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;TreeNode*&gt;&gt; v;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);  </span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;TreeNode*&gt; tmp;</span><br><span class="line">            <span class="keyword">while</span>(size--)&#123;          <span class="comment">// 最精妙的在于此</span></span><br><span class="line">                TreeNode* t = q.<span class="built_in">front</span>();</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(t);</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left) q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right) q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            v.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v[v.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">0</span>]-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​
上述层序遍历中，最为精髓的部分就是在while(!q.empty())中，加入了一个while(size--)的循环，而每次在这里面进行循环的，必定是同一层的节点。这一点尝试以后就会发现是正确的，如此一来就大大缩减了整个层序遍历的过程。如果这道题目需要找到每一层的最大值，也就不需要两次遍历了，我们只要在内循环中每次找到一个最大值，就是在每一层里找最大值。</p>
<p>​ 此篇博客就是为了记录这样一个小的Trick。</p>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>树系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>容器设计——LRU最近最少使用缓存的容器设计</title>
    <url>/2022/02/05/4cd58a8a96c9/</url>
    <content><![CDATA[<h3 id="剑指-offer-ii-031.-最近最少使用缓存"><a
href="https://leetcode-cn.com/problems/OrIXps/">剑指 Offer II 031.
最近最少使用缓存</a></h3>
<h5 id="题目简要描述"><strong>题目简要描述</strong>：</h5>
<p>​ 运用所掌握的数据结构，设计和实现一个 LRU (Least Recently
Used，最近最少使用) 缓存机制 。</p>
<p><strong>实现 LRUCache 类：</strong></p>
<ul>
<li><p>LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU
缓存</p></li>
<li><p>int get(int key) 如果关键字 key
存在于缓存中，则返回关键字的值，否则返回 -1 。</p></li>
<li><p>void put(int key, int value)
如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p></li>
</ul>
<p><strong>类模版</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="解题思路"><strong>解题思路</strong>：</h5>
<p>​ <strong>使用 双向链表 与 Hash 表</strong>，实现
LRU：将新插入的元素放在链表头部，或将最新访问的节点放在链表的头部。如果容量到达上限，去除链表最后的元素。在此期间，<strong>为了保证访问链表的头部和尾部都是O(1)时间，我们需要维护一个Head和一个Tail节点，分别指向双向链表的头部和尾部，这两个头部和尾部的节点中是不存放数据，留空的，仅为了进行指示。</strong>并且为了保证<strong>在O(1)时间内能够获取任意一个元素</strong>，我们还需要建立一个HashMap，将key值与对应的链表节点关联，以方便以O(1)时间进行访问。</p>
<p><strong>代码</strong>：以下代码我并没有做任何的优化，比如说合并一些可复用的函数，因为这样看上去更简单明了一些，其实比如说像一些将Node插入到链表前方的操作，以及删除链表最后一个元素的操作，都是可以写成函数封装起来的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Node* prev;</span><br><span class="line">	Node* next;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Node</span>() &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Node</span>(<span class="type">int</span> key, <span class="type">int</span> value) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;key = key;</span><br><span class="line">		<span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">	<span class="type">int</span> capacity;</span><br><span class="line">	<span class="type">int</span> curr_size;</span><br><span class="line">	Node* head; <span class="comment">//链表头节点</span></span><br><span class="line">	Node* tail; <span class="comment">//链表尾巴节点</span></span><br><span class="line">	unordered_map&lt;<span class="type">int</span>, Node*&gt; key2Node; <span class="comment">//key - Node 的转换</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;curr_size = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">		<span class="keyword">this</span>-&gt;head = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">		<span class="keyword">this</span>-&gt;tail = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">		head-&gt;next = tail;</span><br><span class="line">		tail-&gt;prev = head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (key2Node.<span class="built_in">find</span>(key) == key2Node.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		Node* curr = key2Node[key];</span><br><span class="line">		<span class="comment">//将curr先从链表中删掉</span></span><br><span class="line">		Node* prev = curr-&gt;prev;</span><br><span class="line">		<span class="keyword">if</span> (prev) prev-&gt;next = curr-&gt;next;</span><br><span class="line">		<span class="keyword">if</span> (curr-&gt;next) curr-&gt;next-&gt;prev = prev;</span><br><span class="line">		<span class="comment">//然后添加到链表的最前面</span></span><br><span class="line">		Node* next = <span class="keyword">this</span>-&gt;head-&gt;next;</span><br><span class="line">		curr-&gt;prev = head;</span><br><span class="line">		head-&gt;next = curr;</span><br><span class="line">		curr-&gt;next = next;</span><br><span class="line">		next-&gt;prev = curr;</span><br><span class="line">		<span class="keyword">return</span> curr-&gt;value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (key2Node.<span class="built_in">find</span>(key) != key2Node.<span class="built_in">end</span>()) &#123;</span><br><span class="line">			<span class="comment">//修改值并将该元素插到最前面</span></span><br><span class="line">			Node* curr = key2Node[key];</span><br><span class="line">			curr-&gt;value = value;</span><br><span class="line">			<span class="comment">//将curr先从链表中删掉</span></span><br><span class="line">			Node* prev = curr-&gt;prev;</span><br><span class="line">			<span class="keyword">if</span> (prev) prev-&gt;next = curr-&gt;next;</span><br><span class="line">			<span class="keyword">if</span> (curr-&gt;next) curr-&gt;next-&gt;prev = prev;</span><br><span class="line">			<span class="comment">//然后添加到链表的最前面</span></span><br><span class="line">			Node* next = <span class="keyword">this</span>-&gt;head-&gt;next;</span><br><span class="line">			curr-&gt;prev = head;</span><br><span class="line">			head-&gt;next = curr;</span><br><span class="line">			curr-&gt;next = next;</span><br><span class="line">			next-&gt;prev = curr;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;curr_size == <span class="keyword">this</span>-&gt;capacity) &#123;</span><br><span class="line">			<span class="comment">//如果容量满了,丢掉最尾巴的那个，然后插入到最前面</span></span><br><span class="line">			<span class="comment">//丢掉最尾巴那个</span></span><br><span class="line">			Node* prev = <span class="keyword">this</span>-&gt;tail-&gt;prev;</span><br><span class="line">			key2Node.<span class="built_in">erase</span>(prev-&gt;key); <span class="comment">//抹除key2Node里</span></span><br><span class="line">			<span class="keyword">if</span> (prev-&gt;prev) prev-&gt;prev-&gt;next = tail;</span><br><span class="line">			tail-&gt;prev = prev-&gt;prev;</span><br><span class="line">			prev-&gt;prev = prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="comment">//插入该元素到最前面</span></span><br><span class="line">			Node* temp = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">			Node* next = <span class="keyword">this</span>-&gt;head-&gt;next;</span><br><span class="line">			temp-&gt;prev = head;</span><br><span class="line">			head-&gt;next = temp;</span><br><span class="line">			temp-&gt;next = next;</span><br><span class="line">			next-&gt;prev = temp;</span><br><span class="line">			key2Node[key] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//如果容量没满，元素插入到最前面，并加载入map中</span></span><br><span class="line">			Node* temp = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">			Node* next = <span class="keyword">this</span>-&gt;head-&gt;next;</span><br><span class="line">			temp-&gt;prev = head;</span><br><span class="line">			head-&gt;next = temp;</span><br><span class="line">			temp-&gt;next = next;</span><br><span class="line">			next-&gt;prev = temp;</span><br><span class="line">			key2Node[key] = temp;</span><br><span class="line">			<span class="keyword">this</span>-&gt;curr_size++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong>:</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_06_11_41_37_32.png" /></p>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>容器设计系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>container</tag>
      </tags>
  </entry>
  <entry>
    <title>容器设计——前缀树容器设计</title>
    <url>/2022/02/05/06a3e97dc7c2/</url>
    <content><![CDATA[<h4 id="剑指-offer-ii-062.-实现前缀树"><a
href="https://leetcode-cn.com/problems/QC3q1f/">剑指 Offer II 062.
实现前缀树</a></h4>
<h5 id="题目描述"><strong>题目描述</strong>：</h5>
<p>​ Trie（发音类似 "try"）或者说 前缀树
是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如<strong>自动补完和拼写检查</strong>。****</p>
<p>请你实现 Trie 类：</p>
<pre><code>Trie() 初始化前缀树对象。
void insert(String word) 向前缀树中插入字符串 word 。
boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。
boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</code></pre>
<h5 id="解题思路"><strong>解题思路</strong>：</h5>
<p>​ Trie，又称前缀树或字典树，是一棵有根树，其每个节点包含以下字段：</p>
<ul>
<li>指向子节点的指针数组
childrens。在本题中，这可以是一个动态的vector，也可以是一个大小定为26的vector，因为本文中的字符限定为小写字母。两者各有好处，动态的vector节省一些空间，静态的vector在查找和插入时节省一些时间，实现起来也较为方便一些。</li>
<li>布尔字段 isEnd，表示该节点是否为字符串的结尾。</li>
</ul>
<p>下面是一张比较清晰的图：非常明了</p>
<figure>
<img src="https://pic.leetcode-cn.com/1632672370-gVXuKM-image.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h5
id="代码实现动态vector版本我写的"><strong>代码实现（动态vector版本，我写的）</strong>：</h5>
<p>​
Search操作和startsWith其实就是差一个判定字符串结尾的操作，所以我将两个函数合并成了一个，用一个形参来控制，使得代码尽量简介。Insert操作其实和Search操作也有大量的重复代码，循环判定都是一致的，就是判定后操作逻辑不太一样，但为了不混在一起，我还是将其分开写了。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_08_15_17_08_168.png" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTreeNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line">    <span class="type">char</span> character;</span><br><span class="line">    vector&lt;MyTreeNode*&gt; childrens;</span><br><span class="line">    <span class="built_in">MyTreeNode</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyTreeNode</span>(<span class="type">char</span> character,<span class="type">bool</span> isEnd)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;isEnd = isEnd;</span><br><span class="line">        <span class="keyword">this</span>-&gt;character = character;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    MyTreeNode* root;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;root = <span class="keyword">new</span> <span class="built_in">MyTreeNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        MyTreeNode* r = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;word.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt; r-&gt;childrens.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(r-&gt;childrens[j]-&gt;character == word[i])&#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没找到，插入一个新的节点</span></span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                MyTreeNode* c = <span class="keyword">new</span> <span class="built_in">MyTreeNode</span>(word[i],i == word.<span class="built_in">length</span>()<span class="number">-1</span>);</span><br><span class="line">                r-&gt;childrens.<span class="built_in">push_back</span>(c);</span><br><span class="line">                r = c;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果找到了，那么继续下一个字符，</span></span><br><span class="line">                r = r-&gt;childrens[j];</span><br><span class="line">                <span class="keyword">if</span>(i == word.<span class="built_in">length</span>()<span class="number">-1</span>)&#123;  <span class="comment">//如果是最后一个字符，那么</span></span><br><span class="line">                    r-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mySearch</span>(word,<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mySearch</span>(prefix,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">mySearch</span><span class="params">(string word,<span class="type">bool</span> includePrefix)</span></span>&#123;</span><br><span class="line">        <span class="type">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">        MyTreeNode* r = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;word.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt; r-&gt;childrens.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(r-&gt;childrens[j]-&gt;character == word[i])&#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没找到，返回false</span></span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                res = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果找到了，那么继续找下一个字符，</span></span><br><span class="line">                r = r-&gt;childrens[j];</span><br><span class="line">                <span class="keyword">if</span>(i == word.<span class="built_in">length</span>()<span class="number">-1</span> &amp;&amp; !includePrefix)&#123; <span class="comment">//如果是最后一个自符，还需要判定下一个r-&gt;isEnd</span></span><br><span class="line">                    <span class="keyword">if</span>(!r-&gt;isEnd) res = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5
id="代码实现静态vector版本引自leetcode题解"><strong>代码实现（静态vector版本，引自LeetCode题解）</strong>：</h5>
<p>​
可以看到，其本身代码简洁程度较高，并且它将Trie直接视为一个节点了，没有建立额外的TreeNode类。运行时间上和我的算法类似，差别不是很大。但是其内存消耗是远大于我的算法的，</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_08_15_17_59_414.png" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Trie*&gt; children;</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="function">Trie* <span class="title">searchPrefix</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : prefix) &#123;</span><br><span class="line">            ch -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[ch] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">children</span>(<span class="number">26</span>), <span class="built_in">isEnd</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : word) &#123;</span><br><span class="line">            ch -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[ch] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                node-&gt;children[ch] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>-&gt;<span class="built_in">searchPrefix</span>(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">nullptr</span> &amp;&amp; node-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">searchPrefix</span>(prefix) != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/QC3q1f/solution/shi-xian-qian-zhui-shu-by-leetcode-solut-un50/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p>再记录一道上述数据结构的应用题：</p>
<h4 id="剑指-offer-ii-063.-替换单词"><a
href="https://leetcode-cn.com/problems/UhWRSj/">剑指 Offer II 063.
替换单词</a></h4>
<p>​ 在英语中，有一个叫做 词根(root)
的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为
继承词(successor)。例如，词根an，跟随着单词
other(其他)，可以形成新的单词 another(另一个)。</p>
<p>​
现在，给定一个由许多词根组成的词典和一个句子，需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。需要输出替换之后的句子。</p>
<p>​ 示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：dictionary = [&quot;cat&quot;,&quot;bat&quot;,&quot;rat&quot;], sentence = &quot;the cattle was rattled by the battery&quot;</span><br><span class="line">输出：&quot;the cat was rat by the bat&quot;</span><br></pre></td></tr></table></figure>
<p><strong>代码（Author: Fantast）</strong>：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_08_18_14_35_668.png" /></p>
<p>​
主要思路就是实现一个前缀树，其中和上题不一样的是，上题是前缀找单词，这题是单词找前缀，反了反，所以我将startsWith改成了searchRoot函数，大体搜寻逻辑一致。然后再应用该数据结构解题即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTreeNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line">    <span class="type">char</span> character;</span><br><span class="line">    vector&lt;MyTreeNode*&gt; childrens;</span><br><span class="line">    <span class="built_in">MyTreeNode</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyTreeNode</span>(<span class="type">char</span> character,<span class="type">bool</span> isEnd)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;isEnd = isEnd;</span><br><span class="line">        <span class="keyword">this</span>-&gt;character = character;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    MyTreeNode* root;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;root = <span class="keyword">new</span> <span class="built_in">MyTreeNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        MyTreeNode* r = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;word.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt; r-&gt;childrens.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(r-&gt;childrens[j]-&gt;character == word[i])&#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没找到，插入一个新的节点</span></span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                MyTreeNode* c = <span class="keyword">new</span> <span class="built_in">MyTreeNode</span>(word[i],i == word.<span class="built_in">length</span>()<span class="number">-1</span>);</span><br><span class="line">                r-&gt;childrens.<span class="built_in">push_back</span>(c);</span><br><span class="line">                r = c;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果找到了，那么继续下一个字符，</span></span><br><span class="line">                r = r-&gt;childrens[j];</span><br><span class="line">                <span class="keyword">if</span>(i == word.<span class="built_in">length</span>()<span class="number">-1</span>)&#123;  <span class="comment">//如果是最后一个字符，那么</span></span><br><span class="line">                    r-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 查询字典中是否有该单词的词根，如果有返回词根，如果没有，返回原单词*/</span></span><br><span class="line">    <span class="function">string <span class="title">searchRoot</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        MyTreeNode* r = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;word.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt; r-&gt;childrens.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(r-&gt;childrens[j]-&gt;character == word[i])&#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没找到，返回false</span></span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                res = word;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果找到了，观察其是否是一个词根</span></span><br><span class="line">                r = r-&gt;childrens[j];</span><br><span class="line">                res += r-&gt;character;</span><br><span class="line">                <span class="keyword">if</span>(r-&gt;isEnd)&#123; <span class="comment">//如果是一整个词根，直接返回</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceWords</span><span class="params">(vector&lt;string&gt;&amp; dictionary, string sentence)</span> </span>&#123;</span><br><span class="line">        Trie* t = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;dictionary.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            t-&gt;<span class="built_in">insert</span>(dictionary[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        string res;</span><br><span class="line">        string word;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sentence.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sentence[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                res += t-&gt;<span class="built_in">searchRoot</span>(word) + <span class="string">&quot; &quot;</span>;</span><br><span class="line">                word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                word += sentence[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res += t-&gt;<span class="built_in">searchRoot</span>(word);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再记录一道上述数据结构的拓展应用题：</p>
<h4 id="剑指-offer-ii-067.-最大的异或"><a
href="https://leetcode-cn.com/problems/ms70jA/">剑指 Offer II 067.
最大的异或</a></h4>
<p>给定一个整数数组 <code>nums</code> ，返回
<code>nums[i] XOR nums[j]</code> 的最大运算结果，其中
<code>0 ≤ i ≤ j &lt; n</code> 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 10^4</code></li>
<li><code>0 &lt;= nums[i] &lt;= 2^31 - 1</code></li>
</ul>
<p><strong>解题思路</strong>：</p>
<p>​ 将整数视为二进制字符串 0 /
1，此题目的字典树孩子仅有0和1，然后遍历所有数组中的元素，对于任意一个元素ai来说，通过字典树找到和它异或最大的那个值。遍历元素O(n)复杂度，通过字典树找到每个元素的异或最大的值为log(C)，故而总的时间复杂度为O(nlog(C))</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTreeNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyTreeNode* left;  <span class="comment">// 0 </span></span><br><span class="line">    MyTreeNode* right; <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">MyTreeNode</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left = <span class="keyword">this</span>-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyTreeNode* root;</span><br><span class="line">    <span class="built_in">Trie</span>()&#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">MyTreeNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        MyTreeNode* r = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> bit = (val &gt;&gt; (<span class="number">31</span>-i)) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(bit == <span class="number">0</span> &amp;&amp; r-&gt;left)&#123; <span class="comment">//找到这个节点了</span></span><br><span class="line">                r = r-&gt;left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bit == <span class="number">1</span> &amp;&amp; r-&gt;right)&#123; <span class="comment">//找到这个节点了</span></span><br><span class="line">                r = r-&gt;right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//没找到这个节点，进行插入</span></span><br><span class="line">                MyTreeNode* c = <span class="keyword">new</span> <span class="built_in">MyTreeNode</span>();</span><br><span class="line">                <span class="keyword">if</span>(bit == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//插入左侧</span></span><br><span class="line">                    r-&gt;left = c;</span><br><span class="line">                    r = r-&gt;left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//插入右侧</span></span><br><span class="line">                    r-&gt;right = c;</span><br><span class="line">                    r = r-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculateMax</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        MyTreeNode* r = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="type">int</span> multi_val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> bit = (val &gt;&gt; (<span class="number">31</span>-i)) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(bit == <span class="number">0</span> &amp;&amp; r-&gt;right)&#123;</span><br><span class="line">                <span class="comment">//当前位为0，且有1，那么直接往1那边走</span></span><br><span class="line">                r = r-&gt;right;</span><br><span class="line">                multi_val = (multi_val &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bit == <span class="number">1</span> &amp;&amp; r-&gt;left)&#123;</span><br><span class="line">                <span class="comment">//当前位为1，且有0，那么直接往0那边走</span></span><br><span class="line">                r = r-&gt;left;</span><br><span class="line">                multi_val = multi_val &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bit == <span class="number">0</span> &amp;&amp; !r-&gt;right &amp;&amp; r-&gt;left)&#123;</span><br><span class="line">                <span class="comment">//当前位为0，且无1，则往0那边走</span></span><br><span class="line">                r = r-&gt;left;</span><br><span class="line">                multi_val = multi_val &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bit == <span class="number">1</span> &amp;&amp; !r-&gt;left &amp;&amp; r-&gt;right)&#123;</span><br><span class="line">                <span class="comment">//当前位为1，且无0，那么直接往1那边走</span></span><br><span class="line">                r = r-&gt;right;</span><br><span class="line">                multi_val = (multi_val &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> multi_val ^ val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaximumXOR</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        Trie* t = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">        <span class="type">int</span> maxVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            t-&gt;<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            maxVal = <span class="built_in">max</span>(maxVal,t-&gt;<span class="built_in">calculateMax</span>(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>字符串系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>container</tag>
      </tags>
  </entry>
  <entry>
    <title>容器设计——插入、删除和随机访问都是 O(1) 的容器设计</title>
    <url>/2022/02/05/233281550871/</url>
    <content><![CDATA[<h3 id="剑指-offer-ii-030.-插入删除和随机访问都是-o1-的容器"><a
href="https://leetcode-cn.com/problems/FortPu/">剑指 Offer II 030.
插入、删除和随机访问都是 O(1) 的容器</a></h3>
<h5 id="题目简要描述"><strong>题目简要描述</strong>：</h5>
<p>设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构：</p>
<pre><code>insert(val)：当元素 val 不存在时返回 true ，并向集合中插入该项，否则返回 false 。
remove(val)：当元素 val 存在时返回 true ，并从集合中移除该项，否则返回 false 。
getRandom：随机返回现有集合中的一项。每个元素应该有 相同的概率 被返回。</code></pre>
<p><strong>类模版</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">RandomizedSet</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Get a random element from the set. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="解题思路"><strong>解题思路</strong>：</h5>
<p>​
首先，题目要求插入和删除都需要是O(1)的时间复杂度，在我们熟知的数据结构中，<strong>只有Hash表能达到这个效果</strong>。但是，Hash表显然不能满足随机取getRandom这一操作，随机取的操作，<strong>底层应当是数组，而且最好是紧凑的连续存放内容的数组</strong>，这样才方便进行随机取的行为，并且概率一致。</p>
<p>​
综上所述，我们应当设计这样一个数据结构，利用数组保存元素，然后利用哈希表保存元素值（key）和
该值在数组中存放的index（value），这样子就能实现上述的要求了。</p>
<p>​
同时，我们还需要注意的一个细节就是，<strong>当我们删除元素时，不能直接将该元素在它的位置上删除</strong>，如果这样的话，就会导致数组存储元素的idx不连续，从而后续随机取元素的时候，各个元素的概率不再相等。我们应该用数组最后的那个元素将我们要删的元素进行替换，然后把数组最后的那个元素删除，最后更新哈希表中的idx即可。</p>
<h5 id="代码如下">代码如下：</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">  	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">RandomizedSet</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">find</span>(val) != m.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        m[val] = v.<span class="built_in">size</span>();</span><br><span class="line">        v.<span class="built_in">push_back</span>(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">find</span>(val) == m.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> idx = m[val];</span><br><span class="line">        <span class="type">int</span> max_idx = m.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        m[v[max_idx]] = idx;</span><br><span class="line">        m.<span class="built_in">erase</span>(val);</span><br><span class="line">        v[idx] = v[max_idx];</span><br><span class="line">        v.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get a random element from the set. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> idx = <span class="built_in">rand</span>() % m.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> v[idx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​</p>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>容器设计系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>container</tag>
      </tags>
  </entry>
  <entry>
    <title>链表系列——链表问题的常见技巧</title>
    <url>/2022/02/04/bb6e8e482b2b/</url>
    <content><![CDATA[<h3 id="一剑指-offer-ii-022.-链表中环的入口节点">一、<a
href="https://leetcode-cn.com/problems/c32eOV/">剑指 Offer II 022.
链表中环的入口节点</a></h3>
<p><strong>题目简单描述</strong>：</p>
<p>​ 给定一个链表，需要返回链表开始入环的第一个节点。
从链表的头节点开始沿着 next
指针进入环的第一个节点为环的入口节点。如果链表无环，则返回 null。</p>
<p>​ 进阶：是否可以使用 O(1) 空间解决此题？</p>
<h5 id="解题思路"><strong>解题思路</strong>：</h5>
<p>​
本题本身想要解答十分简单，将其放入博客中整理是想记录我们应该如何利用O(1)空间去解决这个题目呢？</p>
<p>​ <strong>快慢指针法</strong>，我们使用两个指针，fast 与
slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而
fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与
slow 指针在环中相遇。</p>
<p>​
如下图所示，即可非常好的理解如下：那么，又该如何判断入环点的位置呢？我们先上结论：经过数学推断可以得知：</p>
<p>​
<strong>假设快慢指针相遇时，fast指针已经走完了环的n圈，那么</strong></p>
<p>​ <strong>从相遇点到入环点的距离加上 n−1
圈的环长，恰好等于从链表头部到入环点的距离。</strong></p>
<p>​
<strong>根据此结论，我们只需要在快慢指针相遇时，再加一个ptr指针，让其指向链表头部；随后，它和
slow 指针每次向后移动一个位置。最终，它们会在入环点相遇。</strong></p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-02-04 下午2.06.49.png" alt="截屏2022-02-04 下午2.06.49" style="zoom:33%;" /></p>
<p>​ <strong>结论证明</strong>：设链表中环外部分的长度为 a。slow
指针进入环后，又走了 b 的距离与 fast 相遇。此时，fast 指针已经走完了环的
n 圈，因此它走过的总距离为 <span class="math inline">\(a + n \times
(b+c) + b\)</span> ,而此时，slow指针走过的总距离为 <span
class="math inline">\(a + b\)</span>。</p>
<p>​
<strong>【此处需要解释一下：为何fast与slow相遇时，slow必定还在走第一圈？】</strong>（我们假设fast和slow如果同时从入环点出发，由于速度是2倍的关系，slow走完1圈的时候，fast刚好走完2圈，他们会在起点相遇。但是现在，fast比slow先入环，也就是说slow入环的时候，fast不管在环的哪里，肯定能在slow走完一圈前，将其追上。）</p>
<p>​ 由于fast指针走的速度是slow指针的2倍，那么可以得到以下等式：$ a + n
(b+c) = 2 (a + b)$ 所以可以得到如下结论： $ a = c + (n-1) (b+c)$
,这也就意味着，最开始说的， 从相遇点到入环点的距离 + (n-1)
圈环的距离，等于链表头到入环点的距离。</p>
<p>​
那么为什么说，如果相遇的时候，ptr从链表头出发，ptr和slow必定在入环口相遇呢？因为a的距离是c加上许多圈环的距离，所以当ptr到达链表入环口的时候，时间经过了a，此时slow必定出现在入环口处。所以我们可以根据此来判断，入环口的位置是哪一个节点。</p>
<h3 id="二剑指-offer-ii-023.-两个链表的第一个重合节点">二、<a
href="https://leetcode-cn.com/problems/3u1WK4/">剑指 Offer II 023.
两个链表的第一个重合节点</a></h3>
<p><strong>简单题目描述</strong>：</p>
<p>​ 给定两个单链表的头节点 headA 和 headB
，请找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null
。详细见原网址</p>
<p><strong>解题思路</strong>：</p>
<p>参考：https://leetcode-cn.com/problems/3u1WK4/solution/liang-ge-lian-biao-de-di-yi-ge-zhong-he-0msfg/</p>
<p>此题难点在于设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？</p>
<p>​
我们可以考虑双指针的方法对两个链表进行求解，但是双指针的难点在于，两条链表的长度不同，无法做到一一对应。我们先给出<strong>解决方案</strong>：</p>
<p>​ 当链表 headA 和 headB 都不为空时，创建两个指针 pA 和 pB
，初始时分别指向两个链表的头节点 headA和 headB
，然后将两个指针依次遍历两个链表的每个节点。具体做法如下：</p>
<ul>
<li>每步操作需要同时更新指针 pA 和 pB。</li>
<li>如果指针 pA 不为空，则将指针 pA 移到下一个节点；如果指针 pB
不为空，则将指针 pB 移到下一个节点。</li>
<li>如果指针 pA 为空，则将指针 pA 移到链表 headB 的头节点；如果指针 pB
为空，则将指针 pB 移到链表 headA 的头节点。</li>
<li>当指针 pA 和 pB 指向同一个节点或者都为空时，返回它们指向的节点或者
null。</li>
</ul>
<p>​
<strong>乍一看，其中有一个非常奇怪的点</strong>，就是如果指针pA为空，那么将指针pA移动到链表headB的头节点。但其实仔细一想，这样子是没问题的。也正是因为这个操作，我们才能够得以解决两个链表长度不一致导致的不对应问题。较为详细的证明如下：</p>
<p>​
我们先考虑<strong>两链表相交的情况</strong>，如果两链表长度一致，那不需要想，pA和pB必定同时到达某一个节点。</p>
<p>​
如果两链表长度不一致，这样子的话，我们假设链表A、B长度为m和n，A、B的不相交部分节点数为a，b，相交部分节点数为c，那么m
= a + c , n = b + c.
pA和pB第一遍遍历完各自的链表后，他们不是同时到达尾部节点的，但是当pA遍历完
a + c + b个节点，当pB遍历完b + c +
a个节点的时候，两者就会同时到达相交的节点。</p>
<p>​
再证明<strong>两链表不相交的情况</strong>，如果两链表长度一致，那不需要想，pA和pB必定同时到达最终的NULL节点。</p>
<p>​
如果两链表长度不一致，这样子的话，我们假设链表A、B的长度各位m和n，当pA
遍历完 m + n个节点，pB遍历完 n +
m个节点的时候，必定同时到达尾部的NULL节点。</p>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>链表系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title>数组系列——回文字符串相关处理技巧</title>
    <url>/2022/02/04/5959f8901103/</url>
    <content><![CDATA[<h4 id="一剑指-offer-ii-020.-回文子字符串的个数">一、<a
href="https://leetcode-cn.com/problems/a7VOhD/">剑指 Offer II 020.
回文子字符串的个数</a></h4>
<h5 id="题目描述"><strong>题目描述：</strong></h5>
<p>给定一个字符串 s ，请计算这个字符串中有多少个回文子字符串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<pre><code>1 &lt;= s.length &lt;= 1000
s 由小写英文字母组成</code></pre>
<h5 id="解题思路"><strong>解题思路</strong>：</h5>
<p>​
引用：https://leetcode-cn.com/problems/a7VOhD/solution/jssan-jie-bao-li-shuang-zhi-zhen-zhong-x-qqq0/</p>
<ul>
<li><p>思路1: 暴力搜索</p>
<ul>
<li>搜索所有的子串，并分别判断是否为回文串</li>
<li>时间复杂度：O(n^3)</li>
<li>空间复杂度：O(1)</li>
</ul></li>
<li><p>思路2: 双指针，思路1的优化版本：</p>
<ul>
<li>先使用双指针 i 和 j
枚举所有子串的起点和终点，同时分别按顺序和逆序累加所有遍历过的字符得到字符串
s1 和 s2，判断是否回文只需对 s1 和 s2
判等即可。这里将回文判断的时间复杂度从 O(n)优化到
O(1)，但整体空间复杂度从 O(1)升到 O(n)，算是空间换时间。</li>
<li>但此思路的时间耗费仍然会较高，因为字符串的拼接操作都较为费时</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            string s1,s2;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;s.<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">                s1 += s[j];</span><br><span class="line">                s2 = s[j] + s2;</span><br><span class="line">                <span class="keyword">if</span>(s1==s2) count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>思路3: 中心扩展：</strong></p>
<ul>
<li><p>枚举所有可能的回文中心 s[i] 或 s[i]、s[i +
1]，若回文子串长度为奇数则其中心为 s[i]，回文子串长度为偶数则其中心为
s[i]、s[i + 1]；</p></li>
<li><p>以中心向左右两边扩展，即</p>
<ul>
<li>左边界 l 减 1</li>
<li>右边界 r 加1</li>
<li>如果 s[l] 与 s[r] 相等则回文数加1。</li>
</ul></li>
<li><div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">class</span> Solution <span class="op">&#123;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>      <span class="dt">int</span> <span class="fu">countSubstrings</span><span class="op">(</span>string s<span class="op">)</span> <span class="op">&#123;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>          <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>          <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>s<span class="op">.</span><span class="fu">length</span><span class="op">();</span>i<span class="op">++)&#123;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>              <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> l <span class="op">=</span> i<span class="op">,</span> r <span class="op">=</span> i<span class="op">;</span> l <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> s<span class="op">[</span>l<span class="op">]</span> <span class="op">==</span> s<span class="op">[</span>r<span class="op">];</span> l<span class="op">--,</span> r<span class="op">++)</span> count<span class="op">++;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>              <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> l <span class="op">=</span> i<span class="op">,</span> r <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> l <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> s<span class="op">[</span>l<span class="op">]</span> <span class="op">==</span> s<span class="op">[</span>r<span class="op">];</span> l<span class="op">--,</span> r<span class="op">++)</span> count<span class="op">++;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>          <span class="op">&#125;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>          <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>      <span class="op">&#125;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">&#125;;</span></span></code></pre></div></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>字符串系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串系列——字符串压缩问题</title>
    <url>/2022/02/04/91f6bb166e62/</url>
    <content><![CDATA[<h4 id="字符串压缩问题">字符串压缩问题：</h4>
<p>​
如果在字符串中出现了连续重复子串（重复次数&gt;=2），用“数字+左括号+子串+右括号”方式进行压缩，要求每一次压缩都优先压缩当前（
子串长度 * 重复次数
）最长的子串，且优先<strong>按重复次数最大</strong>压缩，如果<strong>最长子串长度一样，优先压缩位置在前的子串</strong>，如果压缩后的字符串如果还能压缩，则继续压缩；</p>
<ul>
<li><p>输入要求：第一行为字符串s，只包含大小写字符，1&lt;s.length&lt;3000</p></li>
<li><p>输出要求：输出压缩后的字符串</p></li>
<li><p>时间限制：C/C++
1000ms，结合输入长度，即要求算法复杂度在O(n^2)</p></li>
<li><p>样例1</p>
<ul>
<li>``` input: aaBcaBcaBcc output: a3(aBc)c <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 样例2：</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    input:  aaaaaa</span><br><span class="line">    output: 6(a)</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>样例3：</p>
<ul>
<li><pre><code>  input:  aAABBccAABBcc
  output: a2(2(A)2(B)2(c))</code></pre></li>
</ul></li>
</ul>
<h5 id="解题思路">解题思路：</h5>
<p>​</p>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>字符串系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>数组系列——经典三数之和问题</title>
    <url>/2022/02/03/16dab5183b1f/</url>
    <content><![CDATA[<h3 id="q1剑指-offer-ii-007.-数组中和为-0-的三个数">Q1、<a
href="https://leetcode-cn.com/problems/1fGaJU/">剑指 Offer II 007.
数组中和为 0 的三个数</a></h3>
<p>​ 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a ，b
，c ，使得 a + b + c = 0 ？请找出所有和为 0 且 不重复 的三元组。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<pre><code>0 &lt;= nums.length &lt;= 3000
-105 &lt;= nums[i] &lt;= 105</code></pre>
<h4 id="解题思路">解题思路：</h4>
<p>​ 该题最重要的是如何<strong>高效率的循环遍历</strong>以及
如何<strong>高效率的去除重复三元组</strong></p>
<p>​
最简单的O(n^3)的暴力求解，对于该题而言时间复杂度会大大超出。所以我们考虑双指针的解法。<strong>双指针在三数之和中如何应用呢？</strong></p>
<p>​
<strong>无非是在传统双指针求法的前提上，在外层多加了一层循环</strong>，也就是先固定住一个元素，然后利用双指针，将内部O(n^2)的复杂度，缩减至O(n)，从而使得整个求解复杂度降至O(n
^2)。</p>
<p>​
该题另外一个核心要点是，如何高效率的去除重复？我们当然可以去使用Hash表，然后每有一个元素就将其push进去，并进行比较，如果已经存在就不计入结果中。但是这样的方法仍然会导致大量的计算浪费。</p>
<p>​ 观察后，我们会发现，在循环的时候，有两种情况会导致重复：</p>
<p><strong>情况1</strong>：当外层循环的i , nums[i] == nums[i-1]
的时候，原因是，如果nums[i] ==
nums[i-1]，那么当前nums[i]能够找到的j和k，在nums[i-1]中必定已经出现过了，所以我们的处理方法是，直接跳过该次外层循环，进入下一个i</p>
<p><strong>情况2</strong>：出现在内部双指针运行的时候，如下述情况：i，j,
k分别指向-4，-1，5，此时满足一组条件，我们会将 j++,
以让循环继续运行。此时，重复发生了，如果nums[j] == nums[j +
1]，那么nums[j+1]所产生的符合条件的三元组就会与之前的重复，所以我们采取的措施是，让j一直自增，直到其和下一个元素不相等或者到达k。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	-4  -1  -1  -1  2  5</span><br><span class="line"></span><br><span class="line">​	i   j              k</span><br></pre></td></tr></table></figure>
<p>综上，代码书写如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">1</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> j = i+<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;k)&#123;</span><br><span class="line">                <span class="type">int</span> value = nums[i] + nums[j] + nums[k];</span><br><span class="line">                <span class="keyword">if</span>(value &gt; <span class="number">0</span>) k--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(value &lt; <span class="number">0</span>) j++;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[i],nums[j],nums[k]&#125;);</span><br><span class="line">                    <span class="keyword">while</span> (j &lt; k &amp;&amp; nums[j] == nums[j + <span class="number">1</span>]) j++; </span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>数组系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>数组系列——连续子串问题</title>
    <url>/2022/02/02/0f0611fa7b0b/</url>
    <content><![CDATA[<h4
id="注意连续子串问题较为常见的两个技巧为滑动窗口法与前缀和滑动窗口法解相关子数组问题一般而言需要数组内元素都为正整数如果数组内元素存在负数的话滑动窗口是无法处理相关的负数样例的需要采用前缀和的技巧进行求解">注意：连续子串问题较为常见的两个技巧为：滑动窗口法与前缀和，滑动窗口法解相关子数组问题，一般而言需要数组内元素都为正整数，如果数组内元素存在负数的话，滑动窗口是无法处理相关的负数样例的，需要采用前缀和的技巧进行求解。</h4>
<h3 id="一剑指-offer-ii-008.-和大于等于-target-的最短子数组">一、<a
href="https://leetcode-cn.com/problems/2VG8Kg/">剑指 Offer II 008.
和大于等于 target 的最短子数组</a></h3>
<p><strong>例题1描述：</strong></p>
<p>​ 给定一个含有 n 个正整数的数组和一个正整数 target 。</p>
<p>​ 找出该数组中满足其和 ≥ target 的长度最小的连续子数组 [numsl,
numsl+1, ..., numsr-1, numsr]
，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
<ul>
<li><p>示例 1：</p>
<ul>
<li>输入：target = 7, nums = [2,3,1,2,4,3]</li>
<li>输出：2</li>
<li>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</li>
</ul></li>
<li><p>示例 2：</p>
<ul>
<li>输入：target = 4, nums = [1,4,4]</li>
<li>输出：1</li>
</ul></li>
<li><p>示例 3：</p>
<ul>
<li>输入：target = 11, nums = [1,1,1,1,1,1,1,1]</li>
<li>输出：0</li>
</ul></li>
<li><p>提示：</p>
<p>1 &lt;= target &lt;= 10^9 1 &lt;= nums.length &lt;= 10^5 1 &lt;=
nums[i] &lt;= 10^5</p></li>
</ul>
<p><strong>例题1详解</strong>：</p>
<p>​ 本题在做的时候有三种解决方案:</p>
<p>​ 第一种就是最为简单的先计算前缀和，然后暴力开始从len = 1 到 len =
nums.length 进行搜索，找到符合条件的len即返回.</p>
<p>​
第二种,在第一种的基础上进行改进,将暴力搜索改为二分索,left=1,right=nums.length,
len=(left + right)/2,时间复杂度能大大降低。</p>
<p>​ 第三种就是本文着重记录的<strong>滑动窗口</strong>解决方案：</p>
<p>​
可以使用滑窗的题目一般题目中都会有明确的“<strong>连续子数组</strong>”、“<strong>连续子串</strong>”等关键字，另外可能会附带<strong>最大</strong>、<strong>最小</strong>的限定词进行补充。</p>
<p>​ 那么遇到此类题目，往往可以分为以下几步进行求解：</p>
<ul>
<li>初始化窗口左边界为0，右边界可以为0，也可以根据题意固定大小。</li>
<li>我们需要初始化一个ret的返回值，默认为0或者根据题意默认为最大值。</li>
<li>窗口的大小需要根据题目条件进行调整
<ul>
<li>最大连续...尽量扩张右边界，直到不满足题意再收缩左边界</li>
<li>最小连续...尽量缩小左边界，直到不满足题意再扩大右边界</li>
</ul></li>
<li>在执行3操作的过程中，不断与ret进行比较</li>
<li>最终返回ret结果即可。</li>
</ul>
<p>根据上述指南，我们可以书写代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">1e7</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;right&lt;nums.<span class="built_in">size</span>();right++)&#123;</span><br><span class="line">            total += nums[right];</span><br><span class="line">            <span class="keyword">while</span>(total &gt;= target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(right - left + <span class="number">1</span> &lt; len) len = right - left + <span class="number">1</span>;</span><br><span class="line">                total-= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1e7</span>) len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二剑指-offer-ii-009-乘积小于-k-的子数组">二、<a
href="https://leetcode-cn.com/problems/ZVAVXX/">剑指 Offer II 009
乘积小于 K 的子数组</a></h3>
<p><strong>例题2描述：</strong></p>
<p>​ 给定一个<strong>正整数数组 <code>nums</code></strong>和整数
<code>k</code> ，请找出该数组内乘积小于 <code>k</code>
的连续的子数组的个数。</p>
<ul>
<li><p>示例 1:</p>
<ul>
<li>输入: nums = [10,5,2,6], k = 100</li>
<li>输出: 8</li>
<li>解释: 8 个乘积小于 100 的子数组分别为: [10], [5], [2], [6], [10,5],
[5,2], [2,6], [5,2,6]。需要注意的是 [10,5,2]
并不是乘积小于100的子数组。</li>
</ul></li>
<li><p>示例 2:</p>
<ul>
<li>输入: nums = [1,2,3], k = 0</li>
<li>输出: 0</li>
</ul></li>
<li><p>提示:</p>
<p>1 &lt;= nums.length &lt;= 3 * 10^4 1 &lt;= nums[i] &lt;= 1000 0 &lt;=
k &lt;= 10^6</p></li>
</ul>
<p><strong>例题2解析</strong>：</p>
<p>​
按照上述例题1的思想，简单来向，我们发现此题目求解的不是某个长度最小或长度最大的值，而是所有的连续子数组的个数，乍一看无法按照先前的内容进行求解，但其实我们可以发现：</p>
<p>​ 窗口每次移动后，ret都可以增加 <strong>right - left +
1</strong>个子数组。具体而言是什么意思呢？</p>
<p>​ 比如某次遍历符合题意的子数组为
ABCX，那么在该条件下符合条件的有X，CX，BCX，ABCX共四个（可以进行多个例子，发现个数符合right-left+1）
​我们可能会有疑问：AB，BC也算，为什么不算进去？ ​
记住一点<strong>我们是以最右边的X为必要条件，进行计算符合条件的子数组，否则会出现重复的！</strong>
​
比如在X为右侧边界时（ABCX），我们把BC算进去了，可是我们在C为最右侧时（ABC），BC已经出现过，我们重复加了BC这个子数组两次！</p>
<p>具体的代码应当如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> product = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;right&lt;nums.<span class="built_in">size</span>();right++)&#123;</span><br><span class="line">            product = product * nums[right];</span><br><span class="line">            <span class="comment">//下面加了一个条件：left&lt;=right是因为，如果不加这个条件，当k=0的时候，会一直陷入该死循环中无法出循环。</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right &amp;&amp; product &gt;= k)&#123;</span><br><span class="line">                product = product / nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            count += right - left + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="三剑指-offer-ii-010.-和为-k-的子数组">三、<a
href="https://leetcode-cn.com/problems/ZVAVXX/">剑指 Offer II 010. 和为
k 的子数组</a></h3>
<p><strong>例题3描述：</strong></p>
<p>​ 给定一个<strong>整数数组</strong>和一个整数 <code>k</code>
<strong>，</strong>请找到该数组中和为 <code>k</code>
的连续子数组的个数。</p>
<ul>
<li><p>示例 1:</p>
<ul>
<li>``` 输入:nums = [1,1,1], k = 2 输出: 2 解释: 此题 [1,1] 与 [1,1]
为两种不同的情况 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 示例 2:</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    输入:nums = [1,2,3], k = 3</span><br><span class="line">    输出: 2</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>提示:</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li>
<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>-107 &lt;= k &lt;= 107</code></li>
</ul></li>
</ul>
<p><strong>例题3解析</strong>：</p>
<p>​
非常需要注意的是：此题中给出的条件是整数数组，而非正整数，故而滑动窗口没法使用，因为滑动窗口是需要你能保证，当右边界扩充时，和必增大，左边界收缩时和必减小，但是如果数组中存在负数，那么我们无法保证。此时需要应用前缀和。</p>
<p>​
<strong>以前我使用前缀和，都是通过先把所有的前缀和计算得到，然后存在Vector<int>中，然后再去根据前缀和，遍历处理问题，但这样人工遍历其复杂度为N^2</strong>，就会导致较高的时间复杂度，并且容易重复计算。那么应当如何去进行处理会比较好呢？</p>
<p>​
我们<strong>一般可以采用Hash表来存储前缀和，</strong>在C++中可以使用速度较快的unordered_map，其底层就是用hash表进行实现。&lt;key,value&gt;，其存储的key代表前缀和的值，value代表该前缀和出现的次数。<strong>（只有在数组内存在负数的时候，才会有前缀和出现多次的情况）</strong></p>
<p>​
然后，在上述例题中，应当在计算前缀和的每一步中，就去计算，到该元素为止，以该元素为结尾的子序列，有没有符合和为k
这一条件的，不然容易重复计算。</p>
<p>​
同时，我们需要注意，要在开始时就往hash表中，插入(0,1)这一对元素，以处理边界条件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//利用哈希表存储 计算前缀和</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; sums;</span><br><span class="line">        sums[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// sum = 0 , 出现了1次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            sum = sum + nums[i];</span><br><span class="line">            <span class="comment">//判断以该元素为结尾的子序列，有没有符合和为k 这一条件的</span></span><br><span class="line">            <span class="keyword">if</span>(sums.<span class="built_in">find</span>(sum-k) != sums.<span class="built_in">end</span>()) count+= sums[sum-k];</span><br><span class="line">			<span class="comment">//将该位置的前缀和也存入hash表中，以供后续计算参考</span></span><br><span class="line">            <span class="keyword">if</span>(sums.<span class="built_in">find</span>(sum) != sums.<span class="built_in">end</span>()) sums[sum]++;</span><br><span class="line">            <span class="keyword">else</span> sums[sum] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>④ 算法类笔记</category>
        <category>数组系列</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>java系列笔记11——java正则表达式</title>
    <url>/2022/02/02/dc49710223cc/</url>
    <content><![CDATA[<p>参考教程网址：https://www.liaoxuefeng.com/wiki/1252599548343744/1304066130968610</p>
<h3 id="一什么是正则表达式">一、什么是正则表达式：</h3>
<p>​
正则表达式可以用字符串来描述规则，并用来匹配字符串。例如，判断手机号，我们用正则表达式<code>\d&#123;11&#125;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isValidMobileNumber</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.matches(<span class="string">&quot;\\d&#123;11&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
使用正则表达式的好处有哪些？一个正则表达式就是一个描述规则的字符串，所以，只需要编写正确的规则，我们就可以让正则表达式引擎去判断目标字符串是否符合规则。</p>
<p>​
正则表达式是用字符串描述的一个匹配规则，使用正则表达式可以快速判断给定的字符串是否符合匹配规则。<strong>Java标准库<code>java.util.regex</code>内建了正则表达式引擎。</strong></p>
<h3 id="二匹配规则">二、匹配规则：</h3>
<p>正则表达式的匹配规则是从左到右按规则匹配。</p>
<h4 id="精确匹配">1、精确匹配：</h4>
<p>​
对于正则表达式<code>abc</code>来说，它只能精确地匹配字符串<code>"abc"</code>，不能匹配<code>"ab"</code>，<code>"Abc"</code>，<code>"abcd"</code>等其他任何字符串。</p>
<p>​
如果正则表达式有特殊字符，那就需要用<code>\</code>转义。例如，正则表达式<code>a\&amp;c</code>，其中<code>\&amp;</code>是用来匹配特殊字符<code>&amp;</code>的，它能精确匹配字符串<code>"a&amp;c"</code>，但不能匹配<code>"ac"</code>、<code>"a-c"</code>、<code>"a&amp;&amp;c"</code>等。</p>
<p>​
如果想匹配非ASCII字符，例如中文，那就用<code>\u####</code>的十六进制表示，例如：<code>a\u548cc</code>匹配字符串<code>"a和c"</code>，中文字符<code>和</code>的Unicode编码是<code>548c</code>。</p>
<h4 id="模糊匹配.">2、模糊匹配：(.)</h4>
<p>​
正则表达式<code>a.c</code>中间的<code>.</code>可以匹配一个任意字符</p>
<p>​ <code>.</code>匹配一个字符且仅限一个字符</p>
<h4 id="匹配数字">3、匹配数字：（</h4>
<p>​
如果我们只想匹配<code>0</code>~<code>9</code>这样的数字，可以用<code>\d</code>匹配。例如，正则表达式<code>00\d</code>可以匹配：</p>
<ul>
<li><code>"007"</code>，因为<code>\d</code>可以匹配字符<code>7</code>；</li>
<li><code>"008"</code>，因为<code>\d</code>可以匹配字符<code>8</code>。</li>
</ul>
<p>​
它不能匹配<code>"00A"</code>，<code>"0077"</code>，因为<code>\d</code>仅限单个数字字符。</p>
<h4 id="匹配常用字符">4、匹配常用字符：()</h4>
<p>用<code>\w</code>可以匹配一个字母、数字或下划线，w的意思是word。例如，<code>java\w</code>可以匹配：</p>
<ul>
<li><code>"javac"</code>，因为<code>\w</code>可以匹配英文字符<code>c</code>；</li>
<li><code>"java9"</code>，因为<code>\w</code>可以匹配数字字符<code>9</code>；。</li>
<li><code>"java_"</code>，因为<code>\w</code>可以匹配下划线<code>_</code>。</li>
</ul>
<p>因为<code>\w</code>不能匹配<code>#</code>、空格等字符。</p>
<h4 id="匹配空格字符">5、 匹配空格字符()</h4>
<p>用<code>\s</code>可以匹配一个空格字符，注意空格字符不但包括空格`<code>，还包括tab字符（在Java中用</code>表示）。例如，<code>a\sc</code>可以匹配：</p>
<ul>
<li><code>"a c"</code>，因为<code>\s</code>可以匹配空格字符``；</li>
<li><code>"a c"</code>，因为<code>\s</code>可以匹配tab字符<code>\t</code>。</li>
</ul>
<p>它不能匹配<code>"ac"</code>，<code>"abc"</code>等。</p>
<h4 id="匹配非数字">6、匹配非数字：（）</h4>
<p>​ <code>\D</code>匹配一个非数字</p>
<p>​
类似的，<code>\W</code>可以匹配<code>\w</code>不能匹配的字符，<code>\S</code>可以匹配<code>\s</code>不能匹配的字符，这几个正好是反着来的。</p>
<h4 id="重复匹配">7、重复匹配：</h4>
<ul>
<li><p>修饰符<code>*</code>可以匹配任意个字符，包括0个字符。我们用<code>A\d*</code>可以匹配：</p>
<ul>
<li><p><code>A</code>：因为<code>\d*</code>可以匹配0个数字；</p></li>
<li><p><code>A0</code>：因为<code>\d*</code>可以匹配1个数字<code>0</code>；</p></li>
<li><p><code>A380</code>：因为<code>\d*</code>可以匹配多个数字<code>380</code>。</p></li>
</ul></li>
<li><p>修饰符<code>+</code>可以匹配至少一个字符。我们用<code>A\d+</code>可以匹配：</p>
<ul>
<li><code>A0</code>：因为<code>\d+</code>可以匹配1个数字<code>0</code>；</li>
<li><code>A380</code>：因为<code>\d+</code>可以匹配多个数字<code>380</code>。</li>
</ul></li>
<li><p>修饰符<code>?</code>可以匹配0个或一个字符。我们用<code>A\d?</code>可以匹配：</p>
<ul>
<li><code>A</code>：因为<code>\d?</code>可以匹配0个数字；</li>
<li><code>A0</code>：因为<code>\d?</code>可以匹配1个数字<code>0</code>。</li>
</ul></li>
<li><p>用修饰符<code>&#123;n&#125;</code>精确指定n个字符,<code>A\d&#123;3&#125;</code>可以精确匹配：</p>
<ul>
<li><code>A380</code>：因为<code>\d&#123;3&#125;</code>可以匹配3个数字<code>380</code>。</li>
</ul></li>
<li><p>用修饰符<code>&#123;n,m&#125;</code>指定匹配n~m个字符,
<code>A\d&#123;3,5&#125;</code>可以精确匹配：</p>
<ul>
<li><code>A380</code>：因为<code>\d&#123;3,5&#125;</code>可以匹配3个数字<code>380</code>；</li>
<li><code>A3800</code>：因为<code>\d&#123;3,5&#125;</code>可以匹配4个数字<code>3800</code>；</li>
<li><code>A38000</code>：因为<code>\d&#123;3,5&#125;</code>可以匹配5个数字<code>38000</code>。</li>
</ul></li>
<li><p>如果没有上限，那么修饰符<code>&#123;n,&#125;</code>就可以匹配至少n个字符。</p></li>
</ul>
<h4 id="匹配规则快速查找">8、匹配规则快速查找：</h4>
<p>单个字符的匹配规则如下：</p>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 37%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th>正则表达式</th>
<th>规则</th>
<th>可以匹配</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>A</code></td>
<td>指定字符</td>
<td><code>A</code></td>
</tr>
<tr class="even">
<td><code>\u548c</code></td>
<td>指定Unicode字符</td>
<td><code>和</code></td>
</tr>
<tr class="odd">
<td><code>.</code></td>
<td>任意字符</td>
<td><code>a</code>，<code>b</code>，<code>&amp;</code>，<code>0</code></td>
</tr>
<tr class="even">
<td><code>\d</code></td>
<td>数字0~9</td>
<td><code>0</code>~<code>9</code></td>
</tr>
<tr class="odd">
<td><code>\w</code></td>
<td>大小写字母，数字和下划线</td>
<td><code>a</code><sub><code>z</code>，<code>A</code></sub><code>Z</code>，<code>0</code>~<code>9</code>，<code>_</code></td>
</tr>
<tr class="even">
<td><code>\s</code></td>
<td>空格、Tab键</td>
<td>空格，Tab</td>
</tr>
<tr class="odd">
<td><code>\D</code></td>
<td>非数字</td>
<td><code>a</code>，<code>A</code>，<code>&amp;</code>，<code>_</code>，……</td>
</tr>
<tr class="even">
<td><code>\W</code></td>
<td>非</td>
<td><code>&amp;</code>，<code>@</code>，<code>中</code>，……</td>
</tr>
<tr class="odd">
<td><code>\S</code></td>
<td>非</td>
<td><code>a</code>，<code>A</code>，<code>&amp;</code>，<code>_</code>，……</td>
</tr>
</tbody>
</table>
<p>多个字符的匹配规则如下：</p>
<table>
<thead>
<tr class="header">
<th>正则表达式</th>
<th>规则</th>
<th>可以匹配</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>A*</code></td>
<td>任意个数字符</td>
<td>空，<code>A</code>，<code>AA</code>，<code>AAA</code>，……</td>
</tr>
<tr class="even">
<td><code>A+</code></td>
<td>至少1个字符</td>
<td><code>A</code>，<code>AA</code>，<code>AAA</code>，……</td>
</tr>
<tr class="odd">
<td><code>A?</code></td>
<td>0个或1个字符</td>
<td>空，<code>A</code></td>
</tr>
<tr class="even">
<td><code>A&#123;3&#125;</code></td>
<td>指定个数字符</td>
<td><code>AAA</code></td>
</tr>
<tr class="odd">
<td><code>A&#123;2,3&#125;</code></td>
<td>指定范围个数字符</td>
<td><code>AA</code>，<code>AAA</code></td>
</tr>
<tr class="even">
<td><code>A&#123;2,&#125;</code></td>
<td>至少n个字符</td>
<td><code>AA</code>，<code>AAA</code>，<code>AAAA</code>，……</td>
</tr>
<tr class="odd">
<td><code>A&#123;0,3&#125;</code></td>
<td>最多n个字符</td>
<td>空，<code>A</code>，<code>AA</code>，<code>AAA</code></td>
</tr>
</tbody>
</table>
<h3 id="三复杂匹配规则">三、复杂匹配规则：</h3>
<h4 id="匹配开头结尾">1、匹配开头结尾：</h4>
<p>​
进行多行匹配时，用<code>^</code>表示开头，<code>$</code>表示结尾。例如，<code>^A\d&#123;3&#125;$</code>，可以匹配<code>"A001"</code>、<code>"A380"</code>。</p>
<h4 id="匹配指定范围">2、匹配指定范围：</h4>
<p>​
<strong>使用<code>[...]</code>可以匹配范围内的字符</strong>，例如，<code>[123456789]</code>可以匹配<code>1</code>~<code>9</code>，这样就可以写出上述电话号码的规则：<code>[123456789]\d&#123;6,7&#125;</code>。</p>
<p>​
把所有字符全列出来太麻烦，<code>[...]</code>还有一种写法，直接写<code>[1-9]</code>就可以。</p>
<p>​
<strong>要匹配大小写不限的十六进制数，比如<code>1A2b3c</code>，我们可以这样写：<code>[0-9a-fA-F]</code>，它表示一共可以匹配以下任意范围的字符：</strong></p>
<ul>
<li><code>0-9</code>：字符<code>0</code>~<code>9</code>；</li>
<li><code>a-f</code>：字符<code>a</code>~<code>f</code>；</li>
<li><code>A-F</code>：字符<code>A</code>~<code>F</code>。</li>
</ul>
<p>​
<strong><code>[...]</code>还有一种排除法，即不包含指定范围的字符。假设我们要匹配任意字符，但不包括数字，可以写<code>[^1-9]&#123;3&#125;</code>：</strong></p>
<ul>
<li>可以匹配<code>"ABC"</code>，因为不包含字符<code>1</code>~<code>9</code>；</li>
<li>可以匹配<code>"A00"</code>，因为不包含字符<code>1</code>~<code>9</code>；</li>
<li>不能匹配<code>"A01"</code>，因为包含字符<code>1</code>；</li>
<li>不能匹配<code>"A05"</code>，因为包含字符<code>5</code>。</li>
</ul>
<h4 id="或规则匹配">3、或规则匹配：</h4>
<p>​
用<code>|</code>连接的两个正则规则是<em>或</em>规则，例如，<code>AB|CD</code>表示可以匹配<code>AB</code>或<code>CD</code>。</p>
<h4 id="使用括号">4、使用括号:</h4>
<p>​
现在我们想要匹配字符串<code>learn java</code>、<code>learn php</code>和<code>learn go</code>怎么办？一个最简单的规则是<code>learn\sjava|learn\sphp|learn\sgo</code>，但是这个规则太复杂了，可以把公共部分提出来，然后用<code>(...)</code>把子规则括起来表示成<code>learn\\s(java|php|go)</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">re</span> <span class="operator">=</span> <span class="string">&quot;learn\\s(java|php|go)&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="规则总结">5、规则总结：</h4>
<p>复杂匹配规则主要有：</p>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 30%" />
<col style="width: 54%" />
</colgroup>
<thead>
<tr class="header">
<th>正则表达式</th>
<th>规则</th>
<th>可以匹配</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>^</td>
<td>开头</td>
<td>字符串开头</td>
</tr>
<tr class="even">
<td>$</td>
<td>结尾</td>
<td>字符串结束</td>
</tr>
<tr class="odd">
<td>[ABC]</td>
<td>[…]内任意字符</td>
<td>A，B，C</td>
</tr>
<tr class="even">
<td>[A-F0-9xy]</td>
<td>指定范围的字符</td>
<td><code>A</code>，……，<code>F</code>，<code>0</code>，……，<code>9</code>，<code>x</code>，<code>y</code></td>
</tr>
<tr class="odd">
<td>[^A-F]</td>
<td>指定范围外的任意字符</td>
<td>非<code>A</code>~<code>F</code></td>
</tr>
<tr class="even">
<td>AB|CD|EF</td>
<td>AB或CD或EF</td>
<td><code>AB</code>，<code>CD</code>，<code>EF</code></td>
</tr>
</tbody>
</table>
<h3 id="四分组匹配-提取子串">四、分组匹配 + 提取子串：</h3>
<p>​ <code>(...)</code>还有一个重要作用，就是分组匹配。</p>
<p>​
我们来看一下如何用正则匹配<code>区号-电话号</code>码这个规则。利用前面讲到的匹配规则，写出来很容易：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\d&#123;3,4&#125;\-\d&#123;6,8&#125;</span><br></pre></td></tr></table></figure>
<p>​
虽然这个正则匹配规则很简单，但是往往匹配成功后，下一步是提取区号和电话号码，分别存入数据库。于是问题来了：<strong>如何提取匹配的子串</strong>？</p>
<p>​
当然可以用<code>String</code>提供的<code>indexOf()</code>和<code>substring()</code>这些方法，但它们从正则匹配的字符串中提取子串没有通用性，下一次要提取<code>learn\s(java|php)</code>还得改代码。</p>
<p>​
<strong>正确的方法是用<code>(...)</code>先把要提取的规则分组，把上述正则表达式变为<code>(\d&#123;3,4&#125;)\-(\d&#123;6,8&#125;)</code></strong>。然后引入<code>java.util.regex</code>包，用<code>Pattern</code>对象匹配，匹配后获得一个<code>Matcher</code>对象，如果匹配成功，就可以直接从<code>Matcher.group(index)</code>返回子串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\\d&#123;3,4&#125;)\\-(\\d&#123;7,8&#125;)&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(<span class="string">&quot;010-12345678&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (m.matches()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">g1</span> <span class="operator">=</span> m.group(<span class="number">1</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">g2</span> <span class="operator">=</span> m.group(<span class="number">2</span>);</span><br><span class="line">            System.out.println(g1);</span><br><span class="line">            System.out.println(g2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配失败!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码，会得到两个匹配上的子串<code>010</code>和<code>12345678</code>。</p>
<p>​
要特别注意，<code>Matcher.group(index)</code>方法的参数用1表示第一个子串，2表示第二个子串。如果我们传入0会得到什么呢？答案是<code>010-12345678</code>，即整个正则匹配到的字符串。</p>
<p>​
我们在前面的代码中用到的正则表达式代码是<code>String.matches()</code>方法，而我们在分组提取的代码中用的是<code>java.util.regex</code>包里面的<code>Pattern</code>类和<code>Matcher</code>类。实际上这两种代码本质上是一样的，因为<code>String.matches()</code>方法内部调用的就是<code>Pattern</code>和<code>Matcher</code>类的方法。</p>
<p>​
但是反复使用<code>String.matches()</code>对同一个正则表达式进行多次匹配效率较低，因为每次都会创建出一样的<code>Pattern</code>对象。完全可以先创建出一个<code>Pattern</code>对象，然后反复使用，就可以实现编译一次，多次匹配：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\\d&#123;3,4&#125;)\\-(\\d&#123;7,8&#125;)&quot;</span>);</span><br><span class="line">        pattern.matcher(<span class="string">&quot;010-12345678&quot;</span>).matches(); <span class="comment">// true</span></span><br><span class="line">        pattern.matcher(<span class="string">&quot;021-123456&quot;</span>).matches(); <span class="comment">// false</span></span><br><span class="line">        pattern.matcher(<span class="string">&quot;022#1234567&quot;</span>).matches(); <span class="comment">// false</span></span><br><span class="line">        <span class="comment">// 获得Matcher对象:</span></span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(<span class="string">&quot;010-12345678&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">whole</span> <span class="operator">=</span> matcher.group(<span class="number">0</span>); <span class="comment">// &quot;010-12345678&quot;, 0表示匹配的整个字符串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">area</span> <span class="operator">=</span> matcher.group(<span class="number">1</span>); <span class="comment">// &quot;010&quot;, 1表示匹配的第1个子串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">tel</span> <span class="operator">=</span> matcher.group(<span class="number">2</span>); <span class="comment">// &quot;12345678&quot;, 2表示匹配的第2个子串</span></span><br><span class="line">            System.out.println(area);</span><br><span class="line">            System.out.println(tel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
使用<code>Matcher</code>时，必须首先调用<code>matches()</code>判断是否匹配成功，匹配成功后，才能调用<code>group()</code>提取子串。</p>
<p>​ 利用提取子串的功能，我们轻松获得了区号和号码两部分。</p>
<h3 id="五非贪婪匹配">五、非贪婪匹配：</h3>
<p>先看一个简单的问题：</p>
<p>给定一个字符串表示的数字，判断该数字末尾<code>0</code>的个数。例如：</p>
<ul>
<li><code>"123000"</code>：3个<code>0</code></li>
<li><code>"10100"</code>：2个<code>0</code></li>
<li><code>"1001"</code>：0个<code>0</code></li>
</ul>
<p>可以很容易地写出该正则表达式：<code>(\d+)(0*)</code>，Java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\\d+)(0*)&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(<span class="string">&quot;1230000&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;group1=&quot;</span> + matcher.group(<span class="number">1</span>)); <span class="comment">// &quot;1230000&quot;</span></span><br><span class="line">            System.out.println(<span class="string">&quot;group2=&quot;</span> + matcher.group(<span class="number">2</span>)); <span class="comment">// &quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然而打印的第二个子串是空字符串<code>""</code>。</p>
<p>实际上，我们期望分组匹配结果是：</p>
<table>
<thead>
<tr class="header">
<th>input</th>
<th><code>\d+</code></th>
<th><code>0*</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>123000</td>
<td>"123"</td>
<td>"000"</td>
</tr>
<tr class="even">
<td>10100</td>
<td>"101"</td>
<td>"00"</td>
</tr>
<tr class="odd">
<td>1001</td>
<td>"1001"</td>
<td>""</td>
</tr>
</tbody>
</table>
<p>但实际的分组匹配结果是这样的：</p>
<table>
<thead>
<tr class="header">
<th>input</th>
<th><code>\d+</code></th>
<th><code>0*</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>123000</td>
<td>"123000"</td>
<td>""</td>
</tr>
<tr class="even">
<td>10100</td>
<td>"10100"</td>
<td>""</td>
</tr>
<tr class="odd">
<td>1001</td>
<td>"1001"</td>
<td>""</td>
</tr>
</tbody>
</table>
<p>​
仔细观察上述实际匹配结果，实际上它是完全合理的，因为<code>\d+</code>确实可以匹配后面任意个<code>0</code>。</p>
<p>​
<strong>这是因为正则表达式默认使用贪婪匹配：任何一个规则，它总是尽可能多地向后匹配，因此，<code>\d+</code>总是会把后面的<code>0</code>包含进来。</strong></p>
<p>​
<strong>要让<code>\d+</code>尽量少匹配，让<code>0*</code>尽量多匹配，我们就必须让<code>\d+</code>使用非贪婪匹配。在规则<code>\d+</code>后面加个<code>?</code>即可表示非贪婪匹配。我们改写正则表达式如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\\d+?)(0*)&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(<span class="string">&quot;1230000&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;group1=&quot;</span> + matcher.group(<span class="number">1</span>)); <span class="comment">// &quot;123&quot;</span></span><br><span class="line">            System.out.println(<span class="string">&quot;group2=&quot;</span> + matcher.group(<span class="number">2</span>)); <span class="comment">// &quot;0000&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
<strong>因此，给定一个匹配规则，加上<code>?</code>后就变成了非贪婪匹配。</strong></p>
<p>​
<strong>我们再来看这个正则表达式<code>(\d??)(9*)</code>，注意<code>\d?</code>表示匹配0个或1个数字，后面第二个<code>?</code>表示非贪婪匹配，因此，给定字符串<code>"9999"</code>，匹配到的两个子串分别是<code>""</code>和<code>"9999"</code>，因为对于<code>\d?</code>来说，可以匹配1个<code>9</code>，也可以匹配0个<code>9</code>，但是因为后面的<code>?</code>表示非贪婪匹配，它就会尽可能少的匹配，结果是匹配了0个<code>9</code>。</strong></p>
<h3 id="六搜索和替换">六、搜索和替换：</h3>
<h4 id="分割字符串">1、分割字符串：</h4>
<p>​
使用正则表达式分割字符串可以实现更加灵活的功能。<code>String.split()</code>方法传入的正是正则表达式。我们来看下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;a b c&quot;.split(&quot;\\s&quot;); // &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot; &#125;</span><br><span class="line">&quot;a b  c&quot;.split(&quot;\\s&quot;); // &#123; &quot;a&quot;, &quot;b&quot;, &quot;&quot;, &quot;c&quot; &#125;</span><br><span class="line">&quot;a, b ;; c&quot;.split(&quot;[\\,\\;\\s]+&quot;); // &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot; &#125;</span><br></pre></td></tr></table></figure>
<p>​
如果我们想让用户输入一组标签，然后把标签提取出来，因为用户的输入往往是不规范的，这时，使用合适的正则表达式，就可以消除多个空格、混合<code>,</code>和<code>;</code>这些不规范的输入，直接提取出规范的字符串。</p>
<h4 id="搜索字符串">2、搜索字符串：</h4>
<p>​ 使用正则表达式还可以搜索字符串，我们来看例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;the quick brown fox jumps over the lazy dog.&quot;</span>;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\wo\\w&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(s);</span><br><span class="line">        <span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> s.substring(m.start(), m.end());</span><br><span class="line">            System.out.println(sub);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
我们获取到<code>Matcher</code>对象后，不需要调用<code>matches()</code>方法（因为匹配整个串肯定返回false），而是反复调用<code>find()</code>方法，在整个串中搜索能匹配上<code>\\wo\\w</code>规则的子串，并打印出来。<strong>这种方式比<code>String.indexOf()</code>要灵活得多，因为我们搜索的规则是3个字符：中间必须是<code>o</code>，前后两个必须是字符<code>[A-Za-z0-9_]</code>。</strong></p>
<h4 id="替换字符串">3、替换字符串：</h4>
<p>​
使用正则表达式替换字符串可以直接调用<code>String.replaceAll()</code>，它的第一个参数是正则表达式，第二个参数是待替换的字符串。我们还是来看例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;The     quick\t\t brown   fox  jumps   over the  lazy dog.&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> s.replaceAll(<span class="string">&quot;\\s+&quot;</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println(r); <span class="comment">// &quot;The quick brown fox jumps over the lazy dog.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>⑤  编程语言类笔记</category>
        <category>java入门系列笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java系列笔记10——java单元测试JUnit</title>
    <url>/2022/02/02/e8aa8ccaa4fe/</url>
    <content><![CDATA[<p>参考教程网址：https://www.liaoxuefeng.com/wiki/1252599548343744/1304048154181666</p>
<h3 id="一编写junit测试">一、编写JUnit测试：</h3>
<h4 id="什么是测试驱动开发">1、什么是测试驱动开发？</h4>
<p>​
所谓测试驱动开发，是指先编写接口，紧接着编写测试。编写完测试后，我们才开始真正编写实现代码。在编写实现代码的过程中，一边写，一边测，什么时候测试全部通过了，那就表示编写的实现完成了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    编写接口</span><br><span class="line">     │</span><br><span class="line">     ▼</span><br><span class="line">    编写测试</span><br><span class="line">     │</span><br><span class="line">     ▼</span><br><span class="line">┌─&gt; 编写实现</span><br><span class="line">│    │</span><br><span class="line">│ N  ▼</span><br><span class="line">└── 运行测试</span><br><span class="line">     │ Y</span><br><span class="line">     ▼</span><br><span class="line">    任务完成</span><br></pre></td></tr></table></figure>
<h4 id="junit测试框架">2、JUnit测试框架：</h4>
<p>​
JUnit是一个开源的Java语言的单元测试框架，专门针对Java设计，使用最广泛。JUnit是事实上的单元测试的标准框架，任何Java开发者都应当学习并使用JUnit编写单元测试</p>
<p>​
使用JUnit编写单元测试的好处在于，我们可以非常简单地组织测试代码，并随时运行它们，JUnit就会给出成功的测试和失败的测试，还可以生成测试报告，不仅包含测试的成功率，还可以统计测试的代码覆盖率，即被测试的代码本身有多少经过了测试。对于高质量的代码来说，测试覆盖率应该在80%以上。</p>
<h4 id="intellij中如何开启单元测试">3、IntelliJ中如何开启单元测试？</h4>
<p>​
教程：https://blog.csdn.net/qq754772661/article/details/107790362</p>
<h4 id="单元测试文件怎么编写">4、单元测试文件怎么编写？</h4>
<p>​
核心测试方法<code>testFact()</code>加上了<code>@Test</code>注解，这是JUnit要求的，它会把带有<code>@Test</code>的方法识别为测试方法。在测试方法内部，我们用<code>assertEquals(1, Factorial.fact(1))</code>表示，期望<code>Factorial.fact(1)</code>返回<code>1</code>。<code>assertEquals(expected, actual)</code>是最常用的测试方法，它在<code>Assertion</code>类中定义。<code>Assertion</code>还定义了其他断言方法，例如：</p>
<ul>
<li><code>assertTrue()</code>: 期待结果为<code>true</code></li>
<li><code>assertFalse()</code>: 期待结果为<code>false</code></li>
<li><code>assertNotNull()</code>: 期待结果为非<code>null</code></li>
<li><code>assertArrayEquals()</code>:
期待结果为数组并与期望数组每个元素的值均相等</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itranswarp.learnjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactorialTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testFact</span><span class="params">()</span> &#123;</span><br><span class="line">        assertEquals(<span class="number">1</span>, Factorial.fact(<span class="number">1</span>));</span><br><span class="line">        assertEquals(<span class="number">2</span>, Factorial.fact(<span class="number">2</span>));</span><br><span class="line">        assertEquals(<span class="number">6</span>, Factorial.fact(<span class="number">3</span>));</span><br><span class="line">        assertEquals(<span class="number">3628800</span>, Factorial.fact(<span class="number">10</span>));</span><br><span class="line">        assertEquals(<span class="number">2432902008176640000L</span>, Factorial.fact(<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写完成后，在编译器内直接选择运行该文件即可。</p>
<h4 id="单元测试的结果">5、单元测试的结果：</h4>
<ul>
<li>如果全部通过测试：</li>
</ul>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_02_10_13_50_410.png"
alt="屏幕捕获_2022_02_02_10_13_50_410" />
<figcaption
aria-hidden="true">屏幕捕获_2022_02_02_10_13_50_410</figcaption>
</figure>
<ul>
<li>如果有案例通不过测试：</li>
</ul>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_02_10_14_11_224.png"
alt="屏幕捕获_2022_02_02_10_14_11_224" />
<figcaption
aria-hidden="true">屏幕捕获_2022_02_02_10_14_11_224</figcaption>
</figure>
<h4 id="单元测试的好处">6、单元测试的好处：</h4>
<p>​
单元测试可以确保单个方法按照正确预期运行，如果修改了某个方法的代码，只需确保其对应的单元测试通过，即可认为改动正确。此外，测试代码本身就可以作为示例代码，用来演示如何调用该方法。</p>
<p>​
使用JUnit进行单元测试，我们可以使用断言（<code>Assertion</code>）来测试期望结果，可以方便地组织和运行测试，并方便地查看测试结果。此外，<strong>JUnit既可以直接在IDE中运行，也可以方便地集成到Maven这些自动化工具中运行。</strong></p>
<p>在编写单元测试的时候，我们要遵循一定的规范：</p>
<p>​
一是单元测试代码本身必须非常简单，能一下看明白，决不能再为测试代码编写测试；</p>
<p>​ 二是每个单元测试应当互相独立，不依赖运行的顺序；</p>
<p>​
<strong>三是测试时不但要覆盖常用测试用例，还要特别注意测试边界条件，例如输入为<code>0</code>，<code>null</code>，空字符串<code>""</code>等情况。</strong></p>
<h3 id="二使用fixture">二、使用Fixture</h3>
<p>​
在一个单元测试中，我们经常编写多个<code>@Test</code>方法，来分组、分类对目标代码进行测试。在测试的时候，我们经常遇到一个对象需要初始化，测试完可能还需要清理的情况。如果每个<code>@Test</code>方法都写一遍这样的重复代码，显然比较麻烦。</p>
<p>​
<strong>JUnit提供了编写测试前准备、测试后清理的固定代码，我们称之为Fixture。</strong></p>
<ul>
<li>以下为要测试的代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">        n = n + x;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sub</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">        n = n - x;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
这个类的功能很简单，但是测试的时候，我们要先初始化对象，我们不必在每个测试方法中都写上初始化代码，而是<strong>通过<code>@BeforeEach</code>来初始化，通过<code>@AfterEach</code>来清理资源：</strong>如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    Calculator calculator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.calculator = <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.calculator = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testAdd</span><span class="params">()</span> &#123;</span><br><span class="line">        assertEquals(<span class="number">100</span>, <span class="built_in">this</span>.calculator.add(<span class="number">100</span>));</span><br><span class="line">        assertEquals(<span class="number">150</span>, <span class="built_in">this</span>.calculator.add(<span class="number">50</span>));</span><br><span class="line">        assertEquals(<span class="number">130</span>, <span class="built_in">this</span>.calculator.add(-<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSub</span><span class="params">()</span> &#123;</span><br><span class="line">        assertEquals(-<span class="number">100</span>, <span class="built_in">this</span>.calculator.sub(<span class="number">100</span>));</span><br><span class="line">        assertEquals(-<span class="number">150</span>, <span class="built_in">this</span>.calculator.sub(<span class="number">50</span>));</span><br><span class="line">        assertEquals(-<span class="number">130</span>, <span class="built_in">this</span>.calculator.sub(-<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
还有一些资源初始化和清理可能更加繁琐，而且会耗费较长的时间，例如初始化数据库。**JUnit还提供了<code>@BeforeAll</code>和<code>@AfterAll</code>，它们在运行所有@Test前后运行。</p>
<p>​
因为<code>@BeforeAll</code>和<code>@AfterAll</code>在所有<code>@Test</code>方法运行前后仅运行一次，因此，它们只能初始化静态变量。</p>
<p><strong>事实上，<code>@BeforeAll</code>和<code>@AfterAll</code>也只能标注在静态方法上。</strong></p>
<p><strong>因此，我们总结出编写Fixture的套路如下：</strong></p>
<ol type="1">
<li>对于实例变量，在<code>@BeforeEach</code>中初始化，在<code>@AfterEach</code>中清理，它们在各个<code>@Test</code>方法中互不影响，因为是不同的实例；</li>
<li>对于静态变量，在<code>@BeforeAll</code>中初始化，在<code>@AfterAll</code>中清理，它们在各个<code>@Test</code>方法中均是唯一实例，会影响各个<code>@Test</code>方法。</li>
</ol>
<p>​
大多数情况下，使用<code>@BeforeEach</code>和<code>@AfterEach</code>就足够了。只有某些测试资源初始化耗费时间太长，以至于我们不得不尽量“复用”时才会用到<code>@BeforeAll</code>和<code>@AfterAll</code>。</p>
<p>​
<strong>最后，注意到每次运行一个<code>@Test</code>方法前，JUnit首先创建一个<code>XxxTest</code>实例，因此，每个<code>@Test</code>方法内部的成员变量都是独立的，不能也无法把成员变量的状态从一个<code>@Test</code>方法带到另一个<code>@Test</code>方法。</strong></p>
<h3 id="三异常测试">三、异常测试：</h3>
<p>​
对于可能抛出的异常进行测试，本身就是测试的重要环节。在编写JUnit测试的时候，除了正常的输入输出，我们还要特别针对可能导致异常的情况进行测试。示例如下：</p>
<ul>
<li>被测试代码如下：在方法入口，我们增加了对参数<code>n</code>的检查，如果为负数，则直接抛出<code>IllegalArgumentException</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">fact</span><span class="params">(<span class="type">long</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            r = r * i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testNegative</span><span class="params">()</span> &#123;</span><br><span class="line">    assertThrows(IllegalArgumentException.class, () -&gt; &#123;</span><br><span class="line">        Factorial.fact(-<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四条件测试">四、条件测试：</h3>
<h4 id="disabled">1、<span class="citation"
data-cites="Disabled">@Disabled</span></h4>
<p>​
在运行测试的时候，有些时候，我们需要排出某些<code>@Test</code>方法，不要让它运行，这时，我们就可以给它标记一个<code>@Disabled</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Disabled</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBug101</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这个测试不会运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
为什么我们不直接注释掉<code>@Test</code>，而是要加一个<code>@Disabled</code>？这是因为注释掉<code>@Test</code>，JUnit就不知道这是个测试方法，而加上<code>@Disabled</code>，JUnit仍然识别出这是个测试方法，只是暂时不运行。它会在测试结果中显示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tests run: 68, Failures: 2, Errors: 0, Skipped: 5</span><br></pre></td></tr></table></figure>
<p>​
类似<code>@Disabled</code>这种注解就称为条件测试，JUnit根据不同的条件注解，决定是否运行当前的<code>@Test</code>方法。</p>
<h4 id="enabledonos">2、<span class="citation"
data-cites="EnabledOnOs">@EnabledOnOs</span></h4>
<p>给两个测试方法分别加上条件如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@EnabledOnOs(OS.WINDOWS)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testWindows</span><span class="params">()</span> &#123;</span><br><span class="line">    assertEquals(<span class="string">&quot;C:\\test.ini&quot;</span>, config.getConfigFile(<span class="string">&quot;test.ini&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@EnabledOnOs(&#123; OS.LINUX, OS.MAC &#125;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testLinuxAndMac</span><span class="params">()</span> &#123;</span><br><span class="line">    assertEquals(<span class="string">&quot;/usr/local/test.cfg&quot;</span>, config.getConfigFile(<span class="string">&quot;test.cfg&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@EnableOnOs</code>就是一个条件测试判断。</p>
<p>在Windows平台执行的测试: <span class="citation"
data-cites="EnabledOnOs">@EnabledOnOs</span>(OS.WINDOWS)</p>
<h4 id="其他条件测试">3、其他条件测试：</h4>
<p>只能在Java
9或更高版本执行的测试，可以加上<code>@DisabledOnJre(JRE.JAVA_8)</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisabledOnJre(JRE.JAVA_8)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testOnJava9OrAbove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> this test is disabled on java 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只能在64位操作系统上执行的测试，可以用<code>@EnabledIfSystemProperty</code>判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@EnabledIfSystemProperty(named = &quot;os.arch&quot;, matches = &quot;.*64.*&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testOnlyOn64bitSystem</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> this test is only run on 64 bit system</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要传入环境变量<code>DEBUG=true</code>才能执行的测试，可以用<code>@EnabledIfEnvironmentVariable</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@EnabledIfEnvironmentVariable(named = &quot;DEBUG&quot;, matches = &quot;true&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testOnlyOnDebugMode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> this test is only run on DEBUG=true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五参数化测试">五、参数化测试：</h3>
<p>如果待测试的输入和输出是一组数据： 可以把测试数据组织起来
用不同的测试数据调用相同的测试方法</p>
<p>参数化测试和普通测试稍微不同的地方在于，一个测试方法需要接收至少一个参数，然后，传入一组参数反复运行。</p>
<p>JUnit提供了一个<code>@ParameterizedTest</code>注解，用来进行参数化测试。</p>
<p>假设我们想对<code>Math.abs()</code>进行测试，先用一组正数进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource(ints = &#123; 0, 1, 5, 100 &#125;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testAbs</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    assertEquals(x, Math.abs(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再用一组负数进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource(ints = &#123; -1, -5, -100 &#125;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testAbsNegative</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    assertEquals(-x, Math.abs(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到参数化测试的注解是<code>@ParameterizedTest</code>，而不是普通的<code>@Test</code>。</p>
<p>实际的测试场景往往没有这么简单。假设我们自己编写了一个<code>StringUtils.capitalize()</code>方法，它会把字符串的第一个字母变为大写，后续字母变为小写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">capitalize</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Character.toUpperCase(s.charAt(<span class="number">0</span>)) + s.substring(<span class="number">1</span>).toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要用参数化测试的方法来测试，我们不但要给出输入，还要给出预期输出。因此，测试方法至少需要接收两个参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCapitalize</span><span class="params">(String input, String result)</span> &#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在问题来了：参数如何传入？</p>
<p>最简单的方法是通过<code>@MethodSource</code>注解，它允许我们编写一个同名的静态方法来提供测试参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@MethodSource</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCapitalize</span><span class="params">(String input, String result)</span> &#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> List&lt;Arguments&gt; <span class="title function_">testCapitalize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> List.of( <span class="comment">// arguments:</span></span><br><span class="line">            Arguments.arguments(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;Abc&quot;</span>), <span class="comment">//</span></span><br><span class="line">            Arguments.arguments(<span class="string">&quot;APPLE&quot;</span>, <span class="string">&quot;Apple&quot;</span>), <span class="comment">//</span></span><br><span class="line">            Arguments.arguments(<span class="string">&quot;gooD&quot;</span>, <span class="string">&quot;Good&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码很容易理解：静态方法<code>testCapitalize()</code>返回了一组测试参数，每个参数都包含两个<code>String</code>，正好作为测试方法的两个参数传入。</p>
<p>如果静态方法和测试方法的名称不同，<span class="citation"
data-cites="MethodSource也允许指定方法名">@MethodSource也允许指定方法名</span>。但使用默认同名方法最方便。</p>
<p>另一种传入测试参数的方法是使用<code>@CsvSource</code>，它的每一个字符串表示一行，一行包含的若干参数用<code>,</code>分隔，因此，上述测试又可以改写如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@CsvSource(&#123; &quot;abc, Abc&quot;, &quot;APPLE, Apple&quot;, &quot;gooD, Good&quot; &#125;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCapitalize</span><span class="params">(String input, String result)</span> &#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有成百上千的测试输入，那么，直接写<code>@CsvSource</code>就很不方便。这个时候，我们可以把测试数据提到一个独立的CSV文件中，然后标注上<code>@CsvFileSource</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@CsvFileSource(resources = &#123; &quot;/test-capitalize.csv&quot; &#125;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCapitalizeUsingCsvFile</span><span class="params">(String input, String result)</span> &#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JUnit只在classpath中查找指定的CSV文件，因此，<code>test-capitalize.csv</code>这个文件要放到<code>test</code>目录下，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apple, Apple</span><br><span class="line">HELLO, Hello</span><br><span class="line">JUnit, Junit</span><br><span class="line">reSource, Resource</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>⑤  编程语言类笔记</category>
        <category>java入门系列笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java系列笔记9——java 日期与时间（更新中）</title>
    <url>/2022/02/01/671534cf591b/</url>
    <content><![CDATA[<p>参考教程网址：https://www.liaoxuefeng.com/wiki/1252599548343744/1298613246361634</p>
<h3 id="一基本概念">一、基本概念：</h3>
<h4 id="本地时间">1、本地时间</h4>
<p>​
不同的时区，在同一时刻，本地时间是不同的。全球一共分为24个时区，<strong>伦敦所在的时区称为标准时区，其他时区按东／西偏移的小时区分，北京所在的时区是东八区。</strong></p>
<h4 id="时区">2、时区</h4>
<p>​
因为光靠本地时间还无法唯一确定一个准确的时刻，所以我们还需要给本地时间加上一个时区。时区有好几种表示方式。</p>
<p>​
一种是以<code>GMT</code>或者<code>UTC</code>加时区偏移表示，例如：<code>GMT+08:00</code>或者<code>UTC+08:00</code>表示东八区。</p>
<p>​
<code>GMT</code>和<code>UTC</code>可以认为基本是等价的，只是<code>UTC</code>使用更精确的原子钟计时，每隔几年会有一个闰秒，我们在开发程序的时候可以忽略两者的误差，因为计算机的时钟在联网的时候会自动与时间服务器同步时间。</p>
<p>​
另一种是缩写，例如，<code>CST</code>表示<code>China Standard Time</code>，也就是中国标准时间。但是<code>CST</code>也可以表示美国中部时间<code>Central Standard Time USA</code>，因此，缩写容易产生混淆，我们尽量不要使用缩写。</p>
<p>​
最后一种是以洲／城市表示，例如，<code>Asia/Shanghai</code>，表示上海所在地的时区。特别注意城市名称不是任意的城市，而是由国际标准组织规定的城市。</p>
<p>​
因为时区的存在，东八区的2019年11月20日早上8:15，和西五区的2019年11月19日晚上19:15，他们的时刻是相同的</p>
<h4 id="夏令时">3、夏令时</h4>
<p>​
时区还不是最复杂的，更复杂的是夏令时。所谓夏令时，就是夏天开始的时候，把时间往后拨1小时，夏天结束的时候，再把时间往前拨1小时。</p>
<p>​
因为涉及到夏令时，相同的时区，如果表示的方式不同，转换出的时间是不同的。我们举个栗子：</p>
<p>对于2019-11-20和2019-6-20两个日期来说，假设北京人在纽约：</p>
<ul>
<li>如果以<code>GMT</code>或者<code>UTC</code>作为时区，无论日期是多少，时间都是<code>19:00</code>；</li>
<li>如果以国家／城市表示，例如<code>America／NewYork</code>，虽然纽约也在西五区，但是，因为夏令时的存在，在不同的日期，<code>GMT</code>时间和纽约时间可能是不一样的：</li>
</ul>
<table>
<thead>
<tr class="header">
<th>时区</th>
<th>2019-11-20</th>
<th>2019-6-20</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>GMT-05:00</td>
<td>19:00</td>
<td>19:00</td>
</tr>
<tr class="even">
<td>UTC-05:00</td>
<td>19:00</td>
<td>19:00</td>
</tr>
<tr class="odd">
<td>America/New_York</td>
<td>19:00</td>
<td>20:00</td>
</tr>
</tbody>
</table>
<p>​
实行夏令时的不同地区，进入和退出夏令时的时间很可能是不同的。同一个地区，根据历史上是否实行过夏令时，标准时间在不同年份换算成当地时间也是不同的。因此，计算夏令时，没有统一的公式，必须按照一组给定的规则来算，并且，该规则要定期更新。</p>
<h4 id="本地化">4、本地化</h4>
<p>​
在计算机中，通常使用<code>Locale</code>表示一个国家或地区的日期、时间、数字、货币等格式。<code>Locale</code>由<code>语言_国家</code>的字母缩写构成，例如，<code>zh_CN</code>表示中文+中国，<code>en_US</code>表示英文+美国。语言使用小写，国家使用大写。</p>
<p>对于日期来说，不同的Locale，例如，中国和美国的表示方式如下：</p>
<ul>
<li>zh_CN：2016-11-30</li>
<li>en_US：11/30/2016</li>
</ul>
<p>​
计算机用<code>Locale</code>在日期、时间、货币和字符串之间进行转换。一个电商网站会根据用户所在的<code>Locale</code>对用户显示如下：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>中国用户</th>
<th>美国用户</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>购买价格</td>
<td>12000.00</td>
<td>12,000.00</td>
</tr>
<tr class="even">
<td>购买日期</td>
<td>2016-11-30</td>
<td>11/30/2016</td>
</tr>
</tbody>
</table>
<h3 id="二date和calendar">二、Date和Calendar</h3>
<p>​
这个“同一个时刻”在计算机中存储的本质上只是一个整数，我们称它为<code>Epoch Time</code></p>
<p>​
<code>Epoch Time</code>是计算从1970年1月1日零点（格林威治时区／GMT+00:00）到现在所经历的秒数，例如：</p>
<p>​
<code>1574208900</code>表示从从1970年1月1日零点GMT时区到该时刻一共经历了1574208900秒，换算成伦敦、北京和纽约时间分别是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1574208900 = 北京时间2019-11-20 8:15:00</span><br><span class="line">           = 伦敦时间2019-11-20 0:15:00</span><br><span class="line">           = 纽约时间2019-11-19 19:15:00</span><br></pre></td></tr></table></figure>
<p><code>Epoch Time</code>又称为时间戳，在不同的编程语言中，会有几种存储方式：</p>
<ul>
<li>以秒为单位的整数：1574208900，缺点是精度只能到秒；</li>
<li>以毫秒为单位的整数：1574208900123，最后3位表示毫秒数；</li>
<li>以秒为单位的浮点数：1574208900.123，小数点后面表示零点几秒。</li>
</ul>
<p><strong>在Java程序中，时间戳通常是用<code>long</code>表示的毫秒数，即：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long t = 1574208900123L;</span><br></pre></td></tr></table></figure>
<p><strong>转换成北京时间就是<code>2019-11-20T8:15:00.123</code>。要获取当前时间戳，可以使用<code>System.currentTimeMillis()</code>，这是Java程序获取时间戳最常用的方法。</strong></p>
]]></content>
      <categories>
        <category>⑤  编程语言类笔记</category>
        <category>java入门系列笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java系列笔记8——java IO模块（更新中）</title>
    <url>/2022/02/01/d6f26999810e/</url>
    <content><![CDATA[<p>参考教程网址：https://www.liaoxuefeng.com/wiki/1252599548343744/1255945227202752</p>
<h3 id="一简介">一、简介：</h3>
<p>​
在Java中，<code>InputStream</code>代表输入字节流，<code>OuputStream</code>代表输出字节流，这是最基本的两种IO流。</p>
<p>​
如果我们需要读写的是字符，并且字符不全是单字节表示的ASCII字符，那么，按照<code>char</code>来读写显然更方便，这种流称为<strong>字符流</strong>。Java提供了<code>Reader</code>和<code>Writer</code>表示字符流，字符流传输的最小数据单位是<code>char</code>。</p>
<p>​
<code>Reader</code>和<code>Writer</code><strong>本质上是一个能自动编解码的<code>InputStream</code>和<code>OutputStream</code></strong>。</p>
<p>​
<strong>使用<code>Reader</code>，数据源虽然是字节，但我们读入的数据都是<code>char</code>类型的字符，原因是<code>Reader</code>内部把读入的<code>byte</code>做了解码，转换成了<code>char</code>。</strong></p>
<p>​
<strong>使用<code>InputStream</code>，我们读入的数据和原始二进制数据一模一样，是<code>byte[]</code>数组</strong>，但是我们可以自己把二进制<code>byte[]</code>数组按照某种编码转换为字符串。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220811092720148.png" style="zoom:67%;" /></p>
<h3 id="二常用的文件操作file对象">二、常用的文件操作：File对象：</h3>
<h4 id="构造file对象">1、构造File对象</h4>
<p>​
Java的标准库<code>java.io</code>提供了<code>File</code>对象来操作文件和目录。</p>
<p>​ 要构造一个<code>File</code>对象，需要传入文件路径，
<code>File</code>对象既可以表示文件，也可以表示目录。特别要注意的是，<strong>构造一个<code>File</code>对象，即使传入的文件或目录不存在，代码也不会出错</strong>，因为构造一个<code>File</code>对象，并不会导致任何磁盘操作。<strong>只有当我们调用<code>File</code>对象的某些方法的时候，才真正进行磁盘操作</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Windows\\notepad.exe&quot;</span>);  </span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">File</span>(File Parent,String child);  <span class="comment">//根据父目录文件 + 子路径</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">File</span>(String Parent,String child); <span class="comment">//估计父目录 + 子路径</span></span><br></pre></td></tr></table></figure>
<ul>
<li>其实现了Serializable和Comparable接口</li>
</ul>
<h4 id="file常用函数与信息">2、File常用函数与信息</h4>
<ul>
<li><code>getPath()</code>，返回构造方法传入的路径</li>
<li><code>getAbsolutePath()</code>，返回绝对路径</li>
<li><code>getCanonicalPath()</code>，它和绝对路径类似，但是返回的是规范路径。</li>
</ul>
<p><strong>什么是规范路径？</strong></p>
<p>​
绝对路径可以表示成<code>C:\Windows\System32\..\notepad.exe</code>，而<strong>规范路径就是把<code>.</code>和<code>..</code>转换成标准的绝对路径后的路径</strong>：<code>C:\Windows\notepad.exe</code>。</p>
<ul>
<li><code>isFile()</code>，判断该<code>File</code>对象是否是一个已存在的文件</li>
<li><code>isDirectory()</code>，判断该<code>File</code>对象是否是一个已存在的目录：</li>
</ul>
<p><strong>用<code>File</code>对象获取到一个文件时，还可以进一步判断文件的权限和大小：</strong></p>
<ul>
<li><code>boolean canRead()</code>：是否可读；</li>
<li><code>boolean canWrite()</code>：是否可写；</li>
<li><code>boolean canExecute()</code>：是否可执行；</li>
<li><code>long length()</code>：文件字节大小。</li>
</ul>
<p>对目录而言，是否可执行表示能否列出它包含的文件和子目录。</p>
<h4 id="创建和删除文件">3、创建和删除文件：</h4>
<p>​
当File对象表示一个文件时，可以通过<code>createNewFile()</code>创建一个新文件，用<code>delete()</code>删除该文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/path/to/file&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (file.createNewFile()) &#123;</span><br><span class="line">    <span class="comment">// 文件创建成功:</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">    <span class="keyword">if</span> (file.delete()) &#123;</span><br><span class="line">        <span class="comment">// 删除文件成功:</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
有些时候，程序需要读写一些临时文件，<strong>File对象提供了<code>createTempFile()</code>来创建一个临时文件</strong>，以及<code>deleteOnExit()</code>在JVM退出时自动删除该文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> File.createTempFile(<span class="string">&quot;tmp-&quot;</span>, <span class="string">&quot;.txt&quot;</span>); <span class="comment">// 提供临时文件的前缀和后缀</span></span><br><span class="line">        f.deleteOnExit(); <span class="comment">// JVM退出时自动删除</span></span><br><span class="line">        System.out.println(f.isFile());</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="number">6</span></span><br></pre></td></tr></table></figure>
<h4 id="创建和删除目录">4、创建和删除目录：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mkdir创建单级目录，mkdirs创建多级目录，delete方法删除目录</span></span><br><span class="line"><span class="type">String</span> <span class="variable">directoryPath</span> <span class="operator">=</span><span class="string">&quot;D:\\demo\\a\\b\\c&quot;</span>;</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(directoryPath);</span><br><span class="line"><span class="keyword">if</span>(file.exists())&#123;</span><br><span class="line">	System.out.printin（directoryPath+“存在..<span class="string">&quot;）；</span></span><br><span class="line"><span class="string">&#125;else&#123;</span></span><br><span class="line"><span class="string">    file.mkdirs();</span></span><br><span class="line"><span class="string">    //如果此处使用 file.mkdir()的话，会报错，因为demo/a目录尚且不存在</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="遍历文件和目录">5、遍历文件和目录：</h4>
<p>​
当File对象表示一个目录时，可以使用<code>list()</code>和<code>listFiles()</code>列出目录下的文件和子目录名。<code>listFiles()</code>提供了一系列重载方法，可以过滤不想要的文件和目录：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Windows&quot;</span>);</span><br><span class="line">        File[] fs1 = f.listFiles(); <span class="comment">// 列出所有文件和子目录</span></span><br><span class="line">        printFiles(fs1);</span><br><span class="line">        File[] fs2 = f.listFiles(<span class="keyword">new</span> <span class="title class_">FilenameFilter</span>() &#123; <span class="comment">// 仅列出.exe文件</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File dir, String name)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> name.endsWith(<span class="string">&quot;.exe&quot;</span>); <span class="comment">// 返回true表示接受该文件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        printFiles(fs2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printFiles</span><span class="params">(File[] files)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (files != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">                System.out.println(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和文件操作类似，File对象如果表示一个目录，可以通过以下方法创建和删除目录：</p>
<ul>
<li><code>boolean mkdir()</code>：创建当前File对象表示的目录；</li>
<li><code>boolean mkdirs()</code>：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来；</li>
<li><code>boolean delete()</code>：删除当前File对象表示的目录，当前目录必须为空才能删除成功。</li>
</ul>
<h4 id="path对象">6、path对象：</h4>
<p>​
Java标准库还提供了一个<code>Path</code>对象，它位于<code>java.nio.file</code>包。<code>Path</code>对象和<code>File</code>对象类似，但操作更加简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Path</span> <span class="variable">p1</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;project&quot;</span>, <span class="string">&quot;study&quot;</span>); <span class="comment">// 构造一个Path对象</span></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        <span class="type">Path</span> <span class="variable">p2</span> <span class="operator">=</span> p1.toAbsolutePath(); <span class="comment">// 转换为绝对路径</span></span><br><span class="line">        System.out.println(p2);</span><br><span class="line">        <span class="type">Path</span> <span class="variable">p3</span> <span class="operator">=</span> p2.normalize(); <span class="comment">// 转换为规范路径</span></span><br><span class="line">        System.out.println(p3);</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> p3.toFile(); <span class="comment">// 转换为File对象</span></span><br><span class="line">        System.out.println(f);</span><br><span class="line">        <span class="keyword">for</span> (Path p : Paths.get(<span class="string">&quot;..&quot;</span>).toAbsolutePath()) &#123; <span class="comment">// 可以直接遍历Path</span></span><br><span class="line">            System.out.println(<span class="string">&quot;  &quot;</span> + p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三io流原理和分类">三、I/O流原理和分类</h3>
<p>java中，对于数据的输入输出操作均以流的形式进行操作</p>
<ul>
<li>字节流、字符流</li>
<li>输入流、输出流</li>
<li>节点流，处理流/包装流</li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220811150309611.png" style="zoom:50%;" /></p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220811223739770.png" style="zoom:67%;" /></p>
<h3 id="四inputstream">四、InputStream</h3>
<h4 id="inputstream">1、InputStream</h4>
<p>​
<code>InputStream</code>并不是一个接口，而是一个抽象类，它是所有输入流的超类。</p>
<p>​
这个抽象类定义的一个最重要的方法就是<code>int read()</code>，签名如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract int read() throws IOException;</span><br></pre></td></tr></table></figure>
<p>​
这个方法会读取输入流的下一个字节，并返回字节表示的<code>int</code>值（0~255）。如果已读到末尾，返回<code>-1</code>表示不能继续读取了。</p>
<h4 id="fileinputstream-文件读取数据">2、FileInputStream
文件读取数据</h4>
<p>​
<code>FileInputStream</code>是<code>InputStream</code>的一个子类。顾名思义，<code>FileInputStream</code>就是从文件流中读取数据。下面的代码演示了如何完整地读取一个<code>FileInputStream</code>的所有字节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 创建一个FileInputStream对象:</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/readme.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> input.read(); <span class="comment">// 反复调用read()方法，直到返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(n); <span class="comment">// 打印byte的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    input.close(); <span class="comment">// 关闭流, InputStream和OutputStream都是通过close()方法来关闭流。关闭流就会释放对应的底层资源。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
我们还要注意到在读取或写入IO流的过程中，可能会发生错误，例如，文件不存在导致无法读取，没有写权限导致写入失败，等等，这些底层错误由Java虚拟机自动封装成<code>IOException</code>异常并抛出。因此，所有与IO操作相关的代码都必须正确处理<code>IOException</code>。</p>
<p>​ <strong>我们可以利用Java
7引入的新的<code>try(resource)</code>的语法</strong>，只需要编写<code>try</code>语句，让编译器自动为我们关闭资源。推荐的写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/readme.txt&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 编译器在此自动为我们写入finally并调用close()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
实际上，编译器并不会特别地为<code>InputStream</code>加上自动关闭。<strong>编译器只看<code>try(resource = ...)</code>中的对象是否实现了<code>java.lang.AutoCloseable</code>接口</strong>，如果实现了，就自动加上<code>finally</code>语句并调用<code>close()</code>方法。<code>InputStream</code>和<code>OutputStream</code>都实现了这个接口，因此，都可以用在<code>try(resource)</code>中。</p>
<h4 id="阻塞">3、阻塞</h4>
<p>​
在调用<code>InputStream</code>的<code>read()</code>方法读取数据时，我们说<code>read()</code>方法是阻塞（Blocking）的。它的意思是，对于下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">n = input.read(); <span class="comment">// 必须等待read()方法返回才能执行下一行代码</span></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> n;</span><br></pre></td></tr></table></figure>
<p>​
执行到第二行代码时，必须等<code>read()</code>方法返回后才能继续。因为读取IO流相比执行普通代码，速度会慢很多，因此，无法确定<code>read()</code>方法调用到底要花费多长时间。</p>
<h3 id="五outputstream">五、OutputStream</h3>
<p>​
和<code>InputStream</code>类似，<code>OutputStream</code>也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是<code>void write(int b)</code>，签名如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>
<p>​
这个方法会<strong>写入一个字节到输出流</strong>。要注意的是，虽然传入的是<code>int</code>参数，但只会写入一个字节，即只写入<code>int</code>最低8位表示字节的部分（相当于<code>b &amp; 0xff</code>）。</p>
<h4 id="flush方法">1、Flush方法</h4>
<p>​
要特别注意：<code>OutputStream</code>还提供了一个<code>flush()</code>方法，它的目的是<strong>将缓冲区的内容真正输出到目的地。</strong></p>
<p>​
为什么要有<code>flush()</code>？因为向磁盘、网络写入数据的时候，出于效率的考虑，操作系统并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个<code>byte[]</code>数组），等到缓冲区写满了，再一次性写入文件或者网络。对于很多IO设备来说，一次写一个字节和一次写1000个字节，花费的时间几乎是完全一样的，<strong>所以<code>OutputStream</code>有个<code>flush()</code>方法，能强制把缓冲区内容输出。</strong></p>
<p>​
<strong>通常情况下，我们不需要调用这个<code>flush()</code>方法，因为缓冲区写满了<code>OutputStream</code>会自动调用它，</strong>并且，在调用<code>close()</code>方法关闭<code>OutputStream</code>之前，也会自动调用<code>flush()</code>方法。</p>
<p>​
<strong>但是，在某些情况下，我们必须手动调用<code>flush()</code>方法。举个栗子：</strong></p>
<p>​
小明正在开发一款在线聊天软件，当用户输入一句话后，就通过<code>OutputStream</code>的<code>write()</code>方法写入网络流。小明测试的时候发现，发送方输入后，接收方根本收不到任何信息，怎么肥四？</p>
<p>​
原因就在于写入网络流是先写入内存缓冲区，等缓冲区满了才会一次性发送到网络。如果缓冲区大小是4K，则发送方要敲几千个字符后，操作系统才会把缓冲区的内容发送出去，这个时候，接收方会一次性收到大量消息。</p>
<p>​
解决办法就是每输入一句话后，立刻调用<code>flush()</code>，不管当前缓冲区是否已满，强迫操作系统把缓冲区的内容立刻发送出去。</p>
<h4 id="将若干个字节写入文件流-示例">2、将若干个字节写入文件流
示例：</h4>
<p>​
我们以<code>FileOutputStream</code>为例，演示如何将若干个字节写入文件流：</p>
<p>​
<strong>每次写入一个字节非常麻烦，更常见的方法是一次性写入若干字节。这时，可以用<code>OutputStream</code>提供的重载方法<code>void write(byte[])</code>来实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out/readme.txt&quot;</span>);</span><br><span class="line">    output.write(<span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>)); <span class="comment">// Hello</span></span><br><span class="line">    output.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
和<code>InputStream</code>一样，上述代码没有考虑到在发生异常的情况下如何正确地关闭资源。写入过程也会经常发生IO错误，例如，磁盘已满，无权限写入等等。我们需要用<code>try(resource)</code>来保证<code>OutputStream</code>在无论是否发生IO错误的时候都能够正确地关闭：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out/readme.txt&quot;</span>)) &#123;</span><br><span class="line">        output.write(<span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>)); <span class="comment">// Hello</span></span><br><span class="line">    &#125; <span class="comment">// 编译器在此自动为我们写入finally并调用close()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="阻塞-1">3、阻塞</h4>
<p>和<code>InputStream</code>一样，<code>OutputStream</code>的<code>write()</code>方法也是阻塞的。</p>
<h3 id="六文件拷贝">六、文件拷贝</h3>
<p>其实就是一边读文件一边写文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(Stringp[] args)</span>&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">srcPath</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">tgtPath</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcPath);</span><br><span class="line">		fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(tgtPath);</span><br><span class="line">		<span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];  <span class="comment">//定义一个字节数组，提高读取效果</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((readLen = fileInputStream.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">			fileOutputStream.write(buf,<span class="number">0</span>,readLen); <span class="comment">//一定要指明读取长度</span></span><br><span class="line">			<span class="comment">// fileOutputStream.write(buf);  如果使用该方法会引发错误</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="七filereader和filewriter">七、FileReader和FileWriter</h3>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220811152647890.png" style="zoom:50%;" /></p>
<ul>
<li><p>FileWriter使用后，必须调用<code>close()</code>或者<code>flush()</code>，否则写入不到指定的文件。close()方法
等于 一个flush() + 关闭文件</p></li>
<li><p>FileReader和FileWriter与先前的字节流读取、写入过程类似，只不过读入的是char[]字符流数组。</p></li>
<li><p>FileWriter的write方法也可以直接写入字符串</p></li>
</ul>
<h3 id="八节点流和处理流及设计模式">八、节点流和处理流及设计模式：</h3>
<h4 id="节点流和处理流">1、节点流和处理流</h4>
<ul>
<li>节点流可以从<strong>一个特定的数据源</strong>读写数据，如FileReader、FileWriter</li>
<li>处理流是“连接”在已存在的流之上。</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220811164059830.png" /></p>
<ul>
<li>处理流：比如说BufferedReader类中，有属性Reader，即可以封装一个节点流。该节点流可以是任意的，只要是Reader的子类。</li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220811164655306.png" style="zoom:50%;" /></p>
<ul>
<li>总结：
<ul>
<li>1.节点流是底层流/低级流，直接跟数据源相接。</li>
<li>2.处理流（包装流）<strong>包装节点流</strong>，<strong>既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出。</strong></li>
<li>3.处理流（也叫包装流）对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相连</li>
</ul></li>
</ul>
<h4 id="处理流的设计模式">2、处理流的设计模式：</h4>
<p>优势：</p>
<ul>
<li>性能的提高：主要以增加缓冲的方式来提高输入输出的效率。</li>
<li>操作的便捷：处理流可能提供了一系列便捷的方法来一次输入输出大批量的数据，使用更加灵活方便</li>
</ul>
<h3
id="九bufferedreaderbufferedwriterbuffered拷贝buffered字节处理流">九、BufferedReader、BufferedWriter，Buffered拷贝，Buffered字节处理流</h3>
<ul>
<li><p>注意：在关闭处理流时，只需要关闭外层流时即可。</p></li>
<li><p><strong>BufferedReader示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\a.java&quot;</span>;</span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath));</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span>((line = bufferedReader.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="comment">//处理line</span></span><br><span class="line">&#125;</span><br><span class="line">bufferedReader.close();</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Buffered拷贝实例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\a.java&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">destPath</span> <span class="operator">=</span> <span class="string">&quot;e:\\a2.java&quot;</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    bufferedReader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath));</span><br><span class="line">    bufferedWriter = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(destPath));</span><br><span class="line"> 	String line;</span><br><span class="line">    <span class="keyword">while</span>((line = bufferedReader.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">        bufferedWriter.write(line);</span><br><span class="line">        bufferedWriter.newLine();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bufferedReader != <span class="literal">null</span>) bufferedReader.close();</span><br><span class="line">	<span class="keyword">if</span>(bufferedWriter != <span class="literal">null</span>) bufferedWriter.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><strong>Buffered字节处理流：BufferedInputStream 和
BufferedOutputStream</strong></p></li>
<li><p><img src="C:\Users\14012\AppData\Roaming\Typora\typora-user-images\image-20220811223030663.png" style="zoom:50%;" /></p>
<ul>
<li><p>BufferedInputStream是字节流，在创建时会创建一个内部缓冲区数组，其构造函数可以接收任何一个InputStream对象。</p></li>
<li><p>BufferedOutputStream是字节流，实现缓冲的输出流，可以将多个字节写入底层输出流中，而不必对每次字节写入调用底层系统，其构造函数可以接收任何一个OutputStream对象。</p></li>
</ul></li>
<li><p><strong>字节处理流的文件拷贝（二进制文件拷贝，如音频等）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String filePath = &quot;e:\\a.jpg&quot;;</span><br><span class="line">String destPath = &quot;e:\\a2.jpg&quot;</span><br><span class="line">BufferedInputStream bufferedInputStream = null;</span><br><span class="line">BufferedOutputStream bufferedOutputStream = null;</span><br><span class="line">try&#123;</span><br><span class="line">    bufferedInputStream = new BufferedInputStream(new FileInputStream(filePath));</span><br><span class="line">    bufferedOutputStream = new BufferedOutputStream(new FileInputStream(destPath));</span><br><span class="line"> 	byte[] buff = new byte[1024];</span><br><span class="line"> 	int readLen = 0;</span><br><span class="line">    while((readLen = bufferedInputStream.read(buff)) != -1)&#123;</span><br><span class="line">        bufferedOutputStream.write(buff,0,readLen);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;catch(IOException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    if(bufferedInputStream != null) bufferedInputStream.close();</span><br><span class="line">	if(bufferedOutputStream != null) bufferedOutputStream.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="十对象流-objectinputstream和objectoutputstream">十、对象流
ObjectInputStream和ObjectOutputStream：</h3>
<p>​
序列化与反序列化：只有某对象实现如下两个接口之一，才能够进行序列化。</p>
<ul>
<li><p>Serializable 这是一个标记接口，没有方法</p></li>
<li><p>Externalizable
该接口有方法需要实现，因此一般实现上面的Serializable接口</p></li>
<li><p><strong>ObjectOutputStream</strong>提供序列化功能，<strong>ObjectInputStream</strong>提供反序列化功能。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220812210742720.png" style="zoom:67%;" /></p></li>
<li><p>序列化存储示例代码</p>
<ul>
<li><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220813090617046.png" alt="image-20220813090617046" style="zoom:67%;" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectStreamTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\data.dat&quot;</span>;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath));</span><br><span class="line">        oos.write(<span class="number">100</span>);</span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;11&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>保存下来的文件并不是以文本形式存在的。</p></li>
</ul></li>
<li><p>反序列化示例代码：<strong>读取（反序列化）的顺序需要和你保存数据（序列化）的顺序一致</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.slks.stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectStreamTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\data.dat&quot;</span>;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath));</span><br><span class="line">        ois.read();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">readDog</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        System.out.println(<span class="string">&quot;runtime class:&quot;</span> + readDog.getClass());</span><br><span class="line">        System.out.println(<span class="string">&quot;dog info:&quot;</span> + readDog);</span><br><span class="line">        <span class="comment">// readDog的编译类型是 Object，运行类型是Dog</span></span><br><span class="line">        <span class="comment">// 如果我们希望调用Dog的方法，需要向下转型</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">newReadDog</span> <span class="operator">=</span> (Dog)readDog;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog call:&quot;</span> + newReadDog.getName());</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name:&quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;age:&quot;</span> + <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实现细节：</p>
<ul>
<li>1）读写顺序要一致</li>
<li>2）要求实现序列化或反序列化对象，需要实现Serializable2）要求实现序列化或反序列化对象，需要实现Serializable</li>
<li>3）序列化的类中建议添加SerialVersionUID，为了提高版本的兼容性</li>
<li>4）序列化对象时，默认将里面所有属性都进行序列化，但除了static或transient修饰的成员</li>
<li>5）序列化对象时，要求里面属性的类型也需要实现序列化接口6）序列化具备可继承性，也就是如果某类已经实现了序列化，则它的所有子类也已经默认实现了序列化</li>
</ul></li>
</ul>
<h3 id="十一标准输入输出流">十一、标准输入输出流</h3>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220813100329630.png" style="zoom:67%;" /></p>
<h3 id="十二转换流-inputstreamreader-和-outputstreamwriter">十二、转换流
InputStreamReader 和 OutputStreamWriter：</h3>
<p>​ 用于将字节流转换成字符流。</p>
<p>​
默认情况下，读取文件按照utf-8编码读取的，如果文件本身不是utf-8编码的话，读取后很容易导致乱码的产生。</p>
<p>​
在转换过程中，我们是可以指定字节流的编码方式的，然后将其按照编码方式转换成字符流即可消除乱码的问题。</p>
<p>​
当处理纯文本数据时，如果使用字符流效率更高，并且可以有效解决中文S问题，所以建议将字节流转换成字符流.可以在使用时指定编码格式（比如
utf-8，gbk，gb2312，ISO8859-1等）</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220813102535318.png" /></p>
<ul>
<li>演示代码：使用InputStreamReader 转换流解决中文乱码问题</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReader_</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[]args）<span class="keyword">throws</span> FileNotFoundException，UnsupportedEncodingException&#123;</span><br><span class="line">		String filePath=<span class="string">&quot;e:\\a.txt&quot;</span>;  <span class="comment">// a.txt编码为gbk，而非utf-8</span></span><br><span class="line">		<span class="comment">//解读</span></span><br><span class="line">        <span class="comment">//1.把FileInputStream 转成InputStreamReader//1.把FileInputStream 转成InputStreamReader</span></span><br><span class="line">        <span class="comment">//2.指定编码gbk</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputstream</span>(filePath)，<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">        <span class="comment">//3.把InputstreamReader传入BufferedReader</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">		<span class="comment">//4.读取</span></span><br><span class="line">        String s=br.readLine();</span><br><span class="line">        System.out.printin（<span class="string">&quot;读取内容=&quot;</span>+s）；	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>按照指定编码方式保存文本文件：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputStreamWriter_</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[]args）<span class="keyword">throws</span> IOException&#123;</span><br><span class="line">		String filePath=<span class="string">&quot;e:\\hsp.txt&quot;</span>;</span><br><span class="line">		string charSet=<span class="string">&quot;utf-8&quot;</span>;</span><br><span class="line">		<span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath),charSet);</span><br><span class="line">		osw.write(<span class="string">&quot;hi，韩顺平教育&quot;</span>);</span><br><span class="line">		osw.close()；</span><br><span class="line">		System.out.printin(<span class="string">&quot;按照&quot;</span>+charSet+<span class="string">&quot;保存文件成功~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3
id="十三打印流printsteam和printwriter">十三、打印流：PrintSteam和PrintWriter</h3>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220813104318225.png" style="zoom:67%;" /></p>
<h3 id="十四操作zip">十四、操作Zip</h3>
<p><code>ZipInputStream</code>是一种<code>FilterInputStream</code>，它可以直接读取zip包的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌───────────────────┐</span><br><span class="line">│    InputStream    │</span><br><span class="line">└───────────────────┘</span><br><span class="line">          ▲</span><br><span class="line">          │</span><br><span class="line">┌───────────────────┐</span><br><span class="line">│ FilterInputStream │</span><br><span class="line">└───────────────────┘</span><br><span class="line">          ▲</span><br><span class="line">          │</span><br><span class="line">┌───────────────────┐</span><br><span class="line">│InflaterInputStream│</span><br><span class="line">└───────────────────┘</span><br><span class="line">          ▲</span><br><span class="line">          │</span><br><span class="line">┌───────────────────┐</span><br><span class="line">│  ZipInputStream   │</span><br><span class="line">└───────────────────┘</span><br><span class="line">          ▲</span><br><span class="line">          │</span><br><span class="line">┌───────────────────┐</span><br><span class="line">│  JarInputStream   │</span><br><span class="line">└───────────────────┘</span><br></pre></td></tr></table></figure>
<h4 id="读取zip包">1、读取Zip包：</h4>
<p>​
我们要创建一个<code>ZipInputStream</code>，通常是传入一个<code>FileInputStream</code>作为数据源，然后，循环调用<code>getNextEntry()</code>，直到返回<code>null</code>，表示zip流结束。</p>
<p>​
一个<code>ZipEntry</code>表示一个压缩文件或目录，如果是压缩文件，我们就用<code>read()</code>方法不断读取，直到返回<code>-1</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">ZipInputStream</span> <span class="variable">zip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(...))) &#123;</span><br><span class="line">    <span class="type">ZipEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> ((entry = zip.getNextEntry()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> entry.getName();</span><br><span class="line">        <span class="keyword">if</span> (!entry.isDirectory()) &#123;</span><br><span class="line">            <span class="type">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = zip.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="写入zip包">2、写入Zip包：</h4>
<p><code>ZipOutputStream</code>是一种<code>FilterOutputStream</code>，它可以直接写入内容到zip包。我们要先创建一个<code>ZipOutputStream</code>，通常是包装一个<code>FileOutputStream</code>，然后，每写入一个文件前，先调用<code>putNextEntry()</code>，然后用<code>write()</code>写入<code>byte[]</code>数据，写入完毕后调用<code>closeEntry()</code>结束这个文件的打包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">ZipOutputStream</span> <span class="variable">zip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(...))) &#123;</span><br><span class="line">    File[] files = ...</span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        zip.putNextEntry(<span class="keyword">new</span> <span class="title class_">ZipEntry</span>(file.getName()));</span><br><span class="line">        zip.write(getFileDataAsBytes(file));</span><br><span class="line">        zip.closeEntry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码没有考虑文件的目录结构。如果要实现目录层次结构，<code>new ZipEntry(name)</code>传入的<code>name</code>要用相对路径。</p>
<h3 id="十五properties类配置文件">十五、Properties类：配置文件</h3>
<p>专门用于读取配置文件的集合类，要求配置文件的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">键=值</span><br><span class="line">键=值</span><br></pre></td></tr></table></figure>
<ul>
<li><p>配置文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// mysql.properties文件</span><br><span class="line">ip=192.168.0.1</span><br><span class="line">user=root</span><br><span class="line">psd=123456</span><br></pre></td></tr></table></figure></li>
<li><p>Properties类对象常用方法</p>
<ul>
<li><p>load</p></li>
<li><p>list</p></li>
<li><p>getProperty</p></li>
<li><p>setProperty</p></li>
<li><p>store:
将Properties中的键值对存储到配置文件，中文会存成unicode编码</p></li>
</ul></li>
<li><p>Properties类进行读取：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//1.创建Properties对象</span><br><span class="line">Properties properties =new Properties();</span><br><span class="line">//2.加载指定配置文件</span><br><span class="line">properties.load(new FileReader(&quot;src\\mysqL.properties&quot;));</span><br><span class="line">//3.把k-v显示控制台</span><br><span class="line">properties.list(System.out);</span><br><span class="line">//4.根据k获取对应的值</span><br><span class="line">properties.getProperty(&quot;user&quot;);</span><br></pre></td></tr></table></figure></li>
<li><p>Properties进行文件的创建：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Properties properties = new Properties();</span><br><span class="line">//创建</span><br><span class="line">properties.setProperty(&quot;charset&quot;,&quot;utf8&quot;);</span><br><span class="line">properties.setProperty(&quot;user&quot;,&quot;slks&quot;);</span><br><span class="line">//存储文件</span><br><span class="line">properties.store(new FileOutputStream(&quot;mysql.properties&quot;),null);  //第二个参数代表一个注释</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>注意：Properties的父类是HashTable，其底层就是Hashtable</p></li>
</ul>
]]></content>
      <categories>
        <category>⑤  编程语言类笔记</category>
        <category>java入门系列笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java系列笔记7——java泛型（更新中）</title>
    <url>/2022/02/01/998c77b4c7e4/</url>
    <content><![CDATA[<p>参考教程网址：https://www.liaoxuefeng.com/wiki/1252599548343744/1264799402020448</p>
<h3 id="一泛型定义简介">一、泛型定义简介</h3>
<p>​ 泛型是一种“代码模板”，可以用一套代码套用各种类型。</p>
<p>​
我们可以把<code>ArrayList</code>变成一种模板：<code>ArrayList&lt;T&gt;</code>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T e)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>T</code>可以是任何class。这样一来，我们就实现了：<strong>编写一次模版，可以创建任意类型的<code>ArrayList</code>：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建可以存储String的ArrayList:</span></span><br><span class="line">ArrayList&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"><span class="comment">// 创建可以存储Float的ArrayList:</span></span><br><span class="line">ArrayList&lt;Float&gt; floatList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Float&gt;();</span><br><span class="line"><span class="comment">// 创建可以存储Person的ArrayList:</span></span><br><span class="line">ArrayList&lt;Person&gt; personList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br></pre></td></tr></table></figure>
<p>​
因此，<strong>泛型就是定义一种模板，例如<code>ArrayList&lt;T&gt;</code>，然后在代码中为用到的类创建对应的<code>ArrayList&lt;类型&gt;</code>：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：注意泛型的继承关系：可以把<code>ArrayList&lt;Integer&gt;</code>向上转型为<code>List&lt;Integer&gt;</code>（<code>T</code>不能变！），但不能把<code>ArrayList&lt;Integer&gt;</code>向上转型为<code>ArrayList&lt;Number&gt;</code>（<code>T</code>不能变成父类）。</p>
<h3 id="二使用泛型">二、使用泛型</h3>
<h4 id="简写泛型">1、简写泛型：</h4>
<p>当我们定义泛型类型<code>&lt;Number&gt;</code>后，<code>List&lt;T&gt;</code>的泛型接口变为强类型<code>List&lt;Number&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">12.34</span>));</span><br><span class="line"><span class="type">Number</span> <span class="variable">first</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line"><span class="type">Number</span> <span class="variable">second</span> <span class="operator">=</span> list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p><strong>编译器如果能自动推断出泛型类型，就可以省略后面的泛型类型</strong>。例如，对于下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br></pre></td></tr></table></figure>
<p>编译器看到泛型类型<code>List&lt;Number&gt;</code>就可以自动推断出后面的<code>ArrayList&lt;T&gt;</code>的泛型类型必须是<code>ArrayList&lt;Number&gt;</code>，因此，可以把代码简写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以省略后面的Number，编译器可以自动推断泛型类型：</span></span><br><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h4 id="使用泛型接口">2、使用泛型接口：</h4>
<p>​
除了<code>ArrayList&lt;T&gt;</code>使用了泛型，还可以在接口中使用泛型。例如，
<code>Arrays.sort(Object[])</code>可以对任意数组进行排序，但待排序的元素必须实现<code>Comparable&lt;T&gt;</code>这个泛型接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Comparable&lt;T&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 返回负数: 当前实例比参数o小</span><br><span class="line">     * 返回0: 当前实例与参数o相等</span><br><span class="line">     * 返回正数: 当前实例比参数o大</span><br><span class="line">     */</span><br><span class="line">    int compareTo(T o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 如下示例所示：实现对我们的自定义类Person的元素排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Person[] ps = <span class="keyword">new</span> <span class="title class_">Person</span>[] &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">61</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">88</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lily&quot;</span>, <span class="number">75</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        Arrays.sort(ps);</span><br><span class="line">        System.out.println(Arrays.toString(ps));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Person&gt; &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    Person(String name, <span class="type">int</span> score) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person other)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name.compareTo(other.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name + <span class="string">&quot;,&quot;</span> + <span class="built_in">this</span>.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行上述代码，可以正确实现按name进行排序。</span></span><br></pre></td></tr></table></figure>
<h3 id="三编写泛型">三、编写泛型</h3>
<h4 id="一般方法">1、一般方法：</h4>
<ul>
<li><p>首先，按照某种类型，例如：<code>String</code>，来编写类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String first;</span><br><span class="line">    <span class="keyword">private</span> String last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(String first, String last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>然后，标记所有的特定类型，这里是<code>String</code>,并替换为T，并申明<code>&lt;T&gt;</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Pair&lt;T&gt; &#123;</span><br><span class="line">    private T first;</span><br><span class="line">    private T last;</span><br><span class="line">    public Pair(T first, T last) &#123;</span><br><span class="line">        this.first = first;</span><br><span class="line">        this.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    public T getFirst() &#123;</span><br><span class="line">        return first;</span><br><span class="line">    &#125;</span><br><span class="line">    public T getLast() &#123;</span><br><span class="line">        return last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>熟练后即可直接从<code>T</code>开始编写。</p></li>
</ul>
<h4 id="静态方法">2、静态方法：</h4>
<p>​ 泛型类型<code>&lt;T&gt;</code>不能用于静态方法。</p>
<p>​
对于静态方法，我们可以单独改写为“泛型”方法，只需要使用另一个类型即可。对于上面的<code>create()</code>静态方法，我们应该把它改为另一种泛型类型，例如，<code>&lt;K&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getLast</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态泛型方法应该使用其他类型区分:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K&gt; Pair&lt;K&gt; <span class="title function_">create</span><span class="params">(K first, K last)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;K&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样才能清楚地将静态方法的泛型类型和实例类型的泛型类型区分开。</p>
<h4 id="多个泛型的类型">3、多个泛型的类型：</h4>
<p>​
泛型还可以定义多种类型。例如，我们希望<code>Pair</code>不总是存储两个类型一样的对象，就可以使用类型<code>&lt;T, K&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T, K&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> K last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, K last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">getLast</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用的时候，需要指出两种类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String, Integer&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;test&quot;</span>, <span class="number">123</span>);</span><br></pre></td></tr></table></figure>
<p>​
<strong>Java标准库的<code>Map&lt;K, V&gt;</code>就是使用两种泛型类型的例子。它对Key使用一种类型，对Value使用另一种类型。</strong></p>
<h3
id="四擦拭法java语言的泛型实现方法">四、擦拭法（java语言的泛型实现方法）：</h3>
<h4 id="擦拭法的基本含义">1、擦拭法的基本含义</h4>
<p>​
擦拭法是指，<strong>虚拟机对泛型其实一无所知，所有的工作都是编译器做的。</strong></p>
<p>​
例如，我们编写了一个泛型类<code>Pair&lt;T&gt;</code>，这是编译器看到的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而虚拟机根本不知道泛型。这是虚拟机执行的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object first;</span><br><span class="line">    <span class="keyword">private</span> Object last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(Object first, Object last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，java使用擦拭法实现泛型，导致了：</p>
<ul>
<li><strong>编译器把类型<code>&lt;T&gt;</code>视为<code>Object</code>；</strong></li>
<li><strong>编译器根据<code>&lt;T&gt;</code>实现安全的强制转型。</strong></li>
</ul>
<p>使用泛型的时候，我们编写的代码也是编译器看到的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line"><span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> p.getLast();</span><br></pre></td></tr></table></figure>
<p>而虚拟机执行的代码并没有泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Pair</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> (String) p.getFirst();</span><br><span class="line"><span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> (String) p.getLast();</span><br></pre></td></tr></table></figure>
<p><strong>Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型<code>T</code>视为<code>Object</code>处理，但是，在需要转型的时候，编译器会根据<code>T</code>的类型自动为我们实行安全地强制转型。</strong></p>
<h4 id="java泛型的局限">2、java泛型的局限：</h4>
<ul>
<li><p>1）
<code>&lt;T&gt;</code>不能是基本类型，例如<code>int</code>，因为实际类型是<code>Object</code>，<code>Object</code>类型无法持有基本类型：</p></li>
<li><p>2）
所有泛型实例，无论<code>T</code>的类型是什么，<code>getClass()</code>返回同一个<code>Class</code>实例，因为编译后它们全部都是<code>Pair&lt;Object&gt;</code>。示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt; p1 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">Pair&lt;Integer&gt; p2 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> p1.getClass();</span><br><span class="line"><span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> p2.getClass();</span><br><span class="line">System.out.println(c1==c2); <span class="comment">// true</span></span><br><span class="line">System.out.println(c1==Pair.class); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li><p>3）无法判断带泛型的类型，原因和前面一样，并不存在<code>Pair&lt;String&gt;.class</code>，而是只有唯一的<code>Pair.class</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;Integer&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line"><span class="comment">// Compile error:</span></span><br><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Pair&lt;String&gt;) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>4）不能实例化<code>T</code>类型</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Compile error:</span></span><br><span class="line">        first = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        last = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码无法通过编译，因为构造方法的两行语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">first = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">last = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br></pre></td></tr></table></figure>
<p>擦拭后实际上变成了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">first = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">last = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>
<p>这样一来，创建<code>new Pair&lt;String&gt;()</code>和创建<code>new Pair&lt;Integer&gt;()</code>就全部成了<code>Object</code>，显然编译器要阻止这种类型不对的代码。</p>
<p>要实例化<code>T</code>类型，我们必须借助额外的<code>Class&lt;T&gt;</code>参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">        first = clazz.newInstance();</span><br><span class="line">        last = clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码借助<code>Class&lt;T&gt;</code>参数并通过反射来实例化<code>T</code>类型，使用的时候，也必须传入<code>Class&lt;T&gt;</code>。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt; pair = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(String.class);</span><br></pre></td></tr></table></figure>
<p>因为传入了<code>Class&lt;String&gt;</code>的实例，所以我们借助<code>String.class</code>就可以实例化<code>String</code>类型。</p>
<h4 id="不恰当的覆写方法">3、不恰当的覆写方法</h4>
<p>有些时候，一个看似正确定义的方法会无法通过编译。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">this</span> <span class="operator">=</span>= t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是因为，定义的<code>equals(T t)</code>方法实际上会被擦拭成<code>equals(Object t)</code>，而这个方法是继承自<code>Object</code>的，编译器会阻止一个实际上会变成覆写的泛型方法定义。</p>
<p>换个方法名，避开与<code>Object.equals(Object)</code>的冲突就可以成功编译：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">same</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">this</span> <span class="operator">=</span>= t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="泛型继承待补充">4、泛型继承（待补充</h4>
<h3 id="五extends通配符">五、Extends通配符</h3>
<h3 id="六super通配符">六、Super通配符</h3>
<h3 id="七泛型和反射">七、泛型和反射</h3>
]]></content>
      <categories>
        <category>⑤  编程语言类笔记</category>
        <category>java入门系列笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java系列笔记6——java注解</title>
    <url>/2022/01/31/0f79bd25febd/</url>
    <content><![CDATA[<p>参考教程网址：https://www.liaoxuefeng.com/wiki/1252599548343744/1264799402020448</p>
<h3 id="一注解是什么">一、注解是什么？</h3>
<p>​ 注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this is a component:</span></span><br><span class="line"><span class="meta">@Resource(&quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(<span class="meta">@Param</span> String name)</span> &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
<strong>注释会被编译器直接忽略，注解则可以被编译器打包进入class文件</strong>，因此，注解是一种用作标注的“元数据”。</p>
<h3 id="二注解的作用">二、注解的作用：</h3>
<p>​
从JVM的角度看，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定。</p>
<p>​ Java的注解可以分为三类：</p>
<ul>
<li>1、<strong>由编译器使用的注解:</strong>(
这类注解不会被编译进入<code>.class</code>文件，它们在编译后就被编译器扔掉了
)
<ul>
<li><code>@Override</code>：让编译器检查该方法是否正确地实现了覆写；</li>
<li><code>@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。</li>
</ul></li>
<li>2、<strong>由工具处理<code>.class</code>文件使用的注解</strong>:
<ul>
<li>比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。<strong>这类注解会被编译进入<code>.class</code>文件，但加载结束后并不会存在于内存中</strong>。这类注解只被一些底层库使用，一般我们不必自己处理。</li>
</ul></li>
<li>3、<strong>在程序运行期能够读取的注解</strong>：
<ul>
<li>它们<strong>在加载后一直存在于JVM中</strong>，这也是最常用的注解。例如，一个配置了<code>@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）</li>
</ul></li>
</ul>
<h3 id="三注解的配置参数">三、注解的配置参数：</h3>
<p>定义一个注解时，还可以定义<strong>配置参数</strong>。配置参数可以包括：</p>
<ul>
<li>所有基本类型；</li>
<li>String；</li>
<li>枚举类型；</li>
<li>基本类型、String、Class以及枚举的数组。</li>
</ul>
<p>因为<strong>配置参数必须是常量</strong>，所以，上述限制保证了注解在定义时就已经确定了每个参数的值。</p>
<p><strong>注解的配置参数可以有默认值，缺少某个配置参数时将使用默认值。</strong></p>
<p>此外，大部分注解会有一个名为<code>value</code>的配置参数，对此参数赋值，可以只写常量，相当于省略了value参数。如果只写注解，相当于全部使用默认值。</p>
<p>举个栗子，对以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="meta">@Check(min=0, max=100, value=55)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check(value=99)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check(99)</span> <span class="comment">// @Check(value=99)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@Check</code>就是一个注解。第一个<code>@Check(min=0, max=100, value=55)</code>明确定义了三个参数，第二个<code>@Check(value=99)</code>只定义了一个<code>value</code>参数，它实际上和<code>@Check(99)</code>是完全一样的。最后一个<code>@Check</code>表示所有参数都使用默认值。</p>
<h3 id="四定义注解">四、定义注解：</h3>
<h4 id="如何定义一个注解">1、如何定义一个注解？</h4>
<p>java语言使用<code>@interface</code>语法来定义注解（<code>Annotation</code>），它的格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
注解的参数类似无参数方法，可以用<code>default</code>设定一个默认值（强烈推荐）。最常用的参数应当命名为<code>value</code>。</p>
<h4 id="元注解">2、元注解：</h4>
<p>​ 有一些注解可以修饰其他注解，这些注解就称为元注解（meta
annotation）。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。</p>
<ul>
<li><p><span class="citation" data-cites="Target">@Target</span>：</p>
<ul>
<li><p>使用<code>@Target</code>可以定义<code>Annotation</code>能够被应用于源码的哪些位置</p>
<ul>
<li>类或接口：<code>ElementType.TYPE</code>；</li>
<li>字段：<code>ElementType.FIELD</code>；</li>
<li>方法：<code>ElementType.METHOD</code>；</li>
<li>构造方法：<code>ElementType.CONSTRUCTOR</code>；</li>
<li>方法参数：<code>ElementType.PARAMETER</code>。</li>
</ul></li>
<li><p>例如，定义注解<code>@Report</code>可用在方法上，我们必须添加一个<code>@Target(ElementType.METHOD)</code></p>
<ul>
<li>```java <span class="citation"
data-cites="Target">@Target</span>(ElementType.METHOD) public <span
class="citation" data-cites="interface">@interface</span> Report { int
type() default 0; String level() default "info"; String value() default
""; } <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 定义注解`@Report`可用在方法或字段上，可以把`@Target`注解参数变为数组`&#123; ElementType.METHOD, ElementType.FIELD &#125;`：</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    @Target(&#123;</span><br><span class="line">        ElementType.METHOD,</span><br><span class="line">        ElementType.FIELD</span><br><span class="line">    &#125;)</span><br><span class="line">    public @interface Report &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li><p><span class="citation"
data-cites="Retention">@Retention</span>:</p>
<ul>
<li><p><code>@Retention</code>定义了<code>Annotation</code>的生命周期</p>
<ul>
<li>仅编译期：<code>RetentionPolicy.SOURCE</code>；</li>
<li>仅class文件：<code>RetentionPolicy.CLASS</code>；</li>
<li>运行期：<code>RetentionPolicy.RUNTIME</code>。</li>
</ul></li>
<li><p>如果<code>@Retention</code>不存在，则该<code>Annotation</code>默认为<code>CLASS</code>。因为通常我们自定义的<code>Annotation</code>都是<code>RUNTIME</code>，所以，务必要加上<code>@Retention(RetentionPolicy.RUNTIME)</code>这个元注解：</p>
<ul>
<li></li>
<li>```java <span class="citation"
data-cites="Retention">@Retention</span>(RetentionPolicy.RUNTIME) public
<span class="citation" data-cites="interface">@interface</span> Report {
int type() default 0; String level() default "info"; String value()
default ""; } <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- @Repeatable</span><br><span class="line"></span><br><span class="line">  - `@Repeatable`这个元注解可以定义`Annotation`是否可重复。</span><br><span class="line"></span><br><span class="line">    - ```</span><br><span class="line">      @Repeatable(Reports.class)</span><br><span class="line">      @Target(ElementType.TYPE)</span><br><span class="line">      public @interface Report &#123;</span><br><span class="line">          int type() default 0;</span><br><span class="line">          String level() default &quot;info&quot;;</span><br><span class="line">          String value() default &quot;&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      @Target(ElementType.TYPE)</span><br><span class="line">      public @interface Reports &#123;</span><br><span class="line">          Report[] value();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>经过<code>@Repeatable</code>修饰后，在某个类型声明处，就可以添加多个<code>@Report</code>注解：</p>
<ul>
<li>```java <span class="citation"
data-cites="Report">@Report</span>(type=1, level="debug") <span
class="citation" data-cites="Report">@Report</span>(type=2,
level="warning") public class Hello { } <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- @Inherited</span><br><span class="line"></span><br><span class="line">  - 使用`@Inherited`定义子类是否可继承父类定义的`Annotation`</span><br><span class="line"></span><br><span class="line">  - `@Inherited`仅针对`@Target(ElementType.TYPE)`类型的`annotation`有效，**并且仅针对`class`的继承，对`interface`的继承无效**</span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">      @Inherited</span><br><span class="line">      @Target(ElementType.TYPE)</span><br><span class="line">      public @interface Report &#123;</span><br><span class="line">          int type() default 0;</span><br><span class="line">          String level() default &quot;info&quot;;</span><br><span class="line">          String value() default &quot;&quot;;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>在使用的时候，如果一个类用到了<code>@Report</code>,则它的子类默认也定义了该注解：</p>
<ul>
<li>```java <span class="citation"
data-cites="Report">@Report</span>(type=1) public class Person { }
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public class Student extends Person &#123;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
</ul>
<h4 id="总结定义annotation的步骤">3、总结定义Annotation的步骤：</h4>
<h5 id="用interface定义注解">1）用<code>@interface</code>定义注解：</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5
id="添加参数默认值把最常用的参数定义为value推荐所有参数都尽量设置默认值">2)
添加参数、默认值：(把最常用的参数定义为<code>value()</code>，推荐所有参数都尽量设置默认值。)</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="第三步用元注解配置注解">3) 第三步，用元注解配置注解：</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
必须设置<code>@Target</code>和<code>@Retention</code>，<code>@Retention</code>一般设置为<code>RUNTIME</code>，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写<code>@Inherited</code>和<code>@Repeatable</code>。</p>
<h3 id="五处理注解">五、处理注解：</h3>
<p>​
Java的注解本身对代码逻辑没有任何影响。根据<code>@Retention</code>的配置：</p>
<ul>
<li><code>SOURCE</code>类型的注解在编译期就被丢掉了；</li>
<li><code>CLASS</code>类型的注解仅保存在class文件中，它们不会被加载进JVM；</li>
<li><code>RUNTIME</code>类型的注解会被加载进JVM，并且在运行期可以被程序读取。</li>
</ul>
<p>​
如何使用注解完全由工具决定。<code>SOURCE</code>类型的注解主要由编译器使用，因此我们一般只使用，不编写。<code>CLASS</code>类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。<strong>只有<code>RUNTIME</code>类型的注解不但要使用，还经常需要编写。</strong></p>
<p>​
因为注解定义后也是一种<code>class</code>，所有的注解都继承自<code>java.lang.annotation.Annotation</code>，因此，读取注解，需要使用反射API。</p>
<p>​ Java提供的使用反射API读取<code>Annotation</code>的方法包括：</p>
<p>判断某个注解是否存在于<code>Class</code>、<code>Field</code>、<code>Method</code>或<code>Constructor</code>：</p>
<ul>
<li><code>Class.isAnnotationPresent(Class)</code></li>
<li><code>Field.isAnnotationPresent(Class)</code></li>
<li><code>Method.isAnnotationPresent(Class)</code></li>
<li><code>Constructor.isAnnotationPresent(Class)</code></li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断@Report是否存在于Person类:</span></span><br><span class="line">Person.class.isAnnotationPresent(Report.class);</span><br></pre></td></tr></table></figure>
<p>使用反射API读取Annotation：</p>
<ul>
<li><code>Class.getAnnotation(Class)</code></li>
<li><code>Field.getAnnotation(Class)</code></li>
<li><code>Method.getAnnotation(Class)</code></li>
<li><code>Constructor.getAnnotation(Class)</code></li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取Person定义的@Report注解:</span></span><br><span class="line"><span class="type">Report</span> <span class="variable">report</span> <span class="operator">=</span> Person.class.getAnnotation(Report.class);</span><br><span class="line"><span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> report.type();</span><br><span class="line"><span class="type">String</span> <span class="variable">level</span> <span class="operator">=</span> report.level();</span><br></pre></td></tr></table></figure>
<p>使用反射API读取<code>Annotation</code>有两种方法。方法一是先判断<code>Annotation</code>是否存在，如果存在，就直接读取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Person.class;</span><br><span class="line"><span class="keyword">if</span> (cls.isAnnotationPresent(Report.class)) &#123;</span><br><span class="line">    <span class="type">Report</span> <span class="variable">report</span> <span class="operator">=</span> cls.getAnnotation(Report.class);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种方法是直接读取<code>Annotation</code>，如果<code>Annotation</code>不存在，将返回<code>null</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Person.class;</span><br><span class="line"><span class="type">Report</span> <span class="variable">report</span> <span class="operator">=</span> cls.getAnnotation(Report.class);</span><br><span class="line"><span class="keyword">if</span> (report != <span class="literal">null</span>) &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取方法、字段和构造方法的<code>Annotation</code>和Class类似。但要读取方法参数的<code>Annotation</code>就比较麻烦一点，因为方法参数本身可以看成一个数组，而每个参数又可以定义多个注解，所以，一次获取方法参数的所有注解就必须用一个二维数组来表示。例如，对于以下方法定义的注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(<span class="meta">@NotNull</span> <span class="meta">@Range(max=5)</span> String name, <span class="meta">@NotNull</span> String prefix)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要读取方法参数的注解，我们先用反射获取<code>Method</code>实例，然后读取方法参数的所有注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取Method实例:</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="comment">// 获取所有参数的Annotation:</span></span><br><span class="line">Annotation[][] annos = m.getParameterAnnotations();</span><br><span class="line"><span class="comment">// 第一个参数（索引为0）的所有Annotation:</span></span><br><span class="line">Annotation[] annosOfName = annos[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (Annotation anno : annosOfName) &#123;</span><br><span class="line">    <span class="keyword">if</span> (anno <span class="keyword">instanceof</span> Range) &#123; <span class="comment">// @Range注解</span></span><br><span class="line">        <span class="type">Range</span> <span class="variable">r</span> <span class="operator">=</span> (Range) anno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anno <span class="keyword">instanceof</span> NotNull) &#123; <span class="comment">// @NotNull注解</span></span><br><span class="line">        <span class="type">NotNull</span> <span class="variable">n</span> <span class="operator">=</span> (NotNull) anno;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="六使用注解">六、使用注解</h3>
<p>​
注解如何使用，完全由程序自己决定。例如，JUnit是一个测试框架，它会自动运行所有标记为<code>@Test</code>的方法。</p>
<p>​
我们来看一个<code>@Range</code>注解，我们希望用它来定义一个<code>String</code>字段的规则：字段长度满足<code>@Range</code>的参数定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Range &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">max</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">255</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 在某个JavaBean中，我们可以使用该注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Range(min=1, max=20)</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Range(max=10)</span></span><br><span class="line">    <span class="keyword">public</span> String city;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
但是，定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。这里，我们编写一个<code>Person</code>实例的检查方法，它可以检查<code>Person</code>实例的<code>String</code>字段长度是否满足<code>@Range</code>的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">check</span><span class="params">(Person person)</span> <span class="keyword">throws</span> IllegalArgumentException, ReflectiveOperationException &#123;</span><br><span class="line">    <span class="comment">// 遍历所有Field:</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : person.getClass().getFields()) &#123;</span><br><span class="line">        <span class="comment">// 获取Field定义的@Range:</span></span><br><span class="line">        <span class="type">Range</span> <span class="variable">range</span> <span class="operator">=</span> field.getAnnotation(Range.class);</span><br><span class="line">        <span class="comment">// 如果@Range存在:</span></span><br><span class="line">        <span class="keyword">if</span> (range != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取Field的值:</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> field.get(person);</span><br><span class="line">            <span class="comment">// 如果值是String:</span></span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) value;</span><br><span class="line">                <span class="comment">// 判断值是否满足@Range的min/max:</span></span><br><span class="line">                <span class="keyword">if</span> (s.length() &lt; range.min() || s.length() &gt; range.max()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid field: &quot;</span> + field.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
这样一来，我们通过<code>@Range</code>注解，配合<code>check()</code>方法，就可以完成<code>Person</code>实例的检查。注意检查逻辑完全是我们自己编写的，JVM不会自动给注解添加任何额外的逻辑。</p>
]]></content>
      <categories>
        <category>⑤  编程语言类笔记</category>
        <category>java入门系列笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>annotation</tag>
      </tags>
  </entry>
  <entry>
    <title>java系列笔记5——java反射机制</title>
    <url>/2022/01/30/c2b593051f4f/</url>
    <content><![CDATA[<p>参考教程网址：https://www.liaoxuefeng.com/wiki/1252599548343744/1255945147512512</p>
<h3 id="一反射简介与机制">一、反射简介与机制</h3>
<p>​ Java的反射是指程序在运行期可以拿到一个对象的所有信息。</p>
<p>​
<strong>所以，反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。</strong></p>
<p>​ 比如说，我们需要根据配置文件 re.propertiesi
指定信息，创建Cat对象并调用method指定的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classfullpath=com.hspedu.Cat</span><br><span class="line">method=hi</span><br></pre></td></tr></table></figure>
<p>我们读取这些信息后，是没法在源码中直接进行Cat对象的创建的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties properties=<span class="keyword">new</span> <span class="title class_">Properties</span>(); </span><br><span class="line">properties. Load(<span class="keyword">new</span> <span class="title class_">FileInputstream</span>(<span class="string">&quot;src\\ re. properties&quot;</span>));</span><br><span class="line"><span class="type">String</span> <span class="variable">classfullpath</span> <span class="operator">=</span>properties.get(<span class="string">&quot;classfulLpath&quot;</span>).tostring(); <span class="comment">//&quot;com.hspedu.Cat&quot;</span></span><br><span class="line">String method=properties.get(<span class="string">&quot;method&quot;</span>).tostring();  <span class="comment">//&quot;hi&quot;</span></span><br><span class="line">System.out.println(<span class="string">&quot;cLassfullpath=&quot;</span>+classfullpath); </span><br><span class="line">System.out.printin(<span class="string">&quot;method=&quot;</span>+method);</span><br><span class="line"></span><br><span class="line"><span class="comment">// new classfullpath() 这样子是没法创建对象的</span></span><br></pre></td></tr></table></figure>
<p>如果使用反射机制来解决，快速入门如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1) 加载类，返回Class类型的对象cls</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(classfullpath);</span><br><span class="line"><span class="comment">// 2) 通过cls得到你加载的类 com.hspedu.Cat 的对象实例</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> cls.newInstance(); <span class="comment">//此时o的运行类型，就是com.hspedu.Cat</span></span><br><span class="line"><span class="comment">// 3) 通过cls得到你加载的类 com.hspedu.Cat 中的 method指定的(hi) Method对象</span></span><br><span class="line"><span class="comment">// 在反射中，可以把方法视为对象</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> cls.getMethod(method)</span><br><span class="line"><span class="comment">// 4) 通过method1对象来调用方法</span></span><br><span class="line">method1.invoke(o);</span><br></pre></td></tr></table></figure>
<p>它实现了通过外部文件配置，在不修改源码的情况下，来控制程序。<strong>符合设计模式的ocp原则</strong>，是框架的灵魂</p>
<h3 id="二反射机制原理">二、反射机制原理：</h3>
<p>1.反射机制允许程序在执行期借助于Reflection
API取得任何类的内部信息（比如成员变量，构造器，成员方法等等），并能操作对象的属性与方法。反射在设计模式和框架底层都会用到</p>
<p>2.加载完类之后，在堆中就产生了一个Class类型的对象（<strong>一个类只有一个Class对象</strong>），这个对象包含了类的完整结构信息。通过这个对象得到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，形象的称之为：反射。</p>
<p><strong>JAVA程序在计算机内执行的三个阶段</strong>：</p>
<p>​
我们平常定义的各个类都是<strong>由JVM在执行过程中动态加载的（ClassLoader）</strong>。JVM在第一次读取到一个不同的类时，就会将其加载入内存。每加载一种类，JVM就会为其创建一个<strong>"Class"</strong>类型的类的实例，并进行关联。</p>
<p>​ 我们可以通过Cat类的对象拿到属于Cat类的Class类对象</p>
<ul>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220828112205093.png" /></li>
</ul>
<h3 id="三反射相关的类">三、反射相关的类：</h3>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">java.lang.Class：代表一个类，Class对象表示某个类加载后在堆中的对象</span><br><span class="line">java.lang.reflect.Method：代表类的方法</span><br><span class="line">java.lang.reflect.Field：代表类的成员变量</span><br><span class="line">java.lang.reflect.Constructor：代表类的构造方法</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(classfullpath);</span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> cls.newInstance(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 1) 成员方法的应用</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> cls.getMethod(method)</span><br><span class="line">method1.invoke(o);</span><br><span class="line"><span class="comment">// 2) 成员变量的应用</span></span><br><span class="line">Field field= cls.getField(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">field.get(o);</span><br><span class="line"><span class="comment">// 3) 构造器的应用</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> cls.getConstructor();</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor2</span> <span class="operator">=</span> cls.getConstructor(String.Class);  <span class="comment">//可以指定构造器参数类型</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>反射可以动态的创建和适用对象，使用灵活。但是使用反射的基本是解释执行，对执行速度有影响。</strong></li>
<li>所以可以对反射进行一些优化：
<ul>
<li>关闭访问检查
<ul>
<li>1.Method和Field、Constructor对象都有setAccessible()方法</li>
<li>2.setAccessible()作用是启动和禁用访问安全检查的开关</li>
<li>3.参数值为true表示反射的对象在使用时取消访问检查，提高反射的效率。参数值为false则表示反射的对象执行访问检查</li>
</ul></li>
</ul></li>
</ul>
<h3 id="四class类简介">四、Class类简介</h3>
<p>​
<strong>Class</strong>类的实例是JVM内部创建的，如果我们查看JDK源码，可以发现<strong>"Class"</strong>类的构造方法是<code>private</code>，只有JVM能创建<strong>"Class"</strong>类的实例，我们自己的Java程序是无法创建<strong>"Class"</strong>实例的。是通过一个ClassLoader类来实现的类的加载。</p>
<p>​
所以，JVM持有的每个<strong>"Class"</strong>实例都指向一个数据类型（<code>class</code>或<code>interface</code>），如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; String</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name = &quot;java.lang.String&quot;  │</span><br><span class="line">└───────────────────────────┘</span><br><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; Random</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name = &quot;java.util.Random&quot;  │</span><br><span class="line">└───────────────────────────┘</span><br></pre></td></tr></table></figure>
<p>一个<strong>"Class"</strong>实例包含了其对应的类的所有完整信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; String</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name = &quot;java.lang.String&quot;  │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│package = &quot;java.lang&quot;      │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│super = &quot;java.lang.Object&quot; │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│interface = CharSequence...│</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│field = value[],hash,...   │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│method = indexOf()...      │</span><br><span class="line">└───────────────────────────┘</span><br></pre></td></tr></table></figure>
<p>​
由于JVM为每个加载的类创建了对应的<strong>"Class"</strong>实例，并在实例中保存了该类的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个<strong>"Class"</strong>实例，我们就可以通过这个<strong>"Class"</strong>实例获取到该实例对应的类的所有信息。</p>
<p>​
<strong>对于某个类的Class类的实例，在内存中只有一份，因为JVM仅加载一次。</strong></p>
<p>​ <strong>Class类的实例，是存放在堆中的</strong></p>
<p>​
<strong>JVM中.类的字节码二进制数据，是放在方法区的，有的地方称为类的元数据（包括方法代码，变量名，方法名，访问权限等等）</strong></p>
<h4 id="class常用方法">1、Class常用方法：</h4>
<ul>
<li>获取到Car类 对应的Class对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.slks.car&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>输出cls的类型：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(cls);  <span class="comment">//显示cls对象</span></span><br><span class="line">System.out.println(cls.getClass());  <span class="comment">//输出运行时类型</span></span><br></pre></td></tr></table></figure>
<ul>
<li>得到包名、类名：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cls.getPackage().getName()</span><br><span class="line">cls.getName()</span><br></pre></td></tr></table></figure>
<ul>
<li>通过cls创建对象实例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> (Car)cls.newInstance();</span><br></pre></td></tr></table></figure>
<ul>
<li>通过反射获取属性brand</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">brand</span> <span class="operator">=</span> cls.getField(<span class="string">&quot;brand&quot;</span>)</span><br><span class="line">brand.get(car)</span><br></pre></td></tr></table></figure>
<ul>
<li>通过反射给属性赋值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">brand.set(car,<span class="string">&quot;奔驰&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>拿到所有的字段属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Fields[] fields = cls.getFields();</span><br></pre></td></tr></table></figure>
<h4
id="如何获取一个类的class实例">2、如何获取一个类的<strong>"Class"</strong>实例</h4>
<ul>
<li>方法1：在类加载阶段：直接通过一个类的静态变量<code>class</code>获取：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多用于参数的传递</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> String.class;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法2：在Runtime运行阶段：如果我们有一个实例变量，可以通过该实例变量提供的<code>getClass()</code>方法获取：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在已经知道有对象实例的基础上，获取</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> s.getClass();</span><br></pre></td></tr></table></figure>
<ul>
<li>方法3：在代码/编译阶段：如果知道一个类的完整类名，可以通过静态方法<code>Class.forName()</code>获取：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多用于配置文件、</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>方法4：还可以通过类加载器来得到Class对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> car.getClass().getClassLoader()</span><br><span class="line">classLoader.loadClass(<span class="string">&quot;java.lang.String&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="哪些类型有class对象">3、哪些类型有Class对象？</h4>
<p>​
外部类、内部类、接口、数组、美剧、注解、基本数据类型、void都有Class对象</p>
<h4 id="比较class实例">4、比较”Class“实例</h4>
<p>​
因为<strong>"Class"</strong>实例在JVM中是唯一的，所以，上述方法获取的<strong>"Class"</strong>实例是同一个实例。可以用<code>==</code>比较两个<strong>"Class"</strong>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls1</span> <span class="operator">=</span> String.class;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">cls2</span> <span class="operator">=</span> s.getClass();</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">sameClass</span> <span class="operator">=</span> cls1 == cls2; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：<strong>"Class"</strong>实例比较和<strong>instanceof</strong>的差别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> Integer; <span class="comment">// true，因为n是Integer类型</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> Number; <span class="comment">// true，因为n是Number类型的子类</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b3</span> <span class="operator">=</span> n.getClass() == Integer.class; <span class="comment">// true，因为n.getClass()返回Integer.class</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b4</span> <span class="operator">=</span> n.getClass() == Number.class; <span class="comment">// false，因为Integer.class!=Number.class</span></span><br></pre></td></tr></table></figure>
<p>​
用<code>instanceof</code>不但匹配指定类型，还匹配指定类型的子类。而用<code>==</code>判断<code>class</code>实例可以精确地判断数据类型，但不能作子类型比较。</p>
<p>​
通常情况下，我们应该用<code>instanceof</code>判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。只有在需要精确判断一个类型是不是某个<code>class</code>的时候，我们才使用<code>==</code>判断<code>class</code>实例。</p>
<h4 id="动态加载特性">4、动态加载特性：</h4>
<p>​
JVM在执行Java程序的时候，<strong>并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载</strong>。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            create(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
当执行<code>Main.java</code>时，由于用到了<code>Main</code>，因此，JVM首先会把<code>Main.class</code>加载到内存。然而，并不会加载<code>Person.class</code>，除非程序执行到<code>create()</code>方法，JVM发现需要加载<code>Person</code>类时，才会首次加载<code>Person.class</code>。如果没有执行<code>create()</code>方法，那么<code>Person.class</code>根本就不会被加载。</p>
<p>​ 这就是<strong>JVM动态加载<code>class</code>的特性</strong>。</p>
<p>​
<strong>备注</strong>：动态加载类的特性对于Java程序非常重要。利用JVM动态加载类的特性，我们才能在运行期根据条件加载不同的实现类。例如，Commons
Logging总是优先使用Log4j，只有当Log4j不存在时，才使用JDK的logging。利用JVM动态加载特性，大致的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Commons Logging优先使用Log4j:</span></span><br><span class="line"><span class="type">LogFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (isClassPresent(<span class="string">&quot;org.apache.logging.log4j.Logger&quot;</span>)) &#123;</span><br><span class="line">    factory = createLog4j();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    factory = createJdkLog();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isClassPresent</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 这就是为什么我们只需要把Log4j的jar包放到classpath中，Commons
Logging就会自动使用Log4j的原因。</p>
<h3 id="五java动态加载和静态加载">五、JAVA动态加载和静态加载</h3>
<ul>
<li><p>静态加载：编译的时候加载相关的类，如果没有则报错，依赖性太强</p></li>
<li><p>动态加载：运行时加载所需的类，如果运行时不用该类，则不会报错。
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220829114232361.png" /></p></li>
<li><p>类加载的时机：</p>
<ul>
<li>创建对象时 //静态加载</li>
<li>当子类被加载时 //静态加载</li>
<li>调用类中的静态成员时候 //静态加载</li>
<li>通过反射 //动态加载</li>
</ul></li>
</ul>
<h3 id="六类加载流程">六、类加载流程:</h3>
<ul>
<li>如下为详细的JAVA代码运行流程：</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220829115028951.png" /></p>
<ul>
<li>类加载的阶段概述：
<ul>
<li>加载：将类的class文件读入内存，并为之创建一个java.lang.Class对象，此过程由类加载器完成</li>
<li>连接：将类的二进制数据合并到JRE中</li>
<li>初始化：JVM负责对类进行初始化，这里主要指静态成员</li>
</ul></li>
</ul>
<h5 id="加载阶段">加载阶段：</h5>
<ul>
<li>JVM在该阶段的主要目的是将字节码从不同的数据源（可能是class
文件、也可能是jar包，甚至网络）<strong>转化为二进制字节流加载到内存中</strong>，并生成一个代表该类的java.lang.Class
对象</li>
</ul>
<h5 id="连接阶段">连接阶段：</h5>
<ul>
<li><strong>验证</strong>：
<ul>
<li>确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。包括：文件格式验证、元数据验证、字节码验证和符号引用验证.</li>
</ul></li>
<li><strong>准备</strong>:
<ul>
<li>JVM
会在该阶段对<strong>静态变量</strong>，分配内存并默认初始化（对应数据类型的默认初始值，如0、0L、null、false等）。这些变量所使用的内存都将在<strong>方法区</strong>中进行分配.</li>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220902174130300.png" /></li>
</ul></li>
<li><strong>解析</strong>:
<ul>
<li>虚拟机将常量池内的符号引用替换为直接引用的过程.</li>
<li>在编译过程中,A类对B类的引用,都是符号引用.
在此阶段把这些符号引用,替换为直接引用(即内存地址的记录)</li>
</ul></li>
</ul>
<h5 id="初始化阶段">初始化阶段:</h5>
<ul>
<li>到初始化阶段，才真正开始执行类中定义的Java程序代码，此阶段是执行&lt;clinit&gt;()方法的过程。</li>
<li>&lt;clinit&gt;()
方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有静态变量的赋值动作和静态代码块中的语句，并进行合并。</li>
<li>虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的&lt;clinit&gt;()方法，其他线程都需要阻塞等待，直到活动线程执行&lt;clinit&gt;()方法完毕</li>
</ul>
<h3 id="七通过class实例访问字段详">七、通过Class实例访问字段——详：</h3>
<h4 id="获取字段信息">1、获取字段信息</h4>
<p>​
对任意的一个<code>Object</code>实例，只要我们获取了它的<strong>"Class"</strong>，就可以获取它的一切信息。</p>
<p>​ <strong>"Class"</strong>类提供了以下几个方法来获取字段Field：</p>
<ul>
<li>Field
getField(name)：根据字段名获取某个public的field（包括父类）</li>
<li>Field
getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）</li>
<li>Field[] getFields()：获取所有public的field（包括父类）</li>
<li>Field[]
getDeclaredFields()：获取当前类的所有field（不包括父类）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">stdClass</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// 获取public字段&quot;score&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getField(<span class="string">&quot;score&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取继承的public字段&quot;name&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getField(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取private字段&quot;grade&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getDeclaredField(<span class="string">&quot;grade&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 上述输出 </span></span><br><span class="line"><span class="comment">public int Student.score</span></span><br><span class="line"><span class="comment">public java.lang.String Person.name</span></span><br><span class="line"><span class="comment">private int Student.grade</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>一个<code>Field</code>对象包含了一个字段的所有信息：</p>
<ul>
<li><code>getName()</code>：返回字段名称，例如，<code>"name"</code>；</li>
<li><code>getType()</code>：返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code>；</li>
<li><code>getModifiers()</code>：返回字段的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li>
</ul>
<h4 id="获取字段值">2、获取字段值：</h4>
<p>​
利用反射拿到字段的一个<code>Field</code>实例只是第一步，我们还可以拿到一个实例对应的该字段的值。</p>
<p>​
例如，对于一个<code>Person</code>实例，我们可以先拿到<code>name</code>字段对应的<code>Field</code>，再获取这个实例的<code>name</code>字段的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> p.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> f.get(p);</span><br><span class="line">        System.out.println(value); <span class="comment">// &quot;Xiao Ming&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
上述代码先获取<code>Class</code>实例，再获取<code>Field</code>实例，然后，用<code>Field.get(Object)</code>获取指定实例的指定字段的值。</p>
<p>​
运行代码，如果不出意外，会得到一个<code>IllegalAccessException</code>，这是因为<code>name</code>被定义为一个<code>private</code>字段，正常情况下，<code>Main</code>类无法访问<code>Person</code>类的<code>private</code>字段。要修复错误，可以将<code>private</code>改为<code>public</code>，或者，在调用<code>Object value = f.get(p);</code>前，先写一句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">f.setAccessible(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>调用<code>Field.setAccessible(true)</code>的意思是，别管这个字段是不是<code>public</code>，一律允许访问。</p>
<h4 id="设置字段值">3、设置字段值：</h4>
<p>​
通过Field实例既然可以获取到指定实例的字段值，自然也可以设置字段的值。</p>
<p>​
设置字段值是通过<code>Field.set(Object, Object)</code>实现的，其中第一个<code>Object</code>参数是指定的实例，第二个<code>Object</code>参数是待修改的值。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Xiao Ming&quot;</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> p.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        f.set(p, <span class="string">&quot;Xiao Hong&quot;</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Xiao Hong&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，修改非<code>public</code>字段，需要首先调用<code>setAccessible(true)</code>。</p>
<h3 id="八调用方法">八、调用方法：</h3>
<h4 id="简介">1、简介</h4>
<p>可以通过<code>Class</code>实例获取所有<code>Method</code>信息。<code>Class</code>类提供了以下几个方法来获取<code>Method</code>：</p>
<ul>
<li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li>
<li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li>
<li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li>
<li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">stdClass</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// 获取public方法getScore，参数为String:</span></span><br><span class="line">        System.out.println(stdClass.getMethod(<span class="string">&quot;getScore&quot;</span>, String.class));</span><br><span class="line">        <span class="comment">// 获取继承的public方法getName，无参数:</span></span><br><span class="line">        System.out.println(stdClass.getMethod(<span class="string">&quot;getName&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取private方法getGrade，参数为int:</span></span><br><span class="line">        System.out.println(stdClass.getDeclaredMethod(<span class="string">&quot;getGrade&quot;</span>, <span class="type">int</span>.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getGrade</span><span class="params">(<span class="type">int</span> year)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public int Student.getScore(java.lang.String)</span></span><br><span class="line"><span class="comment">public java.lang.String Person.getName()</span></span><br><span class="line"><span class="comment">private int Student.getGrade(int)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>一个<code>Method</code>对象包含一个方法的所有信息：</p>
<ul>
<li><code>getName()</code>：返回方法名称，例如：<code>"getScore"</code>；</li>
<li><code>getReturnType()</code>：返回方法返回值类型，也是一个Class实例，例如：<code>String.class</code>；</li>
<li><code>getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code>&#123;String.class, int.class&#125;</code>；</li>
<li><code>getModifiers()</code>：返回方法的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li>
</ul>
<h4 id="调用方法">2、调用方法：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s = &quot;Hello world&quot;;</span><br><span class="line">String r = s.substring(6); // &quot;world&quot;</span><br></pre></td></tr></table></figure>
<p>​ 如果用反射来用<code>substring</code>方法，需要以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// String对象:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取String substring(int)方法，参数为int:</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> String.class.getMethod(<span class="string">&quot;substring&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">// 在s对象上调用该方法并获取结果:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> (String) m.invoke(s, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
对<code>Method</code>实例调用<code>invoke</code>就相当于调用该方法，<code>invoke</code>的第一个参数是对象实例，即在哪个实例上调用该方法，后面的可变参数要与方法参数一致，否则将报错。</p>
<h4 id="调用静态方法">3、调用静态方法：</h4>
<p>​
如果获取到的Method表示一个静态方法，调用静态方法时，由于无需指定实例对象，所以<code>invoke</code>方法传入的第一个参数永远为<code>null</code>。我们以<code>Integer.parseInt(String)</code>为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取Integer.parseInt(String)方法，参数为String:</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> Integer.class.getMethod(<span class="string">&quot;parseInt&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">// 调用该静态方法并获取结果:</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> (Integer) m.invoke(<span class="literal">null</span>, <span class="string">&quot;12345&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="调用非public方法">4、调用非public方法：</h4>
<p>为了调用非public方法，我们通过<code>Method.setAccessible(true)</code>允许其调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> p.getClass().getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        m.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        m.invoke(p, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        System.out.println(p.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="九调用构造方法">九、调用构造方法：</h3>
<p>我们通常使用<code>new</code>操作符创建新的实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Person p = new Person();</span><br></pre></td></tr></table></figure>
<p>如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Person p = Person.class.newInstance();</span><br></pre></td></tr></table></figure>
<p>​ 调用Class.newInstance()
的局限是，<strong>它只能调用该类的public无参数构造方法</strong>。如果构造方法带有参数，或者不是public，就无法直接通过Class.newInstance()
来调用。</p>
<p>​
为了调用任意的构造方法，Java的<strong>反射API提供了Constructor对象</strong>，它包含一个构造方法的所有信息，可以创建一个实例。Constructor对象和Method非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取构造方法Integer(int):</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons1</span> <span class="operator">=</span> Integer.class.getConstructor(<span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">// 调用构造方法:</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n1</span> <span class="operator">=</span> (Integer) cons1.newInstance(<span class="number">123</span>);</span><br><span class="line">        System.out.println(n1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取构造方法Integer(String)</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons2</span> <span class="operator">=</span> Integer.class.getConstructor(String.class);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n2</span> <span class="operator">=</span> (Integer) cons2.newInstance(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">        System.out.println(n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过Class实例获取Constructor的方法如下：</p>
<ul>
<li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的<code>Constructor</code>；</li>
<li><code>getDeclaredConstructor(Class...)</code>：获取某个<code>Constructor</code>；</li>
<li><code>getConstructors()</code>：获取所有<code>public</code>的<code>Constructor</code>；</li>
<li><code>getDeclaredConstructors()</code>：获取所有<code>Constructor</code>。</li>
</ul>
<p>​
注意<code>Constructor</code>总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。</p>
<p>​
调用非<code>public</code>的<code>Constructor</code>时，必须首先通过<code>setAccessible(true)</code>设置允许访问。<code>setAccessible(true)</code>可能会失败。</p>
<h3 id="十获取类的结构信息">十、获取类的结构信息：</h3>
<h4 id="获取父类的class">1、获取父类的Class</h4>
<p>​
有了某个类的<code>Class</code>实例，我们还可以获取它的父类的<code>Class</code>：如下，<code>Integer</code>的父类类型是<code>Number</code>，<code>Number</code>的父类是<code>Object</code>，<code>Object</code>的父类是<code>null</code>。除<code>Object</code>外，其他任何非<code>interface</code>的<code>Class</code>都必定存在一个父类类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">i</span> <span class="operator">=</span> Integer.class;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">n</span> <span class="operator">=</span> i.getSuperclass();</span><br><span class="line">        System.out.println(n);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">o</span> <span class="operator">=</span> n.getSuperclass();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(o.getSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">class java.lang.Number</span></span><br><span class="line"><span class="comment">class java.lang.Object</span></span><br><span class="line"><span class="comment">null </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="获取interface">2、获取Interface</h4>
<p>​
由于一个类可能实现一个或多个接口，通过<code>Class</code>我们就可以查询到实现的接口类型。例如，查询<code>Integer</code>实现的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">s</span> <span class="operator">=</span> Integer.class;</span><br><span class="line">        Class[] is = s.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class i : is) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">interface java.lang.Comparable</span></span><br><span class="line"><span class="comment">interface java.lang.constant.Constable</span></span><br><span class="line"><span class="comment">interface java.lang.constant.ConstantDesc </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>运行上述代码可知，<code>Integer</code>实现的接口有：</p>
<ul>
<li>java.lang.Comparable</li>
<li>java.lang.constant.Constable</li>
<li>java.lang.constant.ConstantDesc</li>
</ul>
<p>要特别注意：</p>
<ul>
<li><p><code>getInterfaces()</code>只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型：</p></li>
<li><p>对所有<code>interface</code>的<code>Class</code>调用<code>getSuperclass()</code>返回的是<code>null</code></p></li>
<li><p>如果一个类没有实现任何<code>interface</code>，那么<code>getInterfaces()</code>返回空数组。</p></li>
</ul>
<h4 id="继承关系">3、继承关系</h4>
<ul>
<li>当我们判断一个实例是否是某个类型时，正常情况下，使用<code>instanceof</code>操作符：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">n</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isDouble</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> Double; <span class="comment">// false</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isInteger</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> Integer; <span class="comment">// true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isNumber</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> Number; <span class="comment">// true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isSerializable</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> java.io.Serializable; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果是两个<code>Class</code>实例，要判断一个向上转型是否成立，可以调用<code>isAssignableFrom()</code>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Integer i = ?</span></span><br><span class="line">Integer.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Integer</span></span><br><span class="line"><span class="comment">// Number n = ?</span></span><br><span class="line">Number.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Number</span></span><br><span class="line"><span class="comment">// Object o = ?</span></span><br><span class="line">Object.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Object</span></span><br><span class="line"><span class="comment">// Integer i = ?</span></span><br><span class="line">Integer.class.isAssignableFrom(Number.class); <span class="comment">// false，因为Number不能赋值给Integer</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>⑤  编程语言类笔记</category>
        <category>java入门系列笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>reflection</tag>
      </tags>
  </entry>
  <entry>
    <title>java系列笔记4——java异常处理</title>
    <url>/2022/01/30/2e7ebd82e85d/</url>
    <content><![CDATA[<p>参考教程网址：https://www.liaoxuefeng.com/wiki/1252599548343744/1264734349295520</p>
<h3 id="一java异常简介">一、Java异常简介：</h3>
<h4 id="异常介绍与分类">1、异常介绍与分类</h4>
<p>所以，一个健壮的程序必须处理各种各样的错误。</p>
<p>调用方如何获知调用失败的信息？有两种方法：</p>
<ul>
<li>方法1：约定返回错误码，常见于C</li>
<li>方法2：在语言层面上提供异常处理机制：（较为常用）</li>
</ul>
<p><strong>异常是一种<code>class</code>，因此它本身带有类型信息。异常可以在任何地方抛出，但只需要在上层捕获，这样就和方法调用分离了</strong></p>
<p>Java的异常是<code>class</code>，它的继承关系如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                     ┌───────────┐</span><br><span class="line">                     │  Object   │</span><br><span class="line">                     └───────────┘</span><br><span class="line">                           ▲</span><br><span class="line">                           │</span><br><span class="line">                     ┌───────────┐</span><br><span class="line">                     │ Throwable │</span><br><span class="line">                     └───────────┘</span><br><span class="line">                           ▲</span><br><span class="line">                 ┌─────────┴─────────┐</span><br><span class="line">                 │                   │</span><br><span class="line">           ┌───────────┐       ┌───────────┐</span><br><span class="line">           │   Error   │       │ Exception │</span><br><span class="line">           └───────────┘       └───────────┘</span><br><span class="line">                 ▲                   ▲</span><br><span class="line">         ┌───────┘              ┌────┴──────────┐</span><br><span class="line">         │                      │               │</span><br><span class="line">┌─────────────────┐    ┌─────────────────┐┌───────────┐</span><br><span class="line">│OutOfMemoryError │... │RuntimeException ││IOException│...</span><br><span class="line">└─────────────────┘    └─────────────────┘└───────────┘</span><br><span class="line">                                ▲</span><br><span class="line">                    ┌───────────┴─────────────┐</span><br><span class="line">                    │                         │</span><br><span class="line">         ┌─────────────────────┐ ┌─────────────────────────┐</span><br><span class="line">         │NullPointerException │ │IllegalArgumentException │...</span><br><span class="line">         └─────────────────────┘ └─────────────────────────┘</span><br></pre></td></tr></table></figure>
<p>从上图继承关系可知：<code>Throwable</code>是异常体系的根，它继承自<code>Object</code>。<code>Throwable</code>有两个体系：<code>Error</code>和<code>Exception</code>，<code>Error</code>表示严重的错误，程序对此一般无能为力，例如：</p>
<ul>
<li><code>OutOfMemoryError</code>：内存耗尽</li>
<li><code>NoClassDefFoundError</code>：无法加载某个Class</li>
<li><code>StackOverflowError</code>：栈溢出</li>
</ul>
<p>而<code>Exception</code>则是运行时的错误，它可以被捕获并处理。</p>
<ul>
<li><p>某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：</p>
<ul>
<li><p><code>NumberFormatException</code>：数值类型的格式错误</p></li>
<li><p><code>FileNotFoundException</code>：未找到文件</p></li>
<li><p><code>SocketException</code>：读取网络失败</p></li>
</ul></li>
<li><p>还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如：</p>
<ul>
<li><p><code>NullPointerException</code>：对某个<code>null</code>的对象调用方法或字段</p></li>
<li><p><code>IndexOutOfBoundsException</code>：数组索引越界</p></li>
</ul></li>
</ul>
<p><code>Exception</code>又分为两大类：</p>
<ol type="1">
<li><code>RuntimeException</code>以及它的子类；</li>
<li>非<code>RuntimeException</code>（包括<code>IOException</code>、<code>ReflectiveOperationException</code>等等）</li>
</ol>
<p><strong>Java规定</strong>：</p>
<ul>
<li>必须捕获的异常，包括<code>Exception</code>及其子类，但不包括<code>RuntimeException</code>及其子类，这种类型的异常称为<strong>Checked
Exception</strong>。</li>
<li>不需要捕获的异常，包括<code>Error</code>及其子类，<code>RuntimeException</code>及其子类。</li>
</ul>
<h3 id="二捕获异常">二、捕获异常：</h3>
<h4 id="普通的捕获异常">1、普通的捕获异常：</h4>
<p>​
捕获异常使用<code>try...catch</code>语句，把可能发生异常的代码放到<code>try &#123;...&#125;</code>中，然后使用<code>catch</code>捕获对应的<code>Exception</code>及其子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">            <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="comment">// 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException:</span></span><br><span class="line">            System.out.println(e); <span class="comment">// 打印异常信息</span></span><br><span class="line">            <span class="keyword">return</span> s.getBytes(); <span class="comment">// 尝试使用用默认编码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​
如果我们不捕获<code>UnsupportedEncodingException</code>，会出现编译失败的问题：编译器会报错，错误信息类似：unreported
exception UnsupportedEncodingException; must be caught or declared to be
thrown，并且准确地指出需要捕获的语句是<code>return s.getBytes("GBK");</code>。意思是说，像<code>UnsupportedEncodingException</code>这样的Checked
Exception，必须被捕获。</p>
<p>​
<strong>这是因为<code>String.getBytes(String)</code>方法定义是：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] getBytes(String charsetName) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
<strong>在方法定义的时候，使用<code>throws Xxx</code>表示该方法可能抛出的异常类型</strong>。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。</p>
<p>​ <strong>注意</strong>：只要是方法声明的Checked
Exception，不在调用层捕获，也必须在更高的调用层捕获。所有未捕获的异常，最终也必须在<code>main()</code>方法中捕获，不会出现漏写<code>try</code>的情况。这是由编译器保证的。<code>main()</code>方法也是最后捕获<code>Exception</code>的机会。</p>
<p>​
<strong>注意</strong>：所有异常都可以调用<code>printStackTrace()</code>方法打印异常栈，这是一个简单有用的快速打印异常的方法。</p>
<h4 id="多个catch语句">2、多个catch语句：</h4>
<p>​
可以使用多个<code>catch</code>语句，每个<code>catch</code>分别捕获对应的<code>Exception</code>及其子类。JVM在捕获到异常后，会从上到下匹配<code>catch</code>语句，匹配到某个<code>catch</code>后，执行<code>catch</code>代码块，然后不再继续匹配。</p>
<p>​
<strong>存在多个<code>catch</code>的时候，<code>catch</code>的顺序非常重要：</strong>子类必须写在前面。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123; <span class="comment">// 永远捕获不到</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
<strong>对于上面的代码，<code>UnsupportedEncodingException</code>异常是永远捕获不到的</strong>，因为它是<code>IOException</code>的子类。当抛出<code>UnsupportedEncodingException</code>异常时，会被<code>catch (IOException e) &#123; ... &#125;</code>捕获并执行。</p>
<h4 id="finally语句">3、finally语句：</h4>
<p>无论是否有异常发生，如果我们都希望执行一些语句</p>
<p>Java的<code>try ... catch</code>机制还提供了<code>finally</code>语句，<code>finally</code>语句块保证有无错误都会执行。上述代码可以改写如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意<code>finally</code>有几个特点：</p>
<ol type="1">
<li><code>finally</code>语句不是必须的，可写可不写；</li>
<li><code>finally</code>总是最后执行。</li>
</ol>
<p>​
如果没有发生异常，就正常执行<code>try &#123; ... &#125;</code>语句块，然后执行<code>finally</code>。如果发生了异常，就中断执行<code>try &#123; ... &#125;</code>语句块，然后跳转执行匹配的<code>catch</code>语句块，最后执行<code>finally</code>。</p>
<h4 id="捕获多种异常">4、捕获多种异常：</h4>
<p>可以把两个处理逻辑一样的异常用<code>|</code>合并到一起</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | NumberFormatException e) &#123; <span class="comment">// IOException或NumberFormatException</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Bad input&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Unknown error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三抛出异常">三、抛出异常：</h3>
<h4 id="抛出异常链条">1、抛出异常链条：</h4>
<p>​
当某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个<code>try ... catch</code>被捕获为止</p>
<p>​ 通过<code>printStackTrace()</code>可以打印出方法的调用栈，类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.NumberFormatException: <span class="literal">null</span></span><br><span class="line">    at java.base/java.lang.Integer.parseInt(Integer.java:<span class="number">614</span>)</span><br><span class="line">    at java.base/java.lang.Integer.parseInt(Integer.java:<span class="number">770</span>)</span><br><span class="line">    at Main.process2(Main.java:<span class="number">16</span>)</span><br><span class="line">    at Main.process1(Main.java:<span class="number">12</span>)</span><br><span class="line">    at Main.main(Main.java:<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><code>printStackTrace()</code>对于调试错误非常有用，上述信息表示：<code>NumberFormatException</code>是在<code>java.lang.Integer.parseInt</code>方法中被抛出的，从下往上看，调用层次依次是：</p>
<ol type="1">
<li><code>main()</code>调用<code>process1()</code>；</li>
<li><code>process1()</code>调用<code>process2()</code>；</li>
<li><code>process2()</code>调用<code>Integer.parseInt(String)</code>；</li>
<li><code>Integer.parseInt(String)</code>调用<code>Integer.parseInt(String, int)</code>。</li>
</ol>
<h4 id="如何抛出异常">2、如何抛出异常：</h4>
<p>抛出异常分两步：</p>
<ol type="1">
<li>创建某个<code>Exception</code>的实例；</li>
<li>用<code>throw</code>语句抛出。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">process2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">NullPointerException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或写成一行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">process2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="异常捕获后再次抛出">3、异常捕获后再次抛出：</h4>
<p>​
如果一个方法捕获了某个异常后，又在<code>catch</code>子句中抛出新的异常，就相当于把抛出的异常类型“转换”了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">process1</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process2();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">process2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印出的异常栈类似：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalArgumentException</span><br><span class="line">    at Main.process1(Main.java:15)</span><br><span class="line">    at Main.main(Main.java:5)</span><br></pre></td></tr></table></figure>
<p>​
这说明<strong>新的异常丢失了原始异常信息</strong>，我们已经看不到原始异常<code>NullPointerException</code>的信息了。</p>
<p>​
<strong>为了能追踪到完整的异常栈，在构造异常的时候，把原始的<code>Exception</code>实例传进去，新的<code>Exception</code>就可以持有原始<code>Exception</code>信息。</strong>对上述代码改进如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行上述代码，打印出的异常栈类似：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: java.lang.NullPointerException</span><br><span class="line">    at Main.process1(Main.java:15)</span><br><span class="line">    at Main.main(Main.java:5)</span><br><span class="line">Caused by: java.lang.NullPointerException</span><br><span class="line">    at Main.process2(Main.java:20)</span><br><span class="line">    at Main.process1(Main.java:13)</span><br></pre></td></tr></table></figure>
<p>​
注意到<code>Caused by: Xxx</code>，说明捕获的<code>IllegalArgumentException</code>并不是造成问题的根源，根源在于<code>NullPointerException</code>，是在<code>Main.process2()</code>方法抛出的。</p>
<p>​
在代码中<strong>获取原始异常可以使用<code>Throwable.getCause()</code>方法。如果返回<code>null</code>，说明已经是“根异常”了。</strong></p>
<h4
id="在try或catch种抛出异常finally语句会先执行然后再抛出异常">4、在try或catch种抛出异常，finally语句会先执行，然后再抛出异常</h4>
<h4 id="异常屏蔽">5、异常屏蔽：</h4>
<p>​
如果在执行<code>finally</code>语句时抛出异常，那么，<code>catch</code>语句的异常还能否继续抛出？例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer.parseInt(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catched&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上述代码，发现异常信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">catched</span><br><span class="line">finally</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException</span><br><span class="line">    at Main.main(Main.java:11)</span><br></pre></td></tr></table></figure>
<p>​
这说明<strong><code>finally</code>抛出异常后，原来在<code>catch</code>中准备抛出的异常就“消失”了，因为只能抛出一个异常。没有被抛出的异常称为“被屏蔽”的异常</strong>（Suppressed
Exception）。</p>
<p>​
<strong>绝大多数情况下，在<code>finally</code>中不要抛出异常</strong>。因此，我们通常不需要关心<code>Suppressed Exception</code>。</p>
<h3 id="四自定义异常">四、自定义异常</h3>
<p>Java标准库定义的常用异常包括：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception</span><br><span class="line">│</span><br><span class="line">├─ RuntimeException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ NullPointerException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ IndexOutOfBoundsException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ SecurityException</span><br><span class="line">│  │</span><br><span class="line">│  └─ IllegalArgumentException 参数检查不合法</span><br><span class="line">│     │</span><br><span class="line">│     └─ NumberFormatException</span><br><span class="line">│</span><br><span class="line">├─ IOException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ UnsupportedCharsetException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ FileNotFoundException</span><br><span class="line">│  │</span><br><span class="line">│  └─ SocketException</span><br><span class="line">│</span><br><span class="line">├─ ParseException</span><br><span class="line">│</span><br><span class="line">├─ GeneralSecurityException</span><br><span class="line">│</span><br><span class="line">├─ SQLException</span><br><span class="line">│</span><br><span class="line">└─ TimeoutException</span><br></pre></td></tr></table></figure>
<p><strong>当我们在代码中需要抛出异常时，尽量使用JDK已定义的异常类型</strong></p>
<p>在一个大型项目中，可以自定义新的异常类型，但是，保持一个合理的异常继承体系是非常重要的。</p>
<p><strong>一个常见的做法是自定义一个<code>BaseException</code>作为“根异常”，然后，派生出各种业务类型的异常。</strong></p>
<p><code>BaseException</code>需要从一个适合的<code>Exception</code>派生，通常建议从<code>RuntimeException</code>派生：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他业务类型的异常就可以从<code>BaseException</code>派生：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserNotFoundException</span> <span class="keyword">extends</span> <span class="title class_">BaseException</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginFailedException</span> <span class="keyword">extends</span> <span class="title class_">BaseException</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>自定义的<code>BaseException</code>应该提供多个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">(String message, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
上述构造方法实际上都是原样照抄<code>RuntimeException</code>。这样，抛出异常的时候，就可以选择合适的构造方法。通过IDE可以根据父类快速生成子类的构造方法。</p>
<h3 id="五nullpointerexception">五、NullPointerException</h3>
<p>​
<code>NullPointerException</code>即空指针异常，俗称NPE。如果一个对象为<code>null</code>，调用其方法或访问其字段就会产生`NullPointerException</p>
<h4
id="如何处理nullpointerexception">1、如何处理NullPointerException</h4>
<p>​
遇到<code>NullPointerException</code>，遵循原则是早暴露，早修复，严禁使用<code>catch</code>来隐藏这种编码错误，一些好的编码习惯：如下</p>
<ul>
<li>成员变量在定义时初始化：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用空字符串<code>""</code>而不是默认的<code>null</code>可避免很多<code>NullPointerException</code>，编写业务逻辑时，用空字符串<code>""</code>表示未填写比<code>null</code>安全得多。</p></li>
<li><p>返回空字符串<code>""</code>、空数组而不是<code>null</code>,这样可以使得调用方无需检查结果是否为<code>null</code>。</p></li>
<li><p>如果调用方一定要根据<code>null</code>判断，比如返回<code>null</code>表示文件不存在，那么考虑返回<code>Optional&lt;T&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Optional&lt;String&gt; <span class="title function_">readFromFile</span><span class="params">(String file)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!fileExist(file)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样调用方必须通过<code>Optional.isPresent()</code>判断是否有结果。</p></li>
</ul>
<h4
id="如何定位nullpointerexception">2、如何定位NullPointerException</h4>
<p>​
如果产生了<code>NullPointerException</code>，例如，调用<code>a.b.c.x()</code>时产生了<code>NullPointerException</code>，原因可能是：</p>
<ul>
<li><code>a</code>是<code>null</code>；</li>
<li><code>a.b</code>是<code>null</code>；</li>
<li><code>a.b.c</code>是<code>null</code>；</li>
</ul>
<p>​ 从Java
14开始，如果产生了<code>NullPointerException</code>，JVM可以给出详细的信息告诉我们<code>null</code>对象到底是谁。我们来看例子：</p>
<p>​
可以在<code>NullPointerException</code>的详细信息中看到类似<code>... because "&lt;local1&gt;.address.city" is null</code>，意思是<code>city</code>字段为<code>null</code>，这样我们就能快速定位问题所在。</p>
<p>​ 这种增强的<code>NullPointerException</code>详细信息是Java
14新增的功能，但默认是关闭的，我们可以给JVM添加一个<code>-XX:+ShowCodeDetailsInExceptionMessages</code>参数启用它：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -XX:+ShowCodeDetailsInExceptionMessages Main.java</span><br></pre></td></tr></table></figure>
<h3 id="六使用断言">六、使用断言</h3>
<p>​
断言（Assertion）是一种<strong>调试程序的方式</strong>。在Java中，使用<code>assert</code>关键字来实现断言。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> Math.abs(-<span class="number">123.45</span>);</span><br><span class="line">    <span class="keyword">assert</span> x &gt;= <span class="number">0</span> : <span class="string">&quot;x must &gt;= 0&quot;</span>;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
语句<code>assert x &gt;= 0;</code>即为断言，断言条件<code>x &gt;= 0</code>预期为<code>true</code>。如果计算结果为<code>false</code>，则断言失败，抛出<code>AssertionError</code>。":
"x must &gt;= 0" " 为可选的断言消息：</p>
<p>​
这样，断言失败的时候，<code>AssertionError</code>会带上消息<code>x must &gt;= 0</code>，更加便于调试。</p>
<p>​
<strong>Java断言的特点是：断言失败时会抛出<code>AssertionError</code>，导致程序结束退出。因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段。</strong></p>
<p><strong>注意</strong>：这JVM默认关闭断言指令，即遇到<code>assert</code>语句就自动忽略了，不执行。要执行<code>assert</code>语句，必须给Java虚拟机传递<code>-enableassertions</code>（可简写为<code>-ea</code>）参数启用断言。所以，上述程序必须在命令行下运行才有效果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ java -ea Main.java</span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.AssertionError</span><br><span class="line">	at Main.main(Main.java:5)</span><br></pre></td></tr></table></figure>
<p>​ 断言很少被使用，更好的方法是编写单元测试。</p>
<h3 id="七使用jdk-logging">七、使用JDK Logging</h3>
<h4 id="使用日志的目的">1、使用日志的目的？</h4>
<p>日志就是Logging，它的目的是为了取代<code>System.out.println()</code>。</p>
<p>输出日志，而不是用<code>System.out.println()</code>，有以下几个好处：</p>
<ol type="1">
<li>可以设置输出样式，避免自己每次都写<code>"ERROR: " + var</code>；</li>
<li>可以设置输出级别，禁止某些级别输出。例如，只输出错误日志；</li>
<li>可以被重定向到文件，这样可以在程序运行结束后查看日志；</li>
<li>可以按包名控制日志级别，只输出某些包打的日志；</li>
</ol>
<h4 id="如何使用日志">2、如何使用日志？</h4>
<p>Java标准库内置了日志包<code>java.util.logging</code>，我们可以直接用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getGlobal();</span><br><span class="line">        logger.info(<span class="string">&quot;start process...&quot;</span>);</span><br><span class="line">        logger.warning(<span class="string">&quot;memory is running out...&quot;</span>);</span><br><span class="line">        logger.fine(<span class="string">&quot;ignored.&quot;</span>);</span><br><span class="line">        logger.severe(<span class="string">&quot;process will be terminated...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行上述代码，得到类似如下的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mar 02, 2019 6:32:13 PM Hello main</span><br><span class="line">INFO: start process...</span><br><span class="line">Mar 02, 2019 6:32:13 PM Hello main</span><br><span class="line">WARNING: memory is running out...</span><br><span class="line">Mar 02, 2019 6:32:13 PM Hello main</span><br><span class="line">SEVERE: process will be terminated...</span><br></pre></td></tr></table></figure>
<p>对比可见，使用日志最大的好处是，它自动打印了时间、调用类、调用方法等很多有用的信息。</p>
<h4 id="日志的输出级别">3、日志的输出级别：</h4>
<p>再仔细观察发现上述输出，4条日志，只打印了3条，<code>logger.fine()</code>没有打印。这是因为，日志的输出可以设定级别。JDK的Logging定义了7个日志级别，从严重到普通：</p>
<ul>
<li>SEVERE</li>
<li>WARNING</li>
<li>INFO</li>
<li>CONFIG</li>
<li>FINE</li>
<li>FINER</li>
<li>FINEST</li>
</ul>
<p>​
因为<strong>默认级别是INFO，因此，INFO级别以下的日志，不会被打印出来。</strong>使用日志级别的好处在于，<strong>调整级别，就可以屏蔽掉很多调试相关的日志输出。</strong></p>
<p>使用Java标准库内置的Logging有以下局限：</p>
<ul>
<li><p>Logging系统在JVM启动时读取配置文件并完成初始化，一旦开始运行<code>main()</code>方法，就无法修改配置；</p></li>
<li><p>配置不太方便，需要在JVM启动时传递参数<code>-Djava.util.logging.config.file=&lt;config-file-name&gt;</code>。</p></li>
</ul>
<p>​
<strong>因此，Java标准库内置的Logging使用并不是非常广泛，更广泛的是下一个模块中所说的Commons
Logging 或 Log4j 或</strong></p>
<h3 id="八使用commons-logging">八、使用Commons Logging</h3>
<h4 id="简单介绍">1、简单介绍</h4>
<p>​ <strong>Commons
Logging是一个第三方日志库，它是由Apache创建的日志模块</strong></p>
<p>​ Commons
Logging的特色是，<strong>它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。</strong>默认情况下，<strong>Commons
Logging自动搜索并使用Log4j</strong>（Log4j是另一个流行的日志系统），如果没有找到Log4j，再使用JDK
Logging。</p>
<h4 id="如何使用">2、如何使用：</h4>
<p>第一步，通过<code>LogFactory</code>获取<code>Log</code>类的实例；</p>
<p>第二步，使用<code>Log</code>实例的方法打日志。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Log</span> <span class="variable">log</span> <span class="operator">=</span> LogFactory.getLog(Main.class);</span><br><span class="line">        log.info(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        log.warn(<span class="string">&quot;end.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="日志级别">3、日志级别：</h4>
<p>Commons Logging定义了6个日志级别：</p>
<ul>
<li>FATAL</li>
<li>ERROR</li>
<li>WARNING</li>
<li>INFO</li>
<li>DEBUG</li>
<li>TRACE</li>
</ul>
<p>默认级别是<code>INFO</code>。</p>
<h4 id="通常使用指南">4、通常使用指南</h4>
<ul>
<li>使用Commons
Logging时，如果在静态方法中引用<code>Log</code>，通常直接定义一个静态类型变量：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在静态方法中引用Log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">log</span> <span class="operator">=</span> LogFactory.getLog(Main.class);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在实例方法中引用<code>Log</code>，通常定义一个实例变量：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在实例方法中引用Log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">log</span> <span class="operator">=</span> LogFactory.getLog(getClass());</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
<strong>注意到实例变量log的获取方式是<code>LogFactory.getLog(getClass())</code>，虽然也可以用<code>LogFactory.getLog(Person.class)</code>，但是前一种方式有个非常大的好处，就是子类可以直接使用该<code>log</code>实例。例如：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在子类中使用父类实例化的log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
由于Java类的动态特性，子类获取的<code>log</code>字段实际上相当于<code>LogFactory.getLog(Student.class)</code>，但却是从父类继承而来，并且无需改动代码。</p>
<h4 id="记录异常">5、记录异常：</h4>
<p>​ 此外，Commons
Logging的日志方法，例如<code>info()</code>，除了标准的<code>info(String)</code>外，还提供了一个非常有用的重载方法：<code>info(String, Throwable)</code>，这使得记录异常更加简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;got exception!&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="九使用log4j">九、使用Log4j</h3>
<h4 id="框架简介">1、框架简介：</h4>
<p>​ 上述介绍了Commons
Logging，可以作为“日志接口”来使用。而真正的“日志实现”可以使用Log4j。</p>
<p>​ Log4j是一种非常流行的日志框架，最新版本是2.x。</p>
<p>​ Log4j是一个组件化设计的日志系统，它的架构大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log.info(&quot;User signed in.&quot;);</span><br><span class="line"> │</span><br><span class="line"> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐</span><br><span class="line"> ├──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│ Console  │</span><br><span class="line"> │   └──────────┘    └──────────┘    └──────────┘    └──────────┘</span><br><span class="line"> │</span><br><span class="line"> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐</span><br><span class="line"> ├──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│   File   │</span><br><span class="line"> │   └──────────┘    └──────────┘    └──────────┘    └──────────┘</span><br><span class="line"> │</span><br><span class="line"> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐</span><br><span class="line"> └──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│  Socket  │</span><br><span class="line">     └──────────┘    └──────────┘    └──────────┘    └──────────┘</span><br></pre></td></tr></table></figure>
<p>​
当我们使用Log4j输出一条日志时，Log4j自动通过不同的Appender把同一条日志输出到不同的目的地。例如：</p>
<ul>
<li>console：输出到屏幕；</li>
<li>file：输出到文件；</li>
<li>socket：通过网络输出到远程计算机；</li>
<li>jdbc：输出到数据库</li>
</ul>
<p>​
<strong>在输出日志的过程中，通过Filter来过滤哪些log需要被输出，哪些log不需要被输出。例如，仅输出<code>ERROR</code>级别的日志。</strong></p>
<p>最后，通过Layout来格式化日志信息，例如，自动添加日期、时间、方法名称等信息。</p>
<p><strong>上述结构虽然复杂，但我们在实际使用的时候，并不需要关心Log4j的API，而是通过配置文件来配置它。</strong></p>
<h4 id="如何使用-1">2、如何使用：</h4>
<p>以XML配置为例，使用Log4j的时候，我们把一个<code>log4j2.xml</code>的文件放到<code>classpath</code>下就可以让Log4j读取配置文件并按照我们的配置来输出日志。下面是一个配置文件的例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义日志格式 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;log.pattern&quot;</span>&gt;</span>%d&#123;MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125;%n%msg%n%n<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义文件名变量 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;file.err.filename&quot;</span>&gt;</span>log/err.log<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;file.err.pattern&quot;</span>&gt;</span>log/err.%i.log.gz<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义Appender，即目的地 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义输出到屏幕 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">&quot;console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志格式引用上面定义的log.pattern --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义输出到文件,文件名引用上面定义的file.err.filename --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;err&quot;</span> <span class="attr">bufferedIO</span>=<span class="string">&quot;true&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;file.err.filename&#125;&quot;</span> <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;file.err.pattern&#125;&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 根据文件大小自动切割日志 --&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;1 MB&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 保留最近10份 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 对info级别的日志，输出到console --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;console&quot;</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 对error级别的日志，输出到err，即上面定义的RollingFile --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;err&quot;</span> <span class="attr">level</span>=<span class="string">&quot;error&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​
虽然配置Log4j比较繁琐，但一旦配置完成，使用起来就非常方便。对上面的配置文件，凡是<code>INFO</code>级别的日志，会自动输出到屏幕，而<code>ERROR</code>级别的日志，不但会输出到屏幕，还会同时输出到文件。并且，一旦日志文件达到指定大小（1MB），Log4j就会自动切割新的日志文件，并最多保留10份。</p>
<p>​ 有了配置文件还不够，因为Log4j也是一个第三方库，我们需要从<a
href="https://logging.apache.org/log4j/2.x/download.html">这里</a>下载Log4j，解压后，把以下3个jar包放到<code>classpath</code>中：</p>
<ul>
<li>log4j-api-2.x.jar</li>
<li>log4j-core-2.x.jar</li>
<li>log4j-jcl-2.x.jar</li>
</ul>
<p>​ 因为Commons
Logging会自动发现并使用Log4j，所以，把上一节下载的<code>commons-logging-1.2.jar</code>也放到<code>classpath</code>中。</p>
<p>​ 要打印日志，只需要按Commons
Logging的写法写，不需要改动任何代码，就可以得到Log4j的日志输出，类似：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">03-03 12:09:45.880 [main] INFO  com.itranswarp.learnjava.Main</span><br><span class="line">Start process...</span><br></pre></td></tr></table></figure>
<h4 id="最佳实践">3、最佳实践：</h4>
<p>​ 在开发阶段，始终使用Commons
Logging接口来写入日志，并且开发阶段无需引入Log4j。如果需要把日志写入文件，
只需要把正确的配置文件和Log4j相关的jar包放入<code>classpath</code>，就可以自动把日志切换成使用Log4j写入，无需修改任何代码。</p>
<h3 id="十使用slf4j和logback">十、使用SLF4J和Logback</h3>
<p>​ SLF4J类似于Commons
Logging，也是一个日志接口，而Logback类似于Log4j，是一个日志的实现。</p>
<p>​ SLF4J对Commons Logging的接口有何改进？在Commons
Logging中，我们要打印日志，有时候得这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">p.setScore(score);</span><br><span class="line">log.info(<span class="string">&quot;Set score &quot;</span> + score + <span class="string">&quot; for Person &quot;</span> + p.getName() + <span class="string">&quot; ok.&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>拼字符串是一个非常麻烦的事情，所以SLF4J的日志接口改进成这样了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">p.setScore(score);</span><br><span class="line">logger.info(<span class="string">&quot;Set score &#123;&#125; for Person &#123;&#125; ok.&quot;</span>, score, p.getName());</span><br></pre></td></tr></table></figure>
<p>我们靠猜也能猜出来，SLF4J的日志接口传入的是一个带占位符的字符串，用后面的变量自动替换占位符，所以看起来更加自然。</p>
<p>具体可以参照更详细的官方网站的教程</p>
]]></content>
      <categories>
        <category>⑤  编程语言类笔记</category>
        <category>java入门系列笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>exception</tag>
      </tags>
  </entry>
  <entry>
    <title>java系列笔记3——java核心类</title>
    <url>/2022/01/30/5dc10d37c664/</url>
    <content><![CDATA[<p>参考教程网址：https://www.liaoxuefeng.com/wiki/1252599548343744/1260469698963456</p>
<h3 id="一字符串和编码">一、字符串和编码</h3>
<p>​
Java字符串的一个重要特点就是字符串<strong>不可变</strong>。这种不可变性是通过内部的<code>private final char[]</code>字段，以及没有任何修改<code>char[]</code>的方法实现的。</p>
<h4 id="字符串比较">1、字符串比较</h4>
<p>​ 必须使用<code>equals()</code>方法而不能用<code>==</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);     <span class="comment">//true</span></span><br><span class="line">        System.out.println(s1.equals(s2));  <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
从表面上看，两个字符串用<code>==</code>和<code>equals()</code>比较都为<code>true</code>，但<strong>实际上那只是Java编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池，自然<code>s1</code>和<code>s2</code>的引用就是相同的。</strong></p>
<p>​
所以，这种<code>==</code>比较返回<code>true</code>纯属巧合。换一种写法，<code>==</code>比较就会失败：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;HELLO&quot;</span>.toLowerCase();</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(s1.equals(s2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 要忽略大小写比较，使用<code>equalsIgnoreCase()</code>方法。</p>
<h4 id="搜索与提取子串">2、搜索与提取子串</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Hello&quot;</span>.contains(<span class="string">&quot;ll&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.indexOf(<span class="string">&quot;l&quot;</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.lastIndexOf(<span class="string">&quot;l&quot;</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.startsWith(<span class="string">&quot;He&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.endsWith(<span class="string">&quot;lo&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.substring(<span class="number">2</span>); <span class="comment">// &quot;llo&quot;</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.substring(<span class="number">2</span>, <span class="number">4</span>); <span class="string">&quot;ll&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="去除首尾空白字符">3、去除首尾空白字符：</h4>
<ul>
<li><p>使用<code>trim()</code>方法可以移除字符串首尾空白字符。<strong>空白字符包括空格，<code>\t</code>，<code>\r</code>，<code>\n</code></strong></p></li>
<li><p>另一个<code>strip()</code>方法也可以移除字符串首尾空白字符。它和<code>trim()</code>不同的是，类似中文的空格字符<code>\u3000</code>也会被移除</p></li>
</ul>
<h4 id="判断是否为空">4、判断是否为空：</h4>
<p><code>String</code>还提供了<code>isEmpty()</code>和<code>isBlank()</code>来判断字符串是否为空
和 空白字符串</p>
<p>空白字符串 代表 只含 <strong>空白字符</strong>的字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span>.isEmpty(); <span class="comment">// true，因为字符串长度为0</span></span><br><span class="line"><span class="string">&quot;  &quot;</span>.isEmpty(); <span class="comment">// false，因为字符串长度不为0</span></span><br><span class="line"><span class="string">&quot;  \n&quot;</span>.isBlank(); <span class="comment">// true，因为只包含空白字符</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.isBlank(); <span class="comment">// false，因为包含非空白字符</span></span><br></pre></td></tr></table></figure>
<h4 id="替换子串">5、替换子串</h4>
<ul>
<li>根据字符或字符串替换</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s.replace(<span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;w&#x27;</span>); <span class="comment">// &quot;hewwo&quot;，所有字符&#x27;l&#x27;被替换为&#x27;w&#x27;</span></span><br><span class="line">s.replace(<span class="string">&quot;ll&quot;</span>, <span class="string">&quot;~~&quot;</span>); <span class="comment">// &quot;he~~o&quot;，所有子串&quot;ll&quot;被替换为&quot;~~&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>正则表达式替换</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;A,,B;C ,D&quot;</span>;</span><br><span class="line">s.replaceAll(<span class="string">&quot;[\\,\\;\\s]+&quot;</span>, <span class="string">&quot;,&quot;</span>); <span class="comment">// &quot;A,B,C,D&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="分割拼接格式化字符串">6、分割、拼接、格式化字符串：</h4>
<ul>
<li>要分割字符串，使用<code>split()</code>方法，并且传入的也是正则表达式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;A,B,C,D&quot;</span>;</span><br><span class="line">String[] ss = s.split(<span class="string">&quot;\\,&quot;</span>); <span class="comment">// &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>拼接字符串使用静态方法<code>join()</code>，它用指定的字符串连接字符串数组：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.join(<span class="string">&quot;***&quot;</span>, arr); <span class="comment">// &quot;A***B***C&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>字符串提供了<code>formatted()</code>方法和<code>format()</code>静态方法，可以传入其他参数，替换占位符，然后生成新的字符串：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hi %s, your score is %d!&quot;</span>;</span><br><span class="line">        System.out.println(s.formatted(<span class="string">&quot;Alice&quot;</span>, <span class="number">80</span>));</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;Hi %s, your score is %.2f!&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="number">59.5</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="类型转换">7、类型转换：</h4>
<p>要把任意基本类型或引用类型转换为字符串，可以使用静态方法<code>valueOf()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String.valueOf(<span class="number">123</span>); <span class="comment">// &quot;123&quot;</span></span><br><span class="line">String.valueOf(<span class="number">45.67</span>); <span class="comment">// &quot;45.67&quot;</span></span><br><span class="line">String.valueOf(<span class="literal">true</span>); <span class="comment">// &quot;true&quot;</span></span><br><span class="line">String.valueOf(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">// 类似java.lang.Object@636be97c</span></span><br></pre></td></tr></table></figure>
<p>把字符串转换为其他类型，就需要根据情况。例如，把字符串转换为<code>int</code>类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;123&quot;</span>); <span class="comment">// 123</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;ff&quot;</span>, <span class="number">16</span>); <span class="comment">// 按十六进制转换，255</span></span><br></pre></td></tr></table></figure>
<p>把字符串转换为<code>boolean</code>类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;true&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;FALSE&quot;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>要特别注意，<code>Integer</code>有个<code>getInteger(String)</code>方法，它不是将字符串转换为<code>int</code>，而是把该字符串对应的系统变量转换为<code>Integer</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer.getInteger(<span class="string">&quot;java.version&quot;</span>); <span class="comment">// 版本号，11</span></span><br></pre></td></tr></table></figure>
<p><code>String</code>和<code>char[]</code>类型可以互相转换，方法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>[] cs = <span class="string">&quot;Hello&quot;</span>.toCharArray(); <span class="comment">// String -&gt; char[]</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cs); <span class="comment">// char[] -&gt; String</span></span><br></pre></td></tr></table></figure>
<p>如果修改了<code>char[]</code>数组，<code>String</code>并不会改变：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] cs = <span class="string">&quot;Hello&quot;</span>.toCharArray();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cs);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        cs[<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
这是因为通过<code>new String(char[])</code>创建新的<code>String</code>实例时，它并不会直接引用传入的<code>char[]</code>数组，而是会复制一份，所以，修改外部的<code>char[]</code>数组不会影响<code>String</code>实例内部的<code>char[]</code>数组，因为这是两个不同的数组。</p>
<p><strong>设计注意</strong>：从<code>String</code>的不变性设计可以看出，如果传入的对象有可能改变，我们需要复制而不是直接引用。</p>
<h4 id="字符编码问题">8、字符编码问题：</h4>
<p>​
为了统一全球所有语言的编码，全球统一码联盟发布了<code>Unicode</code>编码</p>
<p>​ <code>Unicode</code>编码需要两个或者更多字节表示</p>
<p>英文字符<code>'A'</code>的<code>ASCII</code>编码和<code>Unicode</code>编码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         ┌────┐</span><br><span class="line">ASCII:   │ 41 │</span><br><span class="line">         └────┘</span><br><span class="line">         ┌────┬────┐</span><br><span class="line">Unicode: │ 00 │ 41 │</span><br><span class="line">         └────┴────┘</span><br></pre></td></tr></table></figure>
<p>英文字符的<code>Unicode</code>编码就是简单地在前面添加一个<code>00</code>字节。</p>
<p>中文字符<code>'中'</code>的<code>GB2312</code>编码和<code>Unicode</code>编码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         ┌────┬────┐</span><br><span class="line">GB2312:  │ d6 │ d0 │</span><br><span class="line">         └────┴────┘</span><br><span class="line">         ┌────┬────┐</span><br><span class="line">Unicode: │ 4e │ 2d │</span><br><span class="line">         └────┴────┘</span><br></pre></td></tr></table></figure>
<p>​
那我们经常使用的<code>UTF-8</code>又是什么编码呢？因为英文字符的<code>Unicode</code>编码高字节总是<code>00</code>，包含大量英文的文本会浪费空间，所以，出现了<code>UTF-8</code>编码，<strong>它是一种变长编码</strong>，<strong>用来把固定长度的<code>Unicode</code>编码变成1～4字节的变长编码</strong>。通过<code>UTF-8</code>编码，英文字符<code>'A'</code>的<code>UTF-8</code>编码变为<code>0x41</code>，正好和<code>ASCII</code>码一致，而中文<code>'中'</code>的<code>UTF-8</code>编码为3字节<code>0xe4b8ad</code>。</p>
<p>​
<strong><code>UTF-8</code>编码的另一个好处是容错能力强。</strong>如果传输过程中某些字符出错，不会影响后续字符，因为<code>UTF-8</code>编码依靠高字节位来确定一个字符究竟是几个字节，它经常用来作为传输编码。</p>
<p>​
在Java中，<strong><code>char</code>类型实际上就是两个字节的<code>Unicode</code>编码</strong>。如果我们要手动把字符串转换成其他编码，可以这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] b1 = <span class="string">&quot;Hello&quot;</span>.getBytes(); <span class="comment">// 按系统默认编码转换，不推荐</span></span><br><span class="line"><span class="type">byte</span>[] b2 = <span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>); <span class="comment">// 按UTF-8编码转换</span></span><br><span class="line"><span class="type">byte</span>[] b2 = <span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;GBK&quot;</span>); <span class="comment">// 按GBK编码转换</span></span><br><span class="line"><span class="type">byte</span>[] b3 = <span class="string">&quot;Hello&quot;</span>.getBytes(StandardCharsets.UTF_8); <span class="comment">// 按UTF-8编码转换</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：转换编码后，就不再是<code>char</code>类型，而是<code>byte</code>类型表示的数组。</strong></p>
<p>如果要把已知编码的<code>byte[]</code>转换为<code>String</code>，可以这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] b = ...</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="string">&quot;GBK&quot;</span>); <span class="comment">// 按GBK转换</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b, StandardCharsets.UTF_8); <span class="comment">// 按UTF-8转换</span></span><br></pre></td></tr></table></figure>
<p><strong>始终牢记：Java的<code>String</code>和<code>char</code>在内存中总是以Unicode编码表示。</strong></p>
<h3 id="二stringbuilder">二、StringBuilder</h3>
<p>​
在java的String类种，虽然我们可以直接拼接字符串，但是，在循环中，<strong>每次循环都会创建新的字符串对象，然后扔掉旧的字符串</strong>。这样，<strong>绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率</strong>。</p>
<p>​
为了能高效拼接字符串，Java标准库提供了<code>StringBuilder</code>，它是一个可变对象，可以预分配缓冲区，这样，往<code>StringBuilder</code>中新增字符时，不会创建新的临时对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    sb.append(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    sb.append(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br></pre></td></tr></table></figure>
<p><strong>链式操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">1024</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;Mr &quot;</span>)</span><br><span class="line">          .append(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">          .append(<span class="string">&quot;!&quot;</span>)</span><br><span class="line">          .insert(<span class="number">0</span>, <span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
<strong>进行链式操作的关键是：定义的<code>append()</code>方法会返回<code>this</code>，这样，就可以不断调用自身的其他方法</strong></p>
<p><strong>注意</strong>：对于普通的字符串<code>+</code>操作，并不需要我们将其改写为<code>StringBuilder</code>，因为Java编译器在编译时就自动把多个连续的<code>+</code>操作编码为<code>StringConcatFactory</code>的操作。在运行期，<code>StringConcatFactory</code>会自动把字符串连接操作优化为数组复制或者<code>StringBuilder</code>操作。</p>
<h3 id="三stringjoiner">三、StringJoiner</h3>
<ul>
<li>Java标准库还提供了一个<code>StringJoiner</code>可以用于使用分隔符拼接数组。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// var sj = new StringJoiner(&quot;, &quot;);  //case1 指定分隔符 </span></span><br><span class="line">        <span class="type">var</span> <span class="variable">sj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;, &quot;</span>, <span class="string">&quot;Hello &quot;</span>, <span class="string">&quot;!&quot;</span>); <span class="comment">//case2 指定开头和结尾字符</span></span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            sj.add(name);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// case1 Bob, Alice, Grace </span></span><br><span class="line"><span class="comment">// case2 Hello Bob, Alice, Grace! </span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>String</code>还提供了一个静态方法<code>join()</code>，这个方法在内部使用了<code>StringJoiner</code>来拼接字符串，在不需要指定“开头”和“结尾”的时候，用<code>String.join()</code>更方便：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line"><span class="type">var</span> <span class="variable">s</span> <span class="operator">=</span> String.join(<span class="string">&quot;, &quot;</span>, names);</span><br></pre></td></tr></table></figure>
<h3 id="四包装类型">四、包装类型</h3>
<h4 id="什么是包装类型">1、什么是包装类型？</h4>
<p>java的数据类型分两种：</p>
<ul>
<li>基本类型：<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>boolean</code>，<code>float</code>，<code>double</code>，<code>char</code></li>
<li>引用类型：所有<code>class</code>和<code>interface</code>类型</li>
</ul>
<p><strong>引用类型可以赋值为<code>null</code>，表示空，但基本类型不能赋值为<code>null</code></strong></p>
<p>如何把一个基本类型视为对象（引用类型）？</p>
<p>​
比如，想要把<code>int</code>基本类型变成一个引用类型，我们可以定义一个<code>Integer</code>类，它只包含一个实例字段<code>int</code>，这样，<strong><code>Integer</code>类就可以视为<code>int</code>的包装类（Wrapper
Class）</strong></p>
<p>实际上，因为包装类型非常有用，Java核心库为每种基本类型都提供了对应的包装类型：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">基本类型</th>
<th style="text-align: left;">对应的引用类型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">boolean</td>
<td style="text-align: left;">java.lang.Boolean</td>
</tr>
<tr class="even">
<td style="text-align: left;">byte</td>
<td style="text-align: left;">java.lang.Byte</td>
</tr>
<tr class="odd">
<td style="text-align: left;">short</td>
<td style="text-align: left;">java.lang.Short</td>
</tr>
<tr class="even">
<td style="text-align: left;">int</td>
<td style="text-align: left;">java.lang.Integer</td>
</tr>
<tr class="odd">
<td style="text-align: left;">long</td>
<td style="text-align: left;">java.lang.Long</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">java.lang.Float</td>
</tr>
<tr class="odd">
<td style="text-align: left;">double</td>
<td style="text-align: left;">java.lang.Double</td>
</tr>
<tr class="even">
<td style="text-align: left;">char</td>
<td style="text-align: left;">java.lang.Character</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 通过new操作符创建Integer实例(不推荐使用,会有编译警告):</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">        <span class="comment">// 通过静态方法valueOf(int)创建Integer实例:</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n2</span> <span class="operator">=</span> Integer.valueOf(i);</span><br><span class="line">        <span class="comment">// 通过静态方法valueOf(String)创建Integer实例:</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n3</span> <span class="operator">=</span> Integer.valueOf(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">        System.out.println(n3.intValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="auto-boxing">2、Auto Boxing</h4>
<p>因为<code>int</code>和<code>Integer</code>可以互相转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> Integer.valueOf(i);</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> n.intValue();</span><br></pre></td></tr></table></figure>
<p>所以，Java编译器可以帮助我们自动在<code>int</code>和<code>Integer</code>之间转型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 编译器自动使用Integer.valueOf(int)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> n; <span class="comment">// 编译器自动使用Integer.intValue()</span></span><br></pre></td></tr></table></figure>
<p>​
<strong>这种直接把<code>int</code>变为<code>Integer</code>的赋值写法，称为自动装箱（Auto
Boxing），反过来，把<code>Integer</code>变为<code>int</code>的赋值写法，称为自动拆箱（Auto
Unboxing）。</strong></p>
<p>​
注意：<strong>自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码</strong>。</p>
<p>装箱和拆箱会影响代码的执行效率，因为编译后的<code>class</code>代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报<code>NullPointerException</code>：</p>
<h4 id="不变类">3、不变类</h4>
<p>​
所有的包装类型都是不变类，因此，一旦创建了<code>Integer</code>对象，该对象就是不变的。</p>
<p>​
对两个<code>Integer</code>实例进行比较要特别注意：绝对不能用<code>==</code>比较，因为<code>Integer</code>是引用类型，必须使用<code>equals()</code>比较：</p>
<h4 id="进制转换">4、进制转换：</h4>
<p><code>Integer</code>类本身还提供了大量方法，例如，最常用的静态方法<code>parseInt()</code>可以把字符串解析成一个整数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;100&quot;</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;100&quot;</span>, <span class="number">16</span>); <span class="comment">// 256,因为按16进制解析</span></span><br></pre></td></tr></table></figure>
<p><code>Integer</code>还可以把整数格式化为指定进制的字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Integer.toString(<span class="number">100</span>)); <span class="comment">// &quot;100&quot;,表示为10进制</span></span><br><span class="line">        System.out.println(Integer.toString(<span class="number">100</span>, <span class="number">36</span>)); <span class="comment">// &quot;2s&quot;,表示为36进制</span></span><br><span class="line">        System.out.println(Integer.toHexString(<span class="number">100</span>)); <span class="comment">// &quot;64&quot;,表示为16进制</span></span><br><span class="line">        System.out.println(Integer.toOctalString(<span class="number">100</span>)); <span class="comment">// &quot;144&quot;,表示为8进制</span></span><br><span class="line">        System.out.println(Integer.toBinaryString(<span class="number">100</span>)); <span class="comment">// &quot;1100100&quot;,表示为2进制</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五javabean">五、JavaBean</h3>
<p>在Java中，有很多<code>class</code>的定义都符合这样的规范：</p>
<ul>
<li>若干<code>private</code>实例字段；</li>
<li>通过<code>public</code>方法来读写实例字段。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.name; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.age; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123; <span class="built_in">this</span>.age = age; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果读写方法符合以下这种命名规范,
那么这种<code>class</code>被称为<code>JavaBean</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读方法:</span></span><br><span class="line"><span class="keyword">public</span> Type <span class="title function_">getXyz</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 写方法:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setXyz</span><span class="params">(Type value)</span></span><br></pre></td></tr></table></figure>
<p>​
上面的字段是<code>xyz</code>，那么读写方法名分别以<code>get</code>和<code>set</code>开头，并且后接大写字母开头的字段名<code>Xyz</code>，因此两个读写方法名分别是<code>getXyz()</code>和<code>setXyz()</code>。</p>
<p><code>boolean</code>字段比较特殊，它的读方法一般命名为<code>isXyz()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读方法:</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isChild</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 写方法:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setChild</span><span class="params">(<span class="type">boolean</span> value)</span></span><br></pre></td></tr></table></figure>
<p>​
<strong>我们通常把一组对应的读方法（<code>getter</code>）和写方法（<code>setter</code>）称为属性（<code>property</code>）。例如，<code>name</code>属性</strong>：</p>
<ul>
<li>对应的读方法是<code>String getName()</code></li>
<li>对应的写方法是<code>setName(String)</code></li>
</ul>
<p><strong>只有<code>getter</code>的属性称为只读属性（read-only）</strong>，例如，定义一个age只读属性：</p>
<ul>
<li>对应的读方法是<code>int getAge()</code></li>
<li>无对应的写方法<code>setAge(int)</code></li>
</ul>
<p>类似的，只有<code>setter</code>的属性称为只写属性（write-only）。</p>
<h4 id="javabean-的作用">javabean 的作用：</h4>
<p>​
JavaBean主要用来传递数据，即把一组数据组合成一个JavaBean便于传输。此外，JavaBean可以方便地被IDE工具分析，生成读写属性的代码，主要用在图形界面的可视化设计中。</p>
<p>​ 通过IDE，可以快速生成<code>getter</code>和<code>setter</code></p>
<h4 id="如何枚举javabean的所有属性">如何枚举JavaBean的所有属性？</h4>
<p>要枚举一个JavaBean的所有属性，可以直接使用Java核心库提供的<code>Introspector</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">BeanInfo</span> <span class="variable">info</span> <span class="operator">=</span> Introspector.getBeanInfo(Person.class);</span><br><span class="line">        <span class="keyword">for</span> (PropertyDescriptor pd : info.getPropertyDescriptors()) &#123;</span><br><span class="line">            System.out.println(pd.getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;  &quot;</span> + pd.getReadMethod());</span><br><span class="line">            System.out.println(<span class="string">&quot;  &quot;</span> + pd.getWriteMethod());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">age</span></span><br><span class="line"><span class="comment">  public int Person.getAge()</span></span><br><span class="line"><span class="comment">  public void Person.setAge(int)</span></span><br><span class="line"><span class="comment">class</span></span><br><span class="line"><span class="comment">  public final native java.lang.Class java.lang.Object.getClass()</span></span><br><span class="line"><span class="comment">  null</span></span><br><span class="line"><span class="comment">name</span></span><br><span class="line"><span class="comment">  public java.lang.String Person.getName()</span></span><br><span class="line"><span class="comment">  public void Person.setName(java.lang.String) </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="六枚举类">六、枚举类</h3>
<h4 id="为什么需要枚举类">1、为什么需要枚举类：</h4>
<p>​
在Java中，我们可以通过<code>static final</code>来定义常量,但有一个严重的问题就是，编译器无法检查每个值的合理性。比如说：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SUN</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MON</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TUE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WED</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THU</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FRI</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SAT</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>注意到<code>Weekday</code>定义的常量范围是<code>0</code>~<code>6</code>，并不包含<code>7</code>，编译器无法检查不在枚举中的<code>int</code>值；</p></li>
<li><p>定义的常量仍可与其他变量比较，但其用途并非是枚举星期</p></li>
</ul>
<p>​
为了让编译器能自动检查某个值在枚举的集合内，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用<code>enum</code>来定义枚举类：</p>
<h4 id="如何定义枚举类">2、如何定义枚举类？</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">day</span> <span class="operator">=</span> Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day == Weekday.SAT || day == Weekday.SUN) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at home!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at office!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义枚举类是通过关键字<code>enum</code>实现的，我们只需依次列出枚举的常量名。</p>
<p>使用<code>enum</code>定义枚举有如下好处：</p>
<ul>
<li><p>首先，<code>enum</code>常量本身带有类型信息，即<code>Weekday.SUN</code>类型是<code>Weekday</code>，编译器会自动检查出类型错误。</p></li>
<li><p>其次，不可能引用到非枚举的值，因为无法通过编译。</p></li>
<li><p>最后，不同类型的枚举不能互相比较或者赋值，因为类型不符。</p></li>
</ul>
<h4 id="enum的比较">3、enum的比较：</h4>
<p>​
<code>enum</code>类型的每个常量在JVM中只有一个唯一实例，所以可以直接用<code>==</code>比较</p>
<h4 id="enum类型">4、enum类型：</h4>
<p>通过<code>enum</code>定义的枚举类，和其他的<code>class</code>没有任何区别。</p>
<p><code>enum</code>定义的类型就是<code>class</code>，只不过它有以下几个特点：</p>
<ul>
<li><p>定义的<code>enum</code>类型总是继承自<code>java.lang.Enum</code>，且无法被继承；</p></li>
<li><p>只能定义出<code>enum</code>的实例，而无法通过<code>new</code>操作符创建<code>enum</code>的实例；</p></li>
<li><p>定义的每个实例都是引用类型的唯一实例；</p></li>
<li><p>可以将<code>enum</code>类型用于<code>switch</code>语句。</p>
<p>例如，我们定义的<code>Color</code>枚举类：</p></li>
</ul>
<h4 id="enum示例">5、Enum示例：</h4>
<p>如下所示定义的enum:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    RED, GREEN, BLUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么编译器编译出的<code>class</code>大概就像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Color</span> <span class="keyword">extends</span> <span class="title class_">Enum</span> &#123; <span class="comment">// 继承自Enum，标记为final class</span></span><br><span class="line">    <span class="comment">// 每个实例均为全局唯一:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Color</span> <span class="variable">RED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Color</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Color</span> <span class="variable">GREEN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Color</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Color</span> <span class="variable">BLUE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Color</span>();</span><br><span class="line">    <span class="comment">// private构造方法，确保外部无法调用new操作符:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Color</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，编译后的<code>enum</code>类和普通<code>class</code>并没有任何区别。但是我们自己无法按定义普通<code>class</code>那样来定义<code>enum</code>，必须使用<code>enum</code>关键字，这是Java语法规定的。</p>
<p>因为<strong><code>enum</code>是一个<code>class</code>，每个枚举的值都是<code>class</code>实例</strong>，因此，这些实例有一些方法：</p>
<ul>
<li>name()</li>
</ul>
<p>返回常量名，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Weekday.SUN.name(); <span class="comment">// &quot;SUN&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>ordinal()</li>
</ul>
<p>返回定义的常量的顺序，从0开始计数，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Weekday.MON.ordinal(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>改变枚举常量定义的顺序就会导致<code>ordinal()</code>返回值发生变化。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    MON, TUE, WED, THU, FRI, SAT, SUN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
的<code>ordinal</code>就是不同的。如果在代码中编写了类似<code>if(x.ordinal()==1)</code>这样的语句，就要保证<code>enum</code>的枚举顺序不能变。新增的常量必须放在最后。</p>
<h4 id="书写健壮的enum代码">6、书写健壮的Enum代码</h4>
<p><code>Weekday</code>的枚举常量如果要和<code>int</code>转换，使用<code>ordinal()</code>不是非常方便,
比如这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">task</span> <span class="operator">=</span> Weekday.MON.ordinal() + <span class="string">&quot;/ppt&quot;</span>;</span><br><span class="line">saveToFile(task);</span><br></pre></td></tr></table></figure>
<p>​
但是，如果不小心修改了枚举的顺序，编译器是无法检查出这种逻辑错误的。<strong>要编写健壮的代码，就不要依靠<code>ordinal()</code>的返回值。</strong>
<strong>因为<code>enum</code>本身是<code>class</code>，所以我们可以定义<code>private</code>的构造方法，并且，给每个枚举常量添加字段：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">day</span> <span class="operator">=</span> Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day.dayValue == <span class="number">6</span> || day.dayValue == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at home!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at office!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    MON(<span class="number">1</span>), TUE(<span class="number">2</span>), WED(<span class="number">3</span>), THU(<span class="number">4</span>), FRI(<span class="number">5</span>), SAT(<span class="number">6</span>), SUN(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> dayValue;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Weekday</span><span class="params">(<span class="type">int</span> dayValue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dayValue = dayValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样就无需担心顺序的变化，新增枚举常量时，也需要指定一个<code>int</code>值。</p>
<p>默认情况下，对枚举常量调用<code>toString()</code>会返回和<code>name()</code>一样的字符串。但是，<code>toString()</code>可以被覆写，而<code>name()</code>则不行。我们可以给<code>Weekday</code>添加<code>toString()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    MON(<span class="number">1</span>, <span class="string">&quot;星期一&quot;</span>), TUE(<span class="number">2</span>, <span class="string">&quot;星期二&quot;</span>), WED(<span class="number">3</span>, <span class="string">&quot;星期三&quot;</span>), THU(<span class="number">4</span>, <span class="string">&quot;星期四&quot;</span>), FRI(<span class="number">5</span>, <span class="string">&quot;星期五&quot;</span>), SAT(<span class="number">6</span>, <span class="string">&quot;星期六&quot;</span>), SUN(<span class="number">0</span>, <span class="string">&quot;星期日&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> dayValue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String chinese;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Weekday</span><span class="params">(<span class="type">int</span> dayValue, String chinese)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dayValue = dayValue;</span><br><span class="line">        <span class="built_in">this</span>.chinese = chinese;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.chinese;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4
id="enum适合用在switch语句中">7、<code>enum</code>适合用在<code>switch</code>语句中</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">day</span> <span class="operator">=</span> Weekday.SUN;</span><br><span class="line">        <span class="keyword">switch</span>(day) &#123;</span><br><span class="line">        <span class="keyword">case</span> MON:</span><br><span class="line">        <span class="keyword">case</span> TUE:</span><br><span class="line">        <span class="keyword">case</span> WED:</span><br><span class="line">        <span class="keyword">case</span> THU:</span><br><span class="line">        <span class="keyword">case</span> FRI:</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at office!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SAT:</span><br><span class="line">        <span class="keyword">case</span> SUN:</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at home!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;cannot process &quot;</span> + day);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    MON, TUE, WED, THU, FRI, SAT, SUN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="七记录类">七、记录类</h3>
<h4 id="以往类的繁琐之处">1、以往类的繁琐之处：</h4>
<p>使用<code>String</code>、<code>Integer</code>等类型的时候，这些类型都是不变类，一个不变类具有以下特点：</p>
<ol type="1">
<li>定义class时使用<code>final</code>，无法派生子类；</li>
<li>每个字段使用<code>final</code>，保证创建实例后无法修改任何字段。</li>
</ol>
<p>假设我们希望定义一个<code>Point</code>类，有<code>x</code>、<code>y</code>两个变量，同时它是一个不变类，可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">x</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">y</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里演示<code>Point</code>不变类的写法目的是，这些代码写起来都非常简单，但是很繁琐。</p>
<h4 id="record-记录类">2、record 记录类:</h4>
<p>​ 从Java
14开始，引入了新的<code>Record</code>类。我们定义<code>Record</code>类时，使用关键字<code>record</code>。把上述<code>Point</code>类改写为<code>Record</code>类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        System.out.println(p.x());</span><br><span class="line">        System.out.println(p.y());</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果要把上述定义，以class的形式改写代码的话，应当如下所示：（其实也就是编译器会帮我们编译成如下的代码）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class Point extends Record &#123;</span><br><span class="line">    private final int x;</span><br><span class="line">    private final int y;</span><br><span class="line"></span><br><span class="line">    public Point(int x, int y) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int x() &#123;</span><br><span class="line">        return this.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int y() &#123;</span><br><span class="line">        return this.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return String.format(&quot;Point[x=%s, y=%s]&quot;, x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
除了用<code>final</code>修饰class以及每个字段外，编译器还自动为我们创建了构造方法，和字段名同名的方法，以及覆写<code>toString()</code>、<code>equals()</code>和<code>hashCode()</code>方法。</p>
<p>​
<strong>换句话说，使用<code>record</code>关键字，可以一行写出一个不变类。</strong></p>
<p>​
<strong>和<code>enum</code>类似，我们自己不能直接从<code>Record</code>派生，只能通过<code>record</code>关键字由编译器实现继承。</strong></p>
<h4 id="构造方法">3、构造方法：</h4>
<p>​
编译器默认按照<code>record</code>声明的变量顺序自动创建一个构造方法，并在方法内给字段赋值。那么问题来了，如果我们要检查参数，应该怎么办？</p>
<p>​
<strong>假设<code>Point</code>类的<code>x</code>、<code>y</code>不允许负数，我们就得给<code>Point</code>的构造方法加上检查逻辑：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Point &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 注意到方法<code>public Point &#123;...&#125;</code>被称为Compact
Constructor，它的目的是让我们编写检查逻辑，<strong>编译器最终生成的构造方法如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Point</span> <span class="keyword">extends</span> <span class="title class_">Record</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="comment">// 这是我们编写的Compact Constructor:</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这是编译器继续生成的赋值代码:</span></span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为<code>record</code>的<code>Point</code>仍然可以添加静态方法。一种常用的静态方法是<code>of()</code>方法，用来创建<code>Point</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title function_">of</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title function_">of</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Point</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们可以写出更简洁的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">z</span> <span class="operator">=</span> Point.of();</span><br><span class="line"><span class="type">var</span> <span class="variable">p</span> <span class="operator">=</span> Point.of(<span class="number">123</span>, <span class="number">456</span>);</span><br></pre></td></tr></table></figure>
<h4 id="总结">4、总结：</h4>
<p>从Java
14开始，提供新的<code>record</code>关键字，可以非常方便地定义Data
Class：</p>
<ul>
<li>使用<code>record</code>定义的是不变类；</li>
<li>可以编写Compact Constructor对参数进行验证；</li>
<li>可以定义静态方法。</li>
</ul>
<h3 id="八biginteger">八、BigInteger</h3>
<p>​
在Java中，由CPU原生提供的整型最大范围是64位<code>long</code>型整数。<strong>使用<code>long</code>型整数可以直接通过CPU指令进行计算，速度非常快</strong></p>
<p>​
如果我们使用的整数范围超过了<code>long</code>型，就只能用软件来模拟一个大整数。<code>java.math.BigInteger</code>就是用来表示任意大小的整数。<code>BigInteger</code>内部用一个<code>int[]</code>数组来模拟一个非常大的整数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">bi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line">System.out.println(bi.pow(<span class="number">5</span>)); <span class="comment">// 2867971860299718107233761438093672048294900000</span></span><br></pre></td></tr></table></figure>
<p>对<code>BigInteger</code>做运算的时候，只能使用实例方法，例如，加法运算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;12345678901234567890&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">sum</span> <span class="operator">=</span> i1.add(i2); <span class="comment">// 12345678902469135780</span></span><br></pre></td></tr></table></figure>
<p><code>BigInteger</code>和<code>Integer</code>、<code>Long</code>一样，也是不可变类，并且也继承自<code>Number</code>类。因为<code>Number</code>定义了转换为基本类型的几个方法：</p>
<ul>
<li>转换为<code>byte</code>：<code>byteValue()</code></li>
<li>转换为<code>short</code>：<code>shortValue()</code></li>
<li>转换为<code>int</code>：<code>intValue()</code></li>
<li>转换为<code>long</code>：<code>longValue()</code></li>
<li>转换为<code>float</code>：<code>floatValue()</code></li>
<li>转换为<code>double</code>：<code>doubleValue()</code></li>
</ul>
<p>​
因此，通过上述方法，可以把<code>BigInteger</code>转换成基本类型。如果<code>BigInteger</code>表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用<code>intValueExact()</code>、<code>longValueExact()</code>等方法，在转换时如果超出范围，将直接抛出<code>ArithmeticException</code>异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;123456789000&quot;</span>);</span><br><span class="line">System.out.println(i.longValue()); <span class="comment">// 123456789000</span></span><br><span class="line">System.out.println(i.multiply(i).longValueExact()); <span class="comment">// java.lang.ArithmeticException: BigInteger out of long range</span></span><br></pre></td></tr></table></figure>
<p>​
使用<code>longValueExact()</code>方法时，如果超出了<code>long</code>型的范围，会抛出<code>ArithmeticException</code>。</p>
<h3 id="九bigdecimal">九、BigDecimal</h3>
<h4 id="bigdecimal简介">1、BigDecimal简介</h4>
<p>和<code>BigInteger</code>类似，<code>BigDecimal</code>可以表示<strong>一个任意大小且精度完全准确</strong>的浮点数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;123.4567&quot;</span>);</span><br><span class="line">System.out.println(bd.multiply(bd)); <span class="comment">// 15241.55677489</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>BigDecimal</code>用<code>scale()</code>输出小数位数，例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;123.45&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;123.4500&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">d3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1234500&quot;</span>);</span><br><span class="line">System.out.println(d1.scale()); <span class="comment">// 2,两位小数</span></span><br><span class="line">System.out.println(d2.scale()); <span class="comment">// 4</span></span><br><span class="line">System.out.println(d3.scale()); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过<code>BigDecimal</code>的<code>stripTrailingZeros()</code>方法，可以将一个<code>BigDecimal</code>格式化为一个相等的，但去掉了末尾0的<code>BigDecimal</code>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;123.4500&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">d2</span> <span class="operator">=</span> d1.stripTrailingZeros();</span><br><span class="line">System.out.println(d1.scale()); <span class="comment">// 4</span></span><br><span class="line">System.out.println(d2.scale()); <span class="comment">// 2,因为去掉了00</span></span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">d3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1234500&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">d4</span> <span class="operator">=</span> d3.stripTrailingZeros();</span><br><span class="line">System.out.println(d3.scale()); <span class="comment">// 0</span></span><br><span class="line">System.out.println(d4.scale()); <span class="comment">// -2</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果一个<code>BigDecimal</code>的<code>scale()</code>返回负数，例如，<code>-2</code>，表示这个数是个整数，并且末尾有2个0。</p></li>
<li><p>可以对一个<code>BigDecimal</code>设置它的<code>scale</code>，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;123.456789&quot;</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">d2</span> <span class="operator">=</span> d1.setScale(<span class="number">4</span>, RoundingMode.HALF_UP); <span class="comment">// 四舍五入，123.4568</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">d3</span> <span class="operator">=</span> d1.setScale(<span class="number">4</span>, RoundingMode.DOWN); <span class="comment">// 直接截断，123.4567</span></span><br><span class="line">        System.out.println(d2);</span><br><span class="line">        System.out.println(d3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对<code>BigDecimal</code>做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;123.456&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;23.456789&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">d3</span> <span class="operator">=</span> d1.divide(d2, <span class="number">10</span>, RoundingMode.HALF_UP); <span class="comment">// 保留10位小数并四舍五入</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">d4</span> <span class="operator">=</span> d1.divide(d2); <span class="comment">// 报错：ArithmeticException，因为除不尽</span></span><br></pre></td></tr></table></figure>
<p>还可以对<code>BigDecimal</code>做除法的同时求余数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;12.345&quot;</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.12&quot;</span>);</span><br><span class="line">        BigDecimal[] dr = n.divideAndRemainder(m);</span><br><span class="line">        System.out.println(dr[<span class="number">0</span>]); <span class="comment">// 102</span></span><br><span class="line">        System.out.println(dr[<span class="number">1</span>]); <span class="comment">// 0.105</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>divideAndRemainder()</code>方法时，返回的数组包含两个<code>BigDecimal</code>，分别是商和余数，其中商总是整数，余数不会大于除数。我们可以利用这个方法判断两个<code>BigDecimal</code>是否是整数倍数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;12.75&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.15&quot;</span>);</span><br><span class="line">BigDecimal[] dr = n.divideAndRemainder(m);</span><br><span class="line"><span class="keyword">if</span> (dr[<span class="number">1</span>].signum() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// n是m的整数倍</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="比较bigdecimal">2、比较BigDecimal</h4>
<p>在比较两个<code>BigDecimal</code>的值是否相等时，要特别注意，使用<code>equals()</code>方法不但要求两个<code>BigDecimal</code>的值相等，还要求它们的<code>scale()</code>相等：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;123.456&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;123.45600&quot;</span>);</span><br><span class="line">System.out.println(d1.equals(d2)); <span class="comment">// false,因为scale不同</span></span><br><span class="line">System.out.println(d1.equals(d2.stripTrailingZeros())); <span class="comment">// true,因为d2去除尾部0后scale变为2</span></span><br><span class="line">System.out.println(d1.compareTo(d2)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>必须使用<code>compareTo()</code>方法来比较，它根据两个值的大小分别返回负数、正数和<code>0</code>，分别表示小于、大于和等于。</p>
<p>总是使用compareTo()比较两个BigDecimal的值，不要使用equals()！</p>
<p>如果查看<code>BigDecimal</code>的源码，可以发现，实际上一个<code>BigDecimal</code>是通过一个<code>BigInteger</code>和一个<code>scale</code>来表示的，即<code>BigInteger</code>表示一个完整的整数，而<code>scale</code>表示小数位数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigDecimal</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;BigDecimal&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger intVal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> scale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BigDecimal</code>也是从<code>Number</code>继承的，也是不可变对象。</p>
<h3 id="十常用工具类">十、常用工具类</h3>
<h4 id="math">1、Math</h4>
<ul>
<li>求绝对值：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.abs(-<span class="number">100</span>); <span class="comment">// 100</span></span><br><span class="line">Math.abs(-<span class="number">7.8</span>); <span class="comment">// 7.8</span></span><br></pre></td></tr></table></figure>
<ul>
<li>取最大或最小值:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.max(<span class="number">100</span>, <span class="number">99</span>); <span class="comment">// 100</span></span><br><span class="line">Math.min(<span class="number">1.2</span>, <span class="number">2.3</span>); <span class="comment">// 1.2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>计算<span class="math inline">\(x^y\)</span>次方：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.pow(<span class="number">2</span>, <span class="number">10</span>); <span class="comment">// 2的10次方=1024</span></span><br></pre></td></tr></table></figure>
<ul>
<li>计算√x：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.sqrt(<span class="number">2</span>); <span class="comment">// 1.414...</span></span><br></pre></td></tr></table></figure>
<ul>
<li>计算ex次方：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.exp(<span class="number">2</span>); <span class="comment">// 7.389...</span></span><br></pre></td></tr></table></figure>
<ul>
<li>计算以e为底的对数：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.log(<span class="number">4</span>); <span class="comment">// 1.386...</span></span><br></pre></td></tr></table></figure>
<ul>
<li>计算以10为底的对数：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.log10(<span class="number">100</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Math还提供了几个数学常量：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> Math.PI; <span class="comment">// 3.14159...</span></span><br><span class="line"><span class="type">double</span> <span class="variable">e</span> <span class="operator">=</span> Math.E; <span class="comment">// 2.7182818...</span></span><br><span class="line">Math.sin(Math.PI / <span class="number">6</span>); <span class="comment">// sin(π/6) = 0.5</span></span><br></pre></td></tr></table></figure>
<ul>
<li>生成一个随机数x，x的范围是<code>0 &lt;= x &lt; 1</code>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.random(); <span class="comment">// 0.53907... 每次都不一样</span></span><br></pre></td></tr></table></figure>
<h4 id="random">2、Random</h4>
<p><code>Random</code>用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">r.nextInt(); <span class="comment">// 2071575453,每次都不一样</span></span><br><span class="line">r.nextInt(<span class="number">10</span>); <span class="comment">// 5,生成一个[0,10)之间的int</span></span><br><span class="line">r.nextLong(); <span class="comment">// 8811649292570369305,每次都不一样</span></span><br><span class="line">r.nextFloat(); <span class="comment">// 0.54335...生成一个[0,1)之间的float</span></span><br><span class="line">r.nextDouble(); <span class="comment">// 0.3716...生成一个[0,1)之间的double</span></span><br></pre></td></tr></table></figure>
<p>这是因为我们创建<code>Random</code>实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同。</p>
<p>如果我们在创建<code>Random</code>实例时指定一个种子，就会得到完全确定的随机数序列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">12345</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(r.nextInt(<span class="number">100</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 51, 80, 41, 28, 55...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="securerandom">3、SecureRandom</h4>
<p>​
有伪随机数，就有真随机数。实际上真正的真随机数只能通过量子力学原理来获取，而我们想要的是一个不可预测的安全的随机数，<code>SecureRandom</code>就是用来创建安全的随机数的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SecureRandom</span> <span class="variable">sr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandom</span>();</span><br><span class="line">System.out.println(sr.nextInt(<span class="number">100</span>));</span><br></pre></td></tr></table></figure>
<p><code>SecureRandom</code>的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。</p>
]]></content>
      <categories>
        <category>⑤  编程语言类笔记</category>
        <category>java入门系列笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>core class</tag>
      </tags>
  </entry>
  <entry>
    <title>java系列笔记2——java面向对象编程基础</title>
    <url>/2022/01/29/3f72f5c3506a/</url>
    <content><![CDATA[<p>参考教程网址：https://www.liaoxuefeng.com/wiki/1252599548343744/1260467032946976</p>
<h3 id="一类的方法">一、类的方法</h3>
<h4
id="一个类通过定义public方法就可以给外部代码暴露一些操作的接口">1、一个类通过定义public方法，就可以给外部代码暴露一些操作的接口。</h4>
<p>一般而言内部的变量设置为private，对内部变量的操作由暴露的接口进行，这样内部能够自己保证逻辑一致性。</p>
<p>在public的方法内部，我们就有机会检查参数对不对。比如：<code>setName()</code>方法可以做检查，例如，不允许传入<code>null</code>和空字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">null</span> || name.isBlank()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;invalid name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.name = name.strip(); <span class="comment">// 去掉首尾空格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4
id="在方法内部可以使用一个隐含的变量this它始终指向当前实例">2、在方法内部，可以使用一个隐含的变量<code>this</code>，它始终指向当前实例</h4>
<p>如果没有命名冲突，可以省略<code>this</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name; <span class="comment">// 相当于this.name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="可变参数">3、可变参数：</h4>
<p>可变参数用<code>类型...</code>定义，可变参数相当于数组类型,可变参数可以保证无法传入<code>null</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Group</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String[] names;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNames</span><span class="params">(String... names)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.names = names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Group</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Group</span>();</span><br><span class="line">g.setNames(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="string">&quot;Xiao Hong&quot;</span>, <span class="string">&quot;Xiao Jun&quot;</span>); <span class="comment">// 传入3个String</span></span><br><span class="line">g.setNames(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="string">&quot;Xiao Hong&quot;</span>); <span class="comment">// 传入2个String</span></span><br><span class="line">g.setNames(<span class="string">&quot;Xiao Ming&quot;</span>); <span class="comment">// 传入1个String</span></span><br><span class="line">g.setNames(); <span class="comment">// 传入0个String</span></span><br></pre></td></tr></table></figure>
<h4 id="参数传递">4、参数传递：</h4>
<p>引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个陷阱题目</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">bob</span> <span class="operator">=</span> <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">        p.setName(bob); <span class="comment">// 传入bob变量</span></span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Bob&quot;</span></span><br><span class="line">        bob = <span class="string">&quot;Alice&quot;</span>; <span class="comment">// bob改名为Alice</span></span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Bob&quot;还是&quot;Alice&quot;?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回答： 应该是Alice：</span></span><br><span class="line"><span class="comment">// String bob = &quot;Bob&quot;; 的时候，为其分配内存，然后bob 是一个指针，指向该内存，比如0x0011.</span></span><br><span class="line"><span class="comment">// bob = &quot;Alice&quot; 时发生了重新赋值</span></span><br><span class="line"><span class="comment">// 但在java中String类型是不可变的，当发生改变时，会重新分配内存，即生成一个新的内存地址，例如：0x0022,这个时候，现在的bob的内存指向&quot;Alice&quot;，也就是指向0x0022，而p.bob的内存指向仍为0x0011，也就是Bob，所以输出的依旧是Bob。</span></span><br></pre></td></tr></table></figure>
<h3 id="二构造方法">二、构造方法：</h3>
<h4
id="没有在构造方法中初始化字段时引用类型的字段默认是null数值类型的字段用默认值int类型默认值是0布尔类型默认值是false">1、没有在构造方法中初始化字段时，引用类型的字段默认是<code>null</code>，数值类型的字段用默认值，<code>int</code>类型默认值是<code>0</code>，布尔类型默认值是<code>false</code>：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 默认初始化为null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age; <span class="comment">// 默认初始化为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="可以定义多个构造方法">2、可以定义多个构造方法：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4
id="既对字段进行初始化又在构造方法中对字段进行初始化">3、既对字段进行初始化，又在构造方法中对字段进行初始化：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    private String name = &quot;Unamed&quot;;</span><br><span class="line">    private int age = 10;</span><br><span class="line"></span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们创建对象的时候，<code>new Person("Xiao Ming", 12)</code>得到的对象实例，字段的初始值是啥？</p>
<p>在Java中，创建对象实例的时候，按照如下顺序进行初始化：</p>
<ol type="1">
<li>先初始化字段，例如，<code>int age = 10;</code>表示字段初始化为<code>10</code>，<code>double salary;</code>表示字段默认初始化为<code>0</code>，<code>String name;</code>表示引用类型字段默认初始化为<code>null</code>；</li>
<li>执行构造方法的代码进行初始化。</li>
</ol>
<p>​
因此，<strong>构造方法的代码由于后运行</strong>，所以，<code>new Person("Xiao Ming", 12)</code>的字段值最终由构造方法的代码确定。</p>
<h4
id="一个构造方法可以调用其他构造方法这样做的目的是便于代码复用调用其他构造方法的语法是this">4、一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用。调用其他构造方法的语法是<code>this(…)</code>：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(name, <span class="number">18</span>); <span class="comment">// 调用另一个构造方法Person(String, int)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;Unnamed&quot;</span>); <span class="comment">// 调用另一个构造方法Person(String)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三方法重载overload">三、方法重载Overload：</h3>
<ul>
<li><p>方法重载是指多个方法的方法名相同，但各自的参数不同；</p></li>
<li><p>重载方法应该完成类似的功能，参考<code>String</code>的<code>indexOf()</code>；</p></li>
<li><p><strong>重载方法返回值类型应该相同,各自的参数应当不同</strong></p></li>
</ul>
<h3 id="四继承">四、继承：</h3>
<h4 id="基础继承与protected关键字">1、基础继承与Protected关键字：</h4>
<ul>
<li><p>Java使用<code>extends</code>关键字来实现继承：</p></li>
<li><p>注意：子类自动获得了父类的所有字段，严禁定义与父类重名的字段！</p></li>
<li><p>Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 不要重复name和age字段/方法,</span></span><br><span class="line">    <span class="comment">// 只需要定义新增score字段/方法:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123; … &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> &#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>子类无法访问父类的<code>private</code>字段或者<code>private</code>方法</li>
<li>父类中用<code>protected</code>修饰的字段可以被子类访问</li>
<li><code>protected</code>关键字可以把字段和方法的访问权限控制在继承树内部，一个<code>protected</code>字段和方法可以被其子类，以及子类的子类所访问</li>
</ul>
<h4 id="super关键字">2、Super关键字：</h4>
<ul>
<li><p><code>super</code>关键字表示父类（超类）。子类引用父类的字段时，可以用<code>super.fieldName</code>。</p></li>
<li><p>观察以下代码，为何会编译错误？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="number">12</span>, <span class="number">89</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>在Java中，任何<code>class</code>的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句<code>super();</code>，所以，<code>Student</code>类的构造方法实际上是这样：</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">// 自动调用父类的构造方法</span></span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，<code>Person</code>类并没有无参数的构造方法，因此，编译失败。</p>
<p>解决方法是调用<code>Person</code>类存在的某个构造方法。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age); <span class="comment">// 调用父类的构造方法Person(String, int)</span></span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>结论：如果父类没有默认的构造方法，子类就必须显式调用<code>super()</code>并给出参数以便让编译器定位到父类的一个合适的构造方法。且子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。</li>
</ul>
<h4 id="阻止继承">3、阻止继承：</h4>
<ul>
<li>正常情况下，只要某个class没有<code>final</code>修饰符，那么任何类都可以从该class继承。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile error: 不允许继承自Person</span></span><br><span class="line">Student <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>从Java
15开始，允许使用<code>sealed</code>修饰class，并通过<code>permits</code>明确写出能够从该class继承的子类名称。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Shape</span> permits Rect, Circle, Triangle &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：这种<code>sealed</code>类主要用于一些框架，防止继承被滥用。</li>
</ul>
<p><code>sealed</code>类在Java
15中目前是预览状态，要启用它，必须使用参数<code>--enable-preview</code>和<code>--source 15</code>。</p>
<h4 id="向上转型">4、向上转型：</h4>
<p>​ 把一个子类类型赋值给父类类型的变量，被称为向上转型（upcasting）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> s; <span class="comment">// upcasting, ok</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> p; <span class="comment">// upcasting, ok</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> s; <span class="comment">// upcasting, ok</span></span><br></pre></td></tr></table></figure>
<p>​
注意到继承树是<code>Student &gt; Person &gt; Object</code>，所以，可以把<code>Student</code>类型转型为<code>Person</code>，或者更高层次的<code>Object</code>。</p>
<h4 id="向下转型">5、向下转型：</h4>
<p>​
如果把一个父类类型强制转型为子类类型，就是向下转型（downcasting）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(); <span class="comment">// upcasting, ok</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> (Student) p1; <span class="comment">// ok</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> (Student) p2; <span class="comment">// runtime error! ClassCastException!</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>Person</code>类型<code>p1</code>实际指向<code>Student</code>实例，</p></li>
<li><p><code>Person</code>类型变量<code>p2</code>实际指向<code>Person</code>实例。</p></li>
</ul>
<p>在向下转型的时候：</p>
<ul>
<li><p>把<code>p1</code>转型为<code>Student</code>会成功，因为<code>p1</code>确实指向<code>Student</code>实例，</p></li>
<li><p>把<code>p2</code>转型为<code>Student</code>会失败，因为<code>p2</code>的实际类型是<code>Person</code>，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。</p></li>
</ul>
<p>因此，向下转型很可能会失败。失败的时候，Java虚拟机会报<code>ClassCastException</code>。</p>
<p>为了避免向下转型出错，Java提供了<code>instanceof</code>操作符，可以先判断一个实例究竟是不是某种类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">System.out.println(p <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line">System.out.println(p <span class="keyword">instanceof</span> Student); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">System.out.println(s <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line">System.out.println(s <span class="keyword">instanceof</span> Student); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">n</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">System.out.println(n <span class="keyword">instanceof</span> Student); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><code>instanceof</code>实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为<code>null</code>，那么对任何<code>instanceof</code>的判断都为<code>false</code>。</p>
<p>利用<code>instanceof</code>，在向下转型前可以先判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">    <span class="comment">// 只有判断成功才会向下转型:</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) p; <span class="comment">// 一定会成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五多态">五、多态：</h3>
<h4 id="覆写-override">1、覆写 Override</h4>
<p>在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。</p>
<ul>
<li><p>OverRide传入参数与返回值都应该相同。</p></li>
<li><p>加上<code>@Override</code>可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错。</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// Compile error!</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String s)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多态">2、多态</h4>
<p>Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">p.run(); <span class="comment">// 运行的时Student的run()方法</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runTwice</span><span class="params">(Person p)</span> &#123;</span><br><span class="line">    p.run();</span><br><span class="line">    p.run(); <span class="comment">//它传入的参数类型是Person，我们是无法知道传入的参数实际类型究竟是Person，还是Student，还是Person的其他子类，因此，也无法确定调用的是不是Person类定义的run()方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
<strong>多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。这种不确定性的方法调用，究竟有什么作用？</strong></p>
<p>​ 示例如下：</p>
<ul>
<li>假设我们定义一种收入，需要给它报税，那么先定义一个<code>Income</code>类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Income</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">double</span> income;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getTax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> income * <span class="number">0.1</span>; <span class="comment">// 税率10%</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于工资收入，可以减去一个基数，那么我们可以从<code>Income</code>派生出<code>Salary</code>，并覆写<code>getTax()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Salary</span> <span class="keyword">extends</span> <span class="title class_">Income</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getTax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (income &lt;= <span class="number">5000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (income - <span class="number">5000</span>) * <span class="number">0.2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你享受国务院特殊津贴，那么按照规定，可以全部免税：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StateCouncilSpecialAllowance</span> <span class="keyword">extends</span> <span class="title class_">Income</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getTax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们要编写一个报税的财务软件，对于一个人的所有收入进行报税，可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税:</span></span><br><span class="line">        Income[] incomes = <span class="keyword">new</span> <span class="title class_">Income</span>[] &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Income</span>(<span class="number">3000</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Salary</span>(<span class="number">7500</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">StateCouncilSpecialAllowance</span>(<span class="number">15000</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(totalTax(incomes));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">totalTax</span><span class="params">(Income... incomes)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Income income: incomes) &#123;</span><br><span class="line">            total = total + income.getTax();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>观察<code>totalTax()</code>方法：利用多态，<code>totalTax()</code>方法只需要和<code>Income</code>打交道，它完全不需要知道<code>Salary</code>和<code>StateCouncilSpecialAllowance</code>的存在，就可以正确计算出总的税。如果我们要新增一种稿费收入，只需要从<code>Income</code>派生，然后正确覆写<code>getTax()</code>方法就可以。把新的类型传入<code>totalTax()</code>，不需要修改任何代码。</strong></p>
<h4 id="覆写object类的方法">3、覆写Object类的方法：</h4>
<p>​
因为所有的<code>class</code>最终都继承自<code>Object</code>，而<code>Object</code>定义了几个重要的方法：</p>
<ul>
<li><code>toString()</code>：把instance输出为<code>String</code>；</li>
<li><code>equals()</code>：判断两个instance是否逻辑相等；</li>
<li><code>hashCode()</code>：计算一个instance的哈希值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 显示更有意义的字符串:</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person:name=&quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较是否相等:</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">// 当且仅当o为Person类型:</span></span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">            <span class="comment">// 并且name字段相同时，返回true:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.name.equals(p.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算hash:</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="super调用">4、Super调用</h4>
<p>在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过<code>super</code>来调用。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用父类的hello()方法:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.hello() + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="final-字段">5、Final 字段</h4>
<ul>
<li>如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为<code>final</code>。用<code>final</code>修饰的方法不能被<code>Override</code>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于一个类的实例字段，同样可以用<code>final</code>修饰。用<code>final</code>修饰的字段在初始化后不能被修改。例如:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Unamed&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="六抽象类">六、抽象类</h3>
<ul>
<li>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编译错误</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译成功</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>通过<code>abstract</code>定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范；</p></li>
<li><p>定义了抽象方法的class必须被定义为抽象类，从抽象类继承的子类必须实现抽象方法；</p></li>
<li><p>如果不实现抽象方法，则该子类仍是一个抽象类；</p></li>
</ul>
<h3 id="七面向抽象编程">七、面向抽象编程：</h3>
<p>我们定义了抽象类<code>Person</code>，以及具体的<code>Student</code>、<code>Teacher</code>子类的时候，我们可以通过抽象类<code>Person</code>类型去引用具体的子类的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br></pre></td></tr></table></figure>
<p>这种引用抽象类的好处在于，我们对其进行方法调用，并不关心<code>Person</code>类型变量的具体子类型：</p>
<p>这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。</p>
<p>面向抽象编程的本质就是：</p>
<ul>
<li>上层代码只定义规范（例如：<code>abstract class Person</code>）；</li>
<li>不需要子类就可以实现业务逻辑（正常编译）；</li>
<li>具体的业务逻辑由不同的子类实现，调用者并不关心。</li>
</ul>
<h3 id="八接口interface">八、接口Interface</h3>
<h4 id="基础知识">1、基础知识</h4>
<p>如果一个抽象类没有字段，所有方法全部都是抽象方法：就可以把该抽象类改写为接口：<code>interface</code>。</p>
<p>在Java中，使用<code>interface</code>可以声明一个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所谓<code>interface</code>，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是<code>public abstract</code>的，所以这两个修饰符不需要写出来（写不写效果都一样)</p>
<ul>
<li><p>当一个具体的<code>class</code>去实现一个<code>interface</code>时，需要使用<code>implements</code>关键字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>一个类可以实现多个<code>interface</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Student implements Person, Hello &#123; // 实现了两个interface</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="接口继承使用extends">2、接口继承：使用extends</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="default方法">3、default方法：</h3>
<p>在接口中，可以定义<code>default</code>方法。</p>
<p><strong>实现类可以不必覆写<code>default</code>方法。</strong></p>
<p><code>default</code>方法的目的是，当我们需要给接口新增一个方法时，将会涉及到修改全部子类。</p>
<p>但如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p>
<h3 id="九静态字段和静态方法">九、静态字段和静态方法：</h3>
<h4 id="静态字段">1、静态字段：</h4>
<p>​
所有实例共享一个静态字段。推荐用类名来访问静态字段。可以把静态字段理解为描述<code>class</code>本身的字段（非实例字段）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person.number = <span class="number">99</span>;</span><br><span class="line">System.out.println(Person.number);</span><br></pre></td></tr></table></figure>
<h4 id="静态方法">2、静态方法：</h4>
<ul>
<li><p>调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用</p></li>
<li><p>静态方法内部，无法访问<code>this</code>变量，也无法访问实例字段，它只能访问静态字段</p></li>
</ul>
<h4 id="接口的静态字段">3、接口的静态字段：</h4>
<ul>
<li>因为<code>interface</code>是一个纯抽象类，所以它不能定义实例字段。但是，<code>interface</code>是可以有静态字段的，并且静态字段必须为<code>final</code>类型：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MALE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FEMALE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
实际上，因为<code>interface</code>的字段只能是<code>public static final</code>类型，所以我们可以把这些修饰符都去掉，上述代码可以简写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 编译器会自动加上public statc final:</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">MALE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">FEMALE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="十包">十、包：</h3>
<h4 id="简介">1、简介：</h4>
<p>如果小军写了一个<code>Arrays</code>类，恰好JDK也自带了一个<code>Arrays</code>类，如何解决类名冲突？</p>
<p>在Java中，我们使用<code>package</code>来解决名字冲突。</p>
<p><strong>Java定义了一种名字空间，称之为包：<code>package</code>。一个类总是属于某个包，类名（比如<code>Person</code>）只是一个简写，真正的完整类名是<code>包名.类名</code>。</strong></p>
<p>例如：</p>
<ul>
<li><p>小明的<code>Person</code>类存放在包<code>ming</code>下面，因此，完整类名是<code>ming.Person</code>；</p></li>
<li><p>小红的<code>Person</code>类存放在包<code>hong</code>下面，因此，完整类名是<code>hong.Person</code>；</p></li>
<li><p>小军的<code>Arrays</code>类存放在包<code>mr.jun</code>下面，因此，完整类名是<code>mr.jun.Arrays</code>；</p></li>
</ul>
<h4 id="如何申明包">2、如何申明包：</h4>
<p>在定义<code>class</code>的时候，我们需要在第一行声明这个<code>class</code>属于哪个包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ming; <span class="comment">// 申明包名ming</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。</p>
<h4 id="组织java文件">3、组织java文件：</h4>
<p>我们还需要按照包结构把上面的Java文件组织起来。假设以<code>package_sample</code>作为根目录，<code>src</code>作为源码目录，那么所有文件结构就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package_sample</span><br><span class="line">└─ src</span><br><span class="line">    ├─ hong</span><br><span class="line">    │  └─ Person.java</span><br><span class="line">    │  ming</span><br><span class="line">    │  └─ Person.java</span><br><span class="line">    └─ mr</span><br><span class="line">       └─ jun</span><br><span class="line">          └─ Arrays.java</span><br></pre></td></tr></table></figure>
<h4 id="包作用域">4、包作用域：</h4>
<p>​
位于同一个包的类，可以访问包作用域的字段和方法。不用<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法就是包作用域。例如，<code>Person</code>类定义在<code>hello</code>包下面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 包作用域:</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Main</code>类也定义在<code>hello</code>包下面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p.hello(); <span class="comment">// 可以调用，因为Main和Person在同一个包</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="包的引入">5、包的引入：</h4>
<h4
id="在一个class中我们总会引用其他的class由3种方法">1、在一个<code>class</code>中，我们总会引用其他的<code>class</code>，由3种方法：</h4>
<ul>
<li>写完整类名：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">package</span> ming;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        mr.jun.<span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">mr</span>.jun.Arrays();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用<code>import</code>语句，导入小军的<code>Arrays</code>，然后写简单类名：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">package</span> ming;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入完整类名:</span></span><br><span class="line"><span class="keyword">import</span> mr.jun.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arrays</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在写<code>import</code>的时候，可以使用<code>*</code>，表示把这个包下面的所有<code>class</code>都导入进来（但不包括子包的<code>class</code>）：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">package</span> ming;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入mr.jun包的所有class:</span></span><br><span class="line"><span class="keyword">import</span> mr.jun.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arrays</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="java编译器如何查找">2、Java编译器如何查找？</h4>
<p>Java编译器最终编译出的<code>.class</code>文件只使用完整类名，因此，在代码中，当编译器遇到一个<code>class</code>名称时：</p>
<ul>
<li>如果是完整类名，就直接根据完整类名查找这个<code>class</code>；</li>
<li>如果是简单类名，按下面的顺序依次查找：
<ul>
<li>查找当前<code>package</code>是否存在这个<code>class</code>；</li>
<li>查找<code>import</code>的包是否包含这个<code>class</code>；</li>
<li>查找<code>java.lang</code>包是否包含这个<code>class</code>。</li>
</ul></li>
</ul>
<h4 id="最佳实践">3、最佳实践：</h4>
<p>为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的作用域名来确保唯一性。例如：</p>
<ul>
<li>org.apache</li>
<li>org.apache.commons.log</li>
<li>com.liaoxuefeng.sample</li>
</ul>
<p>子包就可以根据功能自行命名。</p>
<h3 id="十一作用域">十一、作用域：</h3>
<h4 id="public">1、public</h4>
<ul>
<li><p>定义为<code>public</code>的<code>class</code>、<code>interface</code>可以被其他任何类访问</p></li>
<li><p>定义为<code>public</code>的<code>field</code>、<code>method</code>可以被其他类访问，前提是首先有访问<code>class</code>的权限：</p></li>
</ul>
<h4 id="private">2、private</h4>
<ul>
<li><p>定义为<code>private</code>的<code>field</code>、<code>method</code>无法被其他类访问</p></li>
<li><p><code>private</code>访问权限被限定在<code>class</code>的内部，而且与方法声明顺序<em>无关</em>。推荐把<code>private</code>方法放到后面，因为<code>public</code>方法定义了类对外提供的功能，阅读代码的时候，应该先关注<code>public</code>方法</p></li>
<li><p>Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问<code>private</code>的权限：</p></li>
<li><p><strong>嵌套类</strong>：</p></li>
<li><p>定义在一个<code>class</code>内部的<code>class</code>称为嵌套类（<code>nested class</code>），Java支持好几种嵌套类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Inner i = new Inner();</span><br><span class="line">        i.hi();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // private方法:</span><br><span class="line">    private static void hello() &#123;</span><br><span class="line">        System.out.println(&quot;private hello!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 静态内部类:</span><br><span class="line">    static class Inner &#123;</span><br><span class="line">        public void hi() &#123;</span><br><span class="line">            Main.hello();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="protected">3、protected</h4>
<ul>
<li><code>protected</code>作用于继承关系。定义为<code>protected</code>的字段和方法可以被子类访问，以及子类的子类</li>
</ul>
<h4 id="package">4、package：</h4>
<ul>
<li>包作用域是指一个类允许访问同一个<code>package</code>的没有<code>public</code>、<code>private</code>修饰的<code>class</code>，以及没有<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"><span class="comment">// package权限的类:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="comment">// package权限的方法:</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>只要在同一个包，就可以访问<code>package</code>权限的<code>class</code>、<code>field</code>和<code>method</code>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 可以访问package权限的类:</span></span><br><span class="line">        <span class="type">Hello</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>();</span><br><span class="line">        <span class="comment">// 可以调用package权限的方法:</span></span><br><span class="line">        h.hi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="final">5、final</h4>
<p><code>final</code>与访问权限不冲突，它有很多作用：</p>
<ul>
<li>用<code>final</code>修饰<code>class</code>可以阻止被继承：</li>
<li>用<code>final</code>修饰<code>method</code>可以阻止被子类覆写</li>
<li>用<code>final</code>修饰<code>field</code>可以阻止被重新赋值</li>
<li>用<code>final</code>修饰局部变量可以阻止被重新赋值</li>
</ul>
<h4 id="最佳实践-1">6、最佳实践：</h4>
<ul>
<li><p>如果不确定是否需要<code>public</code>，就不声明为<code>public</code>，即尽可能少地暴露对外的字段和方法。</p></li>
<li><p>把方法定义为<code>package</code>权限有助于测试，因为测试类和被测试类只要位于同一个<code>package</code>，测试代码就可以访问被测试类的<code>package</code>权限方法。</p></li>
<li><p><strong>一个<code>.java</code>文件只能包含一个<code>public</code>类，但可以包含多个非<code>public</code>类。如果有<code>public</code>类，文件名必须和<code>public</code>类的名字相同。</strong></p></li>
</ul>
<h3 id="十二内部类">十二、内部类：</h3>
<p>Java的内部类分为好几种，通常情况用得不多，但也需要了解它们是如何使用的</p>
<h4 id="inner-class">1、Inner Class</h4>
<p>如果一个类定义在另一个类的内部，这个类就是Inner Class：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="comment">// 定义了一个Inner Class</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Inner Class的实例不能单独存在，必须依附于一个Outer Class的实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>(<span class="string">&quot;Nested&quot;</span>); <span class="comment">// 实例化一个Outer</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>(); <span class="comment">// 实例化一个Inner</span></span><br><span class="line">        inner.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.<span class="built_in">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Outer.Inner inner = outer.new Inner();</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Inner
Class和普通Class相比，除了能引用Outer实例外，还有一个额外的“特权”，<strong>就是可以修改Outer
Class的<code>private</code>字段</strong>，因为Inner Class的作用域在Outer
Class内部，所以能访问Outer
Class的<code>private</code>字段和方法。</p></li>
<li><p>观察Java编译器编译后的<code>.class</code>文件可以发现，<code>Outer</code>类被编译为<code>Outer.class</code>，而<code>Inner</code>类被编译为<code>Outer$Inner.class</code>。</p></li>
</ul>
<h4 id="anonymous-class">2、Anonymous Class</h4>
<p>​ 有一种定义Inner Class的方法，它不需要在Outer
Class中明确地定义这个Class，而是在方法内部，通过匿名类（Anonymous
Class）来定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>(<span class="string">&quot;Nested&quot;</span>);</span><br><span class="line">        outer.asyncHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">asyncHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.<span class="built_in">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
观察<code>asyncHello()</code>方法，我们在方法内部实例化了一个<code>Runnable</code>。<code>Runnable</code>本身是接口，接口是不能实例化的，所以这里实际上是定义了一个实现了<code>Runnable</code>接口的匿名类，并且通过<code>new</code>实例化该匿名类，然后转型为<code>Runnable</code>。在定义匿名类的时候就必须实例化它，定义匿名类的写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="comment">// 实现必要的抽象方法...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>匿名类和Inner Class一样，可以访问Outer
Class的<code>private</code>字段和方法。之所以我们要定义匿名类，是因为在这里我们通常不关心类名，比直接定义Inner
Class可以少写很多代码。</p>
<h4 id="static-nested-class-静态内部类">3、Static Nested Class
静态内部类：</h4>
<p>最后一种内部类和Inner
Class类似，但是使用<code>static</code>修饰，称为静态内部类（Static
Nested Class）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Outer.<span class="type">StaticNested</span> <span class="variable">sn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.StaticNested();</span><br><span class="line">        sn.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">NAME</span> <span class="operator">=</span> <span class="string">&quot;OUTER&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticNested</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.NAME);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 用<code>static</code>修饰的内部类和Inner
Class有很大的不同，它不再依附于<code>Outer</code>的实例，而是一个完全独立的类，因此无法引用<code>Outer.this</code>，但它可以访问<code>Outer</code>的<code>private</code>静态字段和静态方法。如果把<code>StaticNested</code>移到<code>Outer</code>之外，就失去了访问<code>private</code>的权限。</p>
<h4 id="总结">4、总结：</h4>
<p>Java的内部类可分为Inner Class、Anonymous Class和Static Nested
Class三种：</p>
<ul>
<li>Inner Class和Anonymous Class本质上是相同的，都必须依附于Outer
Class的实例，即隐含地持有<code>Outer.this</code>实例，并拥有Outer
Class的<code>private</code>访问权限；</li>
<li>Static Nested Class是独立类，但拥有Outer
Class的<code>private</code>访问权限。</li>
</ul>
<h3 id="十三classpath-和-jar">十三、classpath 和 jar</h3>
<h4 id="classpath是什么">1、classpath是什么？</h4>
<p>​
<code>classpath</code>是JVM用到的一个环境变量，它用来指示JVM如何搜索<code>class</code></p>
<p>​
因为Java是编译型语言，源码文件是<code>.java</code>，而编译后的<code>.class</code>文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，如果要加载一个<code>abc.xyz.Hello</code>的类，应该去哪搜索对应的<code>Hello.class</code>文件。</p>
<p>​
所以，<code>classpath</code>就是一组目录的集合，它设置的搜索路径与操作系统相关。例如，在Windows系统上，用<code>;</code>分隔，带空格的目录用<code>""</code>括起来，可能长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\work\project1\bin;C:\shared;&quot;D:\My Documents\project1\bin&quot;</span><br></pre></td></tr></table></figure>
<p>​ 在Linux系统上，用<code>:</code>分隔，可能长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/shared:/usr/local/bin:/home/liaoxuefeng/bin</span><br></pre></td></tr></table></figure>
<p>​
现在我们假设<code>classpath</code>是<code>.;C:\work\project1\bin;C:\shared</code>，当JVM在加载<code>abc.xyz.Hello</code>这个类时，会依次查找：</p>
<ul>
<li><当前目录>.class</li>
<li>C:.class</li>
<li>C:.class</li>
</ul>
<p>​
注意到<code>.</code>代表当前目录。如果JVM在某个路径下找到了对应的<code>class</code>文件，就不再往后继续搜索。如果所有路径下都没有找到，就报错。</p>
<h4 id="如何设定classpath">2、如何设定classpath?</h4>
<p>​
在启动JVM时设置<code>classpath</code>变量,实际上就是给<code>java</code>命令传入<code>-classpath</code>或<code>-cp</code>参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -classpath .;C:\work\project1\bin;C:\shared abc.xyz.Hello</span><br></pre></td></tr></table></figure>
<p>​
没有设置系统环境变量，也没有传入<code>-cp</code>参数，那么JVM默认的<code>classpath</code>为<code>.</code>，即当前目录：</p>
<p>​
在IDE中运行Java程序，IDE自动传入的<code>-cp</code>参数是当前工程的<code>bin</code>目录和引入的jar包</p>
<p><strong>注意：不要把任何Java核心库添加到classpath中！JVM根本不依赖classpath加载核心库！</strong></p>
<h4 id="jar包是什么">3、jar包是什么？：</h4>
<p>​
如果有很多<code>.class</code>文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。</p>
<p>​
jar包就是用来干这个事的，它可以把<code>package</code>组织的目录层级，以及各个目录下的所有文件（包括<code>.class</code>文件和其他文件）都打成一个jar文件，这样一来，无论是备份，还是发给客户，就简单多了。</p>
<p>​
jar包实际上就是一个zip格式的压缩文件，而jar包相当于目录。如果我们要执行一个jar包的<code>class</code>，就可以把jar包放到<code>classpath</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ava -cp ./hello.jar abc.xyz.Hello</span><br></pre></td></tr></table></figure>
<p>​ 这样JVM会自动在<code>hello.jar</code>文件里去搜索某个类。</p>
<h4 id="如何创建jar包">4、如何创建jar包？</h4>
<p>​
因为jar包就是zip包，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从<code>.zip</code>改为<code>.jar</code>，一个jar包就创建成功。</p>
<p>假设编译输出的目录结构是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package_sample</span><br><span class="line">└─ bin</span><br><span class="line">   ├─ hong</span><br><span class="line">   │  └─ Person.class</span><br><span class="line">   │  ming</span><br><span class="line">   │  └─ Person.class</span><br><span class="line">   └─ mr</span><br><span class="line">      └─ jun</span><br><span class="line">         └─ Arrays.class</span><br></pre></td></tr></table></figure>
<p>这里需要特别注意的是，jar包里的第一层目录，不能是<code>bin</code>，而应该是<code>hong</code>、<code>ming</code>、<code>mr</code>。应当如下所示：</p>
<figure>
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/pic.png"
alt="pic" />
<figcaption aria-hidden="true">pic</figcaption>
</figure>
<h4 id="特殊文件-manifest.mf">4、特殊文件 MANIFEST.MF：</h4>
<p>​
jar包还可以包含一个特殊的<code>/META-INF/MANIFEST.MF</code>文件，<code>MANIFEST.MF</code>是纯文本，可以指定<code>Main-Class</code>和其它信息。JVM会自动读取这个<code>MANIFEST.MF</code>文件，如果存在<code>Main-Class</code>，我们就不必在命令行指定启动的类名，而是用更方便的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar hello.jar</span><br></pre></td></tr></table></figure>
<p>​
jar包还可以包含其它jar包，这个时候，就需要在<code>MANIFEST.MF</code>文件里配置<code>classpath</code>了。</p>
<p>​
在大型项目中，不可能手动编写<code>MANIFEST.MF</code>文件，再手动创建zip包。Java社区提供了大量的开源构建工具，例如<a
href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945359327200">Maven</a>，可以非常方便地创建jar包。</p>
<h3 id="十四模块">十四、模块：</h3>
<h4 id="java9之前的程序打包运行">1、java9之前的程序打包运行：</h4>
<p>从Java 9开始，JDK又引入了模块（Module）</p>
<p><code>.class</code>文件是JVM看到的最小可执行文件，而一个大型程序需要编写很多Class，并生成一堆<code>.class</code>文件，很不便于管理，所以，<code>jar</code>文件就是<code>class</code>文件的容器。</p>
<p>在Java
9之前，一个大型Java程序会生成自己的jar文件，同时引用依赖的第三方jar文件，而JVM自带的Java标准库，实际上也是以jar文件形式存放的，这个文件叫<code>rt.jar</code>，一共有60多M。</p>
<p>如果是自己开发的程序，除了一个自己的<code>app.jar</code>以外，还需要一堆第三方的jar包，运行一个Java程序，一般来说，命令行写这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -cp app.jar:a.jar:b.jar:c.jar com.liaoxuefeng.sample.Main</span><br></pre></td></tr></table></figure>
<p>如果漏写了某个运行时需要用到的jar，那么在运行期极有可能抛出<code>ClassNotFoundException</code>。</p>
<p>所以，jar只是用于存放class的容器，<strong>它并不关心class之间的依赖</strong>。</p>
<h4 id="java9之后引入的模块">2、java9之后引入的模块：</h4>
<p>​ 主要为了解决依赖的问题。</p>
<p>​
如果<code>a.jar</code>必须依赖另一个<code>b.jar</code>才能运行，那我们应该给<code>a.jar</code>加点说明啥的，让程序在编译和运行的时候能自动定位到<code>b.jar</code>，这种自带“依赖关系”的class容器就是模块。</p>
<p>为了表明Java模块化的决心，从Java
9开始，原有的Java标准库已经由一个单一巨大的<code>rt.jar</code>分拆成了几十个模块，这些模块以<code>.jmod</code>扩展名标识，可以在<code>$JAVA_HOME/jmods</code>目录下找到它们：</p>
<ul>
<li>java.base.jmod</li>
<li>java.compiler.jmod</li>
<li>java.datatransfer.jmod</li>
<li>java.desktop.jmod</li>
<li>...</li>
</ul>
<p>​
这些<code>.jmod</code>文件每一个都是一个模块，模块名就是文件名。例如：模块<code>java.base</code>对应的文件就是<code>java.base.jmod</code>。模块之间的依赖关系已经被写入到模块内的<code>module-info.class</code>文件了。所有的模块都直接或间接地依赖<code>java.base</code>模块，只有<code>java.base</code>模块不依赖任何模块，它可以被看作是“根模块”，好比所有的类都是从<code>Object</code>直接或间接继承而来。</p>
<p>​
把一堆class封装为jar仅仅是一个打包的过程，而把一堆class封装为模块则不但需要打包，还需要写入依赖关系，并且还可以包含二进制代码（通常是JNI扩展）。此外，模块支持多版本，即在同一个模块中可以为不同的JVM提供不同的版本。</p>
<h4 id="如何编写模块">3、如何编写模块：</h4>
<p>​
首先，创建模块和原有的创建Java项目是完全一样的，以<code>oop-module</code>工程为例，它的目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">oop-module</span><br><span class="line">├── bin</span><br><span class="line">├── build.sh</span><br><span class="line">└── src</span><br><span class="line">    ├── com</span><br><span class="line">    │   └── itranswarp</span><br><span class="line">    │       └── sample</span><br><span class="line">    │           ├── Greeting.java</span><br><span class="line">    │           └── Main.java</span><br><span class="line">    └── module-info.java</span><br></pre></td></tr></table></figure>
<p>其中，<code>bin</code>目录存放编译后的class文件，<code>src</code>目录存放源码，按包名的目录结构存放，仅仅在<code>src</code>目录下多了一个<code>module-info.java</code>这个文件，这就是模块的描述文件。在这个模块中，它长这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> hello.world &#123;</span><br><span class="line">	<span class="keyword">requires</span> java.base; <span class="comment">// 可不写，任何模块都会自动引入java.base</span></span><br><span class="line">	<span class="keyword">requires</span> java.xml;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>module</code>是关键字，后面的<code>hello.world</code>是模块的名称，它的命名规范与包一致。花括号的<code>requires xxx;</code>表示这个模块需要引用的其他模块名。除了<code>java.base</code>可以被自动引入外，这里我们引入了一个<code>java.xml</code>的模块。</p>
<p>当我们使用模块声明了依赖关系后，才能使用引入的模块。例如，<code>Main.java</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itranswarp.sample;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须引入java.xml模块后才能使用其中的类:</span></span><br><span class="line"><span class="keyword">import</span> javax.xml.XMLConstants;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Greeting</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Greeting</span>();</span><br><span class="line">		System.out.println(g.hello(XMLConstants.XML_NS_PREFIX));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果把<code>requires java.xml;</code>从<code>module-info.java</code>中去掉，编译将报错。可见，模块的重要作用就是声明依赖关系。</p>
<h4 id="命令行编译并创建模块">4、 命令行编译并创建模块：</h4>
<p>首先，我们把工作目录切换到<code>oop-module</code>，在当前目录下编译所有的<code>.java</code>文件，并存放到<code>bin</code>目录下，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ javac -d bin src/module-info.java src/com/itranswarp/sample/*.java</span><br></pre></td></tr></table></figure>
<p>如果编译成功，现在项目结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">oop-module</span><br><span class="line">├── bin</span><br><span class="line">│   ├── com</span><br><span class="line">│   │   └── itranswarp</span><br><span class="line">│   │       └── sample</span><br><span class="line">│   │           ├── Greeting.class</span><br><span class="line">│   │           └── Main.class</span><br><span class="line">│   └── module-info.class</span><br><span class="line">└── src</span><br><span class="line">    ├── com</span><br><span class="line">    │   └── itranswarp</span><br><span class="line">    │       └── sample</span><br><span class="line">    │           ├── Greeting.java</span><br><span class="line">    │           └── Main.java</span><br><span class="line">    └── module-info.java</span><br></pre></td></tr></table></figure>
<p>注意到<code>src</code>目录下的<code>module-info.java</code>被编译到<code>bin</code>目录下的<code>module-info.class</code>。</p>
<p>下一步，我们需要把bin目录下的所有class文件先打包成jar，在打包的时候，注意传入<code>--main-class</code>参数，让这个jar包能自己定位<code>main</code>方法所在的类：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin .</span><br></pre></td></tr></table></figure>
<p>现在我们就在当前目录下得到了<code>hello.jar</code>这个jar包，它和普通jar包并无区别，可以直接使用命令<code>java -jar hello.jar</code>来运行它。但是我们的目标是创建模块，所以，继续使用JDK自带的<code>jmod</code>命令把一个jar包转换成模块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jmod create --class-path hello.jar hello.jmod</span><br></pre></td></tr></table></figure>
<p>于是，在当前目录下我们又得到了<code>hello.jmod</code>这个模块文件，这就是最后打包出来的传说中的模块！</p>
<h4 id="运行模块">5、运行模块：</h4>
<p>要运行一个jar，我们使用<code>java -jar xxx.jar</code>命令。要运行一个模块，我们只需要指定模块名。试试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ java --module-path hello.jmod --module hello.world</span><br></pre></td></tr></table></figure>
<p>结果是一个错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Error occurred during initialization of boot layer</span><br><span class="line">java.lang.module.FindException: JMOD format not supported at execution time: hello.jmod</span><br></pre></td></tr></table></figure>
<p>原因是<code>.jmod</code>不能被放入<code>--module-path</code>中。换成<code>.jar</code>就没问题了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ java --module-path hello.jar --module hello.world</span><br><span class="line">Hello, xml!</span><br></pre></td></tr></table></figure>
<h4 id="打包jre">6、打包JRE</h4>
<p>我们可以利用创建的<code>hello.jmod</code>来打包JRE。</p>
<p>​ 为了支持模块化，Java
9首先带头把自己的一个巨大无比的<code>rt.jar</code>拆成了几十个<code>.jmod</code>模块，原因就是，运行Java程序的时候，实际上我们用到的JDK模块，并没有那么多。不需要的模块，完全可以删除。</p>
<p>​
过去发布一个Java应用程序，要运行它，必须下载一个完整的JRE，再运行jar包。而完整的JRE块头很大，有100多M。怎么给JRE瘦身呢？</p>
<p>​
现在，JRE自身的标准库已经分拆成了模块，只需要带上程序用到的模块，其他的模块就可以被裁剪掉。怎么裁剪JRE呢？并不是说把系统安装的JRE给删掉部分模块，而是“复制”一份JRE，但只带上用到的模块。为此，JDK提供了<code>jlink</code>命令来干这件事。命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.world --output jre/</span><br></pre></td></tr></table></figure>
<p>我们在<code>--module-path</code>参数指定了我们自己的模块<code>hello.jmod</code>，然后，在<code>--add-modules</code>参数中指定了我们用到的3个模块<code>java.base</code>、<code>java.xml</code>和<code>hello.world</code>，用<code>,</code>分隔。最后，在<code>--output</code>参数指定输出目录。</p>
<p>现在，在当前目录下，我们可以找到<code>jre</code>目录，这是一个完整的并且带有我们自己<code>hello.jmod</code>模块的JRE。试试直接运行这个JRE：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jre/bin/java --module hello.world</span><br><span class="line">Hello, xml!</span><br></pre></td></tr></table></figure>
<p>要分发我们自己的Java应用程序，只需要把这个<code>jre</code>目录打个包给对方发过去，对方直接运行上述命令即可，既不用下载安装JDK，也不用知道如何配置我们自己的模块，极大地方便了分发和部署。</p>
<h4 id="访问权限">7、访问权限：</h4>
<p>Java的class访问权限分为public、protected、private和默认的包访问权限。</p>
<p>引入模块后，这些访问权限的规则就要稍微做些调整。</p>
<p>确切地说，<strong>class的这些访问权限只在一个模块内有效</strong>，模块和模块之间，例如，a模块要访问b模块的某个class，必要条件是b模块明确地导出了可以访问的包。</p>
<p>举个例子：我们编写的模块<code>hello.world</code>用到了模块<code>java.xml</code>的一个类<code>javax.xml.XMLConstants</code>，我们之所以能直接使用这个类，是因为模块<code>java.xml</code>的<code>module-info.java</code>中声明了若干导出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> java.xml &#123;</span><br><span class="line">    <span class="keyword">exports</span> java.xml;</span><br><span class="line">    <span class="keyword">exports</span> javax.xml.catalog;</span><br><span class="line">    <span class="keyword">exports</span> javax.xml.datatype;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有它声明的导出的包，外部代码才被允许访问。换句话说，如果外部代码想要访问我们的<code>hello.world</code>模块中的<code>com.itranswarp.sample.Greeting</code>类，我们必须将其导出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> hello.world &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.itranswarp.sample;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">requires</span> java.base;</span><br><span class="line">	<span class="keyword">requires</span> java.xml;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，模块进一步隔离了代码的访问权限。</p>
]]></content>
      <categories>
        <category>⑤  编程语言类笔记</category>
        <category>java入门系列笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>oop</tag>
      </tags>
  </entry>
  <entry>
    <title>java系列笔记1——java基础</title>
    <url>/2022/01/28/3f464858b7bd/</url>
    <content><![CDATA[<p>参考教程网址：https://www.liaoxuefeng.com/wiki/1252599548343744/1260467032946976</p>
<h3 id="一第一个java程序">一、第一个Java程序</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
java规定，某个类定义的<code>public static void main(String[] args)</code>是java程序的固定入口方法，因此，java程序总是从<code>main</code>方法开始执行。</p>
<h3 id="二如何运行java程序">二、如何运行Java程序：</h3>
<p>1、用javac把Hello.java编译成<strong>字节码文件Hello.class</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">javac Hello.java</span></span><br></pre></td></tr></table></figure>
<p>2、然后用<strong>java命令执行这个字节码文件。</strong>javac是编译器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java Hello</span></span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>
<p>给虚拟机传递的参数<code>Hello</code>是我们定义的类名，<strong>虚拟机自动查找对应的class文件并执行</strong></p>
<p><strong>注意</strong>：</p>
<p>一个Java源码只能定义一个<code>public</code>类型的class，并且class名称和文件名要完全一致；</p>
<p>使用<code>javac</code>可以将<code>.java</code>源码编译成<code>.class</code>字节码；</p>
<p>使用<code>java</code>可以运行一个已编译的Java程序，参数是类名。</p>
<h3 id="三程序基本结构">三、程序基本结构：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以用来自动创建文档的注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 向屏幕输出文本:</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">        <span class="comment">/* 多行注释开始</span></span><br><span class="line"><span class="comment">        注释内容</span></span><br><span class="line"><span class="comment">        注释结束 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// class定义结束</span></span><br></pre></td></tr></table></figure>
<p><code>public</code>是访问修饰符，表示该<code>class</code>是公开的。不写<code>public</code>，也能正确编译，但是这个类将无法从命令行执行。</p>
<h3 id="四数据类型">四、数据类型</h3>
<p><strong>基本数据类型：</strong></p>
<ul>
<li>整数类型：byte，short，int，long</li>
<li>浮点数类型：float，double</li>
<li>字符类型：char</li>
<li>布尔类型：boolean</li>
</ul>
<p><strong>引用类型</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>引用类型的变量类似于C语言的指针，它内部存储一个“地址”，指向某个对象在内存的位置</p>
<p><strong>常量</strong>：</p>
<p>如果加上<code>final</code>修饰符，这个变量就变成了常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span>; <span class="comment">// PI是一个常量</span></span><br></pre></td></tr></table></figure>
<p><strong>var关键字:</strong></p>
<p>如果想省略变量类型，可以使用<code>var</code>关键字</p>
<h3 id="五浮点数运算">五、浮点数运算：</h3>
<p>​
由于浮点数存在运算误差，所以比较两个浮点数是否相等常常会出现错误的结果。正确的比较方法是判断两个浮点数之差的绝对值是否小于一个很小的数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">r</span> <span class="operator">=</span> Math.abs(x - y);</span><br><span class="line"><span class="comment">// 再判断绝对值是否足够小:</span></span><br><span class="line"><span class="keyword">if</span> (r &lt; <span class="number">0.00001</span>) &#123;</span><br><span class="line">    <span class="comment">// 可以认为相等</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整数运算在除数为<code>0</code>时会报错，而浮点数运算在除数为<code>0</code>时，不会报错，但会返回几个特殊值：</p>
<ul>
<li><code>NaN</code>表示Not a Number</li>
<li><code>Infinity</code>表示无穷大</li>
<li><code>-Infinity</code>表示负无穷大</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">0.0</span> / <span class="number">0</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="number">1.0</span> / <span class="number">0</span>; <span class="comment">// Infinity</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d3</span> <span class="operator">=</span> -<span class="number">1.0</span> / <span class="number">0</span>; <span class="comment">// -Infinity</span></span><br></pre></td></tr></table></figure>
<h3 id="六字符类型">六、字符类型：</h3>
<p>一个<code>char</code>保存一个Unicode字符：</p>
<p>因为Java在内存中总是使用Unicode表示字符，所以，一个英文字符和一个中文字符都用一个<code>char</code>类型表示，它们都占用两个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n1 = &#x27;A&#x27;; // 字母“A”的Unicodde编码是65</span><br><span class="line">int n2 = &#x27;中&#x27;; // 汉字“中”的Unicode编码是20013</span><br><span class="line">还可以直接用转义字符\u+Unicode编码来表示一个字符：</span><br><span class="line">// 注意是十六进制:</span><br><span class="line">char c3 = &#x27;\u0041&#x27;; // &#x27;A&#x27;，因为十六进制0041 = 十进制65</span><br><span class="line">char c4 = &#x27;\u4e2d&#x27;; // &#x27;中&#x27;，因为十六进制4e2d = 十进制20013</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果用<code>+</code>连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串，再连接：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">25</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;age is &quot;</span> + age;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从Java 13开始，字符串可以用<code>"""..."""</code>表示多行字符串（Text
Blocks）了。</p>
<p>多行字符串前面共同的空格会被去掉，即：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                   SELECT * FROM</span></span><br><span class="line"><span class="string">                     users</span></span><br><span class="line"><span class="string">                   WHERE id &gt; 100</span></span><br><span class="line"><span class="string">                   ORDER BY name DESC</span></span><br><span class="line"><span class="string">                   &quot;&quot;&quot;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>不可见特性：</strong></p>
<p>Java的字符串除了是一个引用类型外，还有个重要特点，就是字符串不可变。考察以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        System.out.println(s); <span class="comment">// 显示 hello</span></span><br><span class="line">        s = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        System.out.println(s); <span class="comment">// 显示 world</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察执行结果，难道字符串<code>s</code>变了吗？其实变的不是字符串，而是变量<code>s</code>的“指向”。</p>
<p><strong>空值null:</strong></p>
<p>引用类型的变量可以指向一个空值<code>null</code>，它表示不存在，即该变量不指向任何对象。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// s1是null</span></span><br><span class="line">String s2; <span class="comment">// 没有赋初值值，s2也是null</span></span><br></pre></td></tr></table></figure>
<h3 id="七数组">七、数组：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] ns = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span>[] ns = &#123; <span class="number">68</span>, <span class="number">79</span>, <span class="number">91</span>, <span class="number">85</span>, <span class="number">62</span> &#125;;</span><br><span class="line">System.out.println(ns.length); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h3 id="八流程控制手段">八、流程控制手段</h3>
<h4 id="输出">1、输出</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.print(<span class="string">&quot;A,&quot;</span>); <span class="comment">//输出后不换行</span></span><br><span class="line">System.out.println() <span class="comment">//输出后自动换行</span></span><br><span class="line">System.out.printf(<span class="string">&quot;%.2f\n&quot;</span>, d); <span class="comment">// 格式化输出，显示两位小数3.14</span></span><br></pre></td></tr></table></figure>
<h4 id="输入">2、输入：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); <span class="comment">// 创建Scanner对象</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Input your name: &quot;</span>); <span class="comment">// 打印提示</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.nextLine(); <span class="comment">// 读取一行输入并获取字符串</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Input your age: &quot;</span>); <span class="comment">// 打印提示</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">// 读取一行输入并获取整数</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;Hi, %s, you are %d\n&quot;</span>, name, age); <span class="comment">// 格式化输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过<code>import</code>语句导入<code>java.util.Scanner</code></li>
<li>创建<code>Scanner</code>对象并传入<code>System.in</code></li>
<li>有了<code>Scanner</code>对象后，要读取用户输入的字符串，使用<code>scanner.nextLine()</code>，要读取用户输入的整数，使用<code>scanner.nextInt()</code>。<code>Scanner</code>会自动转换数据类型，因此不必手动转换。</li>
</ul>
<h3
id="九判断引用类型变量内容是否相等">九、判断引用类型变量内容是否相等：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;HELLO&quot;</span>.toLowerCase();</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        <span class="keyword">if</span> (s1 == s2) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s1 == s2&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s1 != s2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果是 s1 != s2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要判断引用类型的变量内容是否相等，必须使用<code>equals()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s1.equals(s2)</span><br></pre></td></tr></table></figure>
<h3 id="十新switch表达式">十、新Switch表达式：</h3>
<p>​ 从Java
12开始，<code>switch</code>语句升级为更简洁的表达式语法，使用类似模式匹配（Pattern
Matching）的方法，保证只有一种路径会被执行，并且不需要<code>break</code>语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="string">&quot;apple&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;apple&quot;</span> -&gt; System.out.println(<span class="string">&quot;Selected apple&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;pear&quot;</span> -&gt; System.out.println(<span class="string">&quot;Selected pear&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;mango&quot;</span> -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Selected mango&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Good choice!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;No fruit selected&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="十一switch中的yield返回值">十一、Switch中的Yield返回值：</h3>
<p>大多数时候，在<code>switch</code>表达式内部，我们会返回简单的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="string">&quot;orange&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;apple&quot;</span> -&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;mango&quot;</span> -&gt; <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> fruit.hashCode();</span><br><span class="line">                yield code; <span class="comment">// switch语句返回值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;opt = &quot;</span> + opt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="十二for-each-循环">十二、for each 循环</h3>
<p>和<code>for</code>循环相比，<code>for each</code>循环的变量n不再是计数器，而是直接对应到数组的每个元素。<code>for each</code>循环的写法也更简洁。但是，<code>for each</code>循环无法指定遍历顺序，也无法获取数组的索引。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : ns) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="十三排序库arrays.sort">十三、排序库：Arrays.sort()</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ns = &#123; <span class="number">28</span>, <span class="number">12</span>, <span class="number">89</span>, <span class="number">73</span>, <span class="number">65</span>, <span class="number">18</span>, <span class="number">96</span>, <span class="number">50</span>, <span class="number">8</span>, <span class="number">36</span> &#125;;</span><br><span class="line">        Arrays.sort(ns);</span><br><span class="line">        System.out.println(Arrays.toString(ns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="十四多维数组">十四、多维数组：</h3>
<h4 id="二维数组">1) 二维数组</h4>
<p>二维数组的每个数组元素的长度并不要求相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] ns = &#123;</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">            &#123; <span class="number">5</span>, <span class="number">6</span> &#125;,</span><br><span class="line">            &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;</span><br><span class="line">		&#125;;</span><br><span class="line">        System.out.println(ns.length); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>打印多维数组可以使用<code>Arrays.deepToString()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] ns = &#123;</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">            &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;,</span><br><span class="line">            &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(Arrays.deepToString(ns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="十五命令行参数">十五、命令行参数：</h3>
<p>命令行参数类型是<code>String[]</code>数组；
命令行参数由JVM接收用户输入并传给<code>main</code>方法；如何解析命令行参数需要由程序自己实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;-version&quot;</span>.equals(arg)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;v 1.0&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>⑤  编程语言类笔记</category>
        <category>java入门系列笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>《UniFormer:Unifying Convolution and Self-attention for Visual Recognition》</title>
    <url>/2022/01/27/7d2ace115a28/</url>
    <content><![CDATA[<h4
id="论文名称uniformer-unifying-convolution-and-self-attention-for-visual-recognition">论文名称：《UniFormer:
Unifying Convolution and Self-attention for Visual Recognition》</h4>
<h4 id="论文地址-httpsarxiv.orgpdf2201.09450.pdf">论文地址：
https://arxiv.org/pdf/2201.09450.pdf</h4>
<h2 id="关键词">1、关键词：</h2>
<p>​ Visual Recognition、CNN、SelfAttention、Transformer</p>
<h2 id="领域背景visual-recognition">2、领域背景—Visual
Recognition：</h2>
<p>​
表征学习一直是视觉识别领域的比较基本的研究。主要在面临向图像以及视频数据的时候，会存在两个问题：</p>
<ul>
<li>1、局部区域（空间、时间、时空）中的视觉内容往往是相似的，也就意味着局部冗余会比较大，这会导致不必要的计算量</li>
<li>2、全局的依赖关系比较复杂，在不同区域的目标物体之间都会存在一些动态的关系。</li>
</ul>
<h2 id="先前工作描述与比较">3、先前工作描述与比较：</h2>
<p>​
基于领域背景中的两个主要问题，主流的解决方案就是CNN和ViT，但是它们都只针对上述问题中的某一个做出了解决，而忽略了另一个。如下所示：</p>
<ul>
<li><p>CNN能够通过小范围的卷积，降低局部冗余，减小计算量，但在捕获全局依赖中很有限制。</p></li>
<li><p>ViT能够通过Self-Attention很有效的捕获长距离的依赖，但是盲目的去计算所有tokens之间的相似关系，会带来很大的计算冗余。其在浅层网络上很难有效的去编码局部的特征。</p>
<ul>
<li>本文的作者进行了一个实验：如下图所示，显示的是ViT网络的第三层的Attention图，我们发现虽然Attention机制计算了全局的token之间的关系，但最终在锚点（绿色方框）学习到的有效信息均来源于其很小的一个邻域范围（红色填充方框）。所以,ViT花费了非常大的计算复杂度，去编码了一个局部的视觉表示特征。</li>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220129104342853.png" /></li>
</ul></li>
</ul>
<h2 id="主要设计思想">4、主要设计思想：</h2>
<p>​
基于上述的工作描述，作者提出了UniFormer，将3D卷积和时空自注意力机制结合在一个简洁的<a
href="https://so.csdn.net/so/search?q=transformer&amp;spm=1001.2101.3001.7020">transformer</a>结构中，能够同时处理局部冗余和全局依赖，其主要包括三个模块：</p>
<ul>
<li>Dynamic Position Embedding( DPE )</li>
<li>Multi-Head Relation Aggregator ( MHRA )
<strong>【和CNN与ViT的主要不同所在】</strong></li>
<li>Feed-Forward Network ( FFN )</li>
</ul>
<p>UniFormer与其他transformer的区别主要在于MHRA模块：</p>
<ul>
<li><p>在浅层，aggregator利用一个小的learnable
matrix学习局部的token之间的相似性关系，通过聚合小的3D邻域的token信息极大地减少计算量。在深层，aggregator学习全局token之间的相似性关系，可以灵活的建立远距离图像区域或视频帧的token之间的长程依赖关系。</p></li>
<li><p>最后，通过以分层方式逐步堆叠局部和全局 UniFormer
块，我们可以灵活地整合它们的协作能力来促进Representation Learning。
最后，我们为视觉识别提供了一个通用且强大的主干，并通过简单而精细的适应成功地解决了各种下游视觉任务。</p></li>
</ul>
<h2 id="具体方法与网络架构">5、具体方法与网络架构：</h2>
<h3 id="uniformer-block">1) UniFormer Block</h3>
<p>​ 下面图片就是UniFormer
Block的整体架构，其中在标注维度的地方，所有标红的字符都是仅对于视频输入有效，代表了输入视频的帧数，如果输入是个图像，那么这些标红的值应该都
= 1.</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220127163758510.png" /></p>
<ul>
<li><strong>概述</strong>：Uniformer Block
的整体架构如上所示，分割成了几个阶段，每个阶段中由三个核心的模块重复堆叠L次组成，下面就是单词堆叠中，所有的模块的大致介绍：
<ul>
<li>Dynamic Position Embedding( DPE )</li>
<li>Multi-Head Relation Aggregator ( MHRA )</li>
<li>Feed-Forward Network ( FFN )</li>
<li>我们首先引入 DPE
将位置信息动态集成到所有Tokens（等式1）。它支持任意输入分辨率，并充分利用Tokens的顺序以获得更好的视觉识别效果。
然后，我们使用 MHRA
，其利用每个Token的上下文token，通过关系学习的方式，来增强每个Token（等式
2）。 通过在浅层和深层灵活设计Token的相似性，我们的 MHRA
可以巧妙地统一卷积和自注意力机制，以减少局部冗余并学习全局依赖性。
最后，我们像传统的 ViTs 一样添加
FFN，它由两个线性层和一个非线性函数GELU组成（等式 3）。
通道数先扩大4倍再恢复，因此每个token会被单独增强.</li>
</ul></li>
<li><strong>输入</strong>：<span class="math inline">\(X_{in} \in R^{C
\times T \times H \times W}\)</span>, T 为视频帧数，当输入为图像时，T =
1</li>
<li><strong>输出</strong>：<span
class="math inline">\(Z\)</span>特征空间向量</li>
<li><strong>公式表达</strong>：
<ul>
<li><span class="math inline">\(X = DPE(X_{in}) + X_{in}\)</span></li>
<li><span class="math inline">\(Y = MHRA(Norm(X)) + X\)</span></li>
<li><span class="math inline">\(Z = FFN(Norm(Y)) + Y\)</span></li>
</ul></li>
</ul>
<h3 id="multi-head-relation-aggregator">2) Multi-Head Relation
Aggregator</h3>
<ul>
<li><p><strong>概述</strong>：该模块可以巧妙地统一卷积和自注意力机制，以减少局部冗余并学习全局依赖性。MHRA使用multi-head机制来计算token间的关系，公式表达如下：</p></li>
<li><p><strong>公式表达</strong>：</p>
<ul>
<li><strong>MHRA模块的第n个head</strong>： <span
class="math inline">\(R_n(X) = A_nV_n(X)\)</span>，输入向量<span
class="math inline">\(X \in R^{C \times T \times H \times
W}\)</span>，我们会将其首先Reshape成一个token的序列<span
class="math inline">\(X \in R^{L \times C}\)</span>, 其中 <span
class="math inline">\(L = T \times H \times W\)</span></li>
<li><strong>总体</strong>： <span class="math inline">\(MHRA(X) =
Concat(R_1(X);R_2(X);...;R_N(X))U\)</span>，<span
class="math inline">\(U \in R^{C \times
C}\)</span>是一个可学习矩阵，用于聚合N个Head的内容</li>
</ul></li>
<li><p><strong>单个Head内部变换细节介绍</strong>：</p>
<ul>
<li>每个RA包含<strong>token context encoding </strong>和 <strong>token
affinity learning</strong>两步</li>
<li>1、我们应用<strong>线性变换</strong>将<strong>原始标记</strong>编码为<strong>上下文标记</strong>：<span
class="math inline">\(V_n(X) \in R^{L \times \frac{C}{N}}\)</span></li>
<li>2、An是
<strong>token相似度</strong>，RA可以在其指导下来概括上下文信息，进行总结</li>
</ul></li>
<li><p><strong>浅层网络中的Local MHRA</strong>:</p>
<ul>
<li><p><strong>概述：</strong>在先前的比较中，我们发现：在浅层网络计算全局Self-Attention最终学到的也只是局部的信息，所以我们在浅层网络中，现在只在局部区域内来进行计算。因此，在浅层网络中，我们将Local
Affinity作为一个<strong>可学习参数的矩阵</strong>。</p></li>
<li><p><strong>具体而言：</strong>给定anchor token <span
class="math inline">\(X_i\)</span> , 局部RA学习该token和一个小邻域<span
class="math inline">\(\Omega_i^{t \times h \times
w}\)</span>内的其他token的相似性。<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220129110111062.png"
alt="image-20220129110111062" /></p>
<p><span class="math inline">\(a_n \in R^{t \times h \times w}\)</span>
, <span class="math inline">\(X_j\)</span>
代表邻域内的任一一个token，<span class="math inline">\(i-j\)</span>
表示token i和j的相对位置关系</p></li>
<li><p><strong>注意</strong>：因为tokens的感受野很小，相邻token之间的视觉内容在浅层中会发生微妙的变化。在这种情况下，没有必要去让token相似度动态的进行变化，因此我们使用一个可学习的参数矩阵来描述局部的token相似度，token的相似度仅取决于两个token之间的相对位置关系。</p></li>
<li><p><strong>与CNN的比较</strong>：其可以视为是
PWConv-DWConv-PWConv的组合，但是该论文中的Uniformer块是基于一个通用的Transformer的格式进行设计的，也就是说除了MHRA之外，还带有DPE和FFN，这一简单的继承能够非常有效的加强token的表示能力。</p></li>
</ul></li>
<li><p><strong>深层网络中的Global MHRA</strong>:</p>
<ul>
<li><p><strong>概述</strong>：在深层网络中，在更广阔的空间中获取长距离依赖很重要。因此，我们通过在全局条件下比较内容来进行token相似度的计算。</p></li>
<li><p><strong>具体而言</strong>：给定anchor token <span
class="math inline">\(X_i\)</span> , 局部RA学习该token和所有其他token
的相似性</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220129111415083.png" /></p>
<p><span class="math inline">\(X_j\)</span> 代表全局范围<span
class="math inline">\(size = T \times H \times
W\)</span>内的任意一个token，<span class="math inline">\(Q_n 和
K_n\)</span>是两个不同的线性变换。</p></li>
<li><p><strong>与Transformer的比较</strong>：</p>
<p>可以被实例化为一个时空self-attention，<span class="math inline">\(Q_n
、K_n、V_n\)</span>代表Query、Key、Value.但是，UniformerBlock又和传统的ViT块不同：</p>
<ul>
<li>1、以往的video
tranformer在视频域中分割开了时间和空间的attention，为了减少在计算token相似度比较时候的计算量。但是这会不可避免地恶化token之间的时空关系。相比之下，我们的模块联合编码时空token关系以生成更具辨别力的视频表示以进行识别。因为我们在浅层的时候大大的节省了token比较的计算量，所以整体模型上还是能到达一个计算量-准确度比较好的一个平衡。</li>
<li>2、其次，我们在 UniFormer 中采用动态位置嵌入 (DPE)
代替绝对位置嵌入。它是卷积风格的（见下节），可以克服排列不变性，对不同输入长度的视觉tokens友好</li>
</ul></li>
</ul></li>
</ul>
<h3 id="dynamic-position-embedding">3) Dynamic Position Embedding</h3>
<ul>
<li><p><strong>概述：</strong>先前绝大多数的位置编码都采用<strong>绝对或相对位置嵌入</strong>，然而绝对位置嵌入必须通过微调对各种输入大小进行插值，而相对位置嵌入由于自注意力机制的修改容易无法很好地工作。最近，有人提出了卷积位置编码，具体而言，卷积位置编码CPE，可以隐式地将位置信息通过卷积操作进行编码，这样可以让Transformer去处理任意的输入大小，并且提高识别性能。鉴于其即插即用地性质，我们将其拿过来作为我们的DPE模块：</p></li>
<li><p><span class="math inline">\(DPE(X_{in})= DWConv(X_in)\)</span> ,
DWConv 代表 depth-wise 卷积，zero padding</p></li>
<li><p><strong>原因</strong>：</p>
<ul>
<li><p>1、depthwise 卷积对任意的输入大小很友好（使用其时空版本对视频中的
3D 位置信息进行编码很简单）</p></li>
<li><p>2、很轻量化，能够较好的平衡计算量与准确性的平衡。</p></li>
<li><p>3、增加Zero
padding，它可以通过逐步查询它们的邻居来帮助token了解它们的绝对位置</p>
<p>（Finally, we add extra zero paddings, since it can help tokens be
aware of their absolute positions by querying their neighbors
progressively 论文3.3最后一句话 ）</p></li>
</ul>
<!-- Zero Padding ？ 如何逐步查询令居进而帮助token了解绝对位置？ --></li>
</ul>
<h2 id="衍生框架-framework">6、衍生框架 FrameWork</h2>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220129115021079.png" /></p>
<h3 id="图像分类框架">1) 图像分类框架：</h3>
<ul>
<li>Stage1 和 Stage2 用的是 Local Uniformer Blocks
<ul>
<li>使用 PWConv-DWConv-PWConv 进行实例化</li>
</ul></li>
<li>Stage3 和 Stage4 用的是 Global Uniformer Blocks
<ul>
<li>使用 multi-head self-attention 进行实例化，heads = 64</li>
</ul></li>
<li>DPE 都实例化成 DWConv， spatial size = 3 x 3</li>
<li>FFN 的 Expand Ratio = 4</li>
<li>卷积 用 BN， self-attention 用 LN</li>
<li>特征降维：
<ul>
<li>Stage1前： $ 4 ， stride = 4 $</li>
<li>其他Stage前： $ 2 ， stride = 2 $</li>
</ul></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220127163758510.png" /></p>
<h3 id="视频分类-密集预测-等其他框架详见论文主体">2） 视频分类
&amp;&amp; 密集预测 等其他框架详见论文主体</h3>
]]></content>
      <categories>
        <category>③  论文阅读笔记</category>
        <category>CV相关论文</category>
      </categories>
      <tags>
        <tag>CNN</tag>
        <tag>Transformer</tag>
        <tag>Visual Recognition</tag>
      </tags>
  </entry>
  <entry>
    <title>《HandWritting Transformers》(更新中)</title>
    <url>/2022/01/26/8f68bd6cb4f4/</url>
    <content><![CDATA[<h4
id="论文名称handwriting-transformers">论文名称：《<strong>Handwriting
Transformers</strong>》</h4>
<h4 id="论文地址-httpsarxiv.orgabs2104.03964">论文地址：
https://arxiv.org/abs/2104.03964</h4>
<h2 id="关键词">1、关键词：</h2>
<p>​ 手写字体生成（英文）、GAN、Transformer</p>
<h2 id="领域背景手写字体生成">2、领域背景—手写字体生成：</h2>
<p>​
自动的手写文字生成对于一些书写障碍的人十分重要。通常使用的方法是利用GAN来进行离线的手写文字图像生成。</p>
<h2 id="先前工作描述与比较">3、先前工作描述与比较：</h2>
<p>​ 两类生成方法： 基于笔画的在线生成方法（需要记录时序数据） 和
基于图像的离线生成方法。</p>
<ul>
<li><p>GANwriting
：该方法利用在少量信息中提取样式特征和预定义固定长度的文本内容来进行文本生成。</p></li>
<li><p>我们的方法：与GANwritting相似，我们的方法也是在少量的风格样例中去提取风格特征，但又与
GANwriting 不同，我们的方法具有生成任意长度的风格化文本的灵活性。
我们能够同时捕获全局和局部的书写风格。</p></li>
</ul>
<h2 id="主要设计思想">4、主要设计思想：</h2>
<p>两个主要改进的Motivation:</p>
<p>1、除了字/行级别的样式-内容纠缠之外，字符级别的样式和内容之间的纠缠有助于模仿特定字符的写作风格以及泛化到词汇外的内容。</p>
<p>2、为了生成准确的风格文本图像，需要模仿全局的（例如墨水宽度、倾斜度等）和局部的（例如字符风格、连字等）风格特征。</p>
<h2 id="具体方法与网络架构">5、具体方法与网络架构：</h2>
<p><strong>问题公式化描述：</strong></p>
<ul>
<li><span class="math inline">\(i \in W\)</span>, <span
class="math inline">\(W\)</span>包含M个作者，<span
class="math inline">\(i\)</span>代表某一个作者</li>
<li>一个手写文字图像集合 P</li>
<li>输入的文本内容<span class="math inline">\(A =
\{a_j\}_{j=1}^Q\)</span>，视为一个Word String的集合</li>
<li>每个WordString 包含长度不定的字符，字符来自于字符集C</li>
<li>字符集C包含 字母表、标点、数字</li>
<li><span class="math inline">\(\hat
X_i^t\)</span>代表依据新的文本内容t，生成的作者<span
class="math inline">\(i\)</span>的新图像</li>
</ul>
<h3 id="整体架构overall-pipeline">1) 整体架构（Overall Pipeline）</h3>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220127103226508.png" /></p>
<ul>
<li><strong>概述</strong>：先利用CNN，将风格图像变换至高维特征空间，然后进入Transformer
Encoder中，生成特征潜在向量Z，输入到Transformer Decoder中，与Query
Words进行结合，解码输出F，再通过CNN
Decoder，最终生成图像，然后进入到不同的判别器中，基于不同的角度，定义了4个损失函数，进行函数的优化。</li>
<li>Query Words进入到Transformer
Decoder中前，需要进行词嵌入编码，对每个字符，定义了一个可学习的词嵌入向量，<span
class="math inline">\(q_c \in
R^{512}\)</span>，这样一种基于字符的表示，以及基于transformer的序列处理方式，帮助模型能够生成任意长度的手写单词，并且能够更好的泛化到词汇表外的数据。
<ul>
<li><span
class="math inline">\(G_\theta\)</span>生成器，用于合成手写文本图像</li>
<li><span
class="math inline">\(D_\Psi\)</span>判别器，用于确保生成图像的
手写风格的真实性（即确保看上去是手写图像）</li>
<li><span
class="math inline">\(R_\phi\)</span>识别器，用于保持文本内容正确</li>
<li><span
class="math inline">\(S_\eta\)</span>风格分类器，用于确保迁移的手写风格正确性（即确保生成的风格与Style
Example一致）</li>
</ul></li>
<li><strong>输入</strong>： <span class="math inline">\(a_j \in
A\)</span> &amp;&amp; <span class="math inline">\(X_i^s\)</span>文本 +
风格图像示例</li>
<li><strong>输出</strong>： <span class="math inline">\(\hat
X_i^t\)</span>新生成的风格化手写字符图像（文本内容为 t ）</li>
</ul>
<h3 id="encoder-network-tepsilon">2) Encoder Network <span
class="math inline">\(T\epsilon\)</span></h3>
<ul>
<li><strong>概述</strong>：将风格手写示例图编码至风格特征空间向量</li>
<li><strong>输入</strong>：<span
class="math inline">\(X_i^s\)</span>风格手写示例图</li>
<li><strong>输出</strong>：<span class="math inline">\(Z \in R^{N \times
d}\)</span>风格特征空间向量</li>
<li><strong>网络结构</strong>：
<ul>
<li><strong>Part1 : CNN Encoder</strong>
<ul>
<li>采用<strong>ResNet18</strong>: 为每个style
image生成低分辨率的激活图<span class="math inline">\(h_{ij} \in R^{h
\times w \times d}\)</span></li>
<li>将<span
class="math inline">\(h_{ij}\)</span>在空间维度上展平，得到一个Sequence,
<span class="math inline">\(n \times d\)</span>，其中<span
class="math inline">\(n = h \times w\)</span>,
这个序列可以被视为风格图像某区域的描述子</li>
<li>同时，因为总共我们会提供P张风格示例图像，将所有风格示例图像中提取出的Sequence进行拼接，得到一个Tensor，<span
class="math inline">\(H_i \in R^{N \times d}\)</span>其中，<span
class="math inline">\(N = n \times P\)</span></li>
</ul></li>
<li><strong>Part2: Transformer-Based Encoder</strong>
<ul>
<li>L层，每一层都由multihead-self-attention 和
MLP模块组成。重复L遍，很标准的Transformer
Encoder（论文中没有细讲有无Residual）</li>
<li>为保留提供的输入序列的未知信息，采用固定位置编码</li>
</ul></li>
</ul></li>
<li><strong>意义</strong>：对局部的和全局的手写风格图像特征建模，例如倾斜、歪斜、字符形状、连字、墨水宽度等</li>
</ul>
<h3 id="decoder-network-t_d">3) Decoder Network <span
class="math inline">\(T_d\)</span></h3>
<ul>
<li><strong>概述</strong>：结合输入的字符序列，生成风格化的手写字符图像</li>
<li><strong>输入</strong>：<span class="math inline">\(Z \in R^{N \times
d}\)</span>风格特征空间向量 + <span
class="math inline">\(A\)</span>输入的字符序列</li>
<li><strong>输出</strong>：<span class="math inline">\(\hat
X_i^t\)</span>新生成的风格化手写字符图像（文本内容为 t ）</li>
<li><strong>网络结构</strong>：
<ul>
<li><strong>Part1: Query Words 处理</strong>
<ul>
<li>将Query Words 编码成 Query
Embedding，其为可学习的位置编码参数，加入到之后Transformer-Based
Decoder中。简单来讲，这一步的作用就是要让每一个Query
Embedding都在提供的样式图像中，能够去查找感兴趣的区域，从而进一步推断所有查询字符的风格属性。</li>
<li>如下图所示，t对应的位置编码，需要去学习的就是在我们提供的样例风格图像中，寻找字符t相关的位置（感兴趣的区域）。</li>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220127112528447.png" /></li>
</ul></li>
<li><strong>Part2: Transformer Based Decoder:</strong>
<ul>
<li>注意1：和self-attention不同，其key &amp; value 来源于Encoder的输出，
query向量来源于Decoder自己的层。</li>
<li>注意2：在所有的Transformer Based
Decoder中，我们是并行的去处理每一个Query Embeddings的，每个Query
Embedding就代表一个字符。</li>
<li>将上一步的Query Embeddings 经过连续的 Transformer Based
Decoder以后，会累积一些风格信息，产生一个输出 <span
class="math inline">\(F_{a_j} \in R^{m_j \times d}\)</span>. <span
class="math inline">\(m_j\)</span>是某个单词的字符数</li>
<li>然后，我们会将<span
class="math inline">\(N(0,1)\)</span>的噪音，加入到 <span
class="math inline">\(F_{a_j}\)</span>中，来模拟自然情况下的外部干扰变化。</li>
<li><strong>举例而言</strong>：
<ul>
<li>一个m个字符的单词</li>
<li>我们会将m个Embeddings
Vectors连接起来，然后再通过一个FC层，得到一个<span
class="math inline">\(m_j \times 8192\)</span>的矩阵，我们将其Reshape成
<span class="math inline">\(512 \times 4 \times
4m_j\)</span>,然后输入到CNN Decoder中。</li>
</ul></li>
</ul></li>
<li><strong>Part3: CNN Decoder</strong>:
<ul>
<li>4 个残差模块 + tanh激活函数</li>
<li>获得最终的输出图像</li>
</ul></li>
</ul></li>
</ul>
<h3 id="training-loss-objectives">4) Training &amp; Loss Objectives</h3>
<ul>
<li><p><strong>概述</strong>：总共由4个Loss函数组成，每个Loss负责不同的部分，在网络结构概述中已经有所提及。</p>
<ul>
<li>1、<span
class="math inline">\(D_\Psi\)</span>判别器，用于确保生成图像的
手写风格的真实性（即确保看上去是手写图像）</li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220127115520938.png" /></p>
<ul>
<li><p>2、<span
class="math inline">\(R_\phi\)</span>手写文本识别器，用于保持文本内容正确，使用CRNN搭建，使用CTC
Loss函数，比较query words和识别输出的差别。识别器 Rφ
仅针对真实的、标记的、手写样本进行优化训练，但它用于鼓励 Gθ
生成具有准确内容的可读文本。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220127115740239.png" /></p></li>
<li><p>3、<span
class="math inline">\(S_\eta\)</span>风格分类器，用于确保迁移的手写风格正确性（即确保生成的风格与Style
Example一致）
，其能够预测一个给定的手写图像的作者。使用Cross-Entropy来定义Loss函数：其只在真实的样例上利用如下损失函数进行训练：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220127115916996.png" /></p></li>
<li><p>4、利用Cycle Loss 来确保编码的style
features由循环一致性。这个损失函数能够让decoder最大程度上在解码阶段保留风格信息，使得我们能够从生成的图像中重建出最开始的风格特征序列。给定生成的图像
<span class="math inline">\(\hat X_i^t\)</span>，我们使用 编码器<span
class="math inline">\(T\epsilon\)</span>来重建风格特征向量<span
class="math inline">\(\hat Z\)</span>。如下所示的循环损失<span
class="math inline">\(L_c\)</span>用于最小化<span
class="math inline">\(Z\)</span>和 <span class="math inline">\(\hat
Z\)</span>之间的L1差距</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220127120112639.png" /></p>
<p>循环损失对解码器施加了正则化，以一致地模仿生成的样式文本图像中的写作风格。</p></li>
</ul></li>
<li><p>总的来说，我们以端到端的方式训练我们的 HWT
模型，损失目标如下</p></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220127120324671.png" /></p>
<ul>
<li>同时，我们观察到平衡网络 Sη 和 Rφ
的梯度有助于使用我们的损失公式进行训练。根据 [3]，我们将 ∇Sη 和 ∇Rφ
归一化，使其具有与对抗性损失梯度相同的标准偏差 (σ)</li>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220127120433481.png" /></li>
<li><span
class="math inline">\(\alpha\)</span>是一个超参数，在训练我们的模型的时候被固定为1</li>
</ul>
]]></content>
      <categories>
        <category>③  论文阅读笔记</category>
        <category>CV相关论文</category>
      </categories>
      <tags>
        <tag>GAN</tag>
        <tag>Transformer</tag>
        <tag>HandWritting Generation</tag>
      </tags>
  </entry>
  <entry>
    <title>Tmux常用命令</title>
    <url>/2022/01/26/dd1871cc8c9e/</url>
    <content><![CDATA[<h3 id="tmux常用命令">Tmux常用命令</h3>
<ul>
<li><p>创建并指定session名字 tmux new -s $session_name</p></li>
<li><p>删除session Ctrl+b :kill-session</p></li>
<li><p>临时退出session Ctrl+b d</p></li>
<li><p>列出session tmux ls</p></li>
<li><p>进入已存在的session tmux a -t $session_name</p></li>
<li><p>删除所有session Ctrl+b :kill-server</p></li>
<li><p>删除指定session tmux kill-session -t $session_name</p></li>
<li><p>开启光标</p></li>
</ul>
<p>​ ctrl + b 按下后松开 再立马按 [</p>
<ul>
<li>关闭光标</li>
</ul>
<p>​ ctrl + q 按下后松开 再立马按 [</p>
]]></content>
      <categories>
        <category>⑦  工具使用类笔记</category>
      </categories>
      <tags>
        <tag>Tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习基础系列笔记14——ResNet详解及为什么能解决深度网络退化问题</title>
    <url>/2022/01/23/4be37de340a1/</url>
    <content><![CDATA[<h2 id="一深度网络退化背景">一、深度网络退化背景</h2>
<p>​
对于卷积神经网络，深度是一个很重要的因素。深度卷积网络自然的整合了低中高不同层次的特征，特征的层次可以靠加深网络的层次来丰富。因此在构建卷积网络时，网络的深度越高，可抽取的特征层次就越丰富越抽象。所以一般我们会倾向于使用更深层次的网络结构，以便取得更高层次的特征。但是更深层的网络结构有的时候并不会带来更好的结果，层数一旦过多以后，就会导致表现明显下降，这就是深度网络的退化问题。</p>
<p>​
深度网络的退化问题到底是由于什么导致的呢？过拟合？还是梯度消失？梯度爆炸？</p>
<p>​
其实都不是。如下图论文中显示的所示，显然其在训练集上的误差也很大，就不可能是过拟合问题。而梯度消失或梯度爆炸，通过加入BN层，就能够通过规整数据分布来解决这个问题，所以应当也不是梯度消失或爆炸的问题。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS82Y2M3OThjNC0wMTNmLTRkNjQtYmY5Yi0yZDg0YWExOTQzNzYucG5n.png" /></p>
<p>​ 那么根本原因是什么呢？</p>
<p>​ 在<strong>MobileNet
V2</strong>的论文中提到，由于非线性激活函数Relu的存在，每次输入到输出的过程都几乎是不可逆的，这也造成了许多<strong>不可逆的信息损失</strong>。我们试想一下，一个特征的一些有用的信息损失了，那他的表现还能做到持平吗？显然不可能做到持平。随着网络层数的加深，造成了许多不可逆的信息损失，最终导致了深度网络的退化问题。</p>
<h2 id="二resnet提出初衷与详解">二、ResNet提出初衷与详解</h2>
<p>​
我们选择加深网络的层数，是希望深层的网络的表现能比浅层好，或者是<strong>希望它的表现至少和浅层网络持平（相当于直接复制浅层网络的特征）</strong>，可实际的结果却让我们大吃一惊（深度网络退化），这是为什么呢？</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS81OGU1NDU3Yy1lZWEwLTRmMjctOGVlMS04ZDJhMTk4YmJkOTcucG5n.png" /></p>
<p>​
如图所示，这是一个直观的例子，我们把右边的网络理解为左边浅层网络加深了三层（框起来的部分），假如我们希望右边的深层网络与左边的浅层网络持平，即是希望框起来的三层跟没加一样，也就是加的三层的输入等于输出。我们假设这三层的输入为x，输出为H(x)，那么深层网络与浅层网络表现持平的直观理解即是H(x)=x，这种让输出等于输入的方式，就是ResNet论文中提到的<strong>恒等映射（identity
mapping)</strong>。</p>
<p>​
所以<strong>ResNet的初衷，就是让网络拥有这种恒等映射的能力，能够在加深网络的时候，至少能保证深层网络的表现至少和浅层网络持平</strong>。</p>
<p>​
所以，现在我们知道，<strong>如果想要让深度神经网络不退化，根本的原因就是如何去做到恒等映射</strong>。然而现有的神经网络很难拟合潜在的恒等映射函数，H(x)
=
x，因为神经网络内部总会做一些参数的调整。但我们如果把恒等映射作为网络的一部分，将网络设计为H(x)
= F(x) + x的形式，即如残差结构中所示那样，网络的输出是由x 和 F(x)
相加得到的，那么就可以把问题转化为
让中间多出来的那三层，去学习一个残差函数F(x) = H(x) -
x。只要学习到的残差函数，能够使得F(x) =
0，那么就构成了一个恒等映射。最终网络的结果就不会比失去这几层要差。<strong>并且，让网络去拟合一个残差比拟合一个恒等映射容易得多（原因见后）</strong></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9mNGI5ZjRjYi04NWE4LTRmNjQtYjc0Ny1lMzU0ZDdjNmM2YmUucG5n.png" /></p>
<p>​ ResNet中，<strong>shortcut
connection</strong>，<strong>通过跳接在激活函数前，将上一层（或几层）的输出与本层输出相加，将求和的结果输入到激活函数作为本层的输出</strong></p>
<p>​</p>
<h2
id="三为什么resnet能解决深度网络退化问题">三、为什么ResNet能解决深度网络退化问题？</h2>
<p>1、加了残差结构后就是给了输入x多一个选择，在神经网络学习到这层的参数是冗余的时候它可以选择直接走这条“跳接”曲线，跳过这个冗余层，而不需要再去拟合参数使得输出H(x)等于x。</p>
<p>2、因为学习残差的计算量比学习恒等映射小。假设普通网络为A，残差网络为B，输入为2，输出为2（输入和输出一样是为了模拟冗余层需要恒等映射的情况），那么普通网络就是A
(2) = 2，而残差网络就是B ( 2 ) = F ( 2 ) + 2 = 2，显然残差网络中的F ( 2
) = 0
。我们知道网络中权重一般会初始化成0附近的数，那么我们就很容易理解，为什么让F(2)拟合0会比A
(2) = 2 容易了</p>
<p>3、我们知道ReLU能够将负数激活为0，而正数输入等于输出。这相当于过滤了负数的线性变化，让F(x)=0变得更加容易。</p>
<p>4、我们知道残差网络可以表示成H ( x ) = F ( x ) + x
，这就说明了在求输出H ( x ) 对输入x
的倒数（梯度），也就是在反向传播的时候，H ′ ( x ) = F ′ ( x ) +
1，残差结构的这个常数1也能保证在求梯度的时候梯度不会消失。</p>
<h2 id="四一些细节问题">四、一些细节问题：</h2>
<p>​
在ResNet中，残差连接的相加，指的是逐元素相加，在ReSNet的网络示意图中，有的Skip-Connection是实线，有的是虚线，<strong>虚线的代表这些模块前后的维度不一致，因为去掉残差结构的Plain网络还是和VGG一样，也就是每隔n层进行下采样但深度翻倍（VGG通过池化层下采样，ResNet通过卷积）</strong>：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS81YjZhMTNiZi00ZTU1LTRlMzYtOWY1NC05YzAzYzhkMmVkY2EucG5n.png" /></p>
<ul>
<li><p>空间上不一致时，需要给输入的X做一个线性的映射：调整一下H*W维度</p></li>
<li><p>深度上不一致时，有两种解决方法，一种是在跳接过程中加一个1×1的卷积层进行升维，另一种则是直接补零（先做下采样）。</p></li>
<li><p>针对比较深的神经网络，作者也考虑到计算量，会先用1×1的卷积将输入的256维降到64维，然后通过1×1恢复。这样做的目的是减少参数量和计算量。</p></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS85M2RiMDgzYi05NTk3LTRjZmUtODJmZC04NzRlNTI2NjViNmIucG5n.png" /></p>
<p>引用：https://blog.csdn.net/cristiano20/article/details/104309948</p>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Basic系列笔记</category>
      </categories>
      <tags>
        <tag>ResNet</tag>
        <tag>Degradation</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习基础系列笔记13——DropOut详解及为什么能够防止过拟合</title>
    <url>/2022/01/21/788645531548/</url>
    <content><![CDATA[<h2 id="一dropout是什么">一、DropOut是什么？</h2>
<p>​ 过拟合是Deep Neural
Networks(DNN)网络存在的问题之一。过拟合的特点是模型对训练数据的拟合非常好，但对测试数据的拟合却非常差，具体表现为loss和在训练集上的错误率非常低，而在验证集或测试集上却都要高很多。针对解决过拟合问题设计出来的方法很多，dropout就是其中一种最简单，也是最有效的方法。</p>
<p>​ 在训练DNN网络的过程中，对于每一个神经元，以p的概率被随机的drop
out，也就是将其值置零。这样，在该轮前传和反传的过程中，该神经元将失去作用，相当于不存在，如下图所示。DropOut整体来说，是在训练过程中以一定的概率的使神经元失活，即输出为0，以提高模型的泛化能力，减少过拟合。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/dropout.jpeg" /></p>
<h2
id="二dropout阶段在训练阶段和测试阶段的区别">二、DropOut阶段在训练阶段和测试阶段的区别：</h2>
<h3 id="训练阶段">1、训练阶段：</h3>
<p>​
在前向传播时，假设有这一层n个神经元，则我们可以假设每个神经元的概率都是0~1(可以通过python得到随机的值)，然后小于p的就失活，即不参与训练。</p>
<p>​ 在反向传播时，也只对参与训练的神经元进行参数更新。</p>
<p>​ 每次训练的时候，又是n个神经元，重新进行dropout</p>
<p>​ <strong>Dropout
在训练时采用，是为了减少神经元对部分上层神经元的依赖，类似将多个不同网络结构的模型集成起来，减少过拟合的风险。</strong></p>
<h3 id="测试阶段">2、测试阶段：</h3>
<p>​ 在测试时，应该用整个训练好的模型，不需要进行dropout。</p>
<p>​
参与学习的节点和那些被隐藏的节点需要以一定的概率p加权求和，综合计算得到网络的输出。</p>
<p>​ 即预测的时候，每一个单元的参数要预乘以p。为什么要预乘以p呢？</p>
<p>​
因为我们训练的时候会随机的丢弃一些神经元，但是预测的时候就没办法随机丢弃了。<strong>如果丢弃一些神经元，这会带来结果不稳定的问题，也就是给定一个测试数据，有时候输出a有时候输出b，结果不稳定，这是实际系统不能接受的</strong>，用户可能认为模型预测不准。那么<strong>一种”补偿“的方案就是每个神经元的权重都乘以一个p，这样在“总体上”使得测试数据和训练数据是大致一样的</strong>。</p>
<p>​
<strong>比如一个神经元的输出是x，那么在训练的时候它有p的概率参与训练，(1-p)的概率丢弃，那么它输出的期望是<span
class="math inline">\(p \times x+(1-p) \times 0 = p \times
x\)</span>。因此测试的时候把这个神经元的权重乘以p可以得到同样的期望。</strong></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220121204115930.png" /></p>
<h2 id="三dropout如何防止过拟合">三、DropOut如何防止过拟合？</h2>
<p><strong>（1）数据层面</strong></p>
<p>​ 对于每一个dropout后的网络，进行训练时，相当于做了Data
Augmentation。比如，对于某一层，dropout一些单元后，形成的结果是(1.5，0，2.5，0，1，2，0)，其中0是被drop的单元，那么总能找到一个样本，使得结果也是如此。这样每一次dropout其实都相当于增加了样本。</p>
<p><strong>（2）模型层面</strong></p>
<ul>
<li><p><strong>在较大程度上减小了网络的大小：</strong>在这个“残缺”的网络中，让神经网络学习数据中的局部特征（即部分分布式特征），但这些特征也足以进行输出正确的结果。</p></li>
<li><p><strong>取平均的作用：</strong>
如果正常的模型（没有dropout），我们用相同的训练数据去训练5个不同的神经网络，一般会得到5个不同的结果，此时我们可以采用
“5个结果取均值”或者“多数取胜的投票策略”去决定最终结果。（例如
3个网络判断结果为数字9,那么很有可能真正的结果就是数字9，其它两个网络给出了错误结果）。<strong>这种“综合起来取平均”的策略通常可以有效防止过拟合问题。因为不同的网络可能产生不同的过拟合，取平均则有可能让一些“相反的”拟合互相抵消。每次训练随机dropout掉不同的隐藏神经元，网络结构已经不同，这就类似在训练不同的网络，整个dropout过程就相当于对很多个不同的神经网络取平均。而不同的网络产生不同的过拟合，一些互为“反向”的拟合相互抵消就可以达到整体上减少过拟合。</strong></p></li>
<li><p><strong>减少神经元之间共适应关系：</strong>
因为dropout导致两个神经元不一定每次都在一个网络中出现，这样权值的更新不再依赖于有固定关系的隐含节点的共同作用，阻止了某些特征仅仅在其它特定特征下才有效果的情况，
迫使网络去学习更加鲁棒的特征。换句话说，假如神经网络是在做出某种预测，<strong>它不应该对一些特定的线索片段太过敏感</strong>，即使丢失特定的线索，它也应该可以从众多其它线索中学习一些共同的模式（鲁棒性）。</p></li>
</ul>
<p>引用：</p>
<p>https://zhuanlan.zhihu.com/p/175142160</p>
<p>https://www.zhihu.com/question/402485242/answer/1553947864</p>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Basic系列笔记</category>
      </categories>
      <tags>
        <tag>OverFitting</tag>
        <tag>DropOut</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习基础系列笔记12——BatchNorm详解及为什么能防止过拟合</title>
    <url>/2022/01/21/22d362e1f563/</url>
    <content><![CDATA[<h2 id="一详解batchnorm原理">一、详解BatchNorm原理：</h2>
<p>​
BatchNorm是一种能够加速深度神经网络收敛，避免过拟合的方法，那么为什么呢？首先我们需要探讨一下这个问题，为什么深度神经网络<strong>随着网络深度加深，训练起来越困难，收敛越来越慢？</strong></p>
<p>在回答这个问题前需要首先了解两个概念：</p>
<p>​
<strong>1、独立同分布（IID）</strong>：即假设训练数据和测试数据是满足相同分布的。它是通过训练数据获得的模型能够在测试集获得好的效果的一个基本保障</p>
<p>​ <strong>2、Covariate
shift</strong>：<strong>如果ML系统实例集合&lt;X,Y&gt;中的输入值X的分布老是变，这不符合IID假设</strong>，网络模型很难<strong>稳定的学规律</strong>。</p>
<p>​
所以，之所以深度神经网络随着网络深度加深，训练越来越困难是因为，对于深度学习这种包含很多隐层的网络结构，在训练过程中，因为各层参数不停在变化，所以每个隐层都会面临covariate
shift的问题，也就是<strong>在训练过程中，隐层的输入分布老是变来变去，这就是所谓的“Internal
Covariate
Shift（ICS）”，Internal指的是深层网络的隐层，是发生在网络内部的事情，而不是covariate
shift问题只发生在输入层</strong></p>
<p>​
BatchNorm的基本思想就是能不能<strong>让每个隐层节点的激活输入分布固定下来呢</strong>？这样就避免了“Internal
Covariate Shift”问题了。</p>
<p>​
所以BN实质上就是在深度神经网络训练过程中使得每一层神经网络的输入保持相同分布的一种方法。</p>
<p>​
BN的基本思想其实相当直观：因为深层神经网络在做非线性变换前的<strong>激活输入值随着网络深度加深或者在训练过程中，其分布逐渐发生偏移或者变动，之所以训练收敛慢，一般是整体分布逐渐往非线性函数的取值区间的上下限两端靠近</strong>（对于Sigmoid函数来说，意味着激活输入值WU+B是大的负值或正值），所以这<strong>导致反向传播时低层神经网络的梯度消失</strong>，这是训练深层神经网络收敛越来越慢的<strong>本质原因</strong>，<strong>而BN就是通过一定的规范化手段，把每层神经网络任意神经元这个输入值的分布强行拉回到均值为0方差为1的标准正态分布</strong>，其实就是把越来越偏的分布强制拉回比较标准的分布，这样使得激活输入值落在非线性函数对输入比较敏感的区域，这样输入的小变化就会导致损失函数较大的变化，意思是<strong>这样让梯度变大，避免梯度消失问题产生，而且梯度变大意味着学习收敛速度快，能大大加快训练速度。</strong></p>
<p>​
<strong>对于每个隐层神经元，把逐渐向非线性函数映射后向取值区间极限饱和区靠拢的输入分布强制拉回到均值为0方差为1的比较标准的正态分布，使得非线性变换函数的输入值落入对输入比较敏感的区域，以此避免梯度消失问题。</strong>因为梯度一直都能保持比较大的状态，所以很明显对神经网络的参数调整效率比较高，就是变动大，就是说向损失函数最优值迈动的步子大，也就是说收敛地快。BN说到底就是这么个机制，方法很简单，道理很深刻。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/aHR0cDovL3FsLm1hZ2ljLXNldmVuLnRvcC91cGxvYWQvMjAyMC8zL2ltYWdlLTVkMjU4MDQxNGI0YTRkNjhiODEzMDMxMDZlMzY5YzNiLnBuZw.png" style="zoom: 67%;" /></p>
<h2
id="二batchnorm在训练阶段和测试阶段的做法与意义">二、BatchNorm在训练阶段和测试阶段的做法与意义：</h2>
<h3 id="训练阶段">1、训练阶段：</h3>
<p>​
首先计算均值和方差（每次训练给一个批量，计算批量的均值方差），然后归一化，然后缩放和平移，完事！</p>
<h3 id="测试阶段">2、测试阶段：</h3>
<p>​
每次只输入一张图片，这怎么计算批量的均值和方差，于是，应该是这样子，在训练的时候实现计算好mean、
var，测试的时候直接拿来用就可以了，不用计算均值和方差。</p>
<ul>
<li><p>用训练集来估计总体均值 μ 和总体标准差 σ 。</p></li>
<li><p>较为简单的做法就是把每个mini-batch的均值和方差都保存下来，然后训练完了求均值的均值，方差的均值即可。</p></li>
<li><p>在测试阶段应用BatchNorm的含义，应该就是要让测试集的测试精度与整个训练网络保持一致。</p></li>
</ul>
<h2
id="三batchnorm的两个参数gamma和beta有什么作用">三、BatchNorm的两个参数<span
class="math inline">\({\gamma}\)</span>和<span
class="math inline">\(\beta\)</span>有什么作用？</h2>
<p><img
src="https://www.zhihu.com/equation?tex=y%3D\frac%7Bx-\mathrm%7BE%7D%5Bx%5D%7D%7B\sqrt%7B\operatorname%7BVar%7D%5Bx%5D%2B\epsilon%7D%7D+*+\gamma%2B\beta+" /></p>
<h3
id="如果只做归一化为什么是学不到任何东西的">1、如果只做归一化，为什么是学不到任何东西的？</h3>
<p>​
如果在每一层之后都归一化成0-1的高斯分布（减均值除方差）那么数据的分布一直都是高斯分布，数据分布都是固定的了，这样即使加更多层就没有意义了，<strong>深度网络就是想学习数据的分布发现规律性，BN就是不让学习的数据分布偏离太远</strong></p>
<h3 id="两个参数的作用">2、两个参数的作用</h3>
<p>​ 为了减小Internal Covariate
Shift，对神经网络的每一层做归一化不就可以了，假设将每一层输出后的数据都归一化到0均值，1方差，满足正胎分布，但是，此时有一个问题，<strong>如果每一层的数据分布都是标准正态分布，导致其完全学习不到输入数据的特征，因为，费劲心思学习到的特征分布被归一化了，因此，直接对每一层做归一化显然是不合理的。</strong>但是如果稍作修改，加入可训练的参数做归一化，那就是BatchNorm
实现的了。</p>
<p>​
接下来详细介绍一下这额外的两个参数，之前也说过如果直接做归一化不做其他处理，神经网络是学不到任何东西的，但是加入这两个参数后，事情就不一样了。先考虑特殊情况下，如果γ
和β 分别等于此batch的标准差和均值，那么<span
class="math inline">\(y_i\)</span>就还原到归一化前的x了吗，也即是缩放平移到了归一化前的分布，相当于batch
norm没有起作用，<span class="math inline">\(β\)</span>和γ 分别称之为
平移参数和缩放参数
。这样就<strong>保证了每一次数据经过归一化后还保留的有学习来的特征，同时又能完成归一化这个操作，加速训练</strong>。</p>
<p>引用：https://www.cnblogs.com/hoojjack/p/12350707.html</p>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Basic系列笔记</category>
      </categories>
      <tags>
        <tag>OverFitting</tag>
        <tag>Batch Normalization</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习基础系列笔记11——Training Data、Validation Data、Testing Data含义及作用</title>
    <url>/2022/01/21/ff71970a89e2/</url>
    <content><![CDATA[<p>我们在进行一个机器学习的任务的时候，往往会将所有数据划分成三块——Training
Data、Validation Data、Testing
Data,它们各自在训练的过程中扮演何种角色呢？</p>
<h4
id="一trainvaltest的含义与作用">一、Train、Val、Test的含义与作用：</h4>
<p>顾名思义，三个数据集合它们的简单含义如下：</p>
<ul>
<li>训练集(train)：训练模型，用来拟合模型的数据集；</li>
<li>验证集(val)：评估模型，训练过程中提供相对于train的无偏估计的数据集，同时用来调整超参数和特征选择，实际参与训练</li>
<li>测试集(test)：最终模型训练好之后，用来提供相对于train+valid的无偏估计的数据集。</li>
</ul>
<p>​ 一般我们会将最开始划分的Training Set分割为Training Data和Validation
Data两个集合，一般而言比例为9：1。我们使用划分后的Training
Data进行训练，在每个Epoch结束后使用训练期间机器没有见到过的Validation进行验证，依据验证集得到的Loss值来进行模型好坏的衡量。</p>
<p>​ 话句话说，Validation
Data　其实就是用来避免过拟合的，在训练过程中，我们通常用它来确定一些超参数（比如根据validation
data上的accuracy来确定early stopping的epoch大小、根据validation
data确定learning rate等等）。</p>
<p>​ 那为啥不直接在Testing data上做这些呢？因为如果在Testing
data做这些，那么随着训练的进行，我们的网络实际上就是在一点一点地overfitting我们的Testing
data，导致最后得到的Testing accuracy没有任何参考意义。因此，Training
data的作用是计算梯度更新权重，Validation
data在每个Epoch结束后进行验证，Testing
data则给出一个accuracy以判断网络的好坏。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/20210202115236662.png" /></p>
<p><strong>如上所示的训练划分容易带来一些显而易见的问题：</strong></p>
<ul>
<li>如果样本数量太少，验证集和测试集更少，无法在统计学上代表数据</li>
<li>划分数据前时，进行不同的随机打乱则得到的模型性能差别可能很大，可能训练集中的数据都偏向于某一类，而验证集的数据偏向于另一类</li>
</ul>
<h4 id="二n-fold-cross-validation">二、N-Fold Cross Validation</h4>
<p>此时，就可以使用常见的叫做N-Fold Cross
Validation，（K折交叉验证）：</p>
<p>​ 如下图所示,我们将Training
Set分为N个集合(示例中为3个),其中N-1个集合用于训练,1个集合用于验证,然后每轮Epoch中,都执行N遍,每一遍都拿不同的集合用于训练与验证,然后计算一遍Loss值,最终选取平均Loss最小的那一组参数进行模型的更新.</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114111918585.png" /></p>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Basic系列笔记</category>
      </categories>
      <tags>
        <tag>Training Set</tag>
        <tag>Validation Set</tag>
        <tag>Testing Set</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习基础系列笔记10——L1、L2正则化以及为什么正则化能够防止过拟合</title>
    <url>/2022/01/21/d692eb11c4b5/</url>
    <content><![CDATA[<p>在训练数据不够多时，或者overtraining时，常常会导致overfitting（过拟合）。其直观的表现如下图所示，随着训练过程的进行，模型复杂度增加，在Training
data上的error渐渐减小，但是在验证集上的error却反而渐渐增大——因为训练出来的网络过拟合了训练集，对训练集外的数据却不work。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/OhX9eFQ.jpg" /></p>
<p>​
在ML2021课程系列笔记2中，提及了一些防止过拟合的内容，本篇用于详细解释其中正则化的部分：</p>
<h3 id="一什么是l1l2正则化">一、什么是L1、L2正则化？</h3>
<h4 id="l1-正则化">L1 正则化：</h4>
<p>​
简单而言，L1正则化就是在Loss函数后面增加一个正则化项，L1正则化的公式如下,</p>
<p>​ <span
class="math inline">\(C_0\)</span>为原来的损失函数，即所有权重w的绝对值的和.
n是训练集的样本大小，λ 是正则项系数，C为加了正则化后的损失函数</p>
<p>​ <span class="math inline">\(C = C_0 + \frac{\lambda}{n}
\sum_{w}|w|\)</span></p>
<h4 id="l2-正则化">L2 正则化：</h4>
<p>​
简单而言，L2正则化也是在Loss函数后面增加一个正则化项，L2正则化的公式如下,与上含义类似。</p>
<p>​ <span class="math inline">\(C = C_0 + \frac{\lambda}{2n} \sum_w
w^2\)</span></p>
<h3
id="二l1l2正则化如何避免overfitting">二、L1、L2正则化如何避免OverFitting？</h3>
<h4 id="l1l2正则化能降低权重值w">1、L1、L2正则化能降低权重值w</h4>
<p>​
我们以L2正则化项为例，进行解释，首先我们让C对偏置项b和对权重系数w进行求导，得到如下：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/mebEC90.jpg" /></p>
<p>​
我们发现，C对b求导与正则化项无关，C对w求导得到得结果与正则化项有关。</p>
<p>​ 最终所反映到梯度下降优化参数上，就是如下图所示得情况：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/qM83geg.jpg" /></p>
<p>​
<strong>如果没有正则化项，那么更新得w前得系数应当为1，而现在由于因为η、λ、n都是正的，所以
1−ηλ/n小于1，它的效果是减小w，这也就是权重衰减（weight
decay）的由来</strong>。</p>
<p>​
<strong>到此为止，我们发现L2正则化项，其能够使得减小w。（其实这一点比较直观的也能看出来，因为Loss函数中加入了一项<span
class="math inline">\(w^2\)</span>的求和，也就是说如果权重值w过大，Loss函数值会上升，这就意味着这一个正则化项惩罚了权值矩阵使其不能取太大值。）</strong></p>
<p>​
那么，关键问题是，<strong>为什么权重矩阵w小，能够防止过拟合呢？</strong></p>
<h4
id="较高的权重w往往意味着过拟合的函数">2、较高的权重w往往意味着过拟合的函数：</h4>
<p>​
我们会发现：<strong>过拟合的时候，拟合函数的系数往往非常大，为什么？如下图所示，过拟合，就是拟合函数需要顾忌每一个点，最终形成的拟合函数波动很大。在某些很小的区间里，函数值的变化很剧烈。这就意味着函数在某些小区间里的导数值（绝对值）非常大，由于自变量值可大可小，所以只有系数足够大，才能保证导数值很大。</strong></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/RsR5cOK.png" /></p>
<p>​</p>
<p>​
更进一步的解释：当权重系数很小的时候，容易出现像左图一样，高偏差拟合能力很差的情况，随着权重系数逐渐增大，就会像右侧的图进行发展。如果权重系数很大，往往意味着在某些很小的区间中，函数值的变化会非常的剧烈，导致一些高方差的结果，也就是函数对于训练数据过度拟合了。</p>
<p>​ <img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220121122935964.png" /></p>
<p>​</p>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Basic系列笔记</category>
      </categories>
      <tags>
        <tag>OverFitting</tag>
        <tag>Regularization</tag>
      </tags>
  </entry>
  <entry>
    <title>《DG-Font Deformable Generative Networks for Unsupervised Font Generation》</title>
    <url>/2022/01/20/4c71dd4cca5d/</url>
    <content><![CDATA[<h4
id="论文名称dg-font-deformable-generative-networks-for-unsupervised-font-generationcvpr2021">论文名称：《DG-Font:
Deformable Generative Networks for Unsupervised Font
Generation》CVPR2021</h4>
<h4
id="论文地址-httpsopenaccess.thecvf.comcontentcvpr2021htmlxie_dg-font_deformable_generative_networks_for_unsupervised_font_generation_cvpr_2021_paper.html">论文地址：
https://openaccess.thecvf.com/content/CVPR2021/html/Xie_DG-Font_Deformable_Generative_Networks_for_Unsupervised_Font_Generation_CVPR_2021_paper.html</h4>
<h2 id="关键词">1、关键词：</h2>
<p>​ Font-Generation、Deformable Convolution Skip
Connection、Unsupervised Learning</p>
<h2 id="领域背景">2、领域背景：</h2>
<p>​
字体生成是一个具有挑战的任务，现存的大部分方法都是通过<strong>有监督学习</strong>的方法进行字体的生成，他们需要大量的<strong>paired
data</strong>（例如对应风格的字符图像），然而大量的这些数据需要花费非常昂贵的代价去进行收集。</p>
<p>​
字体生成目标是自动的能够生成某种特定字体的字符，并且创造一个字体字符集。</p>
<p>​
在传统的字符集的创造方式中，严重依赖于专家设计者，独立的去绘制每一个字体的图像，这对于一些基于语标的语言（比如中文、日文、韩文）很不友好。专家们需要有大量的工作量去进行设计，字体生成领域就是为了解决这样一个问题，使用神经网络去学习从一种风格到另一种风格的映射关系，从而生成特定语言的某种风格的一个字符集。</p>
<p>​ 与字体生成最相关的<strong>图像生成领域 （Image-To-Image
Translation）</strong>，在通常的image-to-image的转换模型中通常将<strong>style</strong>定义为<strong>纹理和颜色</strong>，而字体的<strong>style</strong>往往是指<strong>字体的格式几何形状、笔画粗细、笔尖和连笔书写的模式等内容。（geometric
transformation, stroke thickness, tips, and joined-up writing
pattern）</strong>，故而没法直接应用到字体的生成上。同时在图像中往往采用的<strong>AdaIN-based</strong>方法（这种方法是在统计学上对齐特征来迁移图像的纹理和颜色特征）对于字体这种变换局部的特征模式的任务是不合适的。</p>
<p>​
同时，对于image-to-image的生成任务而言，一系列的<strong>无监督</strong>的方法，都是使用对抗<strong>训练结合Consistent
Contrains</strong>来进行的。如果使用image-to-image的方法直接应用到字体生成任务中的话，即使Consistent
Constraints会帮助我们<strong>保留一个字符图片内容的结构</strong>，但是他们仍然会导致<strong>诸如模糊、丢失笔画</strong>等问题。</p>
<h2 id="先前工作描述与比较">3、先前工作描述与比较：</h2>
<h4 id="image-to-image-translation">1) Image-To-Image Translation</h4>
<p>​ <strong>image-to-image迁移的任务，就是学习一个从source
domain到target
domain的映射关系。其可以用于艺术风格迁移、语义分割、图像动画等等。</strong></p>
<ul>
<li>Pix2Pix是基于Conditional
GAN的第一个做Image-to-Image的迁移任务。</li>
<li>Cycle-GAN通过Cycle Consistency 做到了无监督学习。</li>
</ul>
<p>​
<strong>这类工作无法直接应用至Font-Generation中，原因在Part2的领域背景最后已经做了简略的描述</strong></p>
<h4 id="font-generation">2) Font-Generation</h4>
<p>​
<strong>字体生成目标是自动的能够生成某种特定字体的字符，并且创造一个字体字符集。</strong></p>
<p>​ <strong>一般而言，从前的方法有两大条路径：</strong></p>
<ul>
<li><strong>基于paired data进行训练</strong>
<ul>
<li>EMD和SAVAE设计的神经网络，分割开了字体的内容和风格（content &amp;
style）的表示，可以生成新的风格的字符内容。</li>
<li>zi2zi和rewrite这两篇论文，通过上千对匹配的字符，基于GAN进行了有监督学习。其之后，很多文章基于zi2zi进行了生成质量的改进。</li>
</ul></li>
<li><strong>基于辅助标识（例如笔画、部首等内容）</strong>
<ul>
<li><strong>这类方法往往都依赖于先验知识，并且只能应用到特定的书写系统中去。
并且这些方法仍旧需要数千匹配的数据以及辅助注释</strong></li>
<li>《Scfont: Structure-guided chinese font generation via deep stacked
networks.》给每个笔画打上标签，来通过书写轨迹的合成，生成字的图像</li>
<li>DM-FONT
提出解纠缠策略来解纠缠复杂的字形结构，这有助于在富文本设计中捕获局部细节</li>
<li>CalliGAN
进一步将字符分解为组件，并提供包括笔画顺序在内的低级结构信息来指导生成过程。</li>
<li>《RD-GAN: few/zero-shot chinese character styletransfer via radical
decomposition and rendering》
使用对字符偏旁部首的分解，来达到字体的生成</li>
<li>其他一些的方法也通过提取字符的骨架和笔画的算法来进行生成</li>
</ul></li>
</ul>
<p>​
<strong>相比之下，该篇论文提出的DG-FONT不需要其他的辅助标识，并且是无监督的形式进行的</strong></p>
<h4 id="deformable-convolution">3) Deformable Convolution</h4>
<p>​
<strong>介绍链接：https://blog.fantast.top/2022/01/07/basic5/</strong></p>
<p>​ <strong>可变形卷积Deformable
Convolution</strong>，<strong>其加强了CNN的变换建模能力</strong>，它通过额外的偏移量增加了模块中的空间采样位置。
可变形卷积已被应用于解决几个高级视觉任务，例如对象检测、视频对象检测采样、语义分割和人体姿态估计。</p>
<p>​ 最近，一些方法尝试在图像生成任务中应用可变形卷积。 TDAN[48]
通过使用可变形卷积对齐两个连续帧并输出高分辨率帧来解决视频超分辨率任务。</p>
<p>​ <strong>在我们提出的 DG-Font 中，可变形卷积的偏移量是通过 learned
latent style code来进行估计的。</strong>（具体内容见后细节）</p>
<h2 id="主要设计思想">4、主要设计思想：</h2>
<p>​ 作者提出了可变形生成网络（Deformable Generative
Networks）来做<strong>非监督的字体生成</strong>。其利用提供的目标字体图像（<strong>style
image input</strong>）来将一种字体的字符变形和转换为另一种字体。</p>
<p>​ DG-FONT
分离了字体的style和content，然后再将两个domain的表示进行融合，生成新的字体的字符。</p>
<p>​ 其核心模块为一个叫做<strong>FDSC（feature deformation skip
connection）的东西</strong>，可以用来预测一个位移映射map然后使用位移映射map去对low-level的特征图做变形卷积。然后FDSC的输出被送入一个混合器，然后生成最终的结果。</p>
<p>​
FDSC模块将会<strong>对内容图像的低层级特征进行变换，其能够保留文字本身的模式</strong>，比如笔画和偏旁部首信息。因为对于内容相同的两种不同风格的字体，<strong>它们的每一笔画通常都是对应的</strong>（如下图所示）。利用字体的空间关系，利用FDSC进行空间变形，<strong>有效地保证了生成的字符具有完整的结构</strong>。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220116172624229.png" /></p>
<p>​</p>
<p>​
同时，为了区分不同的风格，模型还使用了一个多任务标识符判别器Multi-Task
Discriminator，以保证每个风格都可以被独立判定。</p>
<h2 id="具体方法与网络架构">5、具体方法与网络架构：</h2>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220116160758876.png" /></p>
<h3 id="整体架构overall-pipeline">1) 整体架构（Overall Pipeline）</h3>
<ul>
<li><p><strong>概述</strong>：如上图所示，整个网络包含一个 Style
Encoder、一个Content Encoder、一个Mixer、和两个FDSC模块。</p>
<ul>
<li><p><strong>Style Encoder</strong> 从输入图像中学习Style
Representation。具体而言，其将一个Style
Image作为输入，将其映射至一个Style Latent Vector <span
class="math inline">\(Z_S\)</span>。</p></li>
<li><p><strong>Content Encoder</strong> 提取Content
Images的结构特征，将其 映射到一个空间特征图 <span
class="math inline">\(Z_C\)</span></p></li>
<li><p><strong>Deformable Convolution</strong>能够使得<em>Content
Encoder</em>去识别到相同内容的字中Style-Invariant的特征</p></li>
<li><p><strong>Mixer</strong> 通过混合<span
class="math inline">\(Z_C\)</span>和<span
class="math inline">\(Z_S\)</span>来生成输出字符。其使用<strong>AdaIN</strong>方法将style特征注入Mixer中。</p></li>
<li><p><strong>FDSC</strong>
模块能够将变形的<em>Low-Level</em>特征从<em>Content
Encoder</em>中传输到Mixer中</p></li>
<li><p><strong>Multi-Task Discriminator</strong>
：当字符图像从生成网络生成后，该判别器用来对每个单独的 Style
同时执行判断任务。对于每一个style来说，
Discriminator的输出是一个二元分类器，
判断其是真实图片还是生成图片。同时，因为在训练集中，有多种不同的字体风格，所以判别器的输出是一个数组，它的长度是所有风格的数量，数组里的每个元素是一个二元向量【例如，假设总共有5个风格，最终判别器输出的应当是如下的一个向量：</p>
<p>​ [ [ 1 0 ] , [ 0 0 ] , [ 0 0 ] , [ 0 0 ] , [ 0 0 ] ]</p>
<p>】</p></li>
</ul></li>
<li><p><strong>输入</strong>：<strong>Style
Image</strong>【风格A，汉字1】、<strong>Content
Image</strong>【风格B，汉字2】</p></li>
<li><p><strong>输出</strong>：<strong>Output
Image</strong>【风格A，汉字2】</p></li>
</ul>
<h3 id="style-encoder">2) Style Encoder</h3>
<ul>
<li><strong>概述</strong>：从输入图像中学习 Style
Representation。具体而言，其将一个Style
Image作为输入，将其映射至一个Style Latent Vector <span
class="math inline">\(Z_S\)</span>。</li>
<li><strong>输入</strong>：Style Image <span class="math inline">\(I_s
\in R^{H*W}\)</span></li>
<li><strong>输出</strong>：Style Latent Vector <span
class="math inline">\(Z_s \in R\)</span></li>
<li><strong>网络结构</strong>：如下所示
<ul>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220119151744473.png" /></li>
</ul></li>
<li><strong>公式表达</strong>：</li>
<li><strong>实现细节（官方代码）</strong>
<ul>
<li>其在源代码中，其为GuidingNet文件部分，可供选择的项有Vgg11，Vgg13，Vgg16，Vgg19等。这个StyleEncoder网络将输入的StyleImage进行特征的提取以后，得到特征向量，在Decoder中使用AdaIn融合之前，源代码中还经过了一个MLP模块。然后，利用MLP模块输出的内容，对AdaIN2d里面的weight和bias进行初始化，最终达到</li>
</ul></li>
</ul>
<h3 id="content-encoder">3) Content Encoder</h3>
<ul>
<li><p><strong>概述</strong>：提取Content Images的结构特征，将其
映射到一个空间特征图 <span class="math inline">\(Z_C\)</span></p></li>
<li><p><strong>输入</strong>：Content Image <span
class="math inline">\(I_c \in R^{H*W}\)</span></p></li>
<li><p><strong>输出</strong>：Content Latent Vector <span
class="math inline">\(Z_c \in R\)</span></p></li>
<li><p><strong>网络结构细节</strong>：</p>
<ul>
<li><p>in_channel = 3,out_channel=64,kernel_size=7 x 7,stride =
1,padding = 3 的变形卷积层 + IN(64) 归一化 + Activation(ReLu)</p></li>
<li><p>得到FDSC-1模块的输入 skip1 [32, 64, 80, 80]</p></li>
<li><p>in_channel = 64,out_channel=128,kernel_size =4 x
4,stride=2,padding=1 的变形卷积层 + IN(128) 归一化 +
Activation(ReLu)</p></li>
<li><p>得到FDSC-2模块的输入 skip2 [30,128,40,40]</p></li>
<li><p>in_channel =128,out_channel=256,kernel_size =4 x
4,stride=2,padding=1 的变形卷积层 + IN(256) 归一化 +
Activation(ReLu)</p></li>
<li><p>N个ResBlock</p>
<ul>
<li><p>每个ResBlock如下：</p></li>
<li><p>Input---&gt;Conv2D---&gt;Conv2D---&gt; + ---&gt; output</p>
<p><span
class="math inline">\(\downarrow\)</span>-------------------------------------------<span
class="math inline">\(\uparrow\)</span></p></li>
<li><p>Conv2D,in_dim=256,out_dim=256,kernel_size=3x3,stride=1,padding=1
普通卷积层</p></li>
</ul></li>
</ul></li>
<li><p><strong>举例</strong>：</p>
<ul>
<li>假设输入图像为 80 * 80 ，Batch_Size = 32 ,
那么：skip1,skip2和最终的output <span
class="math inline">\(Z_c\)</span>的大小分别如下：</li>
<li>skip1.shape: torch.Size([32, 64, 80, 80])</li>
<li>skip2.shape: torch.Size([32, 128, 40, 40])</li>
<li>ouput.shape: torch.Size([32, 256, 20, 20])</li>
</ul></li>
<li><p><strong>意义</strong>：提取Content
Images的结构特征，应用变形卷积层能够保持字体笔画结构</p></li>
</ul>
<h3 id="feature-deformation-skip-connection-fdsc-module">4) Feature
Deformation Skip Connection ( FDSC Module)</h3>
<ul>
<li><p><strong>概述</strong>：其由一个变形卷积层组成，具体的作用作者在书写时写在了Mixer的卷积层后的内容里</p></li>
<li><p><strong>实现细节</strong></p>
<ul>
<li><p>首先，其输入来自于Content
Encoder，也就是文中提及的skip1和skip2，我们以skip1为例继续讲解：</p></li>
<li><p>其次，它会将Skip1和Mixer中经过了Conv以后的内容A，Concat一起，然后将这个Concat完的东西放入变形卷积模块中，得到一个新计算的Concat_Pre,最后将这个Concat_Pre和A再Concat到一起，得到最终的输出。</p></li>
<li><p>这就是为什么在论文的示意图中：这个FDSC模块有来回的箭头表示：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_01_19_15_31_59_728.png" /></p></li>
</ul></li>
</ul>
<h3 id="mixer">5) Mixer</h3>
<ul>
<li><p><strong>概述</strong>：通过混合<span
class="math inline">\(Z_C\)</span>和<span
class="math inline">\(Z_S\)</span>来生成输出字符。其使用<strong>AdaIN</strong>方法将style特征注入Mixer中。</p></li>
<li><p><strong>输入</strong>： <span class="math inline">\(Z_c \in
R\)</span>即ContentEncoder的输出，256通道的特征图
[32,256,20,20]</p></li>
<li><p><strong>输出</strong>：</p></li>
<li><p><strong>网络结构及细节</strong>：</p>
<ul>
<li>2个ResBlock，输出仍然为256通道的特征图 [32,256,20,20]</li>
<li>Upsample上采样 ，特征图大小变为 40 x 40</li>
<li>Conv2dBlock，in_channel = 256,out_channel=128,kernel_size =5 x
5,stride=1,padding=2 的卷积层 + AdIN(128) 归一化 + Activation(ReLu),
经过该层后，计算得到的大小应当为 [32,128,40,40]
<ul>
<li>然后，需要将此层输出的output和skip2在Channel通道Concat起来，得到deformable_concat
[32,256,40,40]</li>
<li>然后将deformable_concat与skip2 输入 FDSC的变形卷积模块中，得到
concat_pre [32,128,40,40] 和 offset2 [32,18,40,40]</li>
<li>最后将cancat_pre和最开始的output
Concat起来，得到该步的最终输出，大小为 [32，256，40，40]</li>
</ul></li>
<li>Upsample上采样，特征图大小变为80 x 80</li>
<li>Conv2dBlock，in_channel = 256,out_channel=64,kernel_size =5 x
5,stride=1,padding=2 的卷积层 + AdIN(64) 归一化 + Activation(ReLu),
经过该层后，计算得到的大小应当为 [32,64,80,80]
<ul>
<li>然后，需要将此层输出的output和skip1在Channel通道Concat起来，得到deformable_concat
[32,128,80,80]</li>
<li>然后将deformable_concat与skip1 输入 变形卷积模块中，得到 Concat_pre
[32,128,40,40] 和 offset2 [32,18,40,40]</li>
<li>最后将cancat_pre和最开始的outputConcat起来，得到该步的最终输出，大小为
[32，256，40，40]</li>
</ul></li>
<li>Conv2dBlock，in_channel = 128,out_channel=3,kernel_size =7 x
7,stride=1,padding=3 的卷积层 + Activation(Tanh),
经过该层后，计算得到的大小应当为 [32,3,80,80]</li>
</ul></li>
</ul>
<h3 id="multi-task-discriminator">6) Multi-Task Discriminator</h3>
<ul>
<li><p><strong>概述</strong>：当字符图像从生成网络生成后，该判别器用来对每个单独的
Style 同时执行判断任务。对于每一个style来说，
Discriminator的输出是一个二元分类器，
判断其是真实图片还是生成图片。</p></li>
<li><p><strong>输入</strong>：</p>
<ul>
<li>- x: images of shape (batch, 3, image_size, image_size).，例如为 4个
3 * 64 * 64的图像</li>
<li>- y: domain indices of shape (batch). 例如 y_in 为 4个需要其判断的
domain的标号</li>
</ul></li>
<li><p><strong>输出</strong>：各个需要判断的得分情况</p></li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D = Discriminator(<span class="number">64</span>, <span class="number">4</span>)  <span class="comment"># 初始化判别器参数 64 为图像大小，4为该判别器需要判别区分的domain的数量</span></span><br><span class="line">x_in = torch.randn(<span class="number">2</span>, <span class="number">3</span>, <span class="number">64</span>, <span class="number">64</span>)  <span class="comment"># x_in 为 2个 3*64*64的图像  y_in 为 2个需要其判断的 domain的标号</span></span><br><span class="line">y_in = torch.randint(<span class="number">0</span>, <span class="number">10</span>, size=(<span class="number">2</span>, )) <span class="comment"># 假设为[1,3] 就是要让D去判断，第一个图是否属于domain1，第二个图是否属于domain3……</span></span><br><span class="line">out, feat = D(x_in, y_in)</span><br><span class="line"><span class="built_in">print</span>(out, feat)    </span><br><span class="line"><span class="built_in">print</span>(out.shape, feat.shape)  <span class="comment"># out为Discriminator打的分数（内部简化过）,feat为没处理过的原始输出，差别见下示例</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">out。shape = 1 * 2 ,out的第一个值相当于取了feat中[1,1,1,1]因为是第一个图片，并且是判断是否属于domain1的值，即为1.7796</span></span><br><span class="line"><span class="string">out的第二个值相当于取了feat中[2,3,1,1]因为是第二个图片，并且是判断是否属于domain3的值，即为0.9986</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">out: [1.7796, 0.9986]    </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">feat。shape = 2 * 4 * 1 * 1 ，其有2张需要判断的图像，第一张图像有4个值，分别是根据domain0-domain3打的分数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">feat:tensor([[[[-0.8181]],  </span></span><br><span class="line"><span class="string">         [[ 1.7796]],</span></span><br><span class="line"><span class="string">         [[ 3.0122]],</span></span><br><span class="line"><span class="string">         [[ 0.9614]]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        [[[-0.5011]],</span></span><br><span class="line"><span class="string">         [[ 0.5076]],</span></span><br><span class="line"><span class="string">         [[ 3.4774]],</span></span><br><span class="line"><span class="string">         [[ 0.9986]]]]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>网络细节（官方代码）</strong></p>
<ul>
<li>与论文附录一致：</li>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220119155654674.png" /></li>
</ul></li>
</ul>
<h2 id="损失函数">6、损失函数</h2>
<p>​
该论文的模型旨在通过无监督方法实现字体的自动生成。为此，其采用四种损失。</p>
<ul>
<li>使用 Adversarial loss 来产生逼真的图像。</li>
<li>引入Content
Consistency损失，鼓励生成的图像内容与参考的内容图像一致;</li>
<li>利用图像重建损失来保持图像的域不变特征</li>
<li>Deformation offset 归一化，防止FDSC模块偏移量过大。</li>
</ul>
<h4 id="adversarial-loss">1） Adversarial loss</h4>
<p>​
该网络旨在通过求解一个极小极大优化问题来生成可信的图像。就是GAN常用的损失函数。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220322105213541.png" style="zoom: 80%;" /></p>
<p>​ 其中<span
class="math inline">\(D_s\)</span>表示对应类型<strong>判别器</strong>输出的<span
class="math inline">\(logit\)</span>分数。</p>
<h4 id="content-consistency">2）Content Consistency</h4>
<p>​
在忽略内容正确性的情况下，采用对抗性损失来帮助模型生成逼真的风格。为了防止模式崩溃，并确保从相同内容中提取的特征在经过内容编码器后得到的特征序列一致，论文设置了内容一致损失</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220322105408955.png" style="zoom:80%;" /></p>
<p>​ 确保给定的内容图像<span
class="math inline">\(I_c\)</span>和生成器生成的图像，经过内容编码器<span
class="math inline">\(f_c\)</span>后是一致的。</p>
<h4 id="reconstruction-loss">3）Reconstruction Loss</h4>
<p>​ 为了确保在给定参考内容图像<span
class="math inline">\(I_c\)</span>和参考风格图像也是<span
class="math inline">\(I_c\)</span>时，生成器能够重构出源图像<span
class="math inline">\(I_c\)</span>，我们施加了一个重构损失:</p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220322105551098.png"
alt="image-20220322105551098" />
<figcaption aria-hidden="true">image-20220322105551098</figcaption>
</figure>
<p>​ 该损失有助于保持其输入图像<span
class="math inline">\(I_c\)</span>的域不变特征(例如，内容)。</p>
<h4 id="deformation-offset-normalization">4）Deformation offset
normalization</h4>
<p>​
可变形的偏移使得卷积时候的采样网格可以自由变形。由于输入图像和生成图像之间存在大量相同颜色的区域(如背景色和字符色)，这使得问题难以优化，且偏移方案不唯一。
​
同时，字体生成主要关注内容字符图像与目标字符图像之间的笔画关系，如笔画的粗细、笔尖等。但是，对于内容相同但风格不同的图像，同一笔画在这两幅图像中的位置是相近的。为了有效地使用这个可变形的卷积网络，我们对偏移量施加了一个约束<span
class="math inline">\(\delta_p\)</span>:</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220322105756227.png" /></p>
<p>其中<span
class="math inline">\(\delta_p\)</span>为可变形卷积核的偏移量，<span
class="math inline">\(R\)</span>为卷积核的个数。</p>
<h4 id="最终loss加权相加">5）最终Loss：加权相加</h4>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220322105847411.png" /></p>
]]></content>
      <categories>
        <category>③  论文阅读笔记</category>
        <category>CV相关论文</category>
      </categories>
      <tags>
        <tag>Font Generation</tag>
        <tag>Deformable Convolution Skip Connection</tag>
        <tag>Unsupervised Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch学习笔记10——PyTorch 中，nn与nn.functional有什么区别？（搬运）</title>
    <url>/2022/01/18/acaa679c551a/</url>
    <content><![CDATA[<h1 id="pytorch-中nn-与-nn.functional-有什么区别">PyTorch 中，nn 与
nn.functional 有什么区别？</h1>
<p>​
注：在阅读代码以及Pytorch文档的时候发现，nn和nn.functional有很多相同的函数，文档中也有许多引用，故而搜索了一下有何区别，该文为搬运文，以下为引用说明，避免产生误会。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作者：肥波喇齐</span><br><span class="line">链接：https://www.zhihu.com/question/66782101/answer/579393790</span><br><span class="line">来源：知乎</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<h4 id="两者的相同之处">1、两者的相同之处：</h4>
<ul>
<li><code>nn.Xxx</code>和<code>nn.functional.xxx</code>的实际功能是相同的，即<code>nn.Conv2d</code>和<code>nn.functional.conv2d</code>
都是进行卷积，<code>nn.Dropout</code>
和<code>nn.functional.dropout</code>都是进行dropout,………………；</li>
<li>运行效率也是近乎相同。</li>
</ul>
<p>​
<code>nn.functional.xxx</code>是函数接口，而<code>nn.Xxx</code>是<code>nn.functional.xxx</code>的类封装，并且<strong><code>nn.Xxx</code>都继承于一个共同祖先<code>nn.Module</code>。</strong>这一点导致<code>nn.Xxx</code>除了具有<code>nn.functional.xxx</code>功能之外，内部附带了<code>nn.Module</code>相关的属性和方法，例如<code>train(), eval(),load_state_dict, state_dict</code>等。</p>
<h4 id="两者的差别之处">2、两者的差别之处：</h4>
<ul>
<li><strong>两者的调用方式不同。</strong></li>
</ul>
<p><code>nn.Xxx</code>
需要先实例化并传入参数，然后以函数调用的方式调用实例化的对象并传入输入数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inputs = torch.rand(<span class="number">64</span>, <span class="number">3</span>, <span class="number">244</span>, <span class="number">244</span>)</span><br><span class="line">conv = nn.Conv2d(in_channels=<span class="number">3</span>, out_channels=<span class="number">64</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">out = conv(inputs)</span><br></pre></td></tr></table></figure>
<p><code>nn.functional.xxx</code>同时传入输入数据和weight,
bias等其他参数 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">weight = torch.rand(<span class="number">64</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">bias = torch.rand(<span class="number">64</span>) </span><br><span class="line">out = nn.functional.conv2d(inputs, weight, bias, padding=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong><code>nn.Xxx</code>继承于<code>nn.Module</code>，
能够很好的与<code>nn.Sequential</code>结合使用，
而<code>nn.functional.xxx</code>无法与<code>nn.Sequential</code>结合使用。</strong></p></li>
<li><p><strong><code>nn.Xxx</code>不需要你自己定义和管理weight；而<code>nn.functional.xxx</code>需要你自己定义weight，每次调用的时候都需要手动传入weight,
不利于代码复用。</strong></p>
<p>例如：使用<code>nn.Xxx</code>定义一个CNN</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CNN</span>(nn.Module):</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(CNN, self).__init__()</span><br><span class="line">        </span><br><span class="line">        self.cnn1 = nn.Conv2d(in_channels=<span class="number">1</span>,  out_channels=<span class="number">16</span>, kernel_size=<span class="number">5</span>,padding=<span class="number">0</span>)</span><br><span class="line">        self.relu1 = nn.ReLU()</span><br><span class="line">        self.maxpool1 = nn.MaxPool2d(kernel_size=<span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        self.cnn2 = nn.Conv2d(in_channels=<span class="number">16</span>, out_channels=<span class="number">32</span>, kernel_size=<span class="number">5</span>,  padding=<span class="number">0</span>)</span><br><span class="line">        self.relu2 = nn.ReLU()</span><br><span class="line">        self.maxpool2 = nn.MaxPool2d(kernel_size=<span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        self.linear1 = nn.Linear(<span class="number">4</span> * <span class="number">4</span> * <span class="number">32</span>, <span class="number">10</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>), -<span class="number">1</span>)</span><br><span class="line">        out = self.maxpool1(self.relu1(self.cnn1(x)))</span><br><span class="line">        out = self.maxpool2(self.relu2(self.cnn2(out)))</span><br><span class="line">        out = self.linear1(out.view(x.size(<span class="number">0</span>), -<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure>
<p>使用<code>nn.function.xxx</code>定义一个与上面相同的CNN。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CNN</span>(nn.Module):</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(CNN, self).__init__()</span><br><span class="line">        </span><br><span class="line">        self.cnn1_weight = nn.Parameter(torch.rand(<span class="number">16</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">        self.bias1_weight = nn.Parameter(torch.rand(<span class="number">16</span>))</span><br><span class="line">        </span><br><span class="line">        self.cnn2_weight = nn.Parameter(torch.rand(<span class="number">32</span>, <span class="number">16</span>, <span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">        self.bias2_weight = nn.Parameter(torch.rand(<span class="number">32</span>))</span><br><span class="line">        </span><br><span class="line">        self.linear1_weight = nn.Parameter(torch.rand(<span class="number">4</span> * <span class="number">4</span> * <span class="number">32</span>, <span class="number">10</span>))</span><br><span class="line">        self.bias3_weight = nn.Parameter(torch.rand(<span class="number">10</span>))</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>), -<span class="number">1</span>)</span><br><span class="line">        out = F.conv2d(x, self.cnn1_weight, self.bias1_weight)</span><br><span class="line">        out = F.relu(out)</span><br><span class="line">        out = F.max_pool2d(out)</span><br><span class="line">        </span><br><span class="line">        out = F.conv2d(x, self.cnn2_weight, self.bias2_weight)</span><br><span class="line">        out = F.relu(out)</span><br><span class="line">        out = F.max_pool2d(out)</span><br><span class="line">        </span><br><span class="line">        out = F.linear(x, self.linear1_weight, self.bias3_weight)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​
上面两种定义方式得到CNN功能都是相同的，但PyTorch官方推荐：具有学习参数的（例如，conv2d,
linear,
batch_norm)采用<code>nn.Xxx</code>方式，没有学习参数的（例如，maxpool,
loss func, activation
func）等根据个人选择使用<code>nn.functional.xxx</code>或者<code>nn.Xxx</code>方式。</p>
<p>​
但关于<strong>dropout</strong>，个人强烈推荐使用<code>nn.Xxx</code>方式，因为一般情况下只有训练阶段才进行dropout，在eval阶段都不会进行dropout。使用<code>nn.Xxx</code>方式定义dropout，在调用<code>model.eval()</code>之后，model中所有的dropout
layer都关闭，但以<code>nn.function.dropout</code>方式定义dropout，在调用<code>model.eval</code>之后并不能关闭dropout。</p>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Pytorch系列笔记</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习基础系列笔记9——归一化方法FRN(Filter Response Normalization)</title>
    <url>/2022/01/18/920f212c6758/</url>
    <content><![CDATA[<h4 id="一简介">一、简介</h4>
<p>​
<strong>在先前的文章中，链接：https://blog.fantast.top/2022/01/16/basic7/，讲解了BN、LN、IN、CIN、GN等多种不同的Normalization，由于在DG-Font的阅读过程中，又发现了一个新的归一化方法叫做FRN，故而在此篇略做记录。</strong></p>
<p>​
<strong>FRN</strong>是谷歌提出的一种新的归一化方法，和GN一样不依赖batch，故而FRN层不仅消除了模型训练过程中对batch的依赖，而且当batch
size较大时性能优于BN。</p>
<p>​ <strong>原论文名称：</strong>《Filter Response Normalization Layer:
Eliminating Batch Dependence in the Training of Deep Neural
Networks》</p>
<p>​ <strong>原论文地址：</strong>https://arxiv.org/abs/1911.09737</p>
<h4 id="二结构">二、结构：</h4>
<p>​ 如下所示，FRN层整体结构包括归一化层FRN（Filter Response
Normalization）和激活层TLU（Thresholded Linear Unit）。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220118102128474.png" /></p>
<p>​ 整个结构并不复杂，就是通过一个公式计算，最后经过一个阈值限制输出</p>
<p>​ 其中FRN的操作是对每个样例的每个channel单独进行归一化的，这里<span
class="math inline">\(x\)</span>就是一个N（=HxW）维度的向量，所以FRN没有BN层对batch依赖的问题。BN层采用归一化方法是减去均值然后除以标准差，而FRN却不同，这里没有减去均值操作，公式中的<span
class="math inline">\(v^2\)</span>是<span
class="math inline">\({x}\)</span>的二次范数的平均值。这种归一化方式类似BN可以用来消除中间操作（卷积和非线性激活）带来的尺度问题，有助于模型训练。
公式里的<span
class="math inline">\({\epsilon}\)</span>是一个很小的正常量，一般为<span
class="math inline">\(1^{-6}\)</span>以防止除0。</p>
<p>​
一般情况下网络的特征图大小N(=HxW)较大，但是有时候可能会出现1x1的特征图的情况，比如InceptionV3和VGG网络，此时就<span
class="math inline">\({\epsilon}\)</span>比较关键，</p>
<p>​ 归一化之后同样需要进行缩放和平移变换，这里的<span
class="math inline">\(\gamma\)</span>和<span
class="math inline">\(\beta\)</span>也是可学习的参数（参数为长度是C的向量,
即为特征数目，也就是通道数):</p>
<p>​ <span class="math display">\[{y = \gamma \hat{x} +
\beta}\]</span></p>
<p>​
FRN缺少去均值的操作，这可能使得归一化的结果任意地偏移0，如果FRN之后是ReLU激活层，可能产生很多0值，这对于模型训练和性能是不利的。为了解决这个问题，FRN之后采用的阈值化的ReLU，即TLU：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_01_18_10_32_35_986.png" /></p>
<p>​ 这里的<span
class="math inline">\(\tau\)</span>是一个可学习的参数。原论文中发现FRN之后采用TLU对于提升性能是至关重要的。</p>
<h4 id="三代码实现coding">三、代码实现Coding</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FRN</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_features, eps=<span class="number">1e-6</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(FRN, self).__init__()</span><br><span class="line">        self.tau = nn.Parameter(torch.zeros(<span class="number">1</span>, num_features, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">        self.gamma = nn.Parameter(torch.ones(<span class="number">1</span>, num_features, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">        self.beta = nn.Parameter(torch.zeros(<span class="number">1</span>, num_features, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">        self.eps = eps</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment">## input x  shape [B,C,H,W] (batch_size , channel , height , width)</span></span><br><span class="line">        x1 = torch.mean(x**<span class="number">2</span>, dim=[<span class="number">2</span>, <span class="number">3</span>], keepdim=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment">## x1       shape [B,C,1,1] (batch_size , channel , 1 , 1)</span></span><br><span class="line">        x2 = x1 + self.eps</span><br><span class="line">        <span class="comment">## x2 	    shape [B,C,1,1] (batch_size , channel , 1 , 1),  【+ 为逐元素相加，不改变维度】</span></span><br><span class="line">        x3 = torch.rsqrt(x2)</span><br><span class="line">        <span class="comment">## x3       shape [B,C,1,1] (batch_size , channel , 1 , 1),  【sqrt 为逐元素操作，不改变为维度】</span></span><br><span class="line">        x4 = x * x3</span><br><span class="line">        <span class="comment">## x4       shape [B,C,H,W] (batch_size , channel , height , width)  </span></span><br><span class="line">        <span class="comment">##          广播机制,逐元素相乘  [B,C,H,W] * [B,C,1,1] = [B,C,H,W]</span></span><br><span class="line">        output = torch.<span class="built_in">max</span>(self.gamma * x4 + self.beta, self.tau)</span><br><span class="line">        <span class="comment">## output   shape [B,C,H,W] (batch_size , channel , height , width)  torch.max 逐元素操作</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="comment">## 相关注解：</span></span><br><span class="line"><span class="comment">## 输入的 x.shape = [B,C,H,W] ( Batch_Size \ Channel \ Height \ Width )</span></span><br><span class="line"><span class="comment">## torch.rsqrt()  对每个元素取平方根后再取倒数，并不会影响如维度等因素。</span></span><br><span class="line"><span class="comment">## torch.mean() 其中dim=[2,3] 代表按第2、3维求平均值, 即在单个实例、单个Channel上求平均</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Basic系列笔记</category>
      </categories>
      <tags>
        <tag>Normalization</tag>
      </tags>
  </entry>
  <entry>
    <title>Torch/Numpy的广播机制介绍</title>
    <url>/2022/01/18/52f2902757db/</url>
    <content><![CDATA[<p>Numpy以及Tensor的广播机制介绍（以Torch为例，两者一致）</p>
<h3 id="广播机制在何处会出现">1、广播机制在何处会出现？</h3>
<p>​ 广播针对的运算是element wise类型的运算，即元素对元素类型的运算</p>
<p>​ <strong>Element-wise的计算符号包括如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">算数运算：+, -, *, /, //, %, divmod(), ** or pow(), &lt;&lt;, &gt;&gt;, &amp;, ^, |</span><br><span class="line"></span><br><span class="line">比较运算：==, &lt;, &gt;, &lt;=, &gt;=, !=</span><br></pre></td></tr></table></figure>
<h3 id="广播机制的规则与出现的原因">2、广播机制的规则与出现的原因</h3>
<p>​ 正常来说，两个做Element
wise类型运算的变量，其相应维度的长度要相等，如下所示：这种形式做Element-Wise的运算是非常简单且易理解的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.rand(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">b = torch.rand(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">c = a * b</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a:tensor([[0.9912, 0.3736],</span></span><br><span class="line"><span class="string">        [0.0708, 0.6939]])</span></span><br><span class="line"><span class="string">b:tensor([[0.5788, 0.6296],</span></span><br><span class="line"><span class="string">        [0.9746, 0.8540]])</span></span><br><span class="line"><span class="string">c:tensor([[0.5737, 0.2352],</span></span><br><span class="line"><span class="string">        [0.0690, 0.5925]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​
那么当两个Tensor的对应维度不对齐的时候，<strong>为了避免用户使用代码for循环来操作填补数组，导致一些低效率的行为出现</strong>，所以其提供了一种广播机制，其实质就是一种处理规则，在不对齐的维度上，长度较短的自动做值复制来扩充长度，从而使得两个Tensor在该维度上一致。</p>
<h3 id="广播机制起效的情况">3、广播机制起效的情况</h3>
<p>​
但是，实际上，并不是所有的不同维度的Tensor相乘时，都会触发广播机制。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.rand(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">b = torch.rand(<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">c = a * b</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	RuntimeError: The size of tensor a (2) must match the size of tensor b (3) at non-singleton dimension 0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>​ 那么，广播机制在何时才会起效呢？其只对如下情况起作用：</p>
<p>​
<strong>两个Tensor，它们如果在某一个维度上长度不同的话，必定有一个Tensor在这个维度上的长度为1，广播机制才会起效。即
1 vs M 的情况</strong></p>
<p>​
<strong>具体计算规则：</strong>长度为1的Tensor在维度上会复制该元素并扩充至长度为M，当这个维度完成对齐，接着重复检查上一层维度，如此反复，直至所有维度都检查完。</p>
<p>​ <strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.rand(<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line">b = torch.rand(<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>)</span><br><span class="line">c = a * b</span><br><span class="line"><span class="built_in">print</span>(c.shape)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	torch.Size([3, 5, 3])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>​ <strong>示意图</strong>：</p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/20200308204131296.png"
alt="20200308204131296" />
<figcaption aria-hidden="true">20200308204131296</figcaption>
</figure>
]]></content>
      <categories>
        <category>⑤  编程语言类笔记</category>
        <category>Python基础扩充笔记</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
        <tag>Auto BroadCasting</tag>
      </tags>
  </entry>
  <entry>
    <title>Python导入自定义模块（同目录、子目录、跨目录）</title>
    <url>/2022/01/18/a7c2f4fb23de/</url>
    <content><![CDATA[<h3 id="基本格式">1、基本格式：</h3>
<p>​ <strong>from 文件名 import 类名</strong></p>
<h3 id="分情形讨论引入方式">2、分情形讨论引入方式：</h3>
<p>​ 假设现有如下目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── model0.py</span><br><span class="line">├── main.py</span><br><span class="line">├── model1/</span><br><span class="line">│   └── model1_main.py</span><br><span class="line">└── model2/</span><br><span class="line">    └── model2_main.py</span><br></pre></td></tr></table></figure>
<h4 id="同级目录引入">1）同级目录引入</h4>
<p><strong>main.py</strong> 中需要导入 <strong>model0.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> model0</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="keyword">from</span> model0 <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>
<p>两者都是可以的，同级目录下引入十分简便，直接import即可</p>
<h4 id="子目录引入">2）子目录引入</h4>
<p><strong>main.py</strong> 中需要导入
<strong>model1_main.py</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们首先需要在model1/下建立__init__.py空文件，让编译器认为这是一个模块。</span><br></pre></td></tr></table></figure>
<p>建立后，<strong>目录结构应当如下所示：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── model0.py</span><br><span class="line">├── main.py</span><br><span class="line">├── model1/</span><br><span class="line">│   └── model1_main.py</span><br><span class="line">│   └── __init__.py</span><br><span class="line">└── model2/</span><br><span class="line">    └── model2_main.py</span><br></pre></td></tr></table></figure>
<p>然后进行引入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> model1.model1_main</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="keyword">from</span> model1.model1_main <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>
<h4 id="跨目录引入">3）跨目录引入</h4>
<p><strong>model1_main.py</strong>导入<strong>model2/model2_main.py</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">同理我们首先需要在model2/下建立__init__.py空文件，让编译器认为这是一个模块。</span><br></pre></td></tr></table></figure>
<p>建立后，<strong>目录结构应当如下所示：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── model0.py</span><br><span class="line">├── main.py</span><br><span class="line">├── model1/</span><br><span class="line">│   └── model1_main.py</span><br><span class="line">│   └── __init__.py</span><br><span class="line">└── model2/</span><br><span class="line">│   └── model2_main.py</span><br><span class="line">│   └── __init__.py</span><br></pre></td></tr></table></figure>
<p>然后在model1_main文件中进行引入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">&quot;..&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> model2.model2_main</span><br></pre></td></tr></table></figure>
<h4 id="更为一般的介绍">4）更为一般的介绍：</h4>
<p>sys模块是python内置的，我们导入跨自定义模块的步骤一般如下：</p>
<p>​ 首先要确保被导入的模块文件夹内有
__init__.py文件，确保其被识别为一个模块，然后再执行下面步骤：</p>
<ol type="1">
<li><strong>先导入sys模块</strong></li>
<li>然后通过<code>sys.path.append(path)</code>
函数来导入自定义模块所在的目录</li>
<li><strong>导入自定义模块</strong>。</li>
</ol>
<p>​
只不过在同级目录以及子目录下进行引入，不需要这么复杂，可以有更简单的方法，而在跨目录引入时，就需要采用这种方案。</p>
]]></content>
      <categories>
        <category>⑤  编程语言类笔记</category>
        <category>Python基础扩充笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Module Import</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker部署与实践笔记</title>
    <url>/2022/01/17/52faafcaa31c/</url>
    <content><![CDATA[<h3 id="一docker优势功能">一、Docker优势功能</h3>
<p>1：持续交付和部署</p>
<p>​ 对开发和运维（<a
href="https://zh.wikipedia.org/wiki/DevOps">DevOps</a>）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p>
<p>​ 使用 <code>Docker</code>
可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 <a
href="https://yeasy.gitbook.io/docker_practice/image/dockerfile">Dockerfile</a>
来进行镜像构建，并结合 <a
href="https://en.wikipedia.org/wiki/Continuous_integration">持续集成(Continuous
Integration)</a>
系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合
<a
href="https://en.wikipedia.org/wiki/Continuous_delivery">持续部署(Continuous
Delivery/Deployment)</a> 系统进行自动部署。</p>
<p>而且使用 <a
href="https://yeasy.gitbook.io/docker_practice/image/build"><code>Dockerfile</code></a>
使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p>
<p>2、
开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些
bug 并未在开发过程中被发现。而 <code>Docker</code>
的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现
<em>「这段代码在我机器上没问题啊」</em> 这类问题</p>
<h3 id="二docker-基本概念">二、Docker 基本概念</h3>
<ul>
<li><strong>镜像</strong>（<code>Image</code>）</li>
<li><strong>容器</strong>（<code>Container</code>）</li>
<li><strong>仓库</strong>（<code>Repository</code>）</li>
</ul>
<p>1、镜像：<strong>Docker
镜像</strong>（<code>Image</code>），就相当于是一个 <code>root</code>
文件系统。比如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套
Ubuntu 18.04 最小系统的 <code>root</code> 文件系统。</p>
<p>​ 使用分层存储技术，在 Docker 设计时，就充分利用 <a
href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a>
的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个
<code>ISO</code>
那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p>
<p>2、镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的
<code>类</code> 和 <code>实例</code>
一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p>​
每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为
<strong>容器存储层</strong>。</p>
<p>​
容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p>
<p>​ 按照 Docker
最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用
<a href="">数据卷（Volume）</a>、或者 <a
href="">绑定宿主目录</a>，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p>
<p>​
据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p>
<p>3、仓库</p>
<p>​
镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a
href="">Docker Registry</a> 就是这样的服务。</p>
<p>​ 一个 <strong>Docker Registry</strong> 中可以包含多个
<strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个
<strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p>
<h3 id="三使用镜像">三、使用镜像：</h3>
<h4 id="获取镜像">1、 获取镜像：</h4>
<p>​ 从 Docker 镜像仓库获取镜像的命令是
<code>docker pull</code>。其命令格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure>
<p>Docker 镜像仓库地址：地址的格式一般是
<code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker
Hub(<code>docker.io</code>)。</p>
<p>仓库名：如之前所说，这里的仓库名是两段式名称，即
<code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker
Hub，如果不给出用户名，则默认为
<code>library</code>，也就是官方镜像。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例： docker pull ubuntu:18.04</span><br></pre></td></tr></table></figure>
<p>​ 上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub
（<code>docker.io</code>）获取镜像。而镜像名称是
<code>ubuntu:18.04</code>，因此将会获取官方镜像
<code>library/ubuntu</code> 仓库中标签为 <code>18.04</code>
的镜像。<code>docker pull</code>
命令的输出结果最后一行给出了镜像的完整名称，即：
<code>docker.io/library/ubuntu:18.04</code></p>
<h4 id="运行镜像">2、运行镜像：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --rm ubuntu:18.04 bash</span><br></pre></td></tr></table></figure>
<p><code>docker run</code> 就是运行容器的命令，具体格式我们会在 <a
href="">容器</a>
一节进行详细讲解，我们这里简要的说明一下上面用到的参数。</p>
<ul>
<li><code>-it</code>：这是两个参数，一个是
<code>-i</code>：交互式操作，一个是 <code>-t</code>
终端。我们这里打算进入 <code>bash</code>
执行一些命令并查看返回结果，因此我们需要交互式终端。</li>
<li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动
<code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用
<code>--rm</code> 可以避免浪费空间。</li>
<li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code>
镜像为基础来启动容器。</li>
<li><code>bash</code>：放在镜像名后的是
<strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是
<code>bash</code>。</li>
</ul>
<h4 id="想要列出已经下载的镜像">3、想要列出已经下载的镜像：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure>
<p>列表包含了
<code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code>
以及 <code>所占用的空间</code>。</p>
<p>你可以通过 <code>docker system df</code>
命令来便捷的查看镜像、容器、数据卷所占用的空间。</p>
<h5 id="虚悬镜像-指无标签镜像">!! 虚悬镜像 : 指无标签镜像</h5>
<p>一般来说其已经失去了存在的价值，可以随意删除：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure>
<h5
id="中间层镜像为了加速镜像构建重复利用资源docker-会利用-中间层镜像所以在使用一段时间后可能会看到一些依赖的中间层镜像">!!
中间层镜像：为了加速镜像构建、重复利用资源，Docker 会利用
<strong>中间层镜像</strong>。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。</h5>
<p>​ 默认的 <code>docker image ls</code>
列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加
<code>-a</code> 参数。</p>
<p>​
这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。</p>
<h5
id="其余不常用命令见-httpsyeasy.gitbook.iodocker_practiceimagelist">其余不常用命令见：
https://yeasy.gitbook.io/docker_practice/image/list</h5>
<h4 id="删除本地镜像">4、 删除本地镜像</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image <span class="built_in">rm</span> [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure>
<p>其中，<code>&lt;镜像&gt;</code> 可以是
<code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者
<code>镜像摘要</code>。</p>
<p>例子：例如我们有以下镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos                      latest              0584b3d2cf6d        3 weeks ago         196.5 MB</span><br><span class="line">redis                       alpine              501ad78535f0        3 weeks ago         21.03 MB</span><br><span class="line">docker                      latest              cf693ec9b5c7        3 weeks ago         105.1 MB</span><br><span class="line">nginx                       latest              e43d811ce2f4        5 weeks ago     </span><br></pre></td></tr></table></figure>
<p>​ 我们可以用镜像的完整 ID，也称为
<code>长 ID</code>，来删除镜像。使用脚本的时候可能会用长
ID，但是人工输入就太累了，所以更多的时候是用 <code>短 ID</code>
来删除镜像。<code>docker image ls</code> 默认列出的就已经是短 ID
了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p>
<p>比如这里，如果我们要删除 <code>redis:alpine</code>
镜像，可以执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image <span class="built_in">rm</span> 501</span><br><span class="line">Untagged: redis:alpine</span><br><span class="line">Untagged: redis@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86d</span><br><span class="line">Deleted: sha256:501ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7</span><br><span class="line">Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899b</span><br><span class="line">Deleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23</span><br><span class="line">Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2fa</span><br><span class="line">Deleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3</span><br></pre></td></tr></table></figure>
<p>我们也可以用<code>镜像名</code>，也就是
<code>&lt;仓库名&gt;:&lt;标签&gt;</code>，来删除镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image <span class="built_in">rm</span> centos</span><br><span class="line">Untagged: centos:latest</span><br><span class="line">Untagged: centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c</span><br><span class="line">Deleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8a</span><br></pre></td></tr></table></figure>
<h5 id="untagged-和deleted">Untagged 和Deleted</h5>
<p>​ 删除行分两类，镜像的唯一标识是其 ID
和摘要，而一个镜像可以有多个标签。</p>
<p>​
因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。</p>
<p>​
所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的
<code>Untagged</code> 的信息。</p>
<p>​
因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么
<code>Delete</code> 行为就不会发生。所以并非所有的
<code>docker image rm</code>
都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。</p>
<h3 id="四使用容器">四、使用容器：</h3>
<h4 id="启动容器">1、启动容器：</h4>
<h4
id="分两种1新创建一个容器并启动-2启动一个已经停止的容器">分两种：1、新创建一个容器并启动
2、启动一个已经停止的容器</h4>
<p>​
容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用</p>
<h4 id="新创建一个容器并启动">1）新创建一个容器并启动</h4>
<p>​ 当利用 <code>docker run</code> 来创建容器时，Docker
在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从 <a href="">registry</a>
下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<h4 id="启动一个已经停止的容器">2）启动一个已经停止的容器</h4>
<p>可以利用 <code>docker container start</code>
命令，直接将一个已经终止（<code>exited</code>）的容器启动运行。</p>
<p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用
<code>ps</code> 或 <code>top</code> 来查看进程信息。</p>
<h4 id="守护态运行容器">2、守护态运行容器：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d ubuntu:18.04</span><br></pre></td></tr></table></figure>
<p>！！利用-d参数在后台运行容器！！！</p>
<p>注意：容器是否会长久运行，是和 <code>docker run</code>
指定的命令有关，和 <code>-d</code> 参数无关！！！</p>
<p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过
<code>docker container ls</code> 命令来查看容器信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID  IMAGE         COMMAND               CREATED        STATUS       PORTS NAMES</span><br><span class="line">77b2dc01fe0f  ubuntu:18.04  /bin/sh -c &#x27;while tr  2 minutes ago  Up 1 minute        agitated_wright</span><br></pre></td></tr></table></figure>
<p>要获取容器的输出信息，可以通过 <code>docker container logs</code>
命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker container logs [container ID or NAMES]</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>
<h4 id="终止容器">3、终止容器</h4>
<p>可以使用 <code>docker container stop</code>
来终止一个运行中的容器。</p>
<p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止</p>
<p>处于终止状态的容器，可以通过 <code>docker container start</code>
命令来重新启动。</p>
<p>此外，<code>docker container restart</code>
命令会将一个运行态的容器终止，然后再重新启动它。</p>
<h4 id="进入容器">4、进入容器：</h4>
<p>docker exec 命令</p>
<p><code>docker exec</code> 后边可以跟多个参数，这里主要说明
<code>-i</code> <code>-t</code> 参数。</p>
<h4 id="导出容器">5、导出容器：</h4>
<p>如果要导出本地某个容器，可以使用 <code>docker export</code>
命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES</span><br><span class="line">7691a814370e        ubuntu:18.04        &quot;/bin/bash&quot;         36 hours ago        Exited (0) 21 hours ago                       test</span><br><span class="line">$ docker export 7691a814370e &gt; ubuntu.tar</span><br></pre></td></tr></table></figure>
<h4 id="导入容器">6、导入容器：</h4>
<p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat ubuntu.tar | docker import - test/ubuntu:v1.0</span><br><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE</span><br><span class="line">test/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB</span><br></pre></td></tr></table></figure>
<p>​ 用户既可以使用
<code>docker load</code>来导入镜像存储文件到本地镜像库，也可以使用
<em><code>docker import</code></em>
来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。*</p>
<h4
id="删除容器或清理所有处于终止状态的容器">7、删除容器或清理所有处于终止状态的容器：</h4>
<p>​ 可以使用 <code>docker container rm</code>
来删除一个处于终止状态的容器。例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker container rm trusting_newton</span><br><span class="line">trusting_newton</span><br></pre></td></tr></table></figure>
<p>​ 用 <code>docker container ls -a</code>
命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker container prune</span><br></pre></td></tr></table></figure>
<h2 id="五访问仓库">五、访问仓库</h2>
<p>​
一个容易混淆的概念是注册服务器（<code>Registry</code>）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址
<code>docker.io/ubuntu</code> 来说，<code>docker.io</code>
是注册服务器地址，<code>ubuntu</code> 是仓库名。</p>
<h4 id="登录仓库">登录仓库</h4>
<p>！！可以通过执行 <code>docker login</code>
命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。</p>
<p>！！你可以通过 <code>docker logout</code> 退出登录。</p>
<h4 id="镜像查找">镜像查找</h4>
<p>你可以通过 <code>docker search</code>
命令来查找官方仓库中的镜像，并利用 <code>docker pull</code>
命令来将它下载到本地。</p>
<p>例如以 <code>centos</code> 为关键词进行搜索：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker search centos</span><br><span class="line">NAME                               DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">centos                             The official build of CentOS.                   6449      [OK]</span><br><span class="line">ansible/centos7-ansible            Ansible on Centos7                              132                  [OK]</span><br><span class="line">consol/centos-xfce-vnc             Centos container with &quot;headless&quot; VNC session…   126                  [OK]</span><br><span class="line">jdeathe/centos-ssh                 OpenSSH / Supervisor / EPEL/IUS/SCL Repos - …   117                  [OK]</span><br><span class="line">centos/systemd                     systemd enabled base container.                 96                   [OK]</span><br></pre></td></tr></table></figure>
<p>​
可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建（<code>OFFICIAL</code>）、是否自动构建
（<code>AUTOMATED</code>）。</p>
<p>​ 根据是否是官方提供，可将镜像分为两类。</p>
<p>​ 一种是类似 <code>centos</code>
这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker
公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。</p>
<p>​ 还有一种类型，比如 <code>ansible/centos7-ansible</code> 镜像，它是由
Docker Hub 的注册用户创建并维护的，往往带有用户名称前缀。可以通过前缀
<code>username/</code> 来指定使用某个用户提供的镜像，比如 ansible
用户。</p>
<h4 id="推送镜像">推送镜像</h4>
<p>用户也可以在登录后通过 <code>docker push</code>
命令来将自己的镜像推送到 Docker Hub。</p>
<p>以下命令中的 <code>username</code> 请替换为你的 Docker 账号用户名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker tag ubuntu:18.04 username/ubuntu:18.04</span><br><span class="line"></span><br><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line">REPOSITORY                                               TAG                    IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu                                                   18.04                  275d79972a86        6 days ago          94.6MB</span><br><span class="line">username/ubuntu                                          18.04                  275d79972a86        6 days ago          94.6MB</span><br><span class="line"></span><br><span class="line">$ docker push username/ubuntu:18.04</span><br></pre></td></tr></table></figure>
<h4 id="自动构建">自动构建</h4>
<p>自动构建（<code>Automated Builds</code>）功能对于需要经常升级镜像内程序来说，十分方便。</p>
<p>有时候，用户构建了镜像，安装了某个软件，当软件发布新版本则需要手动更新镜像。</p>
<p>而自动构建允许用户通过 Docker Hub 指定跟踪一个目标网站（支持 <a
href="https://github.com/">GitHub</a> 或 <a
href="https://bitbucket.org/">BitBucket</a>）上的项目，一旦项目发生新的提交
（<code>commit</code>）或者创建了新的标签（<code>tag</code>），Docker
Hub 会自动构建镜像并推送到 Docker Hub 中。</p>
<p>要配置自动构建，包括如下的步骤：</p>
<ul>
<li>登录 Docker Hub；</li>
<li>在 Docker Hub
点击右上角头像，在账号设置（<code>Account Settings</code>）中关联（<code>Linked Accounts</code>）目标网站；</li>
<li>在 Docker Hub 中新建或选择已有的仓库，在 <code>Builds</code>
选项卡中选择 <code>Configure Automated Builds</code>；</li>
<li>选取一个目标网站中的项目（需要含
<code>Dockerfile</code>）和分支；</li>
<li>指定 <code>Dockerfile</code> 的位置，并保存。</li>
</ul>
<p>之后，可以在 Docker Hub 的仓库页面的 <code>Timeline</code>
选项卡中查看每次构建的状态</p>
<h2 id="六数据管理">六、数据管理</h2>
<h3 id="如何在-docker-内部以及容器之间管理数据">！！如何在 Docker
内部以及容器之间管理数据，</h3>
<h3
id="在容器中管理数据主要有两种方式">！！在容器中管理数据主要有两种方式：</h3>
<ul>
<li>数据卷（Volumes）</li>
<li>挂载主机目录 (Bind mounts)</li>
</ul>
<h4 id="数据卷">数据卷</h4>
<p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过
UFS，可以提供很多有用的特性：</p>
<ul>
<li><code>数据卷</code> 可以在容器之间共享和重用</li>
<li>对 <code>数据卷</code> 的修改会立马生效</li>
<li>对 <code>数据卷</code> 的更新，不会影响镜像</li>
<li><code>数据卷</code> 默认会一直存在，即使容器被删除</li>
</ul>
<p>创建一个数据卷</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker volume create my-vol</span><br></pre></td></tr></table></figure>
<p>查看所有的 <code>数据卷</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker volume ls</span><br><span class="line"></span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               my-vol</span><br></pre></td></tr></table></figure>
<h4 id="启动一个挂载数据卷的容器">启动一个挂载数据卷的容器</h4>
<p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code>
标记来将 <code>数据卷</code> 挂载到容器里。在一次
<code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p>
<p>下面创建一个名为 <code>web</code> 的容器，并加载一个
<code>数据卷</code> 到容器的 <code>/usr/share/nginx/html</code> 目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    # -v my-vol:/usr/share/nginx/html \</span><br><span class="line">    --mount source=my-vol,target=/usr/share/nginx/html \</span><br><span class="line">    nginx:alpine</span><br></pre></td></tr></table></figure>
<p>查看数据卷的具体信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker inspect web</span><br></pre></td></tr></table></figure>
<p>!!!<code>数据卷</code>
是被设计用来持久化数据的，它的生命周期独立于容器，Docker
不会在容器被删除后自动删除
<code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的
<code>数据卷</code>。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用
<code>docker rm -v</code> 这个命令</p>
<p>删除数据卷时请采用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker volume rm my-vol</span><br></pre></td></tr></table></figure>
<h4 id="挂载主机目录">挂载主机目录</h4>
<p>使用 <code>--mount</code>
标记可以指定挂载一个本地主机的目录到容器中去。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    # -v /src/webapp:/usr/share/nginx/html \</span><br><span class="line">    --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html \</span><br><span class="line">    nginx:alpine</span><br></pre></td></tr></table></figure>
<h2 id="七网络应用">七、网络应用</h2>
<p>​ 容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过
<code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p>
<p>当使用 <code>-P</code> 标记时，Docker
会随机映射一个端口到内部容器开放的网络端口。</p>
<p>​ 使用 <code>docker container ls</code> 可以看到，本地主机的 32768
被映射到了容器的 80 端口。此时访问本机的 32768 端口即可访问容器内 NGINX
默认页面。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -d -P nginx:alpine</span><br><span class="line"></span><br><span class="line">$ docker container ls -l</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES</span><br><span class="line"></span><br><span class="line">fae320d08268        nginx:alpine        &quot;/docker-entrypoint.…&quot;   24 seconds ago      Up 20 seconds       0.0.0.0:32768-&gt;80/tcp   bold_mcnulty</span><br></pre></td></tr></table></figure>
<p>​ <code>-p</code>
则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有
<code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p>
<h4 id="查看映射端口配置">查看映射端口配置</h4>
<p>​ 使用 <code>docker port</code>
来查看当前映射的端口配置，也可以查看到绑定的地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker port fa 80</span><br><span class="line">0.0.0.0:32768</span><br></pre></td></tr></table></figure>
<h3 id="注意">注意：</h3>
<ul>
<li>容器有自己的内部网络和 ip 地址（使用 <code>docker inspect</code>
查看，Docker 还可以有一个可变的网络配置。）</li>
<li><code>-p</code> 标记可以多次使用来绑定多个端口</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">    -p 80:80 \</span><br><span class="line">    -p 443:443 \</span><br><span class="line">    nginx:alpine</span><br></pre></td></tr></table></figure>
<h4 id="八使用dockerfile定制镜像">八、使用DockerFIle定制镜像</h4>
<p>​ Dockerfile 是一个文本文件，其内包含了一条条的
<strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
]]></content>
      <categories>
        <category>⑦  工具使用类笔记</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习基础系列笔记8——图像风格迁移方法AdaIN</title>
    <url>/2022/01/17/27fde64f6abc/</url>
    <content><![CDATA[<p><strong>AdaIN</strong>是一种经典的图片风格迁移算法，在 2017
年ICCV中提出。主要用于将一张图片(风格图) 中的风格、纹理迁移到另一张图片
(内容图)，同时要保留内容图的主体结构。如下所示：</p>
<p>​ <strong>论文名称：《Arbitrary Style Transfer in Real-time with
Adaptive Instance Normalization》</strong></p>
<p>​ <strong>论文链接：https://arxiv.org/abs/1703.06868</strong></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/b219ebc4b74543a95e9180d3cb15748ab9011436.jpeg" /></p>
<h2 id="一adain简介">一、AdaIN简介</h2>
<p>​ 这篇论文的主要目标是实现<strong>实时的、任意风格的风格迁移（style
transfer）</strong>，核心方法就是其提出的自适应实例标准化（<strong>Adaptive
Instance
Normalization，AdaIN</strong>），通过<strong>将内容图像（content
image）特征的均值和方差对齐到风格图像（style
image）的均值和方差</strong>来实现风格迁移。</p>
<p>​ 此外，这个方法还给用户非常多的控制权，包括如下：</p>
<ul>
<li>内容和风格的折中（trade off）
<ul>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220116183935766.png" /></li>
</ul></li>
<li>风格插值（混合风格迁移）
<ul>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220116183943127.png" /></li>
</ul></li>
<li>是否保留颜色
<ul>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220116183918123.png" /></li>
</ul></li>
<li>对图像的特定区域进行风格迁移
<ul>
<li><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220116183906461.png" /></li>
</ul></li>
</ul>
<h2 id="二前备知识">二、前备知识：</h2>
<p>​ 你需要熟悉Batch Normaliztion（BN）、Layer Norm（LN）、Instance
Norm（IN）、Group Norm（GN）、Conditional Instance
Norm（CIN）等概念。</p>
<p>​
下图为特征图张量，可以直观看出BN，LN，IN，GN等规范化方法的区别。N为样本维度，C为通道维度，H为height，W即width，代表特征图的尺寸。</p>
<p><img
src="https://img-blog.csdnimg.cn/2019061216413530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNTU3Njg4MQ==,size_16,color_FFFFFF,t_70" /></p>
<p>​ 具体每种Normalization的方法介绍可以参见我的这一篇Blog：</p>
<p>​ https://blog.fantast.top/2022/01/16/basic7/</p>
<p>​</p>
<h2 id="三adain具体介绍">三、AdaIN具体介绍</h2>
<h5 id="输入content-input-x-style-input-y">输入：Content Input x
&amp;&amp; Style Input y</h5>
<p>​ AdaIN 简单地将 x 的通道均值和方差对齐以匹配 y 的均值和方差。
不像BN、IN或CIN，AdaIN没有需要从网络中进行学习的仿射变换参数，它能够自适应的从style
input中计算得到仿射变换的参数。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220117103448955.png" /></p>
<p>​ 我们简单地用 σ(y) 缩放归一化的Content Input，并用 µ(y) 移动它。 与
IN
类似，这些统计数据是跨空间位置计算的。也就是说，其实对于单个实例的单个特征通道计算的均值和方差数据。</p>
<p>​ 直观地说，让我们考虑一个检测特定风格笔触的特征通道。</p>
<p>​ 具有这种风格的图像会对它的特征部分产生较高的平均激活。AdaIN
产生的输出将对该特征具有相同的高平均激活，同时其也保留内容图像的空间结构。
然后我们可以使用前馈解码器将风格特征转换回图像空间。同时，这个特征通道的方差可以编码更细微的风格信息，这些信息也传递到
AdaIN 输出和最终输出图像。</p>
<p>​ 简而言之，AdaIN
通过传输特征统计数据（特别是通道均值和方差）在特征空间中执行风格迁移。我们的
AdaIN 层就像一个 IN 层一样简单，几乎不增加计算成本。</p>
<h2 id="四网络结构">四、网络结构</h2>
<p>​
在论文中，其使用VGG-19来编码内容和风格，在浅层空间将特征图通过AdaIN层，进行上述仿射变换，解码器根据变换后的特征图试图重建图像，通过反向传播训练解码器，使得解码器输出越来越真实的图像。整体架构如下所示：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/2019061217185282.png" /></p>
<p>​ 更为具体的代码可见以下链接地址：</p>
<p>​ https://github.com/xunhuang1995/AdaIN-style</p>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Basic系列笔记</category>
      </categories>
      <tags>
        <tag>Style Transfer</tag>
        <tag>AdaIN</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习基础系列笔记7——各种归一化Normalization方法（含BN、LN、IN、CIN、GN）</title>
    <url>/2022/01/16/8bf646a3f959/</url>
    <content><![CDATA[<p><strong>本文介绍了常见的几种 <a
href="机器学习基础系列笔记2—数据表征与自动编码器.md">机器学习基础系列笔记2—数据表征与自动编码器.md</a>
Normaliza <a
href="机器学习基础系列笔记0—常见概念与函数（更新中）.md">机器学习基础系列笔记0—常见概念与函数（更新中）.md</a>
tion方式，如BatchNorm、LayerNorm、InstanceNorm、Conditional Instance
Norm、Group Norm。
各种Normalization在理论上都能够起到平滑损失函数平面的效果，加速函数的收敛效果，但是它们在机器学习的各个领域上，各有偏重与优势。</strong></p>
<h3 id="目录概述">目录概述：</h3>
<ul>
<li><strong>BatchNorm</strong>：batch方向做归一化，算N * H * W的均值,
常用于CNN等视觉识别领域，如果当Batch的尺寸比较小或是在一些动态网络中时不适用。</li>
<li><strong>LayerNorm</strong>：channel方向做归一化，算C * H *
W的均值，LN不适用于CNN等视觉识别领域，但是可在BN无法使用的领域如RNN和Batch
Size较小时进行使用。</li>
<li><strong>InstanceNorm</strong>：一个channel一个实例内做归一化，算H *
W的均值，其适用于批量较小且单独考虑每个像素点的场景中，如GAN生成网络，但在MLP或RNN或Feature
Map较小的时候不适用。</li>
<li><strong>GroupNorm</strong>：将channel方向分group，然后每个group内做归一化，算(C
 G) * H * W的均值</li>
</ul>
<h3 id="batch-normbn">1、Batch Norm（BN）</h3>
<p>​ Ioffe 和 Szegedy
的开创性工作引入了批量归一化（BN）层，通过归一化特征统计显示简化了前馈网络的训练。
BN 层最初旨在加速判别网络的训练，但也被发现在生成图像建模中有效。</p>
<h5 id="输入"><strong>输入</strong>：</h5>
<p>​ <strong>An input batch</strong> <span class="math inline">\(x \in
R^{N \times C \times H \times W}\)</span></p>
<h5 id="说明"><strong>说明</strong>：</h5>
<p>​ Batch
Normalization就是对一个Batch中的数据进行标准化，就是每一个值减去batch的均值，除以batch的标准差，计算公式如下：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220116184553370.png" /></p>
<ul>
<li><p><span class="math inline">\(\gamma , \beta \in
R^{C}\)</span>是从数据中训练得到的参数。</p></li>
<li><p><span class="math inline">\(\mu(x) , \sigma(x) \in
R^{C}\)</span>是均值和方差，为每个特征通道（C）独立计算批量大小（N）和空间维度（H
* W）</p></li>
<li><p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220116185246851.png" /></p></li>
</ul>
<h5 id="卷积网络中的bn"><strong>卷积网络中的BN</strong></h5>
<p>​
BN除了可以应用在MLP上，其在CNN网络中的表现也非常好，<strong>卷积网络和MLP的不同点是卷积网络中每个样本的隐层节点的输出是三维（宽度，高度，维度）的</strong>，而MLP是一维的。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_01_17_09_33_31_622.png" /></p>
<p>​ 在上图中，假设一个批量有 <span
class="math inline">\(m\)</span>个样本，Feature Map的尺寸是 <span
class="math inline">\({p \times q}\)</span>，通道数是<span
class="math inline">\(d\)</span>。<strong>在卷积网络中，BN的操作是以Feature
Map为单位的</strong>，因此一个BN要统计的数据个数为 <span
class="math inline">\({m \times p \times q}\)</span>，每个Feature
Map使用一组<span class="math inline">\(\gamma\)</span>和<span
class="math inline">\({\beta}\)</span>.</p>
<h5 id="类比"><strong>类比</strong>：</h5>
<p>​ 如果把输入<span class="math inline">\(x \in R^{N \times C \times H
\times W}\)</span>类比为一摞书，这摞书总共有 N 本，每本有 C 页，每页有 H
行，每行 W 个字符。BN
求均值时，相当于把这些书按页码一一对应地加起来（例如第1本书第36页，第2本书第36页......），再除以每个页码下的字符总数：N<strong>×</strong>H<strong>×</strong>W，因此可以把
<strong>BN
看成求“平均书”</strong>的操作（注意这个“平均书”每页只有一个字）。</p>
<h5 id="总结"><strong>总结：</strong></h5>
<p>​
BN是深度学习调参中非常好用的策略之一（另外一个可能就是Dropout），当你的模型发生<strong>梯度消失/爆炸或者损失值震荡比较严重</strong>的时候，在BN中加入网络往往能取得非常好的效果，因为BN能够起到平滑损失平面的作用。</p>
<p>​ BN也有一些不是非常适用的场景，在遇见这些场景时要谨慎的使用BN：</p>
<ul>
<li>受制于硬件限制，每个Batch的尺寸比较小，这时候谨慎使用BN；</li>
<li>在类似于RNN的<strong>动态网络</strong>中谨慎使用BN；</li>
<li>训练数据集和测试数据集方差较大的时候。</li>
</ul>
<h3 id="layer-normln">2、Layer Norm（LN）</h3>
<p>​ Layer
Normalization（LN）的提出有效的解决了BN的这两个问题（一个是不适用于动态网络，一个是batch尺寸较小的时候）。LN和BN不同点是归一化的维度是互相垂直的。如下图所示。在图1中<span
class="math inline">\(N\)</span>表示样本轴， <span
class="math inline">\(C\)</span>表示通道轴， <span
class="math inline">\(F\)</span>是每个通道的特征数量( W*H )。BN
如右侧所示，它是取不同样本的同一个通道的特征做归一化；LN则是如左侧所示，它取的是同一个样本的不同通道做归一化。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_01_17_09_33_37_355.png" /></p>
<h5 id="mlp中的ln"><strong>MLP中的LN</strong></h5>
<p>​
BN的两个缺点的产生原因均是因为<strong>计算归一化统计量时计算的样本数太少</strong>。LN是一个独立于batch
size的算法，所以无论样本数多少都不会影响参与LN计算的数据量，从而解决BN的两个问题。</p>
<p>​ 先看MLP中的LN。设<span
class="math inline">\(H\)</span>是一层中隐层节点的数量， <span
class="math inline">\(l\)</span>是MLP的层数，我们可以计算LN的归一化统计量<span
class="math inline">\(\mu\)</span>和<span
class="math inline">\(\sigma\)</span>：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_01_17_09_24_28_295.png" /></p>
<p>​
注意上面<strong>统计量的计算是和样本数量没有关系</strong>的，它的<strong>数量只取决于隐层节点的数量</strong>，所以只要隐层节点的数量足够多，我们就能保证LN的归一化统计量足够具有代表性。</p>
<p>​ 通过<span class="math inline">\(\mu ^{l}\)</span>和<span
class="math inline">\(\sigma
^{l}\)</span>可以计算得到归一化后的值：<span
class="math inline">\(\hat{a}^l\)</span></p>
<p>​ <img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_01_17_09_26_22_177.png" /></p>
<p>​
BN的文章中介绍过几乎所有的归一化方法都能起到平滑损失平面的作用。<strong>所以从原理上讲，LN能加速收敛速度的。</strong>但我们发现，将LN添加到CNN后，实验结果表明LN破坏了卷积层学习到的特征，使得模型无法收敛，所以在CNN之后使用BN是一个较好的选择。</p>
<h5 id="类比-1"><strong>类比</strong>：</h5>
<p>​ LN 求均值时，相当于把每一本书的所有字加起来，再除以这本书的
字符总数：C<strong>×</strong>H<strong>×</strong>W，即求整本书的“平均字”，求标准差时也是同理。</p>
<h5 id="总结-1"><strong>总结</strong></h5>
<p>​
总体而言，LN是和BN非常近似的一种归一化方法，不同的是<strong>BN取的是不同样本的同一个特征，而LN取的是同一个样本的不同特征</strong>。在BN和LN都能使用的场景中，<strong>BN的效果一般优于LN，原因是基于不同数据，同一特征得到的归一化特征更不容易损失信息。</strong></p>
<p>​
但是有些场景是不能使用BN的，例如batchsize较小或者在RNN中，这时候可以选择使用LN，LN得到的模型更稳定且起到正则化的作用。RNN能应用到小批量和RNN中是因为LN的归一化统计量的计算是和batchsize没有关系的</p>
<h3 id="instance-normin">3、Instance Norm（IN）</h3>
<p>​
对于图像风格迁移这类<strong>注重每个像素的任务</strong>来说，每个样本的每个像素点的信息都是非常重要的，于是像Batch
Normlization这种每个批量的所有样本都做归一化的算法就不太适用了，因为BN计算归一化统计量时考虑了一个批量中所有图片的内容，从而<strong>造成了每个样本独特细节的丢失</strong>。同理对于LayerNormalization这类需要考虑一个样本所有通道的算法来说可能忽略了不同通道的差异，也不太适用于图像风格迁移这类应用。</p>
<p>​ 所以一篇论文提出了Instance
Normalization（IN），一种更适合对单个像素有更高要求的场景的归一化算法（IST，GAN等）。IN的算法非常简单，<strong>计算归一化统计量时考虑单个样本，单个通道的所有元素</strong>。IN（右）和BN（中）以及LN（左）的不同从图1中可以非常明显的看出。<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_01_17_09_33_44_819.png" /></p>
<p>​ IN方法计算公式如下：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220117093553291.png" /></p>
<p>​ 不同于BN(x),这边的<span class="math inline">\(\mu(x) , \sigma(x) \in
R^{C}\)</span>是均值和方差，是为每个实例的每个特征通道（C）独立计算的。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220117093715421.png" /></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220117093735940.png" /></p>
<p>​
IN在计算归一化统计量时并没有像BN那样跨样本、单通道，也没有像LN那样单样本、跨通道。它是取的单通道，单样本上的数据进行计算。所以对比BN的公式，它只需要它只需要去掉批量维的求和即可。</p>
<h5 id="类比-2"><strong>类比</strong>：</h5>
<p>​ IN
求均值时，相当于把一页书中所有字加起来，再除以该页的总字数：H<strong>×</strong>W，即求每页书的“平均字”，求标准差时也是同理。</p>
<h5 id="总结-2"><strong>总结</strong>：</h5>
<p>​
IN本身是一个非常简单的算法，<strong>尤其适用于批量较小且单独考虑每个像素点的场景中</strong>，因为其计算归一化统计量时没有混合批量和通道之间的数据，对于这种场景下的应用，我们可以考虑使用IN。</p>
<p>​
另外需要注意的一点是在图像这类应用中，每个通道上的值是比较大的，因此也能够取得比较合适的归一化统计量。但是有两个场景建议不要使用IN:</p>
<ol type="1">
<li>MLP或者RNN中：因为在MLP或者RNN中，每个通道上只有一个数据，这时会自然不能使用IN；</li>
<li>Feature
Map比较小时：因为此时IN的采样数据非常少，得到的归一化统计量将不再具有代表性。</li>
</ol>
<h3 id="group-normgn">4、Group Norm（GN）</h3>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/n6ck05dvpj.png" /></p>
<p>​ GN 把通道分为组，并计算每一组之内的均值和方差，以进行归一化。GN
的计算与批量大小无关，其精度也在各种批量大小下保持稳定。可以看到，GN和LN很像。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/1496926-9e0fd762d02d26c1.webp" /></p>
<h5 id="类比-3"><strong>类比</strong>：</h5>
<p>​ GN 相当于把一本 C 页的书平均分成 G 份，每份成为有 C/G
页的小册子，求每个小册子的“平均字”和字的“标准差”。</p>
<h5 id="总体"><strong>总体</strong>：</h5>
<p>​ <strong>LN 和 IN
在视觉识别上的成功率都是很有限的</strong>，对于<strong>训练序列模型（RNN/LSTM）或生成模型（GAN）</strong>很有效。所以，<strong>在视觉识别领域，BN用的比较多，GN就是为了改善BN的不足而来的。</strong></p>
<p>​
<strong>GN适用于占用显存比较大的任务，例如图像分割</strong>。对这类任务，可能
batchsize 只能是个位数，再大显存就不够用了。而当 batchsize
是个位数时，BN
的表现很差，因为没办法通过几个样本的数据量，来近似总体的均值和标准差。GN
是独立于 batch 的,所以可以适用。</p>
<h3 id="conditional-instance-normcin">5、Conditional Instance
Norm（CIN）</h3>
<p>​ Dumoulin等人在进行风格迁移任务，使用IN的时候，用不同的<span
class="math inline">\(\gamma\)</span>和 <span
class="math inline">\(\beta\)</span>即可生成出风格不同的图像，于是提出了Conditional
Instance Normalization(CIN)。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220117102111791.png" /></p>
<p>​ 其中s代表风格，<span class="math inline">\(\gamma ^s\)</span>和
<span class="math inline">\(\beta ^s\)</span>是学出来的，一组 <span
class="math inline">\((\gamma ^s,\beta
^s)\)</span>对应一种风格。Dumoulin等人的方法迁移有限种的风格，想迁移新的的风格则需要训练新的模型。</p>
<p><strong>部分内容参考链接：</strong></p>
<p>https://zhuanlan.zhihu.com/p/54530247</p>
<p>https://zhuanlan.zhihu.com/p/56542480</p>
<p>https://www.jianshu.com/p/f15fcdf13438</p>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Basic系列笔记</category>
      </categories>
      <tags>
        <tag>Normalization</tag>
      </tags>
  </entry>
  <entry>
    <title>《Deep Residual Fourier Transformation for Single Image Deblurring》论文笔记</title>
    <url>/2022/01/14/92b79ab7b72b/</url>
    <content><![CDATA[<h4
id="论文名称deep-residual-fourier-transformation-for-single-image-deblurring">论文名称：《Deep
Residual Fourier Transformation for Single Image Deblurring》</h4>
<h4 id="论文地址-httpsarxiv.orgabs2111.11745">论文地址：
https://arxiv.org/abs/2111.11745</h4>
<h2 id="关键词">1、关键词：</h2>
<p>​ Image Deblurring、FFT、ResBlock</p>
<h2 id="领域背景">2、领域背景：</h2>
<p>​ Image Deblurring
图像去模糊，往往指由非常规相机或物体移动、光学虚焦等因素引起的一种现象，他们会导致看上去低质量的图像。</p>
<h2 id="先前工作描述与比较">3、先前工作描述与比较：</h2>
<p>​
在先前，DeepDeblur使用CNN配合ResBlock，构建了多尺度的一个结构，使用Residual
Block来聚焦学习模糊的图像和清晰的图像对之间的差距。并且取得了非常好的效果。但是，它也有一定的局限性：</p>
<ul>
<li><p>ResBlock通常在CNN中进行，其感知域容易受到限制（尤其是在比较前面的层），所以ResBlock的机制往往会无法对全局的信息进行建模（这些信息往往在从一个模糊图像重建一个清晰图像的时候较为有用）</p></li>
<li><p>先前的方法很少从频域的角度去关注模糊的图像和清晰的图像之间的关系，而我们发现，相较于模糊图像，清晰的图像往往包含更少的低频信息以及更多的高频信息。</p></li>
<li><p>CNN在捕获可见的特征的时候很厉害，但是对于频域的特征较弱，并且ResBlock
可能具备良好的高频信息的学习，但是对于低频信息的学习较弱一些。</p></li>
<li><p>论文贡献</p>
<ul>
<li>这篇论文提出的 <em>Residual Fast Fourier Transform with Convolution
Block (Res FFT-Conv
Block)</em>既能够捕获长距离信息，也能捕获短距离信息，同时也有能力考虑整个高频和低频的信息。通过使用这个Block还提出了一个框架，可以应用于图像去模糊领域
<em>Residual Fourier Transformation (DeepRFT) framework</em></li>
</ul></li>
</ul>
<h2 id="主要设计思想">4、主要设计思想：</h2>
<p>​ 提出了<strong>Residual Fast Fourier Transform with Convolution
Block（Res FFT-Conv
Block）</strong>模块，这是一个即插即用的模块。设计思想如下所示：</p>
<ul>
<li>Res FFT-Conv模块 将图像从空间域转至频域，然后使用<span
class="math inline">\(1 \times
1\)</span>的卷积层进行卷积。由于FFT的特性，就能够使得在很early的层上卷积的感知域就能包含整个图像。其能更好的捕获模糊图像和清晰图像之间全局的差异。</li>
</ul>
<p>​ 提出了<strong>Deep Residual Fourier Transformation (DeepRFT)
框架</strong>，主要操作如下：</p>
<ul>
<li>DeepRFT框架通过将Res
FFT-Conv模块插入进MIMO-UNet这个网络结构中，来进行图像去模糊的任务同时，使用DepthWise
Over-parameterized Conolution以加速网络训练，达到很好的效果。</li>
</ul>
<h2 id="具体方法与网络架构">5、具体方法与网络架构：</h2>
<h3 id="resblocklook-back">1) ResBlock（Look Back）</h3>
<ul>
<li><p><strong>网络结构</strong>：包含两个<span class="math inline">\(3
\times 3\)</span>卷积层 以及 一个 RELU激活函数层</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114155111786.png" alt="image-20220114155111786" style="zoom: 50%;" /></p></li>
<li><p><strong>意义</strong>：能够训练更深的网络结构、拥有更大的感知域、加快训练时的收敛速度。卷积操作能够很好的学习到一些图像中的高频信息，因为其经常能够从图像的edges中捕获信息。</p></li>
<li><p><strong>缺陷</strong>：</p>
<ul>
<li>缺少对低频信息的建模能力</li>
<li>虽然我们能够通过堆叠模块来加大感知域，但是堆叠会带来巨大的计算复杂度。且在前几层网络中，感知域大小还是非常局部的，缺少全局的信息。</li>
</ul></li>
</ul>
<h3
id="residual-fast-fourier-transform-blockcurrent-substitute">2）Residual
Fast Fourier Transform Block（Current Substitute）</h3>
<ul>
<li><p><strong>输入</strong>：<span class="math inline">\(Z \in R^{H
\times W \times C}\)</span></p></li>
<li><p><strong>网络结构</strong>：两条残差流：</p>
<ul>
<li>与ResBlock一致的空间域信息残差流</li>
<li>基于Channel-Wise
FFT的频域信息流，用于在频域中捕获图像的全局信息。</li>
</ul>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114155802644.png" alt="image-20220114155802644" style="zoom: 50%;" /></p></li>
<li><p><strong>核心实现-公式表达</strong>（最左侧的频域信息流）</p>
<ol type="1">
<li><span class="math inline">\(F(Z) \in C^{H \times W/2 \times
C}\)</span>,对输入的特征Z，计算 2D real FFT
,由于傅立叶变换两侧对称，所以宽方向可以仅保留一半</li>
<li><span class="math inline">\(\widetilde{Z} = R(F(Z)) \odot_C
I((F(Z))) \in R^{H \times W/2 \times 2C}\)</span>,
将傅立叶变换后的实数部分和虚数部分在Channel层面Concatenate起来</li>
<li>经过2个<span class="math inline">\(1 \times
1\)</span>的卷积层和1个ReLU激活函数层</li>
<li><span class="math inline">\(Y^{fft} = F^{-1}(f^{real} + jf^{img})
\in R^{H \times W \times C}\)</span>应用逆向2D real FFT来将 f <span
class="math inline">\((f^{real} \odot_C f^{img}
)\)</span>变换回空间域</li>
<li><span class="math inline">\(Y = Y^{fft} + Y^{res} +
Z\)</span>，最终输出使用三个相加的形式得到。</li>
</ol></li>
</ul>
<h3 id="deep-residual-fourier-transform-framework">3） Deep Residual
Fourier Transform Framework</h3>
<ul>
<li><p><strong>简介</strong>：基于MIMO-UNet进行的设计，MIMO-UNet是一个用于做多尺度图像去模糊的多输入多输出的U-Net架构。将MIMO-UNet中的所有ResBlocks用该论文提出的Res
FFT-Conv Blocks进行替换。同时，我们额外将所有的<span
class="math inline">\(1 \times
1\)</span>卷积层用我们提出的DO-Conv替换掉了。</p></li>
<li><p>MIMO-UNet 详细可以参见这篇论文：《Rethinking Coarse-to-Fine
Approach in Single Image Deblurring》</p></li>
<li><p><strong>网络结构</strong>：</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114170635133.png" alt="image-20220114170635133" style="zoom:50%;" /></p></li>
</ul>
<h3 id="depthwise-over-parameterized-convolution">4）<strong>Depthwise
over-parameterized convolution</strong></h3>
<ul>
<li><p><strong>简介</strong>：DO-Conv已经在许多高级别的视觉任务中显示出了它的潜力，它加速了训练并且通过使用深度卷积增强卷积层来获得更好的性能。DO-Conv
是两个相邻的线性运算，在操作时可以组合成传统的卷积运算。</p></li>
<li><p>具体可以参见这篇论文《DO-Conv: Depthwise Over-parameterized
Convolutional》</p></li>
<li><p>论文链接：https://arxiv.org/pdf/2006.12030.pdf</p></li>
</ul>
<h3 id="loss-function">5） Loss Function</h3>
<ul>
<li><p><span class="math inline">\(Let\)</span><span
class="math inline">\({k \in {0,……,K-1}}\)</span>为
DeepRFT的第k个层级</p></li>
<li><p><span class="math inline">\({\hat{S_k}}\)</span>为 <span
class="math inline">\(k_{th}\)</span>重建图像</p></li>
<li><p><span class="math inline">\(S_k 为\)</span> <span
class="math inline">\(k_{th}\)</span>GroundTruth清晰的图像</p></li>
<li><p>考虑3种，不同类型的Loss Function：</p>
<ul>
<li><p>Multi-Scale Charbonnier loss：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114171903475.png" alt="image-20220114171903475" style="zoom:50%;" /></p></li>
<li><p>Multi-Scale Edge loss：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114171944558.png" alt="image-20220114171944558" style="zoom:50%;" /></p></li>
<li><p>Multi-Scale Frequency Reconstruction (MSFR)
在频域计算，FT代表FFT操作</p></li>
</ul></li>
</ul>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114172909832.png" alt="image-20220114172909832" style="zoom: 50%;" /></p>
<ul>
<li>最终Loss函数：<span class="math inline">\(L = L_{msc} +
\alpha_1L_{msed}+ \alpha_2L_{msfr}\)</span></li>
<li><span class="math inline">\(\alpha_1\)</span>、<span
class="math inline">\(\alpha_2\)</span>为tradeoff参数，通常为0.05 和
0.01</li>
</ul>
]]></content>
      <categories>
        <category>③  论文阅读笔记</category>
        <category>CV相关论文</category>
      </categories>
      <tags>
        <tag>FFT</tag>
        <tag>Image Deblurring</tag>
        <tag>Residual Block</tag>
      </tags>
  </entry>
  <entry>
    <title>《SwinIR- Image Restoration Using Swin Transformer》论文笔记</title>
    <url>/2022/01/13/45d8498aa8b8/</url>
    <content><![CDATA[<h3
id="论文名称swinir-image-restoration-using-swin-transformer">论文名称：《SwinIR:
Image Restoration Using Swin Transformer》</h3>
<h3
id="论文链接httpsopenaccess.thecvf.comcontenticcv2021waimhtmlliang_swinir_image_restoration_using_swin_transformer_iccvw_2021_paper.html">论文链接：https://openaccess.thecvf.com/content/ICCV2021W/AIM/html/Liang_SwinIR_Image_Restoration_Using_Swin_Transformer_ICCVW_2021_paper.html</h3>
<h2 id="关键词">1、关键词：</h2>
<p>​ 图像修复（Image Restoration）、Transformer</p>
<h2 id="领域背景图像修复">2、领域背景—图像修复：</h2>
<p>​
图像修复是一个经典问题，一般而言其目标为从低分辨率的图像中恢复出高分辨率的图像。通常可以用于超分辨率、图像去噪，以及JPEG压缩鬼影去除等应用。此篇文章将Swin
Transformer应用于图像修复领域中。</p>
<h2 id="先前工作描述与比较">3、先前工作描述与比较：</h2>
<p>​
和CNN比起来，Transformer设计了Self-Attention机制来捕获全局内容之间的信息交互，也在一系列的任务重得到了比较好的结果。但是ViT用于图像恢复的话，因为Vit要划分patch，所以就会不可避免的导致恢复的图像在patch和patch之间有边界感，同时每一个patch邻近边界的像素也会因为缺少信息而没法做出更好的恢复效果。</p>
<p>​
<strong>先前方法的问题</strong>：使用基于CNN的方法进行图像修复：会存在两个源于卷积层本身带来的基本的问题：</p>
<p>1、图像和卷积核之间是内容无关的，我们用同一个卷积核去修复不同的图像区域，可能并不是一个好的选择</p>
<p>2、由于CNN的local processing方案，卷积层是在局部邻域（ local
neighborhood ）内建立像素关系，其长距离的依赖关系（long-range
dependency）主要通过深度叠加卷积层来进行建模，有的时候可能并不是很有效</p>
<p>​ 而Swin
Transformer，结合了两者的优势。既能够像CNN那样处理大尺度的图像，也能弥补CNN在long-range
dependency上的不足（使用SW-MSA机制）</p>
<h2 id="主要设计思想">4、主要设计思想：</h2>
<p>​
SwinIR由三部分组成。首先浅层特征提取部分是由卷积层组成的，输出结果将直接传输到重建模块中，为了保持图像本身的低频信息，而深层特征提取模块主要由RSTB（Residual
Swin Transformer
blocks）组成。同时，其在每一个block的后面还加了一层卷积层，来做特征加强，以及使用残差网络来为特征聚合提供捷径。最终，浅层和深层特征被输送到重建模块，进行高质量的图像重建。总体流程概括如下：</p>
<ul>
<li>浅层特征提取：<strong>低质量图像</strong> <span
class="math inline">\(\to\)</span><strong>浅层特征图</strong></li>
<li>深层特征提取：<strong>浅层特征图</strong><span
class="math inline">\(\to\)</span><strong>深层特征图</strong></li>
<li>高质量图片生成：<strong>浅层特征图</strong>+<strong>深层特征图</strong><span
class="math inline">\(\to\)</span><strong>高质量图像</strong></li>
</ul>
<h2 id="具体方法与网络架构">5、具体方法与网络架构：</h2>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/network_swinir.png" /></p>
<p>​
首先，对于这一整个架构而言，分为3大块，分别是浅层特征提取、深层特征提取以及图像重建，<strong>对于不同的任务而言，我们使用相同的特征提取模块，但是会使用不同的图像重建模块</strong>。</p>
<h3 id="浅层特征提取shallow-feature-extraction">1）浅层特征提取(Shallow
Feature Extraction)</h3>
<ul>
<li><strong>概述</strong>：使用卷积网络从<strong>低质量图像</strong>中提取<strong>浅层特征图</strong></li>
<li><strong>输入</strong>：<strong>低质量图像(LQ)</strong> <span
class="math inline">\(I_{LQ}\in R^{H\times W\times C_{in}}\)</span></li>
<li><strong>输出</strong>：<strong>浅层特征图</strong> <span
class="math inline">\(F_{0}\in R^{H\times W\times
C_{embed}}\)</span>，<span
class="math inline">\(C_{embed}\)</span>为特征通道数目</li>
<li><strong>网络结构</strong>：单层<span
class="math inline">\(3\times3\)</span>卷积网络</li>
<li><strong>公式表达</strong>：<span
class="math inline">\(F_{0}=H_{SF}(I_{LQ})\)</span>，其中<span
class="math inline">\(H_{SF}\)</span>为卷积网络</li>
<li><strong>实现细节（官方代码）</strong>
<ul>
<li><span class="math inline">\(H_{SF}\)</span>为单层，输入图像通道<span
class="math inline">\(C_{in}=3\)</span>，输出特征通道<span
class="math inline">\(C=96\)</span>，步长<span
class="math inline">\(stride=1\)</span>，填充<span
class="math inline">\(pading=1\)</span>的<span
class="math inline">\(3\times3\)</span>卷积网络</li>
</ul></li>
<li><strong>意义</strong>：卷积层在前期的视觉处理中往往能起到较好的效果，能够导致一个较为稳定的结果，同时也提供了一个从图像空间映射到高维特征空间的手段。</li>
</ul>
<h3 id="深层特征提取deep-feature-extraction">2）深层特征提取(Deep
Feature Extraction)：</h3>
<ul>
<li><p><strong>输入</strong>：<strong>浅层特征图</strong><span
class="math inline">\(F_{0}\in R^{H\times W\times
C_{embed}}\)</span></p></li>
<li><p><strong>输出</strong>：<strong>深层特征图</strong><span
class="math inline">\(F_{DF}\in R^{H\times W\times
C_{embed}}\)</span></p></li>
<li><p><strong>网络结构：</strong></p>
<ul>
<li><span class="math inline">\(K\)</span>个串联的Residual Swin
Transformer Block（RSTB）和 <span
class="math inline">\(1\)</span>个卷积层 构成</li>
<li>每个RSTB（Residual Swin Transformer Block）内部由<span
class="math inline">\(L\)</span>个串联的 Swin Transformer Layer（STL）和
一个卷积层构成（如上图a）</li>
<li>STL（Swin Transformer Layer）结构为Layer Norm<span
class="math inline">\(\to\)</span>MSA<span
class="math inline">\(\to\)</span>Layer Norm<span
class="math inline">\(\to\)</span>MLP 且
MSA和MLP后有残差连接（如上图b）</li>
</ul></li>
<li><p><strong>公式表达</strong>：</p>
<ul>
<li><strong>整体结构</strong>：
<ul>
<li><span class="math inline">\(F_i=H_{RSTB_i}(F_{i-1}),\
i=1,2,...,K\)</span></li>
<li><span class="math inline">\(F_{DF}=H_{CONV}(F_{K})\)</span></li>
</ul></li>
<li><strong>RSTB</strong>：
<ul>
<li><span class="math inline">\(F_{i,j}=H_{Swin_{i,j}}(F_{i,j-1}),\
j=1,2,...,L\)</span></li>
<li><span class="math inline">\(F_i=H_{CONV_i}(F_{i,L})\)</span></li>
</ul></li>
<li><strong>STL</strong>：
<ul>
<li><span
class="math inline">\(H_{Swin_{i,j}}(X)=STL_2(STL_1(X))\)</span></li>
<li><span class="math inline">\(STL_1(X)=MSA(LN(X))+X\)</span></li>
<li><span class="math inline">\(STL_2(X)=MLP(LN(X))+X\)</span></li>
</ul></li>
</ul></li>
<li><p><strong>实现细节（官方代码）</strong></p>
<ul>
<li><p><strong>PatchEmbed和PatchUnEmbed操作</strong></p>
<ul>
<li>代码中使用PatchEmbed操作将<span
class="math inline">\(224\times224\)</span>的特征图拆分为<span
class="math inline">\(16\times16\)</span>的Patch，并且有可选的LayerNorm操作</li>
<li>对应的代码中使用PatchUnEmbed操作将<span
class="math inline">\(16\times16\)</span>的Patch还原为<span
class="math inline">\(224\times224\)</span>的特征图</li>
<li>PatchEmbed和PatchUnEmbed操作的执行逻辑如下
<ul>
<li>每一个RSTB的开头，执行PatchEmbed操作</li>
<li>每一个RSTB的卷积操作前，执行PatchUnEmbed操作</li>
<li>只在第一个RSTB开头的PatchEmbed操作中，使用LayerNorm</li>
</ul></li>
</ul></li>
<li><p><strong>RSTB的串联数量（<span
class="math inline">\(K\)</span>的取值）</strong></p>
<ul>
<li>虽然论文图片中的RSTB有6个，但在代码中只有4个，即<span
class="math inline">\(K=4\)</span></li>
</ul></li>
<li><p><strong>STL的串联数量（<span
class="math inline">\(L\)</span>的取值）</strong></p>
<ul>
<li>代码中每个RSTB内部的STL的数目为6个，与论文图片中的一致，即<span
class="math inline">\(L=6\)</span></li>
</ul></li>
<li><p><strong>配对的STL</strong></p>
<ul>
<li>如前述所说，每个RSTB中STL的数目为6个，其中每两个STL构成一组，第一个STL内的MSA为Swin中的W-MSA，第二个为Swin中的SW-MSA，这一操作与原版Swin中的一致</li>
</ul></li>
<li><p><strong>卷积操作</strong></p>
<ul>
<li>对于整个深层特征提取模块末尾和RSTB内部的卷积，代码根据任务不同分为两种
<ol type="1">
<li>对于小模型任务，如一般图片、轻量图片的SR、图片降噪和JPEG格式压缩图像修复，采用的是单层，输入输出维度为<span
class="math inline">\(C_{embed}=96\)</span>，步长<span
class="math inline">\(stride=1\)</span>，填充<span
class="math inline">\(pading=1\)</span>的<span
class="math inline">\(3\times3\)</span>卷积网络</li>
<li>对于大模型任务，如真实世界图片SR，采用的是一个多层卷积网络
<ul>
<li>第一层为输入维度为<span
class="math inline">\(C_{embed}=96\)</span>，输出维度为<span
class="math inline">\(C_{embed}/4\)</span>，步长<span
class="math inline">\(stride=1\)</span>，填充<span
class="math inline">\(pading=1\)</span>的<span
class="math inline">\(3\times3\)</span>卷积网络，并对输出进行LeakyReLu</li>
<li>第二层为输入维度为<span
class="math inline">\(C_{embed}/4\)</span>，输出维度为<span
class="math inline">\(C_{embed}/4\)</span>，步长<span
class="math inline">\(stride=1\)</span>，填充<span
class="math inline">\(pading=1\)</span>的<span
class="math inline">\(3\times3\)</span>卷积网络，并对输出进行LeakyReLu</li>
<li>第三层为输入维度为<span
class="math inline">\(C_{embed}/4\)</span>，输出维度为<span
class="math inline">\(C_{embed}\)</span>，步长<span
class="math inline">\(stride=1\)</span>，填充<span
class="math inline">\(pading=1\)</span>的<span
class="math inline">\(3\times3\)</span>卷积网络</li>
</ul></li>
</ol></li>
</ul></li>
</ul></li>
<li><p><strong>意义</strong>：</p>
<ul>
<li>作者认为在所有RSTB后面，再加一层Conv层，能够将卷积操作的归纳偏置(inductive
bias)带入这类基于Transformer骨架的网络中，为后续浅层和深层特征的融合打好基础。</li>
<li><!--具体的作用需要通过实验验证，这个Conv层是否是必要的。--></li>
<li>对于单个RSTB内部的卷积操作，论文认为卷积核在空间上的不变性可以增强提取出特征的平移不变性</li>
<li>残差连接为不同的RSTB模块提供了一个到后续图像重建模块的短连接，允许不同级别的特征在最后一个重建模块中更好的进行聚合。</li>
<li><!--同样，具体的作用需要通过实验验证，这个Conv层是否是必要的。--></li>
</ul></li>
</ul>
<h3 id="高质量图像修复-hq-image-reconstruction">3）高质量图像修复 (HQ
Image Reconstruction)：</h3>
<ul>
<li><strong>概述</strong>：根据<strong>浅层与深层特征图</strong>生成<strong>高质量图像</strong>，浅层特征负责包含低频信息，深层特征聚焦于恢复丢失的高频信息。</li>
<li><strong>输入</strong>：<strong>浅层特征图</strong> <span
class="math inline">\(F_{0}\in R^{H\times W\times C_{embed}}\)</span>和
<strong>深层特征图</strong> <span class="math inline">\(F_{DF}\in
R^{H\times W\times C_{embed}}\)</span></li>
<li><strong>输出</strong>：<strong>高质量重建图像(RHQ)</strong> <span
class="math inline">\(I_{RHQ}\in R^{H&#39;\times W&#39;\times
C_{out}}\)</span></li>
<li><strong>网络结构</strong>：卷积网络</li>
<li><strong>公式表达</strong>：<span
class="math inline">\(I_{RHQ}=H_{REC}(F_{0}+F_{DF})\)</span>，其中<span
class="math inline">\(H_{REC}\)</span>为重建模块函数，其实在实现上就是一个卷积模块</li>
<li><strong>实现细节（官方代码）</strong>
<ul>
<li><span
class="math inline">\(H_{REC}(F_{0}+F_{DF})\)</span>中的“+”号就是数学意义上的相加，本质上是残差连接</li>
<li><strong>卷积操作</strong>
<ul>
<li>根据任务不同分为四种卷积操作：
<ol type="1">
<li>对于图像去噪和JPEG格式压缩图像修复，采用的是单层，输入维度为<span
class="math inline">\(C_{embed}=96\)</span>，输出维度为<span
class="math inline">\(C_{out}=3\)</span>，步长<span
class="math inline">\(stride=1\)</span>，填充<span
class="math inline">\(pading=1\)</span>的<span
class="math inline">\(3\times3\)</span>卷积网络，同时卷积输出与输入使用残差连接，即<span
class="math inline">\(H_{REC}(X)=H_{CONV}(X)+X\)</span></li>
<li>对于一般图像SR，卷积分为三层
<ul>
<li>第一层进行特征降维，为输入维度为<span
class="math inline">\(C_{embed}=96\)</span>，输出维度为<span
class="math inline">\(C_{feat}=64\)</span>，步长<span
class="math inline">\(stride=1\)</span>，填充<span
class="math inline">\(pading=1\)</span>的<span
class="math inline">\(3\times3\)</span>卷积网络，并对卷积输出进行LeakyReLU</li>
<li>第二层进行上采样，先通过输入维度为<span
class="math inline">\(C_{feat}=64\)</span>，输出维度为<span
class="math inline">\(4\times C_{feat}\)</span>，步长<span
class="math inline">\(stride=1\)</span>，填充<span
class="math inline">\(pading=1\)</span>的<span
class="math inline">\(3\times3\)</span>卷积网络，然后对卷积输出进行PixelShuffle</li>
<li>第三层为输入维度为<span
class="math inline">\(C_{feat}=64\)</span>，输出维度为<span
class="math inline">\(C_{out}=3\)</span>，步长<span
class="math inline">\(stride=1\)</span>，填充<span
class="math inline">\(pading=1\)</span>的<span
class="math inline">\(3\times3\)</span>卷积网络</li>
</ul></li>
<li>对于轻量图像SR，为了减少参数，采用的是单层，输入维度为<span
class="math inline">\(C_{feat}=64\)</span>，输出维度为<span
class="math inline">\(Scale^2\times C_{out}\)</span>，步长<span
class="math inline">\(stride=1\)</span>，填充<span
class="math inline">\(pading=1\)</span>的<span
class="math inline">\(3\times3\)</span>卷积网络，然后对卷积输出进行PixelShuffle</li>
<li>对于真实世界图像SR，使用多层卷积
<ul>
<li>第一层进行特征降维，为输入维度为<span
class="math inline">\(C_{embed}=96\)</span>，输出维度为<span
class="math inline">\(C_{feat}=64\)</span>，步长<span
class="math inline">\(stride=1\)</span>，填充<span
class="math inline">\(pading=1\)</span>的<span
class="math inline">\(3\times3\)</span>卷积网络，并对卷积输出进行LeakyReLu</li>
<li>第二、三层进行上采样，先使用torch.nn.functional.interpolate函数进行指定<span
class="math inline">\(Scale\)</span>的最近邻上采样，然后通过输入输出维度为<span
class="math inline">\(C_{feat}=64\)</span>，步长<span
class="math inline">\(stride=1\)</span>，填充<span
class="math inline">\(pading=1\)</span>的<span
class="math inline">\(3\times3\)</span>卷积网络，并对卷积输出进行LeakyReLU</li>
<li>第四层为输入输出维度为<span
class="math inline">\(C_{feat}=64\)</span>，步长<span
class="math inline">\(stride=1\)</span>，填充<span
class="math inline">\(pading=1\)</span>的<span
class="math inline">\(3\times3\)</span>卷积网络，并对卷积输出进行LeakyReLU</li>
<li>第五层为输入维度为<span
class="math inline">\(C_{feat}=64\)</span>，输出维度为<span
class="math inline">\(C_{out}=3\)</span>，步长<span
class="math inline">\(stride=1\)</span>，填充<span
class="math inline">\(pading=1\)</span>的<span
class="math inline">\(3\times3\)</span>卷积网络</li>
</ul></li>
</ol></li>
</ul></li>
</ul></li>
</ul>
<h3 id="其他细节">4） 其他细节：</h3>
<p>​
上述总的结构中看到的<strong>Skip-Connection</strong>，是能够将浅层特征直接输入到重建模块中，让深层特征提取模块专注于高频信息的提取以及能够获得更稳定的训练。</p>
<h3 id="使用的损失函数根据任务情况略有不同">5）
使用的损失函数：（根据任务情况略有不同）</h3>
<ul>
<li><p>对于一般图像以及轻量图像SR，使用<strong>L1 Loss</strong>,<span
class="math inline">\(I_{RHQ}\)</span>为重建的高质量图像，<span
class="math inline">\(I_{HQ}\)</span>为Ground_Truth高质量图像</p>
<ul>
<li><span class="math inline">\(L = \sqrt{||I_{RHQ} - I_{HQ}
||_1}\)</span></li>
</ul></li>
<li><p>对于真实世界图像SR，会结合<strong>Pixel
Loss</strong>和<strong>GAN Loss</strong>以及<strong>Percepture
Loss</strong>来提升生成质量</p></li>
<li><p>对于去噪和JPEG压缩任务而言，我们使用<strong>Charbonnier
Loss</strong>进行优化</p>
<ul>
<li><span class="math inline">\(\sqrt{||I_{RHQ}-I_{HQ}||^2 +
\varepsilon^2 }\)</span>, <span
class="math inline">\(\varepsilon\)</span>是个常数，通常被设置为<span
class="math inline">\(10^{-3}\)</span></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>③  论文阅读笔记</category>
        <category>CV相关论文</category>
      </categories>
      <tags>
        <tag>Swin Transformer</tag>
        <tag>Image Restoration</tag>
      </tags>
  </entry>
  <entry>
    <title>《Uformer A General U-Shaped Transformer for Image Restoration》论文笔记</title>
    <url>/2022/01/13/56f3e5f0e0f5/</url>
    <content><![CDATA[<h3
id="论文名称uformer-a-general-u-shaped-transformer-for-image-restoration">论文名称：《Uformer:
A General U-Shaped Transformer for Image Restoration》</h3>
<h3 id="论文地址-httpsarxiv.orgabs2106.03106">论文地址：
https://arxiv.org/abs/2106.03106</h3>
<h2 id="关键词">1、关键词：</h2>
<p>​ 图像修复（Image Restoration）、类UNet结构、Transformer</p>
<h2 id="领域背景图像修复">2、领域背景—图像修复：</h2>
<p>​
图像修复是一个经典问题，一般而言其目标为从低分辨率的图像中恢复出高分辨率的图像。通常可以用于超分辨率、图像去噪，以及JPEG压缩鬼影去除等应用。此篇文章将Swin
Transformer应用于图像修复领域中。</p>
<h2 id="先前工作描述与比较">3、先前工作描述与比较：</h2>
<p>​ 近年来图像修复很好结果的都是基于卷积的网络，但是卷积网络在long-range
dependencies上依旧存在局限性。同时，最近也有很多文章使用transofmer对低分辨率的特征图进行处理（限于self-attention的计算复杂度）。</p>
<h2 id="主要设计思想">4、主要设计思想：</h2>
<p>​ 论文旨在
在多尺度分辨率下，去恢复更多的图像细节。Uformer基于UNet，只不过将所有的卷积层替换为了Encoder-Decoder结构，同时保留了整体的Encoder-Decoder架构以及skip-connections。总体来说就是使用TransformerBlock
构建了一个层次化的encoder-decoder网络。</p>
<p>​ <strong>2个核心设计</strong></p>
<p>​ 1、<strong>LeWin Transformer Block</strong>( locally-enhanced window
Transformer block
),使用分块的self-attetiond代替全局的self-attention，在捕获高分辨率图像的局部特征时，减少了计算量。</p>
<p>​ 2、提出了<strong>可学习的多尺度恢复调制器</strong>，以多尺度
<strong>spatial bias</strong>
的形式去在decoder的不同层上调节特征。来处理不同的图像退化问题（比如说虚焦、运动模糊等。这个模块本身由一个多尺度的spatial
bias组成，用来在decoder的不同层级上调整特征。更具体一点的话，就是一个可学习的基于窗口的tensor张量，和特征直接相加，从而来调整特征能够恢复更多的细节。整体而言，这个调制器对于恢复图像细节而言有非常强的能力，同时只带来了一点点额外的参数和计算代价。</p>
<h2 id="具体方法与网络架构">5、具体方法与网络架构：</h2>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220112112308268.png" /></p>
<h3 id="整体架构overall-pipeline">1) 整体架构（Overall Pipeline）</h3>
<ul>
<li><strong>概述</strong>：U型带Skip-Connection的Encoder-Decoder网络，基于UNet结构，但是将UNet中的所有卷积层都替换成了LeWinBlocks。</li>
<li><strong>输入</strong>：退化图像 <span class="math inline">\(I \in
R^{3\times H\times W}\)</span></li>
<li><strong>输出</strong>：修复图像 <span
class="math inline">\(I^{&#39;} \in R^{3\times H\times W}\)</span>
<ul>
<li><span class="math inline">\(Residual \in R^{3\times H\times W
}\)</span></li>
<li><span class="math inline">\(I^{&#39;} = I + R e sidual\)</span></li>
</ul></li>
</ul>
<h3 id="input-projection">2) Input Projection</h3>
<ul>
<li><strong>概述</strong>：用于从退化图像中提取低层级信息</li>
<li><strong>输入</strong>：退化图像 <span class="math inline">\(I \in
R^{3\times H\times W}\)</span></li>
<li><strong>输出</strong>：low-level 特征图 <span
class="math inline">\(X_0\)</span></li>
<li><strong>网络结构</strong>：
<ul>
<li><span class="math inline">\(3\times 3\)</span>卷积层 +
LeakyReLU激活函数</li>
</ul></li>
</ul>
<h3 id="encoder---one-stage-encoder中总共k个stage">3) Encoder - One
Stage （ Encoder中总共K个Stage ）</h3>
<ul>
<li><strong>概述</strong>：用于从退化图像中提取低层级信息</li>
<li><strong>输入</strong>：特征图 <span
class="math inline">\(X_{l-1}\)</span></li>
<li><strong>输出</strong>：第<span
class="math inline">\(l\)</span>个阶段的输出特征图 <span
class="math inline">\(X_l \in R^{2^lC \times \frac{H}{2^l} \times
\frac{W}{2^l}}\)</span></li>
<li><strong>网络结构</strong>：
<ul>
<li><span class="math inline">\({N_l}\)</span>个
LeWinBlocks的叠加，以及一个下采样层（$4 $卷积 $stride$2）</li>
</ul></li>
<li><strong>实现细节（官方代码）</strong>
<ul>
<li>LeWinBlocks
<ul>
<li>将2D空间特征图先进行patch划分，然后展平，具体见后</li>
</ul></li>
<li>Down Sampling：（channel 翻倍，特征图宽高 减半）
<ul>
<li>Reshape 展平的特征 至 2D的空间特征图，然后使用 <span
class="math inline">\(4 \times 4\)</span>卷积
$stride$2，对其进行卷积</li>
</ul></li>
</ul></li>
<li><strong>意义</strong>：在一遍遍的下采样与Lewin Transformer
Blocks中提取特征信息，Lewin Transformer
Block可以更好的提取远距离的相关性依赖信息，并且有效的降低计算复杂度</li>
</ul>
<h3 id="bottleneck-stage">4) BottleNeck Stage</h3>
<ul>
<li><strong>概述</strong>：用于提取更长距离的信息，甚至是全局的信息</li>
<li><strong>输入</strong>：特征图 <span
class="math inline">\(X_{K}\)</span></li>
<li><strong>输出</strong>：序列向量 V</li>
<li><strong>网络结构</strong>：
<ul>
<li><span class="math inline">\({N_?}\)</span>个 LeWinBlocks的叠加</li>
</ul></li>
<li><strong>实现细节（官方代码）</strong>
<ul>
<li>LeWinBlocks
<ul>
<li>将2D空间特征图先进行patch划分，然后展平，具体见后</li>
</ul></li>
</ul></li>
<li><strong>意义</strong>：由于前面已经进行了许多次的特征提取以及下采样了，所以在此处再增加一个LeWinBlocks的模块，能够捕获到更长距离的信息，甚至是能够捕获全局的信息。</li>
</ul>
<p><!-- 但是这个模块难道不可以用Encoder阶段更大的K 来弥补吗？需要实验 --></p>
<h3
id="decoder---one-stage-decoder中总共k个stage与encoder一致">5）Decoder -
One Stage （Decoder中总共K个Stage，与Encoder一致 ）</h3>
<ul>
<li><strong>概述</strong>：用于小尺寸的特征图中逐渐重建恢复特征信息</li>
<li><strong>输入</strong>：1维特征序列 <span
class="math inline">\(V_{in}\)</span></li>
<li><strong>输出</strong>：1维特征输出序列 <span
class="math inline">\(V_{out}\)</span></li>
<li><strong>网络结构</strong>：
<ul>
<li>一个上采样层（$2 $反卷积 $stride$2）以及 <span
class="math inline">\({N_l}\)</span>个 LeWinBlocks的叠加</li>
</ul></li>
<li><strong>实现细节（官方代码）</strong>
<ul>
<li>Up Sampling：（channel 减半，特征图宽高 翻倍）
<ul>
<li>先将输入的特征序列 Reshape 成
2D特征图，然后进行上采样，得到新的2D特征图</li>
</ul></li>
<li>Residual Module：
<ul>
<li>Up Sampling 完以后得到的2D特征图需要和对应Encoder-Stage中
输出的2D特征图进行Concat，然后得到一个新的2D特征图。</li>
</ul></li>
<li>LeWinBlocks
<ul>
<li>将残差Concat得到的2D空间特征图先进行patch划分，然后展平，具体见后</li>
</ul></li>
</ul></li>
<li><strong>意义</strong>：在一遍遍的上采样与Lewin Transformer
Blocks中重建特征信息。</li>
</ul>
<h3 id="output-projection">6) Output Projection</h3>
<ul>
<li><strong>概述</strong>：用于将输出的序列，变换成2D特征图后，再 映射至
3通道的残差图像，准备和原图像叠加。</li>
<li><strong>输入</strong>：1维特征输出序列 <span
class="math inline">\(V_{out}\)</span></li>
<li><strong>输出</strong>：残差图像 <span class="math inline">\(Residual
\in R^{3\times H\times W }\)</span></li>
<li><strong>网络结构</strong>：
<ul>
<li><span class="math inline">\(3\times 3\)</span>卷积层</li>
</ul></li>
<li><strong>实现细节（官方代码）</strong>：
<ul>
<li>先将 最后一个Decoder Stage输出的 序列 <span
class="math inline">\(V_{out}\)</span>Reshape成2D的特征图，然后应用<span
class="math inline">\(3 \times
3\)</span>的卷积层，来获得一个残差图像</li>
</ul></li>
</ul>
<h3 id="最终输出-loss函数">7）最终输出 &amp; Loss函数</h3>
<ul>
<li><strong>概述</strong>：将OutPut Projection 得到的Residual Image 和
原来的输入图像相加，得到 最终的修复图像。</li>
<li><strong>Loss</strong>：使用 <strong>Charbonnier Loss</strong>，<span
class="math inline">\(I^{&#39;}\)</span>是 ground-truth 图像
<ul>
<li><span class="math display">\[l(I^{&#39;},\hat I) = \sqrt{||I^{&#39;}
- \hat I||^2 + \varepsilon^2}\]</span></li>
</ul></li>
</ul>
<h3 id="lewin-transformer-block">8）LeWin Transformer Block</h3>
<ul>
<li><p><strong>概述</strong>：由W-MSA 以及LeFF两个模块组成</p></li>
<li><p><strong>输入</strong>：2D特征图</p></li>
<li><p><strong>输出</strong>：2D特征图</p></li>
<li><p><strong>网络结构</strong>：公式表达：</p>
<ul>
<li><span class="math inline">\(X_{l}^{&#39;} = W-MSA(LN(X_{l-1})) +
X_{l-1}\)</span><strong>W-MSA 模块的输出</strong></li>
<li><span class="math inline">\(X_l = LeFF(LN(X_l^{&#39;})) +
X_l^{&#39;}\)</span>**LeFF模块的输出*</li>
</ul></li>
<li><p><strong>实现细节（官方代码）</strong>：</p>
<ul>
<li><p>W-MSA 与 Vision Transformer中一致</p></li>
<li><p>作者论文中说尝试了移动窗口，但是带来的结果好坏增长微乎其微，说明：在图像修复领域，窗口与窗口之间的信息交互并不是很重要。图像修复领域比较注重局部的信息交互？</p></li>
<li><p>LeFF模块结构：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/截屏2022-01-12%20下午3.31.12.png" /></p>
<ul>
<li>1、对于每个Token，应用一个Linear Projection，增加特征channel</li>
<li>2、将tokens Reshape 成 2D 特征图，用 <span class="math inline">\(3
\times 3\)</span>depth-wise convolutional 捕获局部信息</li>
<li>3、再将2D特征图展平回tokens，再应用一个Linear
Projection，缩减特征channel</li>
<li>在每一个Linear Projection / Convolution 后都会应用
GELU激活函数。</li>
</ul></li>
</ul></li>
<li><p><strong>意义</strong>：解决了如下两个问题
1）全局计算self-attention复杂度太高
2）在捕捉局部的依赖关系时有限制。</p></li>
</ul>
<h3 id="multi-scale-restoration-modulator">9）Multi-Scale Restoration
Modulator</h3>
<ul>
<li><strong>概述</strong>：因为不同的图像有不同的混乱残差形式，比如模糊、噪音、下雨等等，为了更好的应对各种不同的修复任务，提出了这个light-weight
multi-scale的恢复模块。来calibrate特征以及更好的修复细节。<br />
</li>
<li><strong>网络结构</strong>：
<ul>
<li>在每一个LeWin Transformer Block中，其为一个<span
class="math inline">\(M \times M \times
C\)</span>大小的张量，M为window_size，C为特征图通道数。</li>
<li>在一个LeWin Transformer Block中，对于所有其分割出来的windows，这个
调制器模块的参数都是共享的。</li>
</ul></li>
<li><strong>形式</strong>：在Self-Attention计算前，将其直接加到每一个窗口的像素值上。</li>
<li><strong>意义</strong>：在Image Deblurring 和 Image
Denoising里面，作者证实了该模块的重要性，能够更好的修复细节。一种可能的解释是添加
在解码器的每个阶段的modulator可以对特征图进行更为灵活的调整，从而提高恢复的细节的性能表现。这个跟先前的StyleGAN的某个模块一致。</li>
</ul>
]]></content>
      <categories>
        <category>③  论文阅读笔记</category>
        <category>CV相关论文</category>
      </categories>
      <tags>
        <tag>UNet</tag>
        <tag>Swin Transformer</tag>
        <tag>Image Restoration</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习基础系列笔记6——全卷积网络FCN &amp; U-Net结构</title>
    <url>/2022/01/12/8c9b3da724b3/</url>
    <content><![CDATA[<p>本文讲解FCN与U-Net相关的知识，在此之前你需要了解CNN是什么</p>
<h3 id="一fcn全卷积网络">一、FCN全卷积网络</h3>
<p>​
首先，我们还是要回顾一下CNN的整体网络架构与优势：CNN网络最后输出的是类别的概率值。CNN
的强大之处在于它的多层卷积结构能自动学习特征，并且可以学习到多个层次的特征：</p>
<p>​ 较浅的卷积层感知域较小，学习到一些局部区域的特征。</p>
<p>​
而较深的卷积层具有较大的感知域，能够学习到更加抽象一些的特征。这些抽象特征对物体的大小、位置和方向等敏感性更低，从而有助于识别性能的提高。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114212245766.png" /></p>
<p>​
而FCN相较于CNN来说，其将CNN最后几个用于输出概率的全连接层都改成了卷积层，从而使得模型网络中所有的层都是卷积层，最终输出一张已经label好的图像，故称为全卷积网络。全卷积神经网络主要使用了三种技术：</p>
<p>​ 1、卷积化（Convolutional）</p>
<p>​ 2、上采样（Upsample）</p>
<p>​ 3、跳跃结构（Skip Layer）</p>
<p>​ 整个FCN网络基本原理如图5（只是原理示意图）：</p>
<p>​ 1、image经过多个卷积和+一个max pooling变为pool1
feature，宽高变为1/2</p>
<p>​ 2、pool1 feature再经过多个conv+一个max pooling变为pool2
feature，宽高变为1/4</p>
<p>​ 3、pool2 feature再经过多个conv+一个max pooling变为pool3
feature，宽高变为1/8</p>
<p>​ 4、......</p>
<p>​ 5、直到pool5 feature，宽高变为1/32。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/dsawqeasd.png" /></p>
<p>那么，对于三种不同规格参数的FCN，后续还原操作也不太一样，如下所示：</p>
<p>​ 1、对于FCN-32s，直接对pool5 feature进行32倍上采样获得32x upsampled
feature，再对32x upsampled feature每个点做softmax prediction获得32x
upsampled feature prediction（即语义分割图）。</p>
<p>​ 2、对于FCN-16s，首先对pool5 feature进行2倍上采样获得2x upsampled
feature，再把pool4 feature和2x upsampled
feature逐点相加，然后对相加的feature进行16倍上采样，并softmax
prediction，获得16x upsampled feature prediction。</p>
<p>​ 3、对于FCN-8s，首先进行pool4+2x upsampled
feature逐点相加，然后又进行pool3+2x
upsampled逐点相加，即进行更多次特征融合。具体过程与16s类似，不再赘述。</p>
<p>​ 在上述处理过程中，我们发现FCN-16s和FCN-8s都引入了skip
connection，将pool3或是pool4
feature与pool5上采样后的feature逐像素相加，进行多次特征融合，这样处理的原因在于：</p>
<p>​
FCN模型虽然通过卷积和反卷积我们基本能定位到目标区域，但是，我们会发现模型前期是通过卷积、池化、非线性激活函数等作用输出了特征权重图像，我们经过反卷积等操作输出的<strong>图像实际是很粗糙的</strong>，毕竟丢了很多细节。因此我们需要找到一种方式填补丢失的细节数据，所以就有了跳跃结构。</p>
<p>​ 作者在原文种给出3种网络结果对比，明显可以看出效果：FCN-32s &lt;
FCN-16s &lt; FCN-8s，即使用多层feature融合有利于提高分割准确性。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114212421618.png" /></p>
<h4 id="fcn优点">FCN优点：</h4>
<p>​
与传统用CNN进行图像分割的方法相比，FCN有两大明显的优点：一是可以接受任意大小的输入图像，而不用要求所有的训练图像和测试图像具有同样的尺寸。二是更加高效，因为避免了由于使用像素块而带来的重复存储和计算卷积的问题。</p>
<h4 id="fcn缺点">FCN缺点：</h4>
<p>1、分割的结果不够精细。图像过于模糊或平滑，没有分割出目标图像的细节</p>
<p>2、因为模型是基于CNN改进而来，即便是用卷积替换了全连接，但是依然是独立像素进行分类，没有充分考虑像素与像素之间的关系</p>
<h2
id="二关于卷积网络中降采样与上采样以及特征提取阶段的理解">二、关于卷积网络中降采样与上采样以及特征提取阶段的理解：</h2>
<p>​
1、降采样的理论意义是，它可以增加对输入图像的一些小扰动的鲁棒性，比如图像平移，旋转等，减少过拟合的风险，降低运算量，增加感受野的大小。</p>
<p>​
2、上采样的最大的作用其实就是把抽象的特征再还原到原图的尺寸，最终得到分割结果。但很容易得到模糊或过于平滑的结果，无法还原细节部分。</p>
<p>​
3、对于特征提取阶段，浅层结构可以抓取图像的一些简单的特征，比如边界，颜色，而深层结构因为感受野大了，而且经过的卷积操作多了，能抓取到图像的一些抽象特征。</p>
<h3 id="三unet网络">三、UNet网络</h3>
<p>​ UNet网络整体结构如下：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114212533302.png" /></p>
<p>​ 蓝色箭头代表3*3的卷积层+ReLU激活函数层</p>
<p>​ 红色箭头代表2*2的最大池化层</p>
<p>​ 绿色箭头代表2*2的上采样层（通常采用反卷积）</p>
<p>​ 浅蓝色箭头代表1*1的卷积层，在最后用于调整输出通道数目</p>
<p>​
在整一个过程中，值得注意的是灰色箭头，我们会注意到灰色箭头代表的是“copy
and crop”，即复制和剪切。我们以第一层的灰色箭头举例来看：其左侧大小为64
* 568 * 568，右侧大小为128 * 392 *
392。其中，右侧有64个通道的数据来源于左侧，64个通道的数据来源于上一层的上采样。那么灰色箭头应该就是把左侧的内容复制到了右侧，并且concat在了原先上采样后得到的64
* 392 * 392的数据上，形成了128 * 392 * 392的数据。</p>
<p>​ 但是问题在于，568 * 568和392 *
392还有较大的尺寸差别，这就需要利用crop来完成，由于在每个卷积中都会丢失边界像素，因此裁剪crop是必要的</p>
<p>​
在上述网络形式中，最重要的结构就是其中的<strong>skip-connection</strong>。UNet中<strong>Concat</strong>形式的skip-connection的好处是，<strong>对于分割这个任务，空间域信息非常重要</strong>。而网络的encoder部分，通过各个pooling层已经把特征图分辨率降得非常小了，这一点不利于精确的分割mask生成，通过skip-connection可以把较浅的卷积层特征引过来，那些特征分辨率较高，且层数浅，会含有比较丰富的low-level信息，更利于生成分割mask。</p>
<p>​
总体来说，就是把对应尺度上的特征信息引入到上采样或反卷积过程，为后期图像分割提供多尺度多层次的信息，由此可以得到更精细的分割效果，如U-Net论文描述的分割结果一样。这比单纯用编解码器框架要好，纯粹的编解码器框架，在编码过程中压缩和丢失了大量细节信息，而这些信息很可能会有助于后期的图像分割。</p>
<p>​
同时，需要注意的一点是：此处的skip-connection与ResNet中直接相加形式的skip-connection不同，ResNet中的跳跃连接可以有效的减少梯度消失和网络退化问题，使训练更容易。直观上理解可以认为BP的时候，深层的梯度可以更容易的传回浅层，因为这种结构的存在，对神经网络层数的设定可以更随意一些。</p>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Basic系列笔记</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>FCN</tag>
        <tag>UNet</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习基础系列笔记5——1x1卷积 &amp; 部分卷积 &amp; 空洞卷积 &amp; 可变形卷积</title>
    <url>/2022/01/07/3664afb64da5/</url>
    <content><![CDATA[<h3 id="一1-x-1-卷积">一、1 X 1 卷积</h3>
<h4 id="实现特征的升降维">1、实现特征的升降维</h4>
<p>​
当1*1卷积出现时，在大多数情况下它作用是升/降特征的维度，这里的维度指的是通道数（厚度），而不改变图片的宽和高。</p>
<p>​
因为1*1的卷积核，并不会改变图像的宽和高，但是其能够通过卷积核的数量，来调节输出的feature
map的通道数。同时，其对不同通道上的像素点进行线性组合，有助于通道间信息的交互和整合过程</p>
<h4 id="减少模型参数量">2、减少模型参数量</h4>
<p>​ 这一想法最早在GoogleNet中被提出，比如说如下两个Inception模块：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114211201756.png" /></p>
<p>​
从直观上来看，感觉像是只有3*3卷积的模块会拥有更少的训练数据，实则不然，我们可以计算一下训练数据个数：</p>
<p><strong>情况1:</strong></p>
<ol type="1">
<li><p>1 * 1卷积部分： 96 * 32 * 1 * 1= 3072个</p></li>
<li><p>3 * 3卷积部分： 32 * 48 * 3 * 3= 13824个</p>
<p>总计16896个训练参数</p></li>
</ol>
<p><strong>情况2:</strong> 总计 96*48*3*3 = 41472个训练参数</p>
<p>​ 从实际上来看，带1 *
1卷积的模型参数量更少，本质原因是因为1*1的卷积对数据的特征向量进行了降维的处理，使得特征通道数目先有了一定的减少。</p>
<p>​ 如下所示：在ResNet中的残差模块使用1*1的卷积核的意义也在于此：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114211323250.png" /></p>
<h3 id="二空洞卷积dilated-convolution">二、空洞卷积（Dilated
Convolution）</h3>
<p>​
顾名思义，其做法就是在卷积map中加入空洞的部分，以此增加感受域。如下图所示，</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114211417135.png" /></p>
<p>​ 右侧为普通卷积，左侧为空洞卷积。</p>
<p>​
这个做法起源于最开始的语义分割领域，主要问题在于CNN本身可能存在一些致命性的缺陷，比如up-sampling和pooling
layer的设计。问题主要在于：</p>
<p>​ 1、上采样和池化层是人为设计好的，是不可学习的。</p>
<p>​ 2、容易丢失内部数据结构与空间的层次化信息</p>
<p>​ 3、小物体的信息无法重建，假设有多个pooling
layer，那么从理论上来讲在一定小的范围内的像素的物体是无法被重建的。</p>
<p>​
所以有人提出了空洞卷积的思想。其本身避免了一部分上述讲到的2、3的问题，但是其也存在一些潜在问题，具体可以参考：<a
href="https://www.zhihu.com/question/54149221">如何理解空洞卷积（dilated
convolution）？</a></p>
<p>​
最终，图森组提出了一个HDC的设计结构，来满足整个基于空洞卷积的设计。较为具体的内容也可以参考上述的文章。</p>
<h3 id="三部分卷积partial-convolution">三、部分卷积（Partial
Convolution）</h3>
<p>​ 部分卷积在这篇论文中被提出，用于进行图像补全的任务，《Image
Inpainting for Irregular Holes Using Partial Convolutions》</p>
<p>​
在图像补全领域中，这篇论文前通常使用卷积层对有效像素和mask像素无差别的做卷积，容易导致颜色差异和伪影。而且先前的工作都是聚焦于一个图像中心的规则区域，并且都需要很昂贵的后处理机制。</p>
<p>​
相比于人们以前使用的非神经网络的方法（PatchMatch等），使用神经网络的方法容易学习到语义的优点和有意义的隐藏表示信息，对于图像补全有很大的意义。但是这些网络使用卷积核的时候，使用一个固定的值将输入图像中被mask的地方代替，然后去卷积，这样就很容易导致孔洞区域内的纹理缺失，或者是边缘出现伪影。（就比如说使用经典卷积的U-Net架构。</p>
<p>​
具体一点，如下图所示：先使用固定值m替换掉mask为0的区域，然后进行卷积。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114211456573.png" /></p>
<p>​
而在这篇论文中提出了部分卷积的概念，只针对于有有效像素的部分进行卷积，并且能够自动的更新mask。</p>
<h4 id="部分卷积公式">1、部分卷积公式：</h4>
<p>​ 首先如下所示为部分卷积的公式：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114211521396.png" /></p>
<p>​
仍然以如下所示为例：红色代表图像数据，蓝色代表mask数据，绿色代表卷积核。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114211532929.png" /></p>
<p>我们选择其中红色图像中的两个蓝色框起来的部分做卷积，作为示例：</p>
<p>首先公式中各个运算符号的含义如下英文描述所示，总体的步骤主要就是：</p>
<p>​ 1）将被卷积的区域先展开，形成X</p>
<p>​ 2）将mask对应的区域展开，形成M</p>
<p>​
3）X和M做点对点乘积⊙，然后再乘上一个缩放因子，来调整有效输入的变化量。</p>
<p>​
4）SUM(1)代表区域大小和卷积核一致，但值都是1的区域，所以在此处SUM(1)为9，而SUM(M)为7，因为该对应区域的mask中有7个1.</p>
<p>​ 5）最后再将卷积核展开形成W，两个向量相乘就完成了该区域的卷积。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/图片2.png" /></p>
<p>​ 另外一个区域，由于mask内的值都是0，所以最终输出的值直接为0.</p>
<h4 id="自动更新mask规则">2、自动更新Mask规则</h4>
<p>​
具体更新规则描述如下：如果卷积能够根据至少一个有效输入值来计算输出输出，那么我们在下一步中，就把此像素点的mask标记为1.再讲的通俗一点，其实就是该范围的mask内只要有1，那就在下一层的卷积中，更新mask在此点的值至1.</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114211755555.png" /></p>
<p>​ 具体的示例如下所示：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/图片3.png" /></p>
<p>​
所以你会发现，在部分卷积的自动更新mask的过程中，只要部分卷积层叠加的足够多，最后任何mask都会逐渐变为所有都是1的形式，从而计算出需填补区域的内容。</p>
<p>​
所以最终该论文在图像边界使用带有适当掩码的部分卷积来代替典型的填充。这确保了图像mask边缘处的修复内容不会受到图像外部无效值的影响。</p>
<h3 id="四可变形卷积deformable-convolution">四、可变形卷积（Deformable
Convolution）</h3>
<p>​
普通的卷积在应对一些物体复杂形变的场景的时候，往往无法得到好的结果。这个时候就有人提出了可变性卷积。</p>
<p>​ 简单而言，Deformable Conv
在感受野中引入了偏移量，而且这偏移量是可学习的，这样可以使得感受野不再是单一的方形，而是能够尽可能与物体的实际形状贴近，于是卷积区域便始终覆盖在物体形状周围，无论物体如何形变，加入可学习的偏移量后都可以搞定。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114211950684.png" alt="image-20220114211950684" style="zoom:150%;" /></p>
<p>​</p>
<p>​ 一个二维的卷积通常由两步组成，第一步是使用一个grid
R去到输入的特征图上进行采样。第二步是根据卷积核的权重，对所有采样的点进行加权求和。比如说像下述这样一个就定义了一个3*3的方形的被卷积区域。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114212003778.png" /></p>
<p>​
那么对于一个普通的卷积而言，可以用如下公式来进行表示，p0就是当前点，pn是R中的值。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114212010083.png" /></p>
<p>​ 在可变形卷积中，如下所示，R被加强了，还多了一个offset。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114212018393.png" /></p>
<p>​
这样的话呢，采样就在一个不规则的并且带有偏移的位置上进行了。通常而言这个offset
∆pn
是小数，所以通常需要通过线性插值来计算像素的值，公式如下所示：其实就是x(p)的值要由其周围整数像素x(q)加权得到。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114212038364.png" /></p>
<p>​
那么，关键的问题来了：这个offset怎么得到呢？<strong>这个offset是通过另一个在相同的输入图像上的卷积得到的。这个卷积的卷积核与当前的可变形卷积的卷积核有相同的空间分辨率。同时，经过这个卷积后得到的offest的输出域，和输入也有同样的空间分辨率。输出维度为2N，分别对应N个2维的offsets。</strong></p>
<p>​
在训练过程中，用来生成输出特征的卷积核和用来计算offsets的卷积核是同时进行学习的。下图是一个3*3的可变形卷积的示意图。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114212046759.png" /></p>
<p>​ 至于更为详细的可变形卷积思想以及实验，可以更深入的精读《Deformable
Convolutional Networks》这篇论文。</p>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Basic系列笔记</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Convolution</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习基础系列笔记4——Depth-wise卷积 &amp; Point-wise卷积</title>
    <url>/2022/01/05/d37a1913ba03/</url>
    <content><![CDATA[<p><strong>提示：阅读本文前需要你掌握卷积相关操作概念</strong></p>
<h3 id="normal-convolution">1、Normal Convolution</h3>
<p>​
输入一张3通道的图像，我们有4个3<strong>3</strong>3的卷积核，卷完以后，会生成4个特征图。特征图的数量等于卷积核的数量。每个卷积核的通道数与图像的通道数一致，一一对应相乘。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114211015420.png" /></p>
<h3 id="depth-wise-convolution">2、Depth-Wise Convolution</h3>
<p>​ Depthwise
Convolution的一个卷积核负责一个通道，一个通道只被一个卷积核卷积。上面所提到的常规卷积每个卷积核是同时操作输入图片的每个通道。</p>
<p>​ 同样是对于一张三通道输入图像，Depthwise
Convolution不同于上面的常规卷积，其完全是在二维平面内进行。卷积核的数量应当与输入的图像的通道数相同（因为通道和卷积核是一一对应的）。所以一个三通道的图像经过运算后生成了3个Feature
Map。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114211022892.png" /></p>
<p>​ 总结而言：Depthwise Convolution完成后的Feature
map数量与输入的通道数相同，无法扩展。且这种运算对输入层的每个通道独立进行卷积运算，没有有效的利用不同通道在相同空间位置上的特征信息。</p>
<p>​
但是，Depthwise通过深度以及广度的操作能很好的保留各个通道信息的同时，降低了计算开销。而这一思想也逐渐应用到了移动端神经网络。</p>
<h3 id="point-wise-convolution1x1卷积">3、Point-Wise
Convolution(1x1卷积)</h3>
<p>​ Pointwise Convolution的运算的卷积核的尺寸为
1×1×M，M为输入的图像的通道数。如下图所示：输入图像为3通道，经过4个1x1x3的卷积核以后，生成4个特征图，特征图大小并不会变化，故而这里的卷积运算其实就是将输入的图像在深度方向上进行加权组合，生成新的Feature
map。</p>
<p>​ 详见：<a
href="https://blog.fantast.top/2022/01/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B05%E2%80%941x1%E5%8D%B7%E7%A7%AF&amp;%E9%83%A8%E5%88%86%E5%8D%B7%E7%A7%AF&amp;%E7%A9%BA%E6%B4%9E%E5%8D%B7%E7%A7%AF&amp;%E5%8F%AF%E5%8F%98%E6%80%A7%E5%8D%B7%E7%A7%AF/">机器学习基础系列笔记5——1x1卷积
&amp; 部分卷积 &amp; 空洞卷积 &amp; 可变形卷积</a></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114211035827.png" /></p>
<h3 id="depth-wise-separable-convolution">4、Depth-Wise Separable
Convolution</h3>
<p>​ Depthwise Separable
Convolution是将一个完整的卷积运算分解为两步进行，即上面所述的Depthwise
Convolution与Pointwise Convolution。</p>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Basic系列笔记</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Convolution</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习基础系列笔记3——反卷积Deconvolution</title>
    <url>/2022/01/04/16c9f87609b5/</url>
    <content><![CDATA[<p><strong>提示：在观看此篇文章前，需要你掌握卷积操作。</strong></p>
<p>​
Deconvolution反卷积通常用于进行图像的上采样，恢复分辨率。又称transposed
convolution或是Fractionally-strided
convolution。首先，我们先聊一聊为什么需要反卷积来进行上采样？</p>
<p>​
在反卷积前，人们上采样通常采用插值的方法去进行，但是插值的方法完全是由人工定义规则，并不能够对于不同图像的插值有特定的优化，也没有可调整参数的空间。此时，我们想要让网络能够学出一种最优化的上采样方案，就是我们的反卷积操作。</p>
<p>​
众所周知如下所示是一个普通的卷积操作，我们拿一个3*3的卷积核去卷一个4*4的矩阵，padding=0，stride=1，得到了一个2*2的矩阵。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114210644864.png" /></p>
<p>​
从实质的角度去理解卷积这一件事情，其实它就是建立了输入与输出图像的像素对应关系，比如说按照上图所示的内容，输入图像中每9个像素，通过卷积核，建立起了和输出图像中1个像素的映射关系。所以Convolution建立的是一个“多对一”的像素映射关系。那么，顾名思义，Deconvolution本身应该要做的就是从output到input之间，建立“一对多”的像素映射关系。也就是说从output的一个值中计算出input的9个值。看到这里也许会有些懵，实际上来说，卷积这个操作是没法逆向进行的，我们这边说的反卷积只是一种形式，因为其比较像而已。</p>
<p>​
那么反卷积是如何进行的呢？我们先再来看一看卷积的另一种计算形式（除了移动卷积核遍历以外）——
使用矩阵相乘的形式进行计算，然后能够很好的推出得到反卷积的计算形式。</p>
<p>仍然以上面的例子为例，我们如果想要一次性计算整个ouput中的值，可以如下操作：</p>
<p>​ 1、将input展平，成为一个16 * 1的矩阵A。</p>
<p>​ 2、将kernel按照一定规则扩充，扩充成为一个4 * 16的矩阵B</p>
<p>​ 3、将矩阵A和矩阵B计算矩阵乘法，得到一个1 * 4的向量C，将其reshape成2
* 2即output。</p>
<p>那么在步骤2中的“按照一定规则填充”是指什么呢？</p>
<p>​ 其实就是重新排列一下kernel矩阵,
使得我们通过一次矩阵乘法就能计算出卷积操作后的矩阵。以上述的卷积核为例，应当如下所示：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114210739770.png" /></p>
<p>然后我们发现，原来卷积操作，可以写成两个矩阵相乘的形式，在上述例子中就是：</p>
<p>B（4 * 16）· A（16 * 1） = C（4 * 1）--》reshape --》 output（2 *
2）</p>
<p>​ 那么，现在反卷积要干的事情其实就是让 <span
class="math inline">\(B^T\)</span>（16*4）· <span
class="math inline">\(C\)</span>（4*1）就可以得到一个16*1的矩阵，然后进行reshape就可以变成一个4*4的图像，其分辨率为最开始输入的2*2的图像的两倍，就可以完成反卷积。</p>
<p>​
其实，按照上述的做法，我们就建立了一个1对多的映射关系，请注意，在实际操作中，其实并不需要去计算反卷积的矩阵B内部到底是什么信息，B内部的参数是可以让网络进行学习而得到的，网络学习得到的参数往往就是针对于这一组训练集或者针对于特定任务而言，最好的一个上采样的方案。</p>
<p>​ 所以严格来说，反卷积并不算卷积，只是另一种形式罢了。</p>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Basic系列笔记</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Deconvolution</tag>
      </tags>
  </entry>
  <entry>
    <title>ML2021课程系列笔记4——海森矩阵计算（课程作业）</title>
    <url>/2021/12/23/9bb28e693fc9/</url>
    <content><![CDATA[<h3
id="hung-yi-lee-李宏毅-machine-learning-2021-spring课程-hw2.2笔记">Hung-yi
Lee (李宏毅) MACHINE LEARNING 2021 SPRING课程 HW2.2笔记</h3>
<p>​
https://link.zhihu.com/?target=https%3A//speech.ee.ntu.edu.tw/~hylee/ml/2021-spring.html</p>
<p>​ 先给出课程中助教提供的代码链接：</p>
<p>​
https://colab.research.google.com/github/ga642381/ML2021-Spring/blob/main/HW02/HW02-2.ipynb</p>
<p>​
先前在系列笔记2中——机器学习任务攻略笔记中，已经提及了在数学理论上，当我们训练不下去的时候，如何分辨是达到了一个Local
Minimal还是一个Saddle Point。</p>
<p>​ https://zhuanlan.zhihu.com/p/447280599</p>
<p>​
此篇笔记从实际的角度进行记录，通过一个实例，讲解如何去进行分辨，整理出的这个框架在今后如果遇到了训练不下去的时候，可以采用此计算，分辨到底是碰到了何种情况：</p>
<p>​
首先，在实际的训练过程中，我们很难找到梯度为0的点，并且也很难找到一个真正的Local
Minimal（也就是海森矩阵特征值全大于0），所以我们首先需要做一些近似：</p>
<ul>
<li><p>我们将gradient小于1^-3即视为近似为0</p></li>
<li><p>如果minimum ratio 大于0.5 且 gradient 小于 1^-3
，我们即认为其为一个Local Minimal。</p></li>
<li><p>附： Minimum ratio = 海森矩阵的所有特征值中正的特征值的数量 /
海森矩阵的所有特征值的数量</p></li>
</ul>
<p>​
然后就开始通过代码来实现计算过程：首先我们需要有一个用来作为示例的网络和训练点,这个在助教给的代码中已经准备好了，我此处把重要的东西抽出来记录</p>
<h4 id="step1-定义一个简单的模型">Step1: 定义一个简单的模型</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MathRegressor</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_hidden=<span class="number">128</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.regressor = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">1</span>, num_hidden),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(num_hidden, <span class="number">1</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.regressor(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<h4
id="step2-加载属于该模型的预先准备好的某训练点以及用于训练的数据和标签">Step2:
加载属于该模型的预先准备好的某训练点以及用于训练的数据和标签</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = MathRegressor()</span><br><span class="line">model.load_state_dict(<span class="string">&#x27;xxxx&#x27;</span>)  <span class="comment"># xxxx为事先准备好的训练到某一个点的模型文件路径</span></span><br><span class="line">train = Tensor([[<span class="number">0.2400</span>],  <span class="comment"># 然后feature和target(label)也加载进来</span></span><br><span class="line">        [<span class="number">0.2500</span>],</span><br><span class="line">        [<span class="number">0.2600</span>],</span><br><span class="line">        [<span class="number">0.2700</span>],</span><br><span class="line">        [<span class="number">0.2800</span>],</span><br><span class="line">        [<span class="number">0.2900</span>]])</span><br><span class="line">target = Tensor([[-<span class="number">0.1559</span>],</span><br><span class="line">        [-<span class="number">0.1801</span>],</span><br><span class="line">        [-<span class="number">0.1981</span>],</span><br><span class="line">        [-<span class="number">0.2101</span>],</span><br><span class="line">        [-<span class="number">0.2162</span>],</span><br><span class="line">        [-<span class="number">0.2168</span>]])</span><br></pre></td></tr></table></figure>
<h4 id="step3-定义计算该训练进度当前所在位置loss函数的梯度">Step3:
定义计算该训练进度当前所在位置Loss函数的梯度</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># function to compute gradient norm</span></span><br><span class="line"><span class="comment"># model 代表模型实例 ，例如为 MathRegressor()</span></span><br><span class="line"><span class="comment"># criterion为损失函数,例如为 nn.MSELoss()</span></span><br><span class="line"><span class="comment"># train 为训练数据feature 见上</span></span><br><span class="line"><span class="comment"># target为训练数据label 见上</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_gradient_norm</span>(<span class="params">model, criterion, train, target</span>):</span><br><span class="line">    model.train()</span><br><span class="line">    model.zero_grad()</span><br><span class="line">    output = model(train)</span><br><span class="line">    loss = criterion(output, target)</span><br><span class="line">    loss.backward()  <span class="comment"># 通过反向传播计算该点梯度</span></span><br><span class="line"></span><br><span class="line">    grads = []</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> model.regressor.children():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(p, nn.Linear):</span><br><span class="line">            param_norm = p.weight.grad.norm(<span class="number">2</span>).item()</span><br><span class="line">            grads.append(param_norm)</span><br><span class="line">		</span><br><span class="line">    grad_mean = np.mean(grads) <span class="comment"># compute mean of gradient norms</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> grad_mean</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">对于内容的一些注解：</span></span><br><span class="line"><span class="string">	前半部分比较好理解，就是做了前向计算以后，然后通过反向传播计算梯度</span></span><br><span class="line"><span class="string">	后半部分，其实是对所有的层的参数的梯度做了一个平均的计算：</span></span><br><span class="line"><span class="string">	1、model.regressor 输出的内容如下</span></span><br><span class="line"><span class="string">    Sequential(</span></span><br><span class="line"><span class="string">      (0): Linear(in_features=1, out_features=128, bias=True)</span></span><br><span class="line"><span class="string">      (1): ReLU()</span></span><br><span class="line"><span class="string">      (2): Linear(in_features=128, out_features=1, bias=True)</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">	2、代码中的p在三次循环中分别为：</span></span><br><span class="line"><span class="string">    第一遍循环：Linear(in_features=1, out_features=128, bias=True)</span></span><br><span class="line"><span class="string">    第二遍循环：ReLU()</span></span><br><span class="line"><span class="string">    第三遍循环：Linear(in_features=128, out_features=1, bias=True)</span></span><br><span class="line"><span class="string">    故而我们知道 for p 那个循环其实就是在： 如果该层是全连接层，那么我们就要计算所有权重参数的梯度，如果不是（言外之意是如果是ReLU层，因为ReLU层是激活函数，无权重参数，所以我们不需要考虑）。所以需要注意，如果我们需要计算的模型是一个含有除了Linear以外的 带权重参数的网络模型，这个地方就要有所更改了</span></span><br><span class="line"><span class="string">  3、如果p是Linear层，应当如何计算：</span></span><br><span class="line"><span class="string">  	p.weight 是一个Tensor，为所有的权重参数</span></span><br><span class="line"><span class="string">  	p.weight.grad 是一个Tensor，为所有的权重参数对应当前点的导数（梯度）</span></span><br><span class="line"><span class="string">  	p.weight.grad.norm(2) 是一个仅有一个元素的Tensor，计算了先前的Tensor的二阶范式，其实就是平方和开更号。</span></span><br><span class="line"><span class="string">    p.weight.grad.norm(2).item() 是一个数值，即从Tensor中取出数值来。</span></span><br><span class="line"><span class="string">    最后将该层的 梯度的二阶范式 append 至 grads数组中</span></span><br><span class="line"><span class="string">  4、最后返回值是什么？</span></span><br><span class="line"><span class="string">  	最后grads中有 n个元素，n为所有带权重参数的层的个数（示例中的网络为2个），然后在用np.mean计算即得到最后的返回值，即所有层的梯度的平均值。</span></span><br><span class="line"><span class="string">  	</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="step4-计算hession-矩阵">Step4: 计算Hession 矩阵</h4>
<p>https://github.com/cybertronai/autograd-lib</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我们使用autograd-lib 这个python库计算Hession矩阵</span></span><br><span class="line">pip install autograd-lib</span><br><span class="line"><span class="comment"># 在github的链接中，作者给出了Hessian矩阵的计算示例，其使用的是高斯牛顿法，我们在此不进行赘述，有兴趣的可以看github链接的计算源码。</span></span><br><span class="line"><span class="comment"># 以下是两个依赖函数，下面用得到，也是github源码中给出的</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_activations</span>(<span class="params">layer, A, _</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    A is the input of the layer, we use batch size of 6 here</span></span><br><span class="line"><span class="string">    layer 1: A has size of (6, 1)</span></span><br><span class="line"><span class="string">    layer 2: A has size of (6, 128)</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    activations[layer] = A</span><br><span class="line"></span><br><span class="line"><span class="comment"># helper function to compute Hessian matrix</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_hess</span>(<span class="params">layer, _, B</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    B is the backprop value of the layer</span></span><br><span class="line"><span class="string">    layer 1: B has size of (6, 128)</span></span><br><span class="line"><span class="string">    layer 2: B ahs size of (6, 1)</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    A = activations[layer]</span><br><span class="line">    BA = torch.einsum(<span class="string">&#x27;nl,ni-&gt;nli&#x27;</span>, B, A) <span class="comment"># do batch-wise outer product</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># full Hessian</span></span><br><span class="line">    hess[layer] += torch.einsum(<span class="string">&#x27;nli,nkj-&gt;likj&#x27;</span>, BA, BA) <span class="comment"># do batch-wise outer product, then sum over the batch</span></span><br></pre></td></tr></table></figure>
<h4 id="step5-计算minimal-ratio">Step5: 计算Minimal Ratio</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># function to compute the minimum ratio</span></span><br><span class="line"><span class="comment"># model 代表模型实例 ，例如为 MathRegressor()</span></span><br><span class="line"><span class="comment"># criterion为损失函数,例如为 nn.MSELoss()</span></span><br><span class="line"><span class="comment"># train 为训练数据feature 见上</span></span><br><span class="line"><span class="comment"># target为训练数据label 见上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_minimum_ratio</span>(<span class="params">model, criterion, train, target</span>):</span><br><span class="line">    model.zero_grad() </span><br><span class="line">    <span class="comment"># 1、计算Hessian矩阵</span></span><br><span class="line">    <span class="keyword">with</span> autograd_lib.module_hook(save_activations):</span><br><span class="line">        output = model(train)</span><br><span class="line">        loss = criterion(output, target)</span><br><span class="line">    <span class="keyword">with</span> autograd_lib.module_hook(compute_hess):</span><br><span class="line">        autograd_lib.backward_hessian(output, loss=<span class="string">&#x27;LeastSquares&#x27;</span>)</span><br><span class="line">		</span><br><span class="line">    layer_hess = <span class="built_in">list</span>(hess.values())</span><br><span class="line">    <span class="comment"># 2、计算minimum_ratio</span></span><br><span class="line">    minimum_ratio = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> layer_hess:</span><br><span class="line">        size = h.shape[<span class="number">0</span>] * h.shape[<span class="number">1</span>]</span><br><span class="line">        h = h.reshape(size, size)</span><br><span class="line">        h_eig = torch.symeig(h).eigenvalues </span><br><span class="line">        <span class="comment"># torch.symeig() returns eigenvalues and eigenvectors of a real symmetric matrix</span></span><br><span class="line">        num_greater = torch.<span class="built_in">sum</span>(h_eig &gt; <span class="number">0</span>).item()</span><br><span class="line">        minimum_ratio.append(num_greater / <span class="built_in">len</span>(h_eig))</span><br><span class="line"></span><br><span class="line">    ratio_mean = np.mean(minimum_ratio) <span class="comment"># compute mean of minimum ratio</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ratio_mean</span><br><span class="line">  </span><br><span class="line">activations = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">hess = defaultdict(<span class="built_in">float</span>)</span><br><span class="line">gradient_norm = compute_gradient_norm(model, criterion, train, target)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	在上述代码中，有些许部分与理论不同。代码实现中是分层计算海森矩阵的，即针对于神经网络的每个层计算海森矩阵，而后再求解特征值。然后将每层的结果做一个平均。而理论上，应当计算一个所有参数的大的海森矩阵，对其求解特征值。</span></span><br><span class="line"><span class="string">	即在上述的案例中，我们原本应该得到一个256*256的海森矩阵，但实际上得到了2个128*128的海森矩阵，并且应当是理论上256*256海森矩阵的左上角部分与右下角部分。即下述所示的A和B，剩下的两块的？是L对两层参数交叉求微分的部分，没有计算。</span></span><br><span class="line"><span class="string">	                              [ A   ? ]</span></span><br><span class="line"><span class="string">	                              [ ?   B ]</span></span><br><span class="line"><span class="string">	如此做的原因我思索了很久也没有得出一个结论，有两个合理的可能猜测：</span></span><br><span class="line"><span class="string">		可能1:完整的海森矩阵计算难度过大，故而我们单独计算L对每一层参数的海森矩阵，来作为近似。</span></span><br><span class="line"><span class="string">		可能2:由于某些性质，剩下的没有计算的两块的值，不会影响最终判定海森矩阵是否正定的结果，但是我并没有实际进行证实。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>ML2021课程系列笔记</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>ML2021课程系列笔记3——卷积神经网络CNN</title>
    <url>/2021/12/20/cedd3c9597c5/</url>
    <content><![CDATA[<h3
id="hung-yi-lee-李宏毅-machine-learning-2021-spring课程-week3笔记">Hung-yi
Lee (李宏毅) MACHINE LEARNING 2021 SPRING课程 Week3笔记</h3>
<p>###
课程链接：https://speech.ee.ntu.edu.tw/~hylee/ml/2021-spring.html</p>
<p>​
该篇记录了一个用于影像处理的非常经典的网络架构：CNN网络，其中也提及了如何设计网络架构能够更好的为我们的机器学习任务目标进行服务。</p>
<h2 id="一从neuron-version角度来介绍cnn">一、从Neuron
Version角度来介绍CNN</h2>
<p>​
我们如果使用全连接网络来进行影像处理的话，如下图所示，我们先将一张100*100的3通道RGB图像展平，然后将展平后的向量作为全连接层的输入，假设第一个隐藏层有1000个神经å元，那么第一层的参数就需要有<span
class="math inline">\(310^7\)</span>个，非常的多。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114114729143.png" alt="image-20220114114729143" style="zoom:20%;" /></p>
<p>​
所以考虑到影像本身的特性，其实我们并不需要让每一个neural和每一个像素之间都有权重的联系关系。所以我们需要基于影像的特点，提出一个适用于影像处理的架构CNN：</p>
<p>​ 首先我们提出如下的观察：</p>
<h3 id="观察1">观察1：</h3>
<p>​
我们辨识影响往往是通过影响中的一些重要的部分（Pattern）来做出判断的，比如说，我们要判断一张图片中是不是含有鸟，我们往往可能会判断说有没有鸟嘴、有没有鸟眼睛、有没有鸟爪子等等重要的鸟的组成部分。这样的话呢，我们其实会发现，我们只要训练网络去观察这些重要的组成部分就可以了，而这些组成部分往往是图片的一小部分，所以并不需要每一个神经元都去观察整张图片的信息（FC网络由于每个神经元都和所有的输入像素相连接，所以每个神经元中都会有全局的信息），只需要让网络侦测一些重要的Pattern有没有出现即可。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114114815294.png" alt="image-20220114114815294" style="zoom:25%;" /></p>
<p>​ 基于上述观察1，我们就可以提出一些机制（简化1）：Receptive
Field感知域机制，如下所示：本来的话，在FC中，每一个Neural都会和整张图片的所有像素都有一个weight相连，但是我们现在可以设置一个3<em>3</em>3的感知域，比如图中左上角的这个红色感知域，然后某一个Neural仅和这个感知域内所有的像素相连，也就是这个神经元仅有3<em>3</em>3
= 27
个weight，再加上bias的参数，就可以得到神经元的输出作为下一层的输入。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114114832378.png" alt="image-20220114114832378" style="zoom:25%;" /></p>
<p>​
那么，以此类推，我们可以有很多很多的感知域，对应不同的Neural，每一个不同的Neural负责不同的感知域部分（如图中所示）。这个地方其实会存在比较多的疑问，比如说：同一个感知域可以连接两个不同的神经元吗？感知域之间可以重叠吗？我们一定要3通道的感知域吗？可以有不同尺度的感知域吗？感知域一定要是相邻的吗？感知域可以是非正方形吗？答案都是可以的，感知域的设计是一个非常自由的选项，其归根结底是需要看你对于问题的理解。一般而言，我们说感知域最好是相邻的，是因为我们认为在影响检测中，如果想要检测一个重要的Pattern的话，这个Pattern应该是会在图像任意位置都有可能出现的。如果有一个特殊的任务，其内容都在左上角，那么你可以设计感知域都重叠在左上角。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114114850796.png" alt="image-20220114114850796" style="zoom:25%;" /></p>
<p>​ 那么最经典的Receipt
Field应该是怎么样的呢？我们一般都会考虑所有的通道，而不是单个通道的考虑，这样的话我们只需要确定图像平面的感知域大小就可以，将之称为kernal
size，一般的kernel
size就是3<em>3，5</em>5和7*7已经属于较大的核大小了。然后对于一个receipt
field来说，往往不会只有一个neural与之对应，而是会有一组neuron(
64或128个)去和这个感知域相连。</p>
<p>​ 各个不同的receipt
field一般都是相邻的，有重叠的，相邻距离叫做stride。同时边界的填充大小叫做padding。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220121172659518.png" /></p>
<h3 id="观察2">2、观察2</h3>
<p>​
我们发现，影像中同一个模式的部分，可能出现在图像的任何一个地方，比如说在不同的图像上，鸟嘴可能出现在蓝色方框处，也可能出现在红色方框处。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114115003492.png" alt="image-20220114115003492" style="zoom:25%;" /></p>
<p>​
基于上述的观察，虽然我们在简化1中提到了，对于不同的区域，我们都会有对应的神经元去连接这一块区域（感知域），那么由于我们是要检测同一个模式，所以用于检测同一个模式的感知域的神经元应该是可以共享参数的。如下图所示，用于检测左上角的某模式的一个神经元核检测中部的同一模式的神经元应当共享训练参数。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114115020687.png" alt="image-20220114115020687" style="zoom:25%;" /></p>
<p>​
那么一般而言，我们是如何去共享参数的呢？我们先前说过，一般而言，每一个感知域都会对应连接64个或128个不同的神经元，所有的感知域所对应的相同序号的神经元全都是共享参数的。以下图中两个红色方框框起的感知域为例，每个感知域都对应了64个神经元，即64组参数，它们各自的第1个神经元的参数（filter1）间参数是共享的，后续同理。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114115047789.png" alt="image-20220114115047789" style="zoom:25%;" /></p>
<p>​ 所以我们发现，Convolutional
Layer其实就是人们针对于影像的两大特性，提出了感知域和参数共享这两个简化，从而使得FC进化成了CNN，所以CNN一般情况下我们说仅用于影像处理，或者说用于具有上述我们提及的两大特性的问题领域，才会有比较好的效果。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114115102350.png" alt="image-20220114115102350" style="zoom:25%;" /></p>
<h2 id="二从filter-vision角度来介绍cnn">二、从Filter
Vision角度来介绍CNN</h2>
<p>​
上述的那个角度介绍CNN其实是令我耳目一新的，它非常好的阐明了CNN这个架构之所以这样子设计的原因。那么其实在最开始的时候我学习的是接下来要说的这个从Filter的版本进行的介绍。</p>
<p>​
首先你需要知道卷积的概念，在卷积层中，其实我们就是用许多个不同的卷积核Filter去卷积我们输入的图像。假设我们的图像是3通道的，那么我们一般的卷积核大小就是一个<span
class="math inline">\(3 \times 3 \times
3(width*height*channel)\)</span>的三维Tensor。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114115134255.png" alt="image-20220114115134255" style="zoom:25%;" /></p>
<p>​
每一个Filter卷积过原图像以后，都会生成一张新的图像，被我们称之为特征图，我们通常使用64个或128个卷积核去对图像卷积，在第一层的卷积层过后，就会生成一张64或128通道的图像，每一个通道都是一个Feature
Map。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114115246463.png" alt="image-20220114115246463" style="zoom:20%;" /></p>
<p>那么在多层的卷积层网络中，这样子经过第一层卷积层后得到的一个特征图组成的64通道的图像，将会再次被视为一张图片，经过下一个卷积层。下一层的每个卷积核应当是<span
class="math inline">\(3 \times 3 \times
64\)</span>的大小。然后又会根据卷积核的数目，决定该层输出的特征图的数量</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114115306217.png" alt="image-20220114115306217" style="zoom:25%;" /></p>
<h2 id="三-两个version的介绍中的相通点">三、
两个Version的介绍中的相通点</h2>
<p>​
其实第二个版本中的Filter就是第一个版本中的某个感知域所对应的神经元的参数，也就对应着我们的观察1.如下所示：比如说一个对应着<span
class="math inline">\(3 \times 3 \times
3\)</span>的感知域的神经元，其拥有27个参数，这27个参数其实就是我们在第二个版本中所说的Filter的大小。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114115437195.png" alt="image-20220114115437195" style="zoom:25%;" /></p>
<p>​
同时，我们在卷积的过程中，需要拿卷积核遍历一遍图像，还会有stride和padding，在拿卷积核遍历卷积图像的时候，卷积核的参数不会变化，这也就意味着，对于同一个卷积核（神经元）来说，当其对应去计算不同的感知域时，参数是共享的。对应了我们的观察2.</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114115455473.png" alt="image-20220114115455473" style="zoom:25%;" /></p>
<p>​
所以其实来说两个版本的介绍是完全一致的，从两个方向来介绍能够更好的加深我们对于CNN的理解。</p>
<h2 id="四一些问题与pooling层的作用">四、一些问题与Pooling层的作用</h2>
<p>​ 1、我们一般采用<span class="math inline">\(3 \times
3\)</span>的filter，那么需要担心检测不到比较大的Pattern吗？因为有些Pattern肯定不会只在<span
class="math inline">\(3 \times 3\)</span>这么小的一个区域内出现。</p>
<p>​ 答案是不需要担心，因为在多层的卷积神经网络中，我们第一层使用<span
class="math inline">\(3 \times
3\)</span>的filter，得到的特征图，在第二层卷积的时候，第二层如果采用的是<span
class="math inline">\(3 \times
3\)</span>的filter，我们可以知道，第二层卷积的特征图中的一个像素，其实代表的是原图像中一个<span
class="math inline">\(3 \times 3\)</span>的范围，所以第二层的<span
class="math inline">\(3 \times
3\)</span>的filter所感知到的源图像的范围其实是比<span
class="math inline">\(3 \times 3\)</span>要大的，那就是<span
class="math inline">\(9 \times
9\)</span>吗？也不一定，因为考虑到感知域之间会有所重叠。如下图所示，比较好理解，上面的矩阵是原图，下面的矩阵是第一层卷完以后的特征图，在特征图上做<span
class="math inline">\(3 \times
3\)</span>的蓝色框卷积，其实就相当于感知到了原图的<span
class="math inline">\(5 \times
5\)</span>的一个蓝色方框区域。所以卷积神经网络叠的越深，其能侦测到的特征的尺度上限越大。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114115621526.png" alt="image-20220114115621526" style="zoom:25%;" /></p>
<p>​ 2、Pooling层：</p>
<p>​
池化层基于这样一个观察：我们发现，影像如果做了下采样，并不会影响整体显示的内容。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114115654899.png" alt="image-20220114115654899" style="zoom:25%;" /></p>
<p>​
所以在传统的CNN中，Pooling最主要的作用是减少运算量，减少参数。人们往往把Pooling层和卷积层交替叠加，形成卷积神经网络。但其实在现阶段而言，我们的GPU运算能力上来了，池化层在有些时候可有可无，尤其是当我们需要执行一些识别细小Pattern的任务的时候，池化层所进行的下采样很可能让我们丢失一些信息，导致侦测不到一些细小的Pattern。</p>
<p>​
故而我们在使用一个网络架构的时候，一定要想清楚这个网络架构的某些部分到底是干什么用的，针对什么特性来进行设计的，才能获得比较好的效果以及应用。</p>
<p>3、最后CNN无法处理图像的放缩与旋转，所以在做影像辨识的时候我们往往要做Data
Augmentation（先前提及过的方法），来让我们的训练集尽量多元化，避免这个问题。当然也有专门做了相应处理的网络层，叫做Spatial
Transformer Layer，感兴趣可以学习。 https://youtu.be/SoCywZ1hZak</p>
<h2 id="五cnn应用-playing-go">五、CNN应用： Playing GO</h2>
<h4
id="如何将下围棋变成一个分类问题">1、如何将下围棋变成一个分类问题？</h4>
<p>​
我们把下围棋去当作一个分类的问题，假设棋盘是19*19的大小，网络的输入就是一个19*19的向量，每一个位置可能用一个值来代表这个位置当前的状态，（Alpha
Go原论文中，每个位置是由一个48维的向量进行表示的），经过网络以后，我们要的输出结果是下一步棋会下在哪里？</p>
<p>​ 这就是一个
19*19个类别的分类问题，网络输出在各个地方的落子概率，挑选落子概率最大的那一个位置下子就可以了。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_01_21_17_35_31_200.png" /></p>
<h4
id="为什么cnn可以用在下围棋上呢">2、为什么CNN可以用在下围棋上呢？</h4>
<p>​
1、一些pattern比整个棋局要小，并且可以识别出来。如下所示，围棋中也有一个个小的pattern，通过一个个小的pattern就可以去进行一些的判断。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_01_21_17_32_54_32.png" /></p>
<p>​
2、同一个pattern可能出现在棋盘上的任何位置，可能可以出现在左下角，也可以出现在右上角。围棋中也是这个样子。</p>
<h4
id="那么pooling层在围棋中也会适用吗">3、那么Pooling层在围棋中也会适用吗？</h4>
<p>​
！完全不适用！并且不可以使用！如果我们在棋盘中使用MaxPooling层的话，移除了偶数行和奇数行以后，会导致很多围棋的细节丢失。所以Pooling层虽然适合做影像处理，但在下围棋这个任务中，显然不是很合适。</p>
<p>​ 所以Alpha
Go的原论文中，在附件中阐述的网络结构中也提到了，其设计的网络结构中，已经没有Pooling层了，是非常合理的。</p>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>ML2021课程系列笔记</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>CNN</tag>
      </tags>
  </entry>
  <entry>
    <title>ML2021课程系列笔记2——机器学习训练任务攻略</title>
    <url>/2021/12/19/8dab9ca264e4/</url>
    <content><![CDATA[<h3
id="hung-yi-lee-李宏毅-machine-learning-2021-spring课程-week2笔记">Hung-yi
Lee (李宏毅) MACHINE LEARNING 2021 SPRING课程 Week2笔记</h3>
<h3
id="课程链接httpsspeech.ee.ntu.edu.twhyleeml2021-spring.html">课程链接：https://speech.ee.ntu.edu.tw/~hylee/ml/2021-spring.html</h3>
<p>​
本篇将会介绍一些机器学习深度学习训练过程中，容易发生的一些问题，以及经常使用的一些基础的Tricks。上篇已经阐明了机器学习任务的训练分为以下三个阶段。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114110835052.png" alt="image-20220114110835052" style="zoom:25%;" /></p>
<p>​ 同时也会有对应的测试集数据进行验证的部分。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114110905969.png" alt="image-20220114110905969" style="zoom: 25%;" /></p>
<p>​
那么在训练与测试的过程中，可能会出现一些问题，下面的图就是一个整体的Guidance，基本阐述了当在训练时我们遇到不同的现象时，大概是何种问题所致。</p>
<p>​ 此篇将会顺着以下这个分支树进行前序遍历，一条条往下进行讲解。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114110925311.png" alt="image-20220114110925311" style="zoom:25%;" /></p>
<h2 id="一model-bias问题">一、Model Bias问题</h2>
<p>​ 当在训练数据上得到的Loss函数值较大的话，其中一种可能就是Model
Bias.Model
Bias一般指模型不够复杂，无法很好的拟合数据。从形式化的角度来讲就是，能够拟合数据的函数，不在你所寻找的函数空间中。举个例子来说：你在第一步中设定的拟合函数为Y
= a +
bx，然后使用梯度下降想要寻找使得Loss最低的一组a和b，但是你会发现，即使你找到了使得Loss最低的一组a和b，这组a和b计算得到的Loss还是很高。原因可能是，你需要拟合的数据其实是一个二次函数，或是更复杂的函数，而你却想要使用线性函数去进行拟合。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220129151628264.png" /></p>
<h2 id="二optimization">二、Optimization</h2>
<p>​
当在训练数据上得到的Loss函数值较大的话，另外一种可能就是Optimization导致的。此种情况与第一种不同，其模型是有能力拟合数据的，但是由于优化方法的限制，我们没法找到能够使得Loss函数值最小的那一组未知参数。我们先前使用的Gradient
Descent用于求解优化的方法，还是存在比较多的限制的。如下图为例，假设Loss函数的图像如下图所示，我们设定的θ的起点在左侧，那么经过一段时间的梯度下降后，其会到达图中蓝线所示的Local
Minimum，也就是局部最优，但是其永远也无法找到右侧的全局最优。往往优化算法无法很好的执行是由于模型过于复杂，或不同的特征数据的尺度相差过大等原因导致。</p>
<p>​
此处仅先简单的介绍Optimization是怎样一种问题，后续第八章中会继续探讨这类问题的产生原因以及在第九章中讲如何解决优化这一问题（如何逃出Shaddle
Point）。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114111434996.png" alt="image-20220114111434996" style="zoom: 25%;" /></p>
<h2
id="三如何区分是model-bias还是optimization导致的train-loss过大">三、如何区分是Model
Bias还是Optimization导致的Train Loss过大？</h2>
<p>​
我们先前说，当在训练数据上得到的Loss函数值较大的话，这两种问题都有可能，那么一般而言如何区分呢？一般来说，我们需要通过模型与模型的比较来获得一些见解。如下所示，在右侧的Training
Data显示的图像中，20层的网络已经能够将Training
Error降至比较低的水准了，那么56层的这个网络Training
Error还处于一个较高的水准，那么肯定是Optimizaiton问题，而不是Model
Bias的问题。为何这么说呢？因为56层的网络肯定比20层的网路复杂，如果20层的网络已经能够很好的拟合训练数据了，那么56层的网络肯定是具有拟合训练数据的能力的，但是现在Training
Error还居高不下，说明是优化的时候出现了问题，或者是进入了一个局部最优点中，导致其找不到最好的那一组参数。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114111512628.png" alt="image-20220114111512628" style="zoom:25%;" /></p>
<h2
id="四训练时能够避免上述情况发生的一些tips">四、训练时能够避免上述情况发生的一些Tips？</h2>
<p>​
一般新执行一个训练任务的时候，从较浅的网络开始训练，因为一般较浅的网络不会出现优化的问题。如果发现较浅的网络复杂度不够拟合数据，再逐渐加深网络。</p>
<p>​ 如果更深的网络没有获得更小的损失训练数据，则存在优化问题。</p>
<h2 id="五overfitting问题">五、OverFitting问题</h2>
<p>​ 当Training
Loss已经降至较低水平，但是在Testing集上的Loss值仍然较高，其中一种可能就是出现了Overfitting过拟合的问题。如下图所示，很好的表现了过拟合问题。由于我们的模型非常有弹性，所以可能在训练集上（蓝色点）时非常好的拟合了，但是在测试集（橙色）上的表现就会比较差。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114111606224.png" alt="image-20220114111606224" style="zoom:25%;" /></p>
<p>​
更为极端的情况就是训练出如下图所示的函数：在训练集上的数据，都是完全拟合的，但是对于不在训练集上的数据就是一个随机值。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114111622606.png" alt="image-20220114111622606" style="zoom: 15%;" /></p>
<h2 id="六如何解决overfitting问题">六、如何解决OverFitting问题</h2>
<p>​ 下述是一个随着模型逐渐变得复杂，Training Loss和Testing Loss
的值变化曲线。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114111700084.png" alt="image-20220114111700084" style="zoom:16%;" /></p>
<p>​ 对于Overfitting我们有如下的几种解决方案：</p>
<ul>
<li><p>1、更多的训练数据</p>
<ul>
<li><p>如果我们能够收集到更多的训练数据，就可以一定程度上减轻过拟合的问题。比较常用的增加训练数据的方法，叫做Data
Augmentation.
如下图所示，比如说在一个图像检测的任务中，我们最开始数据集里的图片只有最左侧一张图片，我们可以将其左右翻转、或者进行放缩，就能够形成新的一些训练数据，来扩充我们的数据集。然而，上下翻转形成的新的图像，一般不会被我们放入数据集中，因为它并不是正常形成的图片，如果加入数据集中很可能让机器学到奇怪的内容。因此，Augmentation也不是随意的对数据进行变换，是需要有一定依据的。</p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114111733247.png"
alt="image-20220114111733247" />
<figcaption aria-hidden="true">image-20220114111733247</figcaption>
</figure></li>
</ul></li>
<li><p>2、减少未知参数或共享部分参数：</p>
<ul>
<li>减少模型的复杂度，或者使得模型中某些层共享一些参数，能够一定程度上解决Overfitting的问题。</li>
</ul></li>
<li><p>3、使用更少的特征</p>
<ul>
<li>将一些对于结果影响较为不显著的特征进行丢弃，只保留一些关键重要的特征，也可以一定程度上解决Overfitting。例如：我们要训练一个模型预测车的价格，根据车的如下特征：车大小、车颜色、车品牌、车动力等。其实，在这么多特征中，车颜色应该是对价格影响较少的，所以我们在训练时可以将这个特征舍去，不参与训练。</li>
</ul></li>
<li><p>4、Early Stopping机制（在Week1的Hw中已经提及）</p></li>
<li><p>5、Regularization正则化技术（见后）</p></li>
<li><p>6、DropOut技术（见后）</p></li>
</ul>
<h2
id="七如何避免在training-data上表现很好但是testing-data上表现很差的问题cross-validation交叉验证技术">七、如何避免在Training
Data上表现很好但是Testing Data上表现很差的问题——Cross
Validation交叉验证技术？</h2>
<p>​ 我们将Training Set分割为Training Set和Validation
Set两个集合，一般而言比例为9：1。我们使用划分后的Training
Set进行训练，在每个Epoch结束后使用训练期间机器没有见到过的Validation进行验证，依据验证集得到的Loss值来进行模型好坏的衡量。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114111856862.png" alt="image-20220114111856862" style="zoom:15%;" /></p>
<p>​
那么该如何进行划分呢？一般来说随即划分即可。但随即划分也可能带来一些问题，比如说可能训练集中的数据都偏向于某一类，而验证集的数据偏向于另一类，就可能导致Validation出现问题.故而又出现了N-Fold
Cross Validation.如下图所示,我们将Training
Set分为N个集合(示例中为3个),其中N-1个集合用于训练,1个集合用于验证,然后每轮Epoch中,都执行N遍,每一遍都拿不同的集合用于训练与验证,然后计算一遍Loss值,最终选取平均Loss最小的那一组参数进行模型的更新.</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114111918585.png" alt="image-20220114111918585" style="zoom: 25%;" /></p>
<h2
id="八optimization问题产生的原因small-gradient">八、Optimization问题产生的原因：Small
Gradient</h2>
<p>​
我们先来看一下优化无法进行的根本原因是什么？无论是训练了一段时间以后Loss无法再下降，还是一开始Loss就无法下降，其终极原因就是达到了梯度接近于0的点，我们通常称为critical
point。注意，此处千万不能说是碰到了local
minimum，因为这样子会非常不严谨。Critical point 不仅仅指Local
Minimum，还有可能是 Saddle Point（鞍点）等情况。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114112021653.png" alt="image-20220114112021653" style="zoom:15%;" /></p>
<p>​ 所以我们首先要知道，当我们遇到一个Critical
Point的时候，需要区分这到底是一个Local Minimum还是一个Saddle
Point。因为如果是一个局部最小值，那么其实就已经无路可走了，但是如果是一个Saddle
Point的话，周边仍然是有比他低的值的。还是有办法可以解决一番.</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114112044178.png" alt="image-20220114112044178" style="zoom:25%;" /></p>
<p>​ <span
class="math inline">\(L(\theta)\)</span>函数本身会是一个非常复杂的函数,我们没法知道它的全貌,但是我们可以动用如下的数学手段来判断某一个Critical
Point到底是Local Minimum还是Saddle Point,如下所示:</p>
<p>​ 利用泰勒展开,我们可以知道<span
class="math inline">\(L(\theta)\)</span>在某一个点<span
class="math inline">\(\theta^{&#39;}\)</span>周围的函数的近似值: <span
class="math inline">\(g\)</span>为梯度,是<span
class="math inline">\(L\)</span>对<span
class="math inline">\(\theta\)</span>的一阶导数组成的向量.<span
class="math inline">\(H\)</span>为海森矩阵,为<span
class="math inline">\(L\)</span>对<span
class="math inline">\(\theta\)</span>的二阶微分组成的矩阵.</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114112216322.png" alt="image-20220114112216322" style="zoom:15%;" /></p>
<p>​ 我们知道,在Critical
Point上,梯度为0,所以我们可以将上述公式中中间那一项划掉不看,那么L(θ)在θ’周围的函数值就可以近似为L(θ’)
加上后面这一项.</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114112238183.png" alt="image-20220114112238183" style="zoom:25%;" /></p>
<p>​
因此,我们其实可以通过后面红色方框内的这一项的正负,来判断θ’周围的值的分布到底是如下图所示的三种中的哪一种:</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114112259806.png" alt="image-20220114112259806" style="zoom: 25%;" /></p>
<p>​ 为了后续的数学表示,我们先将<span class="math inline">\((\theta -
\theta^{&#39;})\)</span>表示为符号<span
class="math inline">\(v\)</span>,那么如下图所示:
上述近似式子中的红色方框的那项,值有如下三种情况:</p>
<p>​ 如果对于所有的<span
class="math inline">\(v\)</span>来说,该项恒大于0,那就代表在<span
class="math inline">\(\theta^{&#39;}\)</span>周围,所有的值都比该点大,该点即为局部最小值.但是问题在于我们没法验证所有的<span
class="math inline">\(v\)</span>,那应该如何呢?</p>
<p>​ 已经有人为我们证明了, 对于所有<span
class="math inline">\(v\)</span>,<span
class="math inline">\(v^THv\)</span>恒大于0这件事情,和海森矩阵H是一个正定矩阵
是等价的, 也等价于 H矩阵的所有特征值都是正的这件事情.</p>
<p>​ 所以理论上我们如果想要知道<span
class="math inline">\(v^THv\)</span>的情况,知道θ’周围的分布,那么其实只要计算出H矩阵的所有特征值,看一下分布即可.</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114112443208.png" alt="image-20220114112443208" style="zoom:25%;" /></p>
<p>​ 那么如果我们发现这个点是一个Saddle Point的话, 应当如何去继续优化呢?
我们可以利用H进行优化, 我们找到一个矩阵H的特征向量u, 其对应的特征值为λ,
λ&lt;0 ,那么如下图所示: <span
class="math inline">\(u^THu\)</span>这一项就应当为 &lt; 0 的值.</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114112505138.png" alt="image-20220114112505138" style="zoom:15%;" /></p>
<p>​ 故而: 我们令<span class="math inline">\((\theta - \theta^{&#39;}) =
u\)</span>即可得到一个比<span
class="math inline">\(L(\theta^{&#39;})\)</span>小的值,完成了L值的优化.</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114112600293.png" alt="image-20220114112600293" style="zoom: 25%;" /></p>
<p>​
从执行上来讲,其实就是找一个H矩阵的特征值为负的特征向量u,这个向量u就指明了梯度下降的方向,沿着该方向走一小步,就可以完成Loss函数的值的优化.</p>
<p>​ 到此为止,已经记录了Saddle Point和Local Minimum怎么去区分,
并且也发现Saddle Point并不可怕,可以通过计算H矩阵来进行求解.</p>
<p>​ 在实际我们的训练过程中,其实达到Local
Minimum的机会是很少的,基本上都会停留在Saddle
Point上,那么这是不是就意味着我们如果碰到了Critical
Point也就是梯度为0的点,基本上就可以用求解H来继续训练呢?
理论上应该是可以的,但是在实际操作中,其实我们并不会去这样子做,因为计算H矩阵所需要花费的时间代价太过昂贵了.我们会有其他的训练技巧,来帮助绕过这一些Saddle
Point.
这些内容在下面的第9章中会讲述。同时最后的话还需要提及一点，其实大部分的训练优化做不下去了，并不是由于到达了Critical
Point，而是由于学习率的原因，在一个山谷的两侧来回震荡，这一点会在10章中进行详细的叙述。</p>
<h2 id="九optimize训练tips-batch-and-momentum">九、Optimize训练Tips:
Batch and Momentum:</h2>
<h4 id="batch技术">1、Batch技术</h4>
<p>​
先前我们说过在训练的过程中，每次进行梯度下降并不是参考所有的训练数据来计算Loss函数的，而是会像下图一样通过一个Batch一个Batch的进行计算。我们在每一轮Epoch之前，一般而言都会对数据集重新划分Batch，也就是说在不同的Epoch中，每一个Batch都是不一样的，这件事情叫做Shuffle。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114112658511.png" alt="image-20220114112658511" style="zoom:25%;" /></p>
<p>​
接下去的问题就是我们为什么要使用Batch呢？考虑如下的一个例子，左侧的Full
batch就是每一次机器都要看过所有的数据集以后再更新参数，而右侧的Batch
Size =
1则是会在看过每个样例以后都更新一遍参数。从直观上来看，BatchSize越大，其就更新一次参数而言所需要花费的时间越大，但是其更新更有效。那么按照这样子说的话，我们为什么还要分Batch呢？实际状况跟我们的直觉有一些不同。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114112717272.png" alt="image-20220114112717272" style="zoom:25%;" /></p>
<p>​
下面这张图显示了单次update以及一轮epoch训练的时间和BatchSize的关系，我们发现单次update的时间，对于batchsize
=
1和=1000来说，竟然差别不大。导致这个的原因是我们考虑了并行计算的因素，也就是使用GPU进行运算的原因。当然，如果BatchSize再增长下去，我们的GPU也是有一定的上限的所以后面也会有较大的一个时间增长。那么，右侧的这幅图就比较好理解了，对于一轮Epoch来说，如果我们的Batch
Size比较小的话，在一轮Epoch中，更新Update次数就会比较多，相对而言整体的一轮Epoch的耗时就会较长。所以随着Batch
Size的增大，反而一轮Epoch的时间会变长。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114112747946.png" alt="image-20220114112747946" style="zoom:25%;" /></p>
<p>​
这样看来，BatchSize越大，反而训练速度越快。这样的话BatchSize越大，速度又快，更新又准确，那为什么还要分Batch呢？下面一张图表示了BatchSize大小对训练出的网络的准确率的影响，我们可以看到，在BatchSize较大的时候，准确率直线下降，这是为什么呢？原因在于：我们先前所说BatchSize较大的话，每次Update较为准确，没有问题。但是对于网络而言，并不是一次Update就能解决问题的。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114112807695.png" alt="image-20220114112807695" style="zoom:23%;" /></p>
<p>​
如果BatchSize过大，会导致优化问题的出现，如左图所示，原因就是因为其每次update都太准确，如果遇到
critical point或者是local
minimum，那么其就会深陷其中，无法继续优化了。如过分了Batch的话，由于每次使用的是不同的Batch，所以每次的L函数都会有些许不一样，如果在L1处到达了一个critical
point，在一个Batch训练的时候，也许该点又重新可以继续梯度下降训练了。所以，Batch
Size较小的时候带来的单次更新的”Noisy”反而对整体的网络训练能够带来好处。那么，如何衡量就是一个需要我们手工调整的问题了。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114112827827.png" alt="image-20220114112827827" style="zoom:27%;" /></p>
<p>​
最后，先辈们还发现了一个有趣的现象，就是如果我们使用BatchSize不一样的训练方法，训练同一个网络，将Training
Loss训练到一样好以后，我们将其在测试集上进行测试，往往是BatchSize小的训练出来的网络，准确率较高。大致原因如下图所示：large
batch容易让网络的参数进入一些Sharp
Minima峡谷中，这样子的话，一旦训练数据集和测试数据集的分布有些许不同，在训练集上处于很低点的参数应用到测试集上可能会有一个比较大的Loss。相比较而言，small
batch往往会跳出这种sharp minima的峡谷，找到一些较为平坦的flat
minima，对于这些flat
minima的参数来说，即使训练集与分布集的数据分布不同，表现出来的loss性能也不会相差太多。有兴趣的可以研读这篇paper.《On
Large-Batch Training for Deep Learning: Generalization Gap and Sharp
Minima 》</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114112849800.png" alt="image-20220114112849800" style="zoom:25%;" /></p>
<h4 id="momentum技术">2、Momentum技术</h4>
<p>​
除了使用Batch来帮助我们训练以外，还有一种借鉴了物理世界的Momentum技术，可以帮助我们走出一些Critical
point。</p>
<p>​ 如下图所示，在梯度下降中，也许我们训练至一些critical
point，参数就不会继续优化了，但是在物理世界中，如果一个小球从高处滚下，其将会靠着动量滚下saddle
point，也有可能靠着动量滚出local minimum。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114112915300.png" alt="image-20220114112915300" style="zoom:25%;" /></p>
<p>​ 如下图所示是我们普通梯度下降的算法示意图：从<span
class="math inline">\(\theta_0\)</span>开始计算梯度，然后沿着梯度反方向移动下降，一步步进行优化。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114112942271.png" alt="image-20220114112942271" style="zoom:25%;" /></p>
<p>​ 那么在Gradient Descent +
Momentum的算法如下：最开始第一步和原来的一样，从<span
class="math inline">\(\theta^0\)</span>开始计算梯度，然后沿着梯度反方向移动下降，达到<span
class="math inline">\(\theta^1\)</span>时，此时和原先就会发生不同了，其现在的移动会结合前一步的movement（即<span
class="math inline">\(m^1\)</span>）以及当前点的梯度<span
class="math inline">\(g^1\)</span>，计算出一个新的下降方向<span
class="math inline">\(m^2\)</span>，然后进行更新。如图所示：<span
class="math inline">\(m^2\)</span>是由 <span
class="math inline">\(m^1\)</span>和 <span
class="math inline">\(-g^1\)</span>两个向量相加所得到的。从公式上来讲就是$m^1
- g^1 $，两者都有自己的参数，来控制影响整个梯度下降方向的比例。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114113022761.png" alt="image-20220114113022761" style="zoom:25%;" /></p>
<p>​ 其实从另一个角度来看，mi其实是先前所有的梯度的和，也就是g0 -
gi-1的和。所以我们可以说Momentum是考虑了上一步的movement，也可以说Momentum是考虑了先前所有更新点的梯度值。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114113348655.png" alt="image-20220114113348655" style="zoom:15%;" /></p>
<h2
id="十optimize训练tips-automatic-learning-rate">十、Optimize训练Tips:
Automatic Learning Rate</h2>
<p>​
其实，当我们训练卡住的时候，并不一定是碰到了梯度较低的地方，很有可能是在某个山谷的两侧由于学习率过大的问题来回震荡。那么这种现象是怎么产生的呢？</p>
<p>​
在Week1的HW1笔记中，曾经记录数据预处理归一化的重要性，否则很有可能因为不同特征的数据尺度相差太大导致震荡，从而导致训练不出结果，如下图所示：</p>
<p>​ 下图是一个Error
Surface,就是Loss函数的平面，我们使用两种不同大小的学习率去进行梯度下降，黄色的叉叉代表训练终点。我们发现整个Error
Surface中，上下维度的梯度比较陡，左右维度的梯度比较缓。如果我们采用较大的学习率，就会产生左图这样子的黑色训练线，在竖直方向疯狂震荡。但是如果我们使用如右图所示的较小的学习率，一开始是可以沿着竖直方向的梯度慢慢更新，但是当要开始沿水平方向更新的时候，会发现学习率太小了，以至于更新了10w次，还距离我们的训练重点遥遥无期。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220121170751170.png" /></p>
<p>​
所以，我们发现，一个固定的学习率在训练中是不太合适的，最好的话是如图所示，要对不同的参数有不同的学习率，学习率要随着梯度的变化以及参数的变化而进行变化。</p>
<p>​ 于是我们首先提出了如下想法，将原来的学习率η修改成 η/(σit),
这个σit既跟参数相关又跟训练步骤（不同点所在的梯度）相关。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220121170754841.png" /></p>
<p>​
以下就是一种最为简单的σ的计算方式，通过计算每次更新得到的参数空间所在点的梯度的Norm值的平方的平均，即RMS来计算每步中σ。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114113547513.png" alt="image-20220114113547513" style="zoom:25%;" /></p>
<p>​
这种方法被用在Adagrad中，主要思想就是，如果Loss函数在某个方向上比较平坦,梯度比较小，那么我们希望Learning
Rate比较大，快速的走过这一片平坦的区域。如果在某个方向上比较陡峭，我们希望Learning
Rate比较小.</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114113613777.png" alt="image-20220114113613777" style="zoom:25%;" /></p>
<p>​
接下来一种较为进阶的做法叫做RMSProp，它在计算每一步的σ的时候，结合了上一步的σ以及该步的梯度g，同时还有一个超参数α，可以进行调整。如果我们调整α比较大的话，代表其参考当前的梯度较多，也就是说如果梯度突然产生较大变化，其就能快速的反应过来，对LearningRate进行快速的调整。相较于前RMS所有先前的梯度都平均权值考虑的做法，这一做法能够更快速的对梯度的变化进行响应。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114113634056.png" alt="image-20220114113634056" style="zoom:25%;" /></p>
<p>​ 如下所示，是一个较为公式化的写法，以及一个简单的示意图。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114113649974.png" alt="image-20220114113649974" style="zoom: 25%;" /></p>
<p>​
其实按照这种方法，进行训练的话，可能出现如下图所示的训练曲线：为何训练时过一段时间就会突然上下暴走呢？因为其σ是累积平均得到的，在先前的一段时间里，上下方向的更新梯度都近乎为0，累积一段时间以后，上下的梯度就会很小，然后学习率就会变得很大，但是马上又会因为我们的机制更新学习率回来，从而只会出现这样的震荡一下的现象，而不是一直的上下乱窜。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114113710215.png" alt="image-20220114113710215" style="zoom:25%;" /></p>
<p>​ 在自动修改学习率的方法中，还有一种形式叫做Learning Rate
Scheduling：它在原先的基础上对η也进行了一些调整。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114113737186.png" alt="image-20220114113737186" style="zoom:8%;" /></p>
<p>​ 较为常见的就是Learning Rate
Decay这种，随着优化的更新深入，我们使得η逐渐变小。这种想法也是比较能够理解的。类似于越往后快要到达终点了，我们就越要慢慢的靠近，精细的调整，而一开始可以以较大的速率进行更新。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114113805989.png" alt="image-20220114113805989" style="zoom:25%;" /></p>
<p>​ 也有一些网络会用到类似下面的Warming Up的黑科技：</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114113828593.png" alt="image-20220114113828593" style="zoom:25%;" /></p>
<h2
id="十一综合各种训练技巧的优化器adam">十一、综合各种训练技巧的优化器：Adam</h2>
<p>​
Adam是一种综合了RMSProp和Momentum技术的优化器，其大致算法如下图所示，在此处就不多赘述。原论文网址：https://arxiv.org/pdf/1412.6980.pdf</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114113903161.png" alt="image-20220114113903161" style="zoom:33%;" /></p>
<h2
id="十二改变loss函数也有可能影响训练">十二、改变Loss函数，也有可能影响训练：</h2>
<p>​
此部分通过描述分类任务，来顺带阐明改变Loss函数的形式，也有可能影响训练这样一件事情。下图是回归与分类的任务一些差别，在分类任务中，最终的结果往往是一个类别，而不是一个数值，同时，类别往往会由One-hot向量进行表示。所以，我们分类任务所输出的内容往往是一个多个数值的向量y。然后我们需要比较y和
真实类别的标签直接的差别，尽可能的最小化这个差别即可。那么，由于标签往往都是One-hot
向量，所以我们为了比较y和标签的值，往往都会先对y做一个softmax函数进行处理，将y中的所有值归约化至0-1之间，并且所有值的和为1.</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114113948987.png" alt="image-20220114113948987" style="zoom:23%;" /></p>
<p>​
Soft-Max内部对输入进行的处理如下图所示，我们假设输入y1,y2,y3，我们先将三个输入计算exp(y1),exp(y2),exp(y3),然后求和，然后计算输出。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114114013901.png" alt="image-20220114114013901" style="zoom: 25%;" /></p>
<p>​ 那么在得到归一化后的y’之后，我们如何去计算y’和label y
的差距呢？按照先前回归的想法是计算两个向量之间的MSE，也就是如下图所示：</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114114036461.png" alt="image-20220114114036461" style="zoom:25%;" /></p>
<p>​
但其实一般而言，我们在分类任务中，都会采用Cross-Entropy作为Loss函数，即如下所示的公式：</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114114056586.png" alt="image-20220114114056586" style="zoom:9%;" /></p>
<p>​</p>
<p>​
一个简单的解释是，最小化Cross-Entropy和最大化似然概率是完全等同的一件事情（至于为什么完全等同，可以找相关资料），分类任务就是要找出计算得到的y属于哪一类的概率最大，所以我们往往采用Cross-Entropy作为Loss函数。而计算Cross-Entropy之前，我们往往就是要对网络的输出进行SoftMax函数的处理。所以往往SoftMax会和Cross-Entropy绑定在一起，有趣的是Pytorch的底部实现中，如果你的Loss函数使用了Cross-Entropy，那么你在网络结构中是不需要实现SoftMax层的，因为它会自动将SoftMax层加到你的网络的最上面。</p>
<p>​ 如下所示是一个比较直观的结果：当我们采用不同的Loss函数的时候，Error
Map也会截然不同。左侧采用MSE的Error map在左上角的区域上（也就是Large
Loss）的区域上，梯度就很平坦，就很难训练，而采用Cross-Entropy则会好训练很多。这也就是为什么说有的时候改变Loss函数，也可以改变训练的难度。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114114125892.png" alt="image-20220114114125892" style="zoom:25%;" /></p>
<h2
id="十三feature-normalization-batch-normalization-技术">十三、Feature
Normalization: Batch Normalization 技术</h2>
<p>​
我们先前提及过，当训练数据不同维度的特征的尺度相差较大时，训练难度会较大，那么Feature
Normalization就是为了使得不同特征的尺度类似，从而使得Error
Surface较为平滑。如下图所示：左侧的Loss函数平面，不同特征的梯度变化不同，有Smooth和Steep两类不同的内容。右侧就是做了一个Feature
Normalization以后的Error Surface，各个维度都较为平滑。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114114217069.png" alt="image-20220114114217069" style="zoom:25%;" /></p>
<p>​
那么最为平常的特征正则化，如下所示：比如说给出一组x向量，我们计算向量中每个维度的平均值与方差，然后通过如下公式进行计算，我们就可以将所有维度的数据归约化至一个mean为0，deviation为1的一个分布中，使得大致的数据尺度差不多。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114114244676.png" alt="image-20220114114244676" style="zoom:25%;" /></p>
<p>​
上述的归约化处理在HW1的代码中也已经有所体现，那么先前我们在说的是数据预处理步骤中，对于所有数据的归约化。那么对于深度学习来说，可能存在如下问题：</p>
<p>​
如下图所示，输入的特征经过归一化以后，在第一层的训练参数是比较正常的，但是经过第一层的参数以后，输出的不同维度的数据又可能回到了不同尺度这样一种状态。这样的话，对于第二层的网络来讲，参数优化又会变得较为困难。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114114310723.png" alt="image-20220114114310723" style="zoom:25%;" /></p>
<p>​
所以我们需要在层与层之间也进行归一化的操作，如下示例来讲，就是通过z1,z2,z3计算出u和σ。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114114331145.png" alt="image-20220114114331145" style="zoom:25%;" /></p>
<p>​
然后我们再将z1,z2,z3根据公式来进行归一化的操作，得到归约化后的z1,z2,z3。这边的话其实有一个有趣的内容：原本来说，如果参数更新了，z1更新了，那么只会影响a1的改变，但是现在而言，加入了BN以后，z1更新了以后，会影响到u和σ,从而会再影响归约化后的z1,z2,z3，随后a2,a3也会受到影响。所以，当我们加入归约化的时候，就需要将整个考虑成一个大的网络。所以就把BN做成一个Batch
Normalization层。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114114355882.png" alt="image-20220114114355882" style="zoom:25%;" /></p>
<p>​
并且，我们在训练过程中，由于输入数据往往是一个Batch一个Batch输入的，所以训练时计算的u和σ我们往往不会去计算所有的训练数据，而是计算该Batch内部的所有数据的u（向量）和σ（向量）。故而，这个技术叫Batch
Normalization。</p>
<p>​ 所以，Batch
Normalization往往需要在Batch比较大的时候才会可以使用，会比较好一些。不然的话计算得到的u和σ并不能代表训练数据的一些分布，归约化就会出现一些问题。同时，再归约化时也会有一些小的问题如下：</p>
<p>​ 因为我们归约化至了mean = 0,
deviation=1的数据分布，会不会影响后续机器学习的性能，所以我们再归约化后又加入了γ和β两个参数，在训练开始时，γ
一般为1，β一般为0，帮助其更好的拟合后续的特征，同时又能较大程度的保持各个维度的数据在统一尺度下。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114114421588.png" alt="image-20220114114421588" style="zoom:26%;" /></p>
<p>​
那么先前所讲的是在训练过程中的BatchNoramlization,那么如果在Testing的过程中，</p>
<p>​
每次输入一个数据，没有凑齐一个Batch的情况下，BatchNormalization又应当如何执行呢？此时，我们的u和σ就不来源于测试的Batch了，而是来源于训练时候每一个Batches计算得到的u的均值依据一些权重累加得到。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114114447990.png" alt="image-20220114114447990" style="zoom:25%;" /></p>
<p>​ 总而言之，Batch Normalization能让你的error surface
更加平滑，从而降低训练的难度，让网络拥有更好的性能，这样的解释无论是理论还是实验都已经被人所证实。具体可以参见这篇论文《How
Does Batch Normalization Help Optimization?》。</p>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>ML2021课程系列笔记</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Training Tricks</tag>
      </tags>
  </entry>
  <entry>
    <title>ML2021课程系列笔记1——DeepLearning基本介绍</title>
    <url>/2021/12/17/d3d6f910aaf2/</url>
    <content><![CDATA[<h3
id="hung-yi-lee-李宏毅-machine-learning2021spring课程week1笔记">Hung-yi
Lee (李宏毅) MACHINE LEARNING2021SPRING课程Week1笔记</h3>
<h3
id="课程网址httpsspeech.ee.ntu.edu.twhyleeml2021-spring.html">课程网址：https://speech.ee.ntu.edu.tw/~hylee/ml/2021-spring.html</h3>
<p>其实Machine Learning的过程就是以下的三个基本步骤：</p>
<p>​ 1、 Function with Unknown Parameters</p>
<p>​ 2、 Define Loss From Training Data</p>
<p>​ 3、 Optimization</p>
<p>本篇就围绕这三个步骤进行简单的讲解：</p>
<h2 id="一最简单的ml模型函数">一、最简单的ML模型函数：</h2>
<p>​ 在最简单的ML的过程中：</p>
<p>​
我们的第一步就是要找一个有未知参数的函数，那么最简单的就是最为纯粹的线性模型：Y
= wx1 + b.</p>
<p>​
我们将x1称为feature，w，b称为未知待训练参数，在第二步中，我们定义一个损失函数Loss，这个损失函数代表该线性模型拟合数据的好坏程度。它是模型未知参数的函数，即L(w,b)。我们利用训练数据集，来计算这个Loss函数的值，从而判断该模型拟合数据的好坏。</p>
<p>​
第三步，我们就是要找到一组最好的w和b，使得Loss函数最小，也就是使得我们的模型最能够拟合数据。在这一步中，常常会用到梯度下降的方法去进行优化。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220121170849128.png" /></p>
<p>​
至此，一个最为简单的机器学习任务就完成了，我们用一个最简单的带两个未知参数的函数，去拟合一组数据，找到了最能够拟合这组数据的两个参数的数值。简单而言，训练的步骤就是由以下这三步组成。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114105405284.png" alt="image-20220114105405284" style="zoom: 25%;" /></p>
<h2 id="二进阶的ml模型函数">二、进阶的ML模型函数</h2>
<p>​
然后我们在想，刚才那样是最简单的线性模型，如果我们增加features，我们可以得到如下图所示的带7个参数的模型，也可以得到有28个参数的模型……当然在第二步和第三步中过程是一样的。参数越多，我们能够拟合的features就越多。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114105522828.png" alt="image-20220114105522828" style="zoom: 8%;" />
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114105556231.png" alt="image-20220114105556231" style="zoom:8%;" /></p>
<p>​
但是，仅仅是线性的模型的组合，还是让我们能够拟合的函数太过有限了，所以我们还想在第一步中找到更flex一点的函数，于是乎，我们就发现了sigmoid函数：它也有b，w，c三个未知参数。。那么进行推广以后，也可以将所有的函数</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114105640184.png" alt="image-20220114105640184" style="zoom:19%;" /></p>
<p>​
那么进行推广以后，我们可以将如图所示的红色函数，用三个sigmoid函数的叠加来进行拟合，也就是能够列出一个图片左下方的公式，这个公式共有3*3
+ 1 = 10个参数。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114105705024.png" alt="image-20220114105705024" style="zoom:25%;" /></p>
<p>​</p>
<p>​ 我们将这个式子提取出来，再仔细的看一看：</p>
<p>​
其实我们可以讲上述这个式子写成矩阵相乘的形式，我们首先看sigmoid函数内部所干的事情，sigmoid函数内部所干的事情就可以写成如下所示的矩阵表示形式，r
= b + W * x</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114105732731.png" alt="image-20220114105732731" style="zoom:25%;" /></p>
<p>​ 然后我们的r向量中的每一项再分别通过sigmoid函数，得到a向量</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114105800543.png" alt="image-20220114105800543" style="zoom:25%;" /></p>
<p>​
最后a向量[a1,a2,a3]乘上系数c1,c2,c3，再加上偏执b，得到最终的预测值y。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114105825308.png" alt="image-20220114105825308" style="zoom:25%;" /></p>
<p>​ 故而我们最终就可以将这个more
flexible的函数写成如下形式，其中的W，b(绿色)，c，b(灰色)，都是未知参数，而x是features，y是tag。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114105847631.png" alt="image-20220114105847631" style="zoom:25%;" /></p>
<p>​ 随后，我们可以把所有的未知参数拼接起来，称为向量θ。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114105904095.png" alt="image-20220114105904095" style="zoom: 15%;" /></p>
<p>​
然后，再次回到ML框架中，在第二步的寻找Loss函数的时候，与前面基础的其实相差不多。此时Loss函数应当是θ的函数，即L(θ)，最后再使用梯度下降优化的时候，我们就是要找到一个θ*来使得Loss函数值最小。</p>
<p>​ <span class="math inline">\(\theta^{*} = arg min_\theta
L\)</span></p>
<p>​
至于方法，也与前面一致：计算Loss函数对各个未知参数的倒数，然后梯度下降即可。按照下图所示，我们将L对各个未知参数的导数组成了一个向量，称为梯度。然后依据学习率来进行未知参数的更新。</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114110015271.png" alt="image-20220114110015271" style="zoom:23%;" /></p>
<p>​
在这个训练优化参数的过程中，我们需要注意，我们往往不会一次性拿所有的训练数据来计算损失函数，从而更新未知参数，而是会将训练数据分成一个batch一个batch，每次使用一个batch来计算损失函数，进而计算梯度，更新未知参数。</p>
<p>​ 所有我们需要区分以下一些名词：<strong>Update / Epoch / Batch Size /
Training Data</strong></p>
<ul>
<li><p>Update: 每做一次梯度下降，更新一次参数，就叫做一次Update</p></li>
<li><p>Batch Size:
每次用来计算梯度下降更新参数用到的训练集中样本的个数，我们在训练时往往会将其分为一个Batch一个Batch，每次使用一个Batch来计算梯度，更新参数。</p></li>
<li><p>Training Data: 所有的训练数据集样本。</p></li>
<li><p>Epoch:
每当使用过一轮所有的训练数据集样本以后，叫做一个Epoch</p></li>
</ul>
<p>​ 整个的Optimization的过程如下所示：</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114110125128.png" alt="image-20220114110125128" style="zoom:23%;" /></p>
<p>​ 下面是一些帮助理解的例子：</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114110144324.png" alt="image-20220114110144324" style="zoom:25%;" /></p>
<h2
id="三ml模型最终进化deeplearning">三、ML模型最终进化——DeepLearning</h2>
<p>​
在第二部分的function中，我们拟合了许多个sigmoid函数，sigmoid函数内部又是线性的函数。最终，形成了如下图所示的一个数据流。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114110230140.png" alt="image-20220114110230140" style="zoom:20%;" /></p>
<p>​
其实，我们在得到[a1,a2,a3]之后，还可以将[a1,a2,a3]再次作为输入，输入到另一个类似结构中去，如下所示：这样子所形成的模型够更好的拟合数据。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114110253145.png" alt="image-20220114110253145" style="zoom:25%;" />‘</p>
<p>​
我们将每一个sigmoid函数组成的单位叫做一个Neuron，每处理一次数据所有的Neuron组成的叫做一个Hidden
Layer，由于整个架构会有很多个Hidden
Layer组成，这种架构的模型函数就叫做<strong>Deep Neural Network ( DNN
)</strong>，深度神经网络，</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114110326577.png" alt="image-20220114110326577" style="zoom:20%;" />‘’</p>
<p>​ 以下便是一些比较经典的DNN架构的网络：ALexNet、VGG、GoogleNet等等</p>
<p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114110348644.png" alt="image-20220114110348644" style="zoom:25%;" /></p>
<h2 id="附录-hw1-回归任务作业笔记">附录： HW1 回归任务作业笔记</h2>
<h4
id="有关数据预处理中的归一化处理">1、有关数据预处理中的归一化处理</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.data[:, <span class="number">40</span>:] = (self.data[:, <span class="number">40</span>:] - self.data[:, <span class="number">40</span>:].mean(dim=<span class="number">0</span>, keepdim=<span class="literal">True</span>)) / self.data[:, <span class="number">40</span>:].std(dim=<span class="number">0</span>, keepdim=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>​
其可以帮助你将数据的不同维度的特征数值，压到类似的尺度上，不至于出现有些维度的特征数值是km级别，有些可能是mm级别。如果不同维度的特征尺度相差太大，会导致训练时梯度下降算法非常难以执行，Lr过小的话，体现出的结果就是训练了半天Loss降不下去。Lr过大又可能导致Loss乱窜。所以归一化处理还是很重要的。</p>
<h4
id="如果模型太复杂易过拟合我们可以在loss函数中加入l2正则化项">2、如果模型太复杂易过拟合，我们可以在Loss函数中加入L2正则化项</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cal_loss</span>(<span class="params">self, pred, target</span>):</span><br><span class="line">	regularization_loss = <span class="number">0</span></span><br><span class="line">	<span class="comment"># 使用L2正则项</span></span><br><span class="line">	<span class="keyword">for</span> param <span class="keyword">in</span> model.parameters():</span><br><span class="line">		regularization_loss += torch.<span class="built_in">sum</span>(param ** <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">return</span> self.criterion(pred, target) + <span class="number">0.00075</span> * regularization_loss</span><br></pre></td></tr></table></figure>
<h4
id="训练模型的基本步骤以及一些tricks">3、训练模型的基本步骤以及一些tricks</h4>
<ul>
<li>1）每一个epoch中需要执行的必备步骤：切换模型至train模式，通过dataLoader迭代遍历每一个Batch，在每一个Batch中，首先将梯度调整至0，然后前向计算，然后计算Loss，然后通过Loss.backward()反向传播，最后通过优化器更新模型参数。</li>
<li>2）在每一轮epoch结束后 ，使用验证集进行验证，计算dev_mse.</li>
<li>3）在每一轮epoch结束后，如果dev_mse没有进步的话early_stop_cnt++,当early_stop_cnt达到设定值时，提早结束训练。（代表已经很多轮没有进步了）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">min_mse = <span class="number">1000.</span></span><br><span class="line">early_stop_cnt = <span class="number">0</span></span><br><span class="line">epoch = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> epoch &lt; n_epochs:</span><br><span class="line">	model.train() <span class="comment"># set model to training mode</span></span><br><span class="line">	<span class="keyword">for</span> x, y <span class="keyword">in</span> tr_set: <span class="comment"># iterate through the dataloader</span></span><br><span class="line">		optimizer.zero_grad() <span class="comment"># set gradient to zero</span></span><br><span class="line">		x, y = x.to(device), y.to(device) <span class="comment"># move data to device (cpu/cuda)</span></span><br><span class="line">		pred = model(x) <span class="comment"># forward pass (compute output)</span></span><br><span class="line">		mse_loss = model.cal_loss(pred, y) <span class="comment"># compute loss</span></span><br><span class="line">		mse_loss.backward() <span class="comment"># compute gradient (backpropagation)</span></span><br><span class="line">		optimizer.step() <span class="comment"># update model with optimizer</span></span><br><span class="line">	<span class="comment"># After each epoch, test your model on the validation (development) set.</span></span><br><span class="line">	dev_mse = dev(dv_set, model, device)</span><br><span class="line">	<span class="keyword">if</span> dev_mse &lt; min_mse:</span><br><span class="line">		<span class="comment"># Save model if your model improved</span></span><br><span class="line">		min_mse = dev_mse</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;Saving model (epoch = &#123;:4d&#125;, loss = &#123;:.4f&#125;)&#x27;</span>.<span class="built_in">format</span>(epoch + <span class="number">1</span>, min_mse))</span><br><span class="line">		torch.save(model.state_dict(), config[<span class="string">&#x27;save_path&#x27;</span>]) <span class="comment"># Save model to specified path</span></span><br><span class="line">		early_stop_cnt = <span class="number">0</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		early_stop_cnt += <span class="number">1</span></span><br><span class="line">	epoch += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># Stop training if your model stops improving for &quot;config[&#x27;early_stop&#x27;]&quot; epochs.</span></span><br><span class="line">	<span class="keyword">if</span> early_stop_cnt &gt; config[<span class="string">&#x27;early_stop&#x27;</span>]:</span><br><span class="line">		<span class="keyword">break</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>ML2021课程系列笔记</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch学习笔记9——常用编码技巧（更新中）</title>
    <url>/2021/12/17/17d1273518ee/</url>
    <content><![CDATA[<h3 id="task1">Task1：</h3>
<h4
id="任务描述完成padding填充使得h和w为2的倍数同时实现下图所示的变换">任务描述：完成padding填充，使得H和W为2的倍数同时，实现下图所示的变换：</h4>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/image-20211229101356170.png" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入的x，维度size为[B,L,C] ,其中L = H * W</span></span><br><span class="line">x = x.view(B, H, W, C) <span class="comment"># 首先将其重新展为 [B,H,W,C]</span></span><br><span class="line"><span class="comment"># padding 然后，如果输入feature map的H，W不是2的整数倍，需要进行padding</span></span><br><span class="line">pad_input = (H % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">or</span> (W % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> pad_input:</span><br><span class="line">   <span class="comment"># (C_front, C_back, W_left, W_right, H_top, H_bottom)</span></span><br><span class="line">   <span class="comment"># 注意这里的Tensor通道是[B, H, W, C]，所以会和官方文档有些不同</span></span><br><span class="line">   x = F.pad(x, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, W % <span class="number">2</span>, <span class="number">0</span>, H % <span class="number">2</span>)) <span class="comment"># 在右侧和底侧进行padding</span></span><br><span class="line">   </span><br><span class="line"><span class="comment"># 此时要开始进行下采样了，如何在H，W这个平面上进行下采样呢？ 非常关键的编码技巧！！</span></span><br><span class="line">x0 = x[:, <span class="number">0</span>::<span class="number">2</span>, <span class="number">0</span>::<span class="number">2</span>, :]  <span class="comment"># [B, H/2, W/2, C]   ::2 代表 步长</span></span><br><span class="line">x1 = x[:, <span class="number">1</span>::<span class="number">2</span>, <span class="number">0</span>::<span class="number">2</span>, :]  <span class="comment"># [B, H/2, W/2, C]</span></span><br><span class="line">x2 = x[:, <span class="number">0</span>::<span class="number">2</span>, <span class="number">1</span>::<span class="number">2</span>, :]  <span class="comment"># [B, H/2, W/2, C]</span></span><br><span class="line">x3 = x[:, <span class="number">1</span>::<span class="number">2</span>, <span class="number">1</span>::<span class="number">2</span>, :]  <span class="comment"># [B, H/2, W/2, C]</span></span><br><span class="line"><span class="comment"># 然后将四个子矩阵在channel维度[也就是最后一个维度]上进行拼接</span></span><br><span class="line">x = torch.cat([x0, x1, x2, x3], -<span class="number">1</span>)  <span class="comment"># [B, H/2, W/2, 4*C]</span></span><br><span class="line"><span class="comment"># 再重新将H/2,W/2平面展成1个维度</span></span><br><span class="line">x = x.view(B, -<span class="number">1</span>, <span class="number">4</span> * C)  <span class="comment"># [B, H/2*W/2, 4*C]</span></span><br></pre></td></tr></table></figure>
<h3 id="task2">Task2:</h3>
<h4 id="任务描述-python中的广播机制">任务描述： Python中的广播机制</h4>
<p>​
在python中使用numpy进行<strong>按位运算</strong>的时候，有一个小技巧可以帮助减少代码量——那就是broadcasting,广播机制。简单来说，broadcasting可以这样理解：如果你有一个m
* n的矩阵，让它加减乘除一个1 * n的矩阵，它会被复制m次，成为一个m *
n的矩阵，然后再逐元素地进行加减乘除操作。同样地对m * 1的矩阵成立。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/750.png" /></p>
<p>代码示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = numpy.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">result = A + <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	[101 102 103]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 就不再需要去书写 A + [100,100,100] 了</span></span><br><span class="line"></span><br><span class="line">A = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])  <span class="comment"># [3,2]</span></span><br><span class="line">result = A + [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]   <span class="comment"># [3,1]</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[[101 202 303]</span></span><br><span class="line"><span class="string"> [104 205 306]]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>### Task3:</p>
<h4 id="section"></h4>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Pytorch系列笔记</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch学习笔记8——常用函数整理（更新中）</title>
    <url>/2021/12/16/60a9625b780d/</url>
    <content><![CDATA[<h3 id="softmax-dim应当如何填">1、SoftMax — dim应当如何填？</h3>
<p>官方文档：https://pytorch.org/docs/stable/generated/torch.nn.functional.softmax.html?highlight=softmax#torch.nn.functional.softmax</p>
<p>1）标准用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.functional.softmax(<span class="built_in">input</span>, dim)</span><br><span class="line">（Applies a softmax function.）</span><br></pre></td></tr></table></figure>
<p>2）依赖库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br></pre></td></tr></table></figure>
<p>3）简单示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=torch.rand(<span class="number">3</span>,<span class="number">16</span>,<span class="number">20</span>) <span class="comment"># 我们看一个三维的tensor</span></span><br><span class="line">b=F.softmax(a,dim=<span class="number">0</span>)  </span><br><span class="line"><span class="comment"># dim = 0代表 输出的是在dim=0维上的概率分布，也就是说 对于任意的i,j (i是dim=1上的某个坐标，j是dim=2上的某个坐标)，通过softmax之后，要求 a[0][i][j] + a[1][i][j] + a[2][i][j] = 1 【此处仅有3项相加，原因是a向量dim=0维度 长度为3，仅有3个元素。】</span></span><br></pre></td></tr></table></figure>
<p>4）一个更为一般的示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=torch.rand(x1,x2,x3,x4,……,xn) <span class="comment"># 我们看一个n维的tensor</span></span><br><span class="line">b=F.softmax(a,dim=m)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dim = m代表 输出的是在dim=m维上的概率分布，也就是说 通过softmax之后，对于任意的dim!=m的维度的一个定位：i1,i2,i3,……im-1,im+1,……in，需要满足如下公式 </span></span><br><span class="line"><span class="comment">#  a[i1][i2]……[im-1][0][im+1]……[in] + </span></span><br><span class="line"><span class="comment">#  a[i1][i2]……[im-1][1][im+1]……[in] +</span></span><br><span class="line"><span class="comment">#  a[i1][i2]……[im-1][2][im+1]……[in] +</span></span><br><span class="line"><span class="comment">#  …… +</span></span><br><span class="line"><span class="comment">#  a[i1][i2]……[im-1][xm][im+1]……[in] = 1 即可</span></span><br></pre></td></tr></table></figure>
<h3 id="view函数">2、View函数</h3>
<p>官方文档：https://pytorch.org/docs/stable/generated/torch.Tensor.view.html?highlight=view#torch.Tensor.view</p>
<p>1）标准用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tensor.view(*shape) → Tensor</span><br><span class="line">(Returns a new tensor with the same data as the `self` tensor but of a different `shape`.)</span><br></pre></td></tr></table></figure>
<p>2）依赖库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import torch</span><br></pre></td></tr></table></figure>
<p>3）简单示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.rand(<span class="number">10</span>)  <span class="comment"># 一个1维的Tensor</span></span><br><span class="line">y = x.view(<span class="number">2</span>, <span class="number">5</span>) <span class="comment"># 将其resize成了一个2*5大小的 二维的Tensor</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">x: tensor([0.6611, 0.3041, 0.8008, 0.1733, 0.0197, 0.3914, 0.0468, 0.2380, 0.4159,</span></span><br><span class="line"><span class="string">        0.8241])</span></span><br><span class="line"><span class="string">y: tensor([[0.6611, 0.3041, 0.8008, 0.1733, 0.0197],</span></span><br><span class="line"><span class="string">        [0.3914, 0.0468, 0.2380, 0.4159, 0.8241]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>4）扩展示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.rand(<span class="number">20</span>)  <span class="comment"># 一个1维的Tensor</span></span><br><span class="line">y = x.view(<span class="number">2</span>,<span class="number">5</span>,-<span class="number">1</span>) <span class="comment"># 将其resize成了一个 2*5*? 大小的 三维的Tensor，？代表第三维度的大小需要推断得到，在此处的话，最后应该会形成一个2*5*2的三维Tensor。</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">x: tensor([0.5704, 0.4154, 0.0700, 0.8145, 0.1743, 0.1049, 0.1678, 0.2554, 0.9557,</span></span><br><span class="line"><span class="string">        0.0484, 0.7714, 0.5377, 0.8711, 0.6069, 0.0996, 0.6384, 0.9334, 0.2851,</span></span><br><span class="line"><span class="string">        0.5883, 0.5882])</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">y: tensor([[[0.5704, 0.4154],</span></span><br><span class="line"><span class="string">         [0.0700, 0.8145],</span></span><br><span class="line"><span class="string">         [0.1743, 0.1049],</span></span><br><span class="line"><span class="string">         [0.1678, 0.2554],</span></span><br><span class="line"><span class="string">         [0.9557, 0.0484]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        [[0.7714, 0.5377],</span></span><br><span class="line"><span class="string">         [0.8711, 0.6069],</span></span><br><span class="line"><span class="string">         [0.0996, 0.6384],</span></span><br><span class="line"><span class="string">         [0.9334, 0.2851],</span></span><br><span class="line"><span class="string">         [0.5883, 0.5882]]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下为错误示例：</span></span><br><span class="line">x = torch.rand(<span class="number">10</span>)</span><br><span class="line">y = x.view(<span class="number">2</span>,<span class="number">3</span>)  <span class="comment"># 会报错</span></span><br><span class="line">y = x.view(<span class="number">2</span>,)   <span class="comment"># 会报错</span></span><br></pre></td></tr></table></figure>
<h3 id="permute函数">3、Permute函数</h3>
<p>1）标准用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">torch.permute(input, dims) → Tensor</span><br><span class="line">- parameters:</span><br><span class="line">  input (Tensor) – the input tensor.</span><br><span class="line">  dims (tuple of python:ints) – The desired ordering of dimensions</span><br></pre></td></tr></table></figure>
<p>2）依赖库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure>
<p>3）简单示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.randn(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(x.size())</span><br><span class="line"><span class="comment"># torch.Size([2, 3, 5])</span></span><br><span class="line"><span class="built_in">print</span>(torch.permute(x, (<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>)).size())</span><br><span class="line"><span class="comment"># torch.Size([5, 2, 3])</span></span><br><span class="line"><span class="comment"># 我们可以看到：  [dim0,dim1,dim2,dim3,dim4]  经过permute(2,0,1,4,3)以后：</span></span><br><span class="line"><span class="comment"># （ permute的含义：	现在的第0维应当为原来的第2维，现在的第1维应当为原来的第0维，…… ）</span></span><br><span class="line"><span class="comment"># 会变成如下形式。[dim2,dim0,dim1,dim4,dim3]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="nn.identity">4、nn.Identity()</h3>
<p>官方文档：https://pytorch.org/docs/stable/generated/torch.nn.Identity.html#torch.nn.Identity</p>
<p>1）标准用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class torch.nn.Identity(*args, **kwargs)</span><br><span class="line">- A placeholder identity operator that is argument-insensitive.</span><br></pre></td></tr></table></figure>
<p>2）依赖库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import torch.nn</span><br></pre></td></tr></table></figure>
<p>3）简单示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; m = nn.Identity(54, unused_argument1=0.1, unused_argument2=False)</span><br><span class="line">&gt;&gt;&gt; input = torch.randn(128, 20)</span><br><span class="line">&gt;&gt;&gt; output = m(input)</span><br><span class="line">&gt;&gt;&gt; print(output.size())</span><br><span class="line">torch.Size([128, 20])</span><br><span class="line"></span><br><span class="line"># 经过m等于 没有发生任何变换 </span><br></pre></td></tr></table></figure>
<h3 id="nn.parameter">5、nn.Parameter</h3>
<p>官方文档：https://pytorch.org/docs/stable/generated/torch.nn.parameter.Parameter.html?highlight=parameter#torch.nn.parameter.Parameter</p>
<p>1）标准用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class torch.nn.Parameter(data=None, requires_grad=True)</span><br><span class="line">- A kind of Tensor that is to be considered a module parameter.</span><br><span class="line">- 创建一个可训练参数</span><br><span class="line">- when they’re assigned as Module attributes they are automatically added to the list of its parameters, and will appear e.g. in parameters() iterator. </span><br><span class="line">- 当它们作为模型的一个属性的时候，会被自动加入到模型的可训练参数中去</span><br></pre></td></tr></table></figure>
<p>2）依赖库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn</span><br></pre></td></tr></table></figure>
<p>3）简单示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Layer</span>(nn.Module):</span><br><span class="line">	  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">	  	self.cls_token = nn.Parameter(torch.zeros(<span class="number">1</span>, <span class="number">1</span>, <span class="number">762</span>))</span><br></pre></td></tr></table></figure>
<h3 id="nn.functional.pad">6、nn.functional.pad</h3>
<p>官方文档：https://pytorch.org/docs/stable/generated/torch.nn.functional.pad.html?highlight=pad#torch.nn.functional.pad</p>
<p>1）标准用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">torch.nn.functional.pad(input, pad, mode=&#x27;constant&#x27;, value=0.0)</span><br><span class="line">-	input (Tensor) – N-dimensional tensor</span><br><span class="line">- pad (tuple) – m-elements tuple, where m/2 ≤ input dimensions and m is even.</span><br><span class="line">- mode – &#x27;constant&#x27;, &#x27;reflect&#x27;, &#x27;replicate&#x27; or &#x27;circular&#x27;. Default: &#x27;constant&#x27;</span><br><span class="line">- value – fill value for &#x27;constant&#x27; padding. Default: 0</span><br><span class="line"></span><br><span class="line">对于padding-size的说明：</span><br><span class="line">	填充尺寸用来填充输入的某些维度，从最后一个维度开始进行描述。比如说:</span><br><span class="line">	如果想要填充最后一个维度，那就设置为(padding_left,padding_right)</span><br><span class="line">	如果想要填充最后两个维度，那就设置为(padding_left,padding_right,padding_top,padding_bottom)</span><br></pre></td></tr></table></figure>
<p>2）依赖库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn.function <span class="keyword">as</span> F</span><br></pre></td></tr></table></figure>
<p>3）简单示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line">t2d = torch.rand(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">p1d = (<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(t2d)</span><br><span class="line">out = F.pad(t2d, p1d, <span class="string">&quot;constant&quot;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(out.size())</span><br><span class="line"><span class="built_in">print</span>(out)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[0.6359, 0.0629],</span></span><br><span class="line"><span class="string">        [0.5814, 0.5980]])</span></span><br><span class="line"><span class="string">torch.Size([2, 4])</span></span><br><span class="line"><span class="string">tensor([[0.0000, 0.6359, 0.0629, 0.0000],</span></span><br><span class="line"><span class="string">        [0.0000, 0.5814, 0.5980, 0.0000]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>4）扩展示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t4d = torch.empty(<span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p3d = (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>) <span class="comment"># pad by (0, 1), (2, 1), and (3, 3)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>out = F.pad(t4d, p3d, <span class="string">&quot;constant&quot;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(out.size())</span><br><span class="line">torch.Size([<span class="number">3</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<h3 id="flatten">7、flatten</h3>
<p>官方文档：https://pytorch.org/docs/stable/generated/torch.flatten.html#torch.flatten</p>
<p>1）标准用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">torch.flatten(input, start_dim=0, end_dim=- 1) → Tensor</span><br><span class="line">  - input (Tensor) – the input tensor.</span><br><span class="line">  - start_dim (int) – the first dim to flatten</span><br><span class="line">  - end_dim (int) – the last dim to flatten</span><br></pre></td></tr></table></figure>
<p>2）依赖库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure>
<p>3）简单示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">t2d = torch.rand(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(t2d, t2d.size())</span><br><span class="line">out = torch.flatten(t2d, <span class="number">1</span>)  <span class="comment"># 从第1维开始，展平后续所有维度</span></span><br><span class="line"><span class="built_in">print</span>(out, out.size())</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[[0.4151, 0.8645],</span></span><br><span class="line"><span class="string">         [0.1289, 0.2260]],</span></span><br><span class="line"><span class="string">        [[0.3302, 0.0393],</span></span><br><span class="line"><span class="string">         [0.9822, 0.5305]]]) torch.Size([2, 2, 2])</span></span><br><span class="line"><span class="string">tensor([[0.4151, 0.8645, 0.1289, 0.2260],</span></span><br><span class="line"><span class="string">        [0.3302, 0.0393, 0.9822, 0.5305]]) torch.Size([2, 4])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>4）扩展示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Q1、现在有一个向量t，其size为 [A,B,C,D,E,F,G] ,然后我们对其应用flatten: torch.flatten(t,2,4),</span><br><span class="line">那么size会变成？</span><br><span class="line">Answer: [A,B,C*D*E,F,G]</span><br><span class="line"></span><br><span class="line">Q2、现在有一个向量t，其size为 [A,B,C,D,E,F,G] ,然后我们对其应用flatten: torch.flatten(t,-2),</span><br><span class="line">那么size会变成？</span><br><span class="line">Answer: [A,B,C,D,E,F*G] 等效于应用torch.flatten(t,5) 等效于应用torch.flatten(t,5,6)</span><br><span class="line"></span><br><span class="line">Q3、现在有一个向量t，其size为 [A,B,C,D,E,F,G] ,然后我们对其应用flatten: torch.flatten(t),</span><br><span class="line">那么size会变成？</span><br><span class="line">Answer: [A*B*C*D*E*F*G] </span><br><span class="line"></span><br><span class="line">Q3、现在有一个向量t，其size为 [A,B,C,D,E,F,G] ,然后我们对其应用flatten: torch.flatten(t,1),</span><br><span class="line">那么size会变成？</span><br><span class="line">Answer: [A,B*C*D*E*F*G] </span><br></pre></td></tr></table></figure>
<h3 id="transpose">8、Transpose</h3>
<p>官方文档：https://pytorch.org/docs/stable/generated/torch.transpose.html#torch.transpose</p>
<p>1）标准用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">torch.transpose(input, dim0, dim1) → Tensor</span><br><span class="line"></span><br><span class="line">-	Returns a tensor that is a transposed version of input. The given dimensions dim0 and dim1 are swapped.</span><br><span class="line">- input (Tensor) – the input tensor.</span><br><span class="line">- dim0 (int) – the first dimension to be transposed</span><br><span class="line">- dim1 (int) – the second dimension to be transposed</span><br><span class="line"></span><br><span class="line">注：此处的转置通用于高阶矩阵，函数将会对dim0和dim1这两个维度形成的平面进行转置，交换dim0和dim1,而不影响其他维度。</span><br></pre></td></tr></table></figure>
<p>2）依赖库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure>
<p>3）简单示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t2d = torch.rand(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(t2d, t2d.size())</span><br><span class="line">out = torch.transpose(t2d, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(out, out.size())</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[0.5228, 0.2990, 0.1111],</span></span><br><span class="line"><span class="string">        [0.4857, 0.4479, 0.6637]]) torch.Size([2, 3])</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">tensor([[0.5228, 0.4857],</span></span><br><span class="line"><span class="string">        [0.2990, 0.4479],</span></span><br><span class="line"><span class="string">        [0.1111, 0.6637]]) torch.Size([3, 2])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>4）扩展示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在高维的矩阵中，不要太过注重打印数据显示的变化形式，从维度长度的变化入手，即可清晰的搞懂</span><br><span class="line"></span><br><span class="line">Q1、现在有一个向量t，其size为 [A,B,C,D,E,F,G] ,然后我们对其应用transpose: torch.transpose(t,2,4),</span><br><span class="line">那么size会变成？</span><br><span class="line"></span><br><span class="line">Answer: [A,B,E,D,C,F,G]  可以看到，从size上来讲其实就是交换了第2维和第4维的长度。从数据上来讲，你可以想象其找到了第2维和第4维形成的数据平面，然后应用了正常的转置。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="cat函数">9、Cat函数</h3>
<p>官方文档：https://pytorch.org/docs/stable/generated/torch.cat.html?highlight=cat#torch.cat</p>
<p>1）标准用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">torch.cat(tensors, dim=0, *, out=None) → Tensor</span><br><span class="line"></span><br><span class="line">- Concatenates the given sequence of seq tensors in the given dimension. All tensors must either have the same shape (except in the concatenating dimension) or be empty.</span><br><span class="line"></span><br><span class="line">- tensors (sequence of Tensors) – any python sequence of tensors of the same type. Non-empty tensors provided must have the same shape, except in the cat dimension.</span><br><span class="line">- dim (int, optional) – the dimension over which the tensors are concatenated</span><br><span class="line"></span><br><span class="line">注：tensors参数需要输入一个tensor的序列，所有的需要拼接的tensors需要有同样的形状维度（除了拼接的那一维）</span><br><span class="line">dim指定要拼接的维度</span><br></pre></td></tr></table></figure>
<p>2）依赖库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure>
<p>3）简单示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">x = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(x, x.size())</span><br><span class="line">out = torch.cat((x, x, x), <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(out, out.size())</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[-1.2926, -0.3155,  0.5966],</span></span><br><span class="line"><span class="string">        [ 0.8921, -2.0986,  0.0748]]) torch.Size([2, 3])</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">tensor([[-1.2926, -0.3155,  0.5966],</span></span><br><span class="line"><span class="string">        [ 0.8921, -2.0986,  0.0748],</span></span><br><span class="line"><span class="string">        [-1.2926, -0.3155,  0.5966],</span></span><br><span class="line"><span class="string">        [ 0.8921, -2.0986,  0.0748],</span></span><br><span class="line"><span class="string">        [-1.2926, -0.3155,  0.5966],</span></span><br><span class="line"><span class="string">        [ 0.8921, -2.0986,  0.0748]]) torch.Size([6, 3])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>4）扩展示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Q1、现在有一个向量t1，其size为 [A,B,C,D] ,向量t2，其size为[A,B,E,D] 然后我们对其应用cat: torch.cat((t1,t2),2),那么size会变成？</span><br><span class="line"></span><br><span class="line">Answer: [A,B,C+E,D]</span><br><span class="line"></span><br><span class="line">Q2、现在有一个向量t1，其size为 [A,B,C,D] ,向量t2，其size为[A,B,E,D] 然后我们对其应用cat: torch.cat((t1,t2),1),那么size会变成？</span><br><span class="line"></span><br><span class="line">Answer: 函数会报错，因为除了维度1以外，t1和t2的维度2的shape不一样</span><br></pre></td></tr></table></figure>
<h3 id="roll">10、Roll</h3>
<p>官方文档：https://pytorch.org/docs/stable/generated/torch.roll.html?highlight=roll#torch.roll</p>
<p>1）标准用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">torch.roll(input, shifts, dims=None) → Tensor</span><br><span class="line"></span><br><span class="line">	沿着给定的维数滚动张量。移动到最后一个位置以外的元素将在第一个位置重新引入。如果没有指定尺寸，张量在滚动之前将被压平，然后恢复到原来的形状。</span><br><span class="line">	</span><br><span class="line">- input (Tensor) – the input tensor.</span><br><span class="line">- shifts (int or tuple of python:ints) – 张量的元素被移动的位置数。如果shift是一个元组，dim必须是一个相同大小的元组，并且每个维度将被相应的值滚动</span><br><span class="line">- dims (int or tuple of python:ints) – Axis along which to roll</span><br></pre></td></tr></table></figure>
<p>2）依赖库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure>
<p>3）简单示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">x = torch.tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]).view(<span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line">y1 = torch.roll(x, <span class="number">1</span>, <span class="number">0</span>)  <span class="comment"># 沿着第0维（列），滚动1个元素</span></span><br><span class="line"><span class="built_in">print</span>(y1)</span><br><span class="line">y2 = torch.roll(x, -<span class="number">1</span>, <span class="number">0</span>) <span class="comment"># 沿着第0维（列），滚动-1个元素</span></span><br><span class="line"><span class="built_in">print</span>(y2)</span><br><span class="line">y3 = torch.roll(x, shifts=(<span class="number">2</span>, <span class="number">1</span>), dims=(<span class="number">0</span>, <span class="number">1</span>)) <span class="comment"># 沿着第0维（列），滚动2个元素，沿着第1维（行），滚动1个元素</span></span><br><span class="line"><span class="built_in">print</span>(y3)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">x:tensor([[1, 2],</span></span><br><span class="line"><span class="string">        [3, 4],</span></span><br><span class="line"><span class="string">        [5, 6],</span></span><br><span class="line"><span class="string">        [7, 8]])</span></span><br><span class="line"><span class="string">y1:tensor([[7, 8],</span></span><br><span class="line"><span class="string">        [1, 2],</span></span><br><span class="line"><span class="string">        [3, 4],</span></span><br><span class="line"><span class="string">        [5, 6]])</span></span><br><span class="line"><span class="string">y2:tensor([[3, 4],</span></span><br><span class="line"><span class="string">        [5, 6],</span></span><br><span class="line"><span class="string">        [7, 8],</span></span><br><span class="line"><span class="string">        [1, 2]])</span></span><br><span class="line"><span class="string">y3:tensor([[6, 5],</span></span><br><span class="line"><span class="string">        [8, 7],</span></span><br><span class="line"><span class="string">        [2, 1],</span></span><br><span class="line"><span class="string">        [4, 3]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="contiguous">11、Contiguous</h3>
<p>官方文档：https://pytorch.org/docs/stable/generated/torch.Tensor.contiguous.html?highlight=contiguous#torch.Tensor.contiguous</p>
<p>1）标准用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tensor.contiguous(memory_format=torch.contiguous_format) → Tensor</span><br><span class="line"></span><br><span class="line">返回一个连续的内存张量，其中包含与当前张量相同的数据。 如果当前已经是指定的内存格式，则此函数返回当前张量。 </span><br></pre></td></tr></table></figure>
<p>2）依赖库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure>
<p>3）为什么需要Contiguous?</p>
<ul>
<li><strong><code>torch.view</code></strong>等方法操作需要连续的Tensor。详细原因可见：https://zhuanlan.zhihu.com/p/64551412</li>
<li>出于性能考虑，连续的Tensor，语义上相邻的元素，在内存中也是连续的，访问相邻元素是矩阵运算中经常用到的操作，语义和内存顺序的一致性是缓存友好的，在内存中连续的数据可以（但不一定）被高速缓存预取，以提升CPU获取操作数据的速度。</li>
</ul>
<h3 id="section">12、</h3>
<p>官方文档：</p>
<p>1）标准用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>2）依赖库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure>
<p>3）简单示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>4）扩展示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="section-1">13、</h3>
<p>官方文档：</p>
<p>1）标准用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>2）依赖库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure>
<p>3）简单示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>4）扩展示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="section-2">14、</h3>
<p>官方文档：</p>
<p>1）标准用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>2）依赖库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure>
<p>3）简单示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>4）扩展示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="section-3">15、</h3>
<p>官方文档：</p>
<p>1）标准用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>2）依赖库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure>
<p>3）简单示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>4）扩展示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Pytorch系列笔记</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch学习笔记7——一个深度学习程序的通用框架</title>
    <url>/2021/12/15/74d5fdd90932/</url>
    <content><![CDATA[<p>以下是一个深度学习程序的通用框架，大部分基础的深度学习任务都可以按照以下这个框架的步骤去进行书写：</p>
<h4 id="step0-一些依赖项函数">Step0: 一些依赖项函数</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_device</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; Get device (if GPU is available, use GPU) &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span></span><br><span class="line">  </span><br><span class="line"> <span class="comment"># fix random seed</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">same_seeds</span>(<span class="params">seed</span>):</span><br><span class="line">    torch.manual_seed(seed)</span><br><span class="line">    <span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">        torch.cuda.manual_seed(seed)</span><br><span class="line">        torch.cuda.manual_seed_all(seed)  </span><br><span class="line">    np.random.seed(seed)  </span><br><span class="line">    torch.backends.cudnn.benchmark = <span class="literal">False</span></span><br><span class="line">    torch.backends.cudnn.deterministic = <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h4 id="step1-下载数据准备数据这一步将硬盘的数据加载到内存中">Step1:
下载数据、准备数据（这一步将硬盘的数据加载到内存中）</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Loading data ...&#x27;</span>)</span><br><span class="line"><span class="comment"># 加载Train Features、Train Labels、Test Features</span></span><br><span class="line">train = np.load(<span class="string">&#x27;train.npy&#x27;</span>)</span><br><span class="line">train_label = np.load(<span class="string">&#x27;train_label.npy&#x27;</span>)</span><br><span class="line">test = np.load(<span class="string">&#x27;test.npy&#x27;</span>)</span><br><span class="line"><span class="comment"># 一般而言可以打印一下数据集的大小，心中有数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Size of training data: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(train.shape))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Size of testing data: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(test.shape))</span><br></pre></td></tr></table></figure>
<h4 id="step2-创建dataset类">Step2: 创建Dataset类</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, X, y=<span class="literal">None</span></span>):   <span class="comment"># 主要就是在init函数里定义好 self.data 和 self.label</span></span><br><span class="line">        self.data = torch.from_numpy(X).<span class="built_in">float</span>()  <span class="comment"># 进行赋值</span></span><br><span class="line">        <span class="keyword">if</span> y <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:   <span class="comment"># 这儿需要考虑有y的训练集 和 没有y的测试集</span></span><br><span class="line">            self.label = torch.LongTensor(y.astype(np.<span class="built_in">int</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.label = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):    <span class="comment"># 基本都是如下这个形式，不太需要变化</span></span><br><span class="line">        <span class="keyword">if</span> self.label <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self.data[idx], self.label[idx]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.data[idx]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):  <span class="comment"># 返回数据集长度，一般都是如下这个形式，也不太需要变化</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.data)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="step3-将训练数据分割为-训练集-和-验证集">Step3: 将训练数据分割为
训练集 和 验证集</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">VAL_RATIO = <span class="number">0.2</span>  <span class="comment"># 利用此参数控制 验证集占 整个训练数据的比例</span></span><br><span class="line"></span><br><span class="line">percent = <span class="built_in">int</span>(train.shape[<span class="number">0</span>] * (<span class="number">1</span> - VAL_RATIO))</span><br><span class="line">train_x, train_y, val_x, val_y = train[:percent], train_label[:percent], train[percent:], train_label[percent:]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Size of training set: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(train_x.shape))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Size of validation set: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(val_x.shape))</span><br></pre></td></tr></table></figure>
<h4 id="step4-实例化dataset对象以及对应的dataloader对象">Step4:
实例化Dataset对象以及对应的DataLoader对象</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BATCH_SIZE = <span class="number">64</span>  <span class="comment"># 设定 Batch_size，此参数DataLoader</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line">train_set = MyDataset(train_x, train_y)</span><br><span class="line">val_set = MyDataset(val_x, val_y)</span><br><span class="line"></span><br><span class="line"><span class="comment">#only shuffle the training data</span></span><br><span class="line">train_loader = DataLoader(train_set, batch_size=BATCH_SIZE, shuffle=<span class="literal">True</span>) </span><br><span class="line">val_loader = DataLoader(val_set, batch_size=BATCH_SIZE, shuffle=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<h4 id="step5-创建网络模型">Step5: 创建网络模型</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Classifier</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):   <span class="comment"># 定义网络层级</span></span><br><span class="line">        <span class="built_in">super</span>(Classifier, self).__init__()</span><br><span class="line">        self.layer1 = nn.Linear(<span class="number">429</span>, <span class="number">1024</span>)</span><br><span class="line">        self.layer2 = nn.Linear(<span class="number">1024</span>, <span class="number">512</span>)</span><br><span class="line">        self.layer3 = nn.Linear(<span class="number">512</span>, <span class="number">128</span>)</span><br><span class="line">        self.out = nn.Linear(<span class="number">128</span>, <span class="number">39</span>) </span><br><span class="line">        self.act_fn = nn.Sigmoid()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>): <span class="comment"># 定义数据的流转逻辑过程</span></span><br><span class="line">        x = self.layer1(x)</span><br><span class="line">        x = self.act_fn(x)</span><br><span class="line">        </span><br><span class="line">        x = self.layer2(x)</span><br><span class="line">        x = self.act_fn(x)</span><br><span class="line"></span><br><span class="line">        x = self.layer3(x)</span><br><span class="line">        x = self.act_fn(x)</span><br><span class="line"></span><br><span class="line">        x = self.out(x)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<h4 id="step6-设定一些训练参数为训练作准备">Step6:
设定一些训练参数，为训练作准备</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># fix random seed for reproducibility</span></span><br><span class="line">same_seeds(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get device </span></span><br><span class="line">device = get_device()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;DEVICE: <span class="subst">&#123;device&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># training parameters </span></span><br><span class="line">num_epoch = <span class="number">20</span>               <span class="comment"># number of training epoch</span></span><br><span class="line">learning_rate = <span class="number">0.0001</span>       <span class="comment"># learning rate</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># the path where checkpoint saved</span></span><br><span class="line">model_path = <span class="string">&#x27;./model.ckpt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create model, define a loss function, and optimizer</span></span><br><span class="line">model = Classifier().to(device)</span><br><span class="line">criterion = nn.CrossEntropyLoss() </span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)</span><br></pre></td></tr></table></figure>
<h4 id="step7-开启网络训练参数优化">Step7: 开启网络训练，参数优化</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># start training</span></span><br><span class="line"></span><br><span class="line">best_acc = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epoch):</span><br><span class="line">    train_loss = <span class="number">0.0</span></span><br><span class="line">    val_loss = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># training</span></span><br><span class="line">    model.train() <span class="comment"># set the model to training mode</span></span><br><span class="line">    <span class="keyword">for</span> i, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        inputs, labels = data  <span class="comment"># 从data中加载inputs和labels</span></span><br><span class="line">        inputs, labels = inputs.to(device), labels.to(device) <span class="comment"># 拷贝至设备</span></span><br><span class="line">        optimizer.zero_grad()  <span class="comment"># 清零梯度</span></span><br><span class="line">        outputs = model(inputs)   <span class="comment"># 将输入放到模型中拿到输出</span></span><br><span class="line">        batch_loss = criterion(outputs, labels) <span class="comment"># 通过损失函数，计算本次损失值</span></span><br><span class="line">        batch_loss.backward()  <span class="comment"># 损失反向传播，计算梯度</span></span><br><span class="line">        optimizer.step() <span class="comment"># 使用optimizer更新一步模型</span></span><br><span class="line"></span><br><span class="line">        train_loss += batch_loss.item()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每一个epoch完成后，如果有验证集的话，就进行validation验证</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(val_set) &gt; <span class="number">0</span>:</span><br><span class="line">        model.<span class="built_in">eval</span>() <span class="comment"># set the model to evaluation mode</span></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad(): <span class="comment"># 验证集不需要计算梯度</span></span><br><span class="line">            <span class="keyword">for</span> i, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(val_loader):</span><br><span class="line">                inputs, labels = data </span><br><span class="line">                inputs, labels = inputs.to(device), labels.to(device)</span><br><span class="line">                outputs = model(inputs)</span><br><span class="line">                batch_loss = criterion(outputs, labels) </span><br><span class="line"></span><br><span class="line">                val_loss += batch_loss.item()</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;[&#123;:03d&#125;/&#123;:03d&#125;] Train Loss: &#123;:3.6f&#125; | Val Loss: &#123;:3.6f&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">                epoch + <span class="number">1</span>, num_epoch, train_loss/<span class="built_in">len</span>(train_loader), val_loss/<span class="built_in">len</span>(val_loader)</span><br><span class="line">            ))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 必备过程，如果模型比截止当前更优了，那么就保存并记录，然后输出</span></span><br><span class="line">            <span class="keyword">if</span> val_acc &gt; best_acc:</span><br><span class="line">                best_acc = val_acc</span><br><span class="line">                torch.save(model.state_dict(), model_path)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;saving model with acc &#123;:.3f&#125;&#x27;</span>.<span class="built_in">format</span>(best_acc/<span class="built_in">len</span>(val_set)))</span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># 没有验证集这一步的话，就可以直接打印输出</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[&#123;:03d&#125;/&#123;:03d&#125;] Train Acc: &#123;:3.6f&#125; Loss: &#123;:3.6f&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">            epoch + <span class="number">1</span>, num_epoch, train_acc/<span class="built_in">len</span>(train_set), train_loss/<span class="built_in">len</span>(train_loader)</span><br><span class="line">        ))</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 如果没有验证这一步骤的话，我们需要保存最终训练得到的这个模型</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(val_set) == <span class="number">0</span>:</span><br><span class="line">    torch.save(model.state_dict(), model_path)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;saving model at last epoch&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="step8-test-测试计算测试集的预测值">Step8: Test
测试,计算测试集的预测值</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实例化测试用的DataSet和DataLoader</span></span><br><span class="line">test_set = MyDataset(test, <span class="literal">None</span>)</span><br><span class="line">test_loader = DataLoader(test_set, batch_size=BATCH_SIZE, shuffle=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#  实例化模型，加载参数</span></span><br><span class="line">model = Classifier().to(device)</span><br><span class="line">model.load_state_dict(torch.load(model_path))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始进行预测， </span></span><br><span class="line">predict = []</span><br><span class="line">model.<span class="built_in">eval</span>() <span class="comment"># 将模型调整至评估状态（必备步骤）</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad(): <span class="comment"># 由于预测不需要跟踪梯度</span></span><br><span class="line">    <span class="keyword">for</span> i, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(test_loader): <span class="comment"># 计算s</span></span><br><span class="line">        inputs = data</span><br><span class="line">        inputs = inputs.to(device)</span><br><span class="line">        outputs = model(inputs)</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> test_pred.cpu().numpy():</span><br><span class="line">            predict.append(y)</span><br><span class="line">           </span><br><span class="line"><span class="comment"># 输出预测的CSV文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;prediction.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> i, y <span class="keyword">in</span> <span class="built_in">enumerate</span>(predict):</span><br><span class="line">        f.write(<span class="string">&#x27;&#123;&#125;,&#123;&#125;\n&#x27;</span>.<span class="built_in">format</span>(i, y))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Pytorch系列笔记</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch学习笔记6——优化模型参数</title>
    <url>/2021/12/14/81d5ccd11a24/</url>
    <content><![CDATA[<h1 id="六优化模型参数">六、优化模型参数</h1>
<p>现在我们有了模型和数据，接下去需要通过优化数据参数来训练、验证和测试我们的模型了。</p>
<p>训练模型是一个迭代过程； 在每次迭代（称为
epoch）中，模型对输出进行猜测，计算其猜测中的误差（损失），收集误差对其参数的导数，并使用梯度下降优化这些参数。
下面的代码是先预定义了一些之前记录过的内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> torchvision.transforms <span class="keyword">import</span> ToTensor, Lambda</span><br><span class="line"></span><br><span class="line">training_data = datasets.FashionMNIST(</span><br><span class="line">    root=<span class="string">&quot;data&quot;</span>,</span><br><span class="line">    train=<span class="literal">True</span>,</span><br><span class="line">    download=<span class="literal">True</span>,</span><br><span class="line">    transform=ToTensor()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">test_data = datasets.FashionMNIST(</span><br><span class="line">    root=<span class="string">&quot;data&quot;</span>,</span><br><span class="line">    train=<span class="literal">False</span>,</span><br><span class="line">    download=<span class="literal">True</span>,</span><br><span class="line">    transform=ToTensor()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">train_dataloader = DataLoader(training_data, batch_size=<span class="number">64</span>)</span><br><span class="line">test_dataloader = DataLoader(test_data, batch_size=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NeuralNetwork</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(NeuralNetwork, self).__init__()</span><br><span class="line">        self.flatten = nn.Flatten()</span><br><span class="line">        self.linear_relu_stack = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">28</span>*<span class="number">28</span>, <span class="number">512</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">512</span>, <span class="number">512</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">512</span>, <span class="number">10</span>),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.flatten(x)</span><br><span class="line">        logits = self.linear_relu_stack(x)</span><br><span class="line">        <span class="keyword">return</span> logits</span><br><span class="line"></span><br><span class="line">model = NeuralNetwork()</span><br></pre></td></tr></table></figure>
<h3 id="超参数">1、超参数：</h3>
<p>超参数是可调节的参数，可控制模型优化过程。不同的超参数值会影响模型训练和收敛速度</p>
<p>我们为训练定义了以下超参数： - Number of Epochs 迭代数据集的次数 -
Batch Size
在更新参数之前通过网络传播的数据样本数量(单次传入网络进行训练的样本数量)
- Learning Rate 在每个批次/时期更新模型参数的程度。
较小的值会导致学习速度变慢，而较大的值可能会导致训练过程中出现不可预测的行为。</p>
<p>此处注意区分一些概念： - Batch
Size：批大小。在深度学习中，一般采用SGD训练，即每次训练在训练集中取batchsize个样本训练；
- iteration：1个iteration等于使用batchsize个样本训练一次； -
Epoch：1个epoch等于使用训练集中的全部样本训练一次，通俗的讲epoch的值就是整个数据集被轮几次。</p>
<p>举个例子，我们现在有一个5000个数据的数据集，Batch Size = 100,
我们需要迭代训练50次，那么最终Number of Epoches = 10,Interation =
50.</p>
<h3 id="优化循环">2、优化循环：</h3>
<p>每个Epoch由两个主要部分组成： - Train Loop -
迭代训练数据集并尝试收敛到最佳参数。(由很多次Interation组成) -
Validation/Test Loop - 迭代测试数据集以检查模型性能是否正在提高。</p>
<h3 id="损失函数">3、损失函数</h3>
<ul>
<li><p>当提供一些训练数据时，我们未经训练的网络可能没法给出正确的答案。</p></li>
<li><p>损失函数衡量得到的结果与目标值的不相似程度，是我们在训练过程中想要最小化的损失函数。</p></li>
<li><p>为了计算损失，我们使用给定数据样本的输入进行预测，并将其与真实数据标签值进行比较。</p></li>
</ul>
<p>常见的损失函数包括用于回归任务的 nn.MSELoss（均方误差）和用于分类的
nn.NLLLoss（负对数似然）。 nn.CrossEntropyLoss 结合了 nn.LogSoftmax 和
nn.NLLLoss。</p>
<h3 id="优化器">4、优化器</h3>
<ul>
<li><p>优化是在每个训练步骤中调整模型参数以减少模型误差的过程。</p></li>
<li><p>优化算法定义了这个过程是如何执行的（在这个例子中我们使用随机梯度下降）。</p></li>
<li><p>所有优化逻辑都封装在优化器对象中。</p></li>
<li><p>在这里，我们使用 SGD 优化器； 此外，PyTorch
中有许多不同的优化器可用，例如 ADAM 和
RMSProp，它们更适用于不同类型的模型和数据。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)</span><br></pre></td></tr></table></figure></p></li>
<li><p>我们通过注册模型需要训练的参数并传入学习率超参数来初始化优化器。</p></li>
</ul>
<h4 id="训练循环中优化的三个步骤">训练循环中优化的三个步骤：</h4>
<ul>
<li><p>调用 optimizer.zero_grad() 来重置模型参数的梯度。
梯度默认情况下会相加；
为了防止重复计算，我们在每次迭代时明确地将它们归零。</p></li>
<li><p>通过调用 loss.backwards() 来反向传播预测损失。PyTorch
将损失的梯度存入 w.r.t. 每个参数。</p></li>
<li><p>一旦我们有了梯度，我们就调用 optimizer.step()
通过backward()中收集的梯度来调整参数。</p></li>
</ul>
<h3 id="train-loop-和-test-loop的整体实现">5、Train Loop 和 Test
Loop的整体实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train_loop</span>(<span class="params">dataloader, model, loss_fn, optimizer</span>):</span><br><span class="line">    size = <span class="built_in">len</span>(dataloader.dataset)</span><br><span class="line">    <span class="keyword">for</span> batch, (X, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(dataloader):</span><br><span class="line">        <span class="comment"># Compute prediction and loss</span></span><br><span class="line">        pred = model(X)</span><br><span class="line">        loss = loss_fn(pred, y)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Backpropagation</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> batch % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            loss, current = loss.item(), batch * <span class="built_in">len</span>(X)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;loss: <span class="subst">&#123;loss:&gt;7f&#125;</span>  [<span class="subst">&#123;current:&gt;5d&#125;</span>/<span class="subst">&#123;size:&gt;5d&#125;</span>]&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_loop</span>(<span class="params">dataloader, model, loss_fn</span>):</span><br><span class="line">    size = <span class="built_in">len</span>(dataloader.dataset)</span><br><span class="line">    num_batches = <span class="built_in">len</span>(dataloader)</span><br><span class="line">    test_loss, correct = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> dataloader:</span><br><span class="line">            pred = model(X)</span><br><span class="line">            test_loss += loss_fn(pred, y).item()</span><br><span class="line">            correct += (pred.argmax(<span class="number">1</span>) == y).<span class="built_in">type</span>(torch.<span class="built_in">float</span>).<span class="built_in">sum</span>().item()</span><br><span class="line"></span><br><span class="line">    test_loss /= num_batches</span><br><span class="line">    correct /= size</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Test Error: \n Accuracy: <span class="subst">&#123;(<span class="number">100</span>*correct):&gt;<span class="number">0.1</span>f&#125;</span>%, Avg loss: <span class="subst">&#123;test_loss:&gt;8f&#125;</span> \n&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">learning_rate = <span class="number">1e-3</span></span><br><span class="line"></span><br><span class="line">loss_fn = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)</span><br><span class="line"></span><br><span class="line">epochs = <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Epoch <span class="subst">&#123;t+<span class="number">1</span>&#125;</span>\n-------------------------------&quot;</span>)</span><br><span class="line">    train_loop(train_dataloader, model, loss_fn, optimizer)</span><br><span class="line">    test_loop(test_dataloader, model, loss_fn)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Done!&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Epoch 1
-------------------------------
loss: 2.305831  [    0/60000]
loss: 2.286264  [ 6400/60000]
loss: 2.275372  [12800/60000]
loss: 2.270570  [19200/60000]
loss: 2.243541  [25600/60000]
loss: 2.228191  [32000/60000]
loss: 2.224830  [38400/60000]
loss: 2.197911  [44800/60000]
loss: 2.188963  [51200/60000]
loss: 2.156472  [57600/60000]
Test Error: 
 Accuracy: 44.4%, Avg loss: 2.153718 

Epoch 2
-------------------------------
loss: 2.164675  [    0/60000]
loss: 2.149587  [ 6400/60000]
loss: 2.099088  [12800/60000]
loss: 2.116142  [19200/60000]
loss: 2.057026  [25600/60000]
loss: 2.006994  [32000/60000]
loss: 2.027068  [38400/60000]
loss: 1.953798  [44800/60000]
loss: 1.955666  [51200/60000]
loss: 1.876484  [57600/60000]
Test Error: 
 Accuracy: 54.6%, Avg loss: 1.882143 

Epoch 3
-------------------------------
loss: 1.914309  [    0/60000]
loss: 1.881881  [ 6400/60000]
loss: 1.770059  [12800/60000]
loss: 1.812282  [19200/60000]
loss: 1.696313  [25600/60000]
loss: 1.650967  [32000/60000]
loss: 1.665257  [38400/60000]
loss: 1.568552  [44800/60000]
loss: 1.594818  [51200/60000]
loss: 1.484761  [57600/60000]
Test Error: 
 Accuracy: 61.4%, Avg loss: 1.509315 

Epoch 4
-------------------------------
loss: 1.575193  [    0/60000]
loss: 1.537402  [ 6400/60000]
loss: 1.389850  [12800/60000]
loss: 1.466425  [19200/60000]
loss: 1.346153  [25600/60000]
loss: 1.345708  [32000/60000]
loss: 1.351373  [38400/60000]
loss: 1.272530  [44800/60000]
loss: 1.314754  [51200/60000]
loss: 1.217384  [57600/60000]
Test Error: 
 Accuracy: 63.7%, Avg loss: 1.243355 

Epoch 5
-------------------------------
loss: 1.322318  [    0/60000]
loss: 1.297594  [ 6400/60000]
loss: 1.132705  [12800/60000]
loss: 1.242817  [19200/60000]
loss: 1.121882  [25600/60000]
loss: 1.150953  [32000/60000]
loss: 1.163450  [38400/60000]
loss: 1.091253  [44800/60000]
loss: 1.141570  [51200/60000]
loss: 1.064053  [57600/60000]
Test Error: 
 Accuracy: 65.1%, Avg loss: 1.080539 

Epoch 6
-------------------------------
loss: 1.154191  [    0/60000]
loss: 1.148584  [ 6400/60000]
loss: 0.965631  [12800/60000]
loss: 1.104692  [19200/60000]
loss: 0.985084  [25600/60000]
loss: 1.020977  [32000/60000]
loss: 1.047947  [38400/60000]
loss: 0.976197  [44800/60000]
loss: 1.029986  [51200/60000]
loss: 0.968344  [57600/60000]
Test Error: 
 Accuracy: 66.1%, Avg loss: 0.976119 

Epoch 7
-------------------------------
loss: 1.037672  [    0/60000]
loss: 1.052149  [ 6400/60000]
loss: 0.852071  [12800/60000]
loss: 1.013271  [19200/60000]
loss: 0.898881  [25600/60000]
loss: 0.930241  [32000/60000]
loss: 0.972335  [38400/60000]
loss: 0.901890  [44800/60000]
loss: 0.953780  [51200/60000]
loss: 0.904363  [57600/60000]
Test Error: 
 Accuracy: 67.0%, Avg loss: 0.905581 

Epoch 8
-------------------------------
loss: 0.952564  [    0/60000]
loss: 0.985621  [ 6400/60000]
loss: 0.771567  [12800/60000]
loss: 0.949356  [19200/60000]
loss: 0.841446  [25600/60000]
loss: 0.864854  [32000/60000]
loss: 0.919260  [38400/60000]
loss: 0.852853  [44800/60000]
loss: 0.899662  [51200/60000]
loss: 0.858536  [57600/60000]
Test Error: 
 Accuracy: 68.2%, Avg loss: 0.855451 

Epoch 9
-------------------------------
loss: 0.887674  [    0/60000]
loss: 0.936516  [ 6400/60000]
loss: 0.712008  [12800/60000]
loss: 0.902735  [19200/60000]
loss: 0.800700  [25600/60000]
loss: 0.816214  [32000/60000]
loss: 0.879292  [38400/60000]
loss: 0.819085  [44800/60000]
loss: 0.859679  [51200/60000]
loss: 0.823750  [57600/60000]
Test Error: 
 Accuracy: 69.5%, Avg loss: 0.817833 

Epoch 10
-------------------------------
loss: 0.836203  [    0/60000]
loss: 0.897646  [ 6400/60000]
loss: 0.666050  [12800/60000]
loss: 0.867214  [19200/60000]
loss: 0.769769  [25600/60000]
loss: 0.778995  [32000/60000]
loss: 0.846987  [38400/60000]
loss: 0.794176  [44800/60000]
loss: 0.828553  [51200/60000]
loss: 0.795993  [57600/60000]
Test Error: 
 Accuracy: 70.8%, Avg loss: 0.788062 

Done!</code></pre>
<h3 id="七保存与加载模型">七、保存与加载模型</h3>
<p>PyTorch 模型将学习到的参数存储在称为 state_dict 的内部状态字典中。
这些可以通过 torch.save 方法持久化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision.models <span class="keyword">as</span> models</span><br><span class="line"></span><br><span class="line">model = models.vgg16(pretrained=<span class="literal">True</span>)</span><br><span class="line">torch.save(model.state_dict(), <span class="string">&#x27;model_weights.pth&#x27;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Downloading: &quot;https://download.pytorch.org/models/vgg16-397923af.pth&quot; to C:\Users\14012/.cache\torch\hub\checkpoints\vgg16-397923af.pth
4.4%IOPub message rate exceeded.
The notebook server will temporarily stop sending output
to the client in order to avoid crashing it.
To change this limit, set the config variable
`--NotebookApp.iopub_msg_rate_limit`.

Current values:
NotebookApp.iopub_msg_rate_limit=1000.0 (msgs/sec)
NotebookApp.rate_limit_window=3.0 (secs)

11.4%IOPub message rate exceeded.
The notebook server will temporarily stop sending output
to the client in order to avoid crashing it.
To change this limit, set the config variable
`--NotebookApp.iopub_msg_rate_limit`.

Current values:
NotebookApp.iopub_msg_rate_limit=1000.0 (msgs/sec)
NotebookApp.rate_limit_window=3.0 (secs)

18.5%IOPub message rate exceeded.
The notebook server will temporarily stop sending output
to the client in order to avoid crashing it.
To change this limit, set the config variable
`--NotebookApp.iopub_msg_rate_limit`.

Current values:
NotebookApp.iopub_msg_rate_limit=1000.0 (msgs/sec)
NotebookApp.rate_limit_window=3.0 (secs)

25.5%IOPub message rate exceeded.
The notebook server will temporarily stop sending output
to the client in order to avoid crashing it.
To change this limit, set the config variable
`--NotebookApp.iopub_msg_rate_limit`.

Current values:
NotebookApp.iopub_msg_rate_limit=1000.0 (msgs/sec)
NotebookApp.rate_limit_window=3.0 (secs)

35.0%IOPub message rate exceeded.
The notebook server will temporarily stop sending output
to the client in order to avoid crashing it.
To change this limit, set the config variable
`--NotebookApp.iopub_msg_rate_limit`.

Current values:
NotebookApp.iopub_msg_rate_limit=1000.0 (msgs/sec)
NotebookApp.rate_limit_window=3.0 (secs)

45.9%IOPub message rate exceeded.
The notebook server will temporarily stop sending output
to the client in order to avoid crashing it.
To change this limit, set the config variable
`--NotebookApp.iopub_msg_rate_limit`.

Current values:
NotebookApp.iopub_msg_rate_limit=1000.0 (msgs/sec)
NotebookApp.rate_limit_window=3.0 (secs)

54.3%IOPub message rate exceeded.
The notebook server will temporarily stop sending output
to the client in order to avoid crashing it.
To change this limit, set the config variable
`--NotebookApp.iopub_msg_rate_limit`.

Current values:
NotebookApp.iopub_msg_rate_limit=1000.0 (msgs/sec)
NotebookApp.rate_limit_window=3.0 (secs)

61.2%IOPub message rate exceeded.
The notebook server will temporarily stop sending output
to the client in order to avoid crashing it.
To change this limit, set the config variable
`--NotebookApp.iopub_msg_rate_limit`.

Current values:
NotebookApp.iopub_msg_rate_limit=1000.0 (msgs/sec)
NotebookApp.rate_limit_window=3.0 (secs)

69.2%IOPub message rate exceeded.
The notebook server will temporarily stop sending output
to the client in order to avoid crashing it.
To change this limit, set the config variable
`--NotebookApp.iopub_msg_rate_limit`.

Current values:
NotebookApp.iopub_msg_rate_limit=1000.0 (msgs/sec)
NotebookApp.rate_limit_window=3.0 (secs)

76.2%IOPub message rate exceeded.
The notebook server will temporarily stop sending output
to the client in order to avoid crashing it.
To change this limit, set the config variable
`--NotebookApp.iopub_msg_rate_limit`.

Current values:
NotebookApp.iopub_msg_rate_limit=1000.0 (msgs/sec)
NotebookApp.rate_limit_window=3.0 (secs)

86.6%IOPub message rate exceeded.
The notebook server will temporarily stop sending output
to the client in order to avoid crashing it.
To change this limit, set the config variable
`--NotebookApp.iopub_msg_rate_limit`.

Current values:
NotebookApp.iopub_msg_rate_limit=1000.0 (msgs/sec)
NotebookApp.rate_limit_window=3.0 (secs)

98.3%IOPub message rate exceeded.
The notebook server will temporarily stop sending output
to the client in order to avoid crashing it.
To change this limit, set the config variable
`--NotebookApp.iopub_msg_rate_limit`.

Current values:
NotebookApp.iopub_msg_rate_limit=1000.0 (msgs/sec)
NotebookApp.rate_limit_window=3.0 (secs)</code></pre>
<p>要加载模型权重，您需要先创建相同模型的实例，然后使用
load_state_dict() 方法加载参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = models.vgg16() <span class="comment"># we do not specify pretrained=True, i.e. do not load default weights</span></span><br><span class="line">model.load_state_dict(torch.load(<span class="string">&#x27;model_weights.pth&#x27;</span>))</span><br><span class="line">model.<span class="built_in">eval</span>()</span><br></pre></td></tr></table></figure>
<pre><code>VGG(
  (features): Sequential(
    (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (1): ReLU(inplace=True)
    (2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (3): ReLU(inplace=True)
    (4): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
    (5): Conv2d(64, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (6): ReLU(inplace=True)
    (7): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (8): ReLU(inplace=True)
    (9): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
    (10): Conv2d(128, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (11): ReLU(inplace=True)
    (12): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (13): ReLU(inplace=True)
    (14): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (15): ReLU(inplace=True)
    (16): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
    (17): Conv2d(256, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (18): ReLU(inplace=True)
    (19): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (20): ReLU(inplace=True)
    (21): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (22): ReLU(inplace=True)
    (23): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
    (24): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (25): ReLU(inplace=True)
    (26): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (27): ReLU(inplace=True)
    (28): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (29): ReLU(inplace=True)
    (30): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
  )
  (avgpool): AdaptiveAvgPool2d(output_size=(7, 7))
  (classifier): Sequential(
    (0): Linear(in_features=25088, out_features=4096, bias=True)
    (1): ReLU(inplace=True)
    (2): Dropout(p=0.5, inplace=False)
    (3): Linear(in_features=4096, out_features=4096, bias=True)
    (4): ReLU(inplace=True)
    (5): Dropout(p=0.5, inplace=False)
    (6): Linear(in_features=4096, out_features=1000, bias=True)
  )
)</code></pre>
<h4
id="注意一定要在预测之前调用-model.eval-方法以将-dropout-和批量归一化层设置为评估模式-不这样做会产生不一致的推理结果">注意：一定要在预测之前调用
model.eval() 方法，以将 dropout 和批量归一化层设置为评估模式。
不这样做会产生不一致的推理结果。</h4>
<p>在加载模型权重时，我们需要先实例化模型类，因为该类定义了网络的结构。
我们可能希望将此类的结构与模型一起保存，在这种情况下，我们可以将模型（而不是
model.state_dict()）传递给保存函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.save(model, <span class="string">&#x27;model.pth&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = torch.load(<span class="string">&#x27;model.pth&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Pytorch系列笔记</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch学习笔记5——使用AutoGrad自动微分</title>
    <url>/2021/12/13/2c757a5017fb/</url>
    <content><![CDATA[<h1 id="五使用autograd计算自动微分">五、使用AutoGrad计算自动微分</h1>
<p>在训练神经网络时，最常用的算法是反向传播。
在该算法中，参数（模型权重）根据损失函数相对于给定参数的梯度进行调整。
为了计算这些梯度，PyTorch 有一个名为 torch.autograd 的内置微分引擎。
它支持任何计算图的梯度自动计算。</p>
<p>考虑最简单的一层神经网络，输入 x，参数 w 和 b，以及一些损失函数。
它可以通过以下方式在 PyTorch 中定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x = torch.ones(<span class="number">5</span>)  <span class="comment"># input tensor</span></span><br><span class="line">y = torch.zeros(<span class="number">3</span>)  <span class="comment"># expected output</span></span><br><span class="line">w = torch.randn(<span class="number">5</span>, <span class="number">3</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">z = torch.matmul(x, w)+b</span><br><span class="line">loss = torch.nn.functional.binary_cross_entropy_with_logits(z, y)</span><br></pre></td></tr></table></figure>
<p>以下是计算图，因为我们需要计算Loss函数对w和b的梯度，所以在上面我们将w和b的requires_grad设置为了True</p>
<figure>
<img src="https://pytorch.org/tutorials/_images/comp-graph.png"
alt="avatar" />
<figcaption aria-hidden="true">avatar</figcaption>
</figure>
<p>我们应用于张量来构建计算图的函数实际上是类 Function 的对象。
该对象知道如何在前向计算函数，以及如何在反向传播步骤中计算其导数。
对反向传播函数的引用存储在张量的 grad_fn 属性中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Gradient function for z =&#x27;</span>, z.grad_fn)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Gradient function for loss =&#x27;</span>, loss.grad_fn)</span><br></pre></td></tr></table></figure>
<pre><code>Gradient function for z = &lt;AddBackward0 object at 0x00000271D5D03D90&gt;
Gradient function for loss = &lt;BinaryCrossEntropyWithLogitsBackward0 object at 0x00000271D5CF0F40&gt;</code></pre>
<h3 id="通过-backward函数计算梯度">通过 backward()函数计算梯度</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss.backward()</span><br><span class="line"><span class="built_in">print</span>(w.grad)</span><br><span class="line"><span class="built_in">print</span>(b.grad)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[0.2175, 0.0032, 0.1359],
        [0.2175, 0.0032, 0.1359],
        [0.2175, 0.0032, 0.1359],
        [0.2175, 0.0032, 0.1359],
        [0.2175, 0.0032, 0.1359]])
tensor([0.2175, 0.0032, 0.1359])</code></pre>
<p>注意：我们只能获取计算图的叶子节点的 grad 属性，这些节点的
requires_grad 属性设置为 True。
对于图中的所有其他节点，梯度将不可用。</p>
<p>出于性能原因，我们只能在给定的计算图上使用一次backward()来执行梯度计算。如果我们需要在同一个计算图上进行多次backward()调用，我们需要将
retain_graph=True 传递给反向调用。</p>
<h3 id="如何停止跟踪梯度">如何停止跟踪梯度？</h3>
<p>默认情况下，所有具有 requires_grad=True
的张量都在跟踪它们的计算历史并支持梯度计算。
但是，在某些情况下我们不需要这样做，例如，当我们训练了模型并且只想将其应用于某些输入数据时，即我们只想通过网络进行前向计算。
我们可以通过用 torch.no_grad() 块包围我们的计算代码来停止跟踪计算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z = torch.matmul(x, w)+b</span><br><span class="line"><span class="built_in">print</span>(z.requires_grad)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    z = torch.matmul(x, w)+b</span><br><span class="line"><span class="built_in">print</span>(z.requires_grad)</span><br></pre></td></tr></table></figure>
<pre><code>True
False</code></pre>
<p>或者使用 detach方法也可以完成此项工作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z = torch.matmul(x, w)+b</span><br><span class="line">z_det = z.detach()</span><br><span class="line"><span class="built_in">print</span>(z_det.requires_grad)</span><br></pre></td></tr></table></figure>
<pre><code>False</code></pre>
<h3 id="停止跟踪梯度的一些情况">停止跟踪梯度的一些情况</h3>
<ul>
<li><p>1、将神经网络中的某些参数标记为冻结参数。（通常见于迁移学习）</p></li>
<li><p>2、在仅进行前向传递时加快计算速度，因为对不跟踪梯度的张量进行计算会更有效。</p></li>
</ul>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Pytorch系列笔记</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch学习笔记4——Building NeuralNetwork</title>
    <url>/2021/12/13/e052d246f1f0/</url>
    <content><![CDATA[<h1 id="四神经网络建立">四、神经网络建立</h1>
<p>神经网络由对数据执行操作的层/模块组成。 torch.nn
命名空间提供了构建自己的神经网络所需的所有构建块。 PyTorch
中的每个模块都是 nn.Module 的子类。
神经网络是一个模块本身，由其他模块（层）组成。
这种嵌套结构允许轻松构建和管理复杂的架构。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, transforms</span><br></pre></td></tr></table></figure>
<h4 id="步骤-1如果有条件的话使用cuda设备">步骤
1、如果有条件的话，使用Cuda设备</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">device = <span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Using <span class="subst">&#123;device&#125;</span> device&#x27;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Using cuda device</code></pre>
<h4
id="步骤-2我们通过继承nn.module来自定义我们的神经网络类在__ini__中完成神经网络层的定义且在forward函数中完成对输入的处理">步骤
2、我们通过继承nn.Module来自定义我们的神经网络类，在__ini__中完成神经网络层的定义，且在Forward函数中，完成对输入的处理</h4>
<p>nn.Sequential()
是一个有序的层的容器，将一系列的层线性组合在一起，按照顺序执行</p>
<p>nn.Flatten() 将每个 2D 28x28 图像转换为 784
个像素值的连续数组（注意：batches的那个维度被保留了（也就是dim=0的维度被保留了），举例来说，一个[3,28,28]的矩阵，被摊平成了[3,784]的矩阵</p>
<p>nn.Linear(in_features=28*28, out_features=20) 全连接层</p>
<p>nn.ReLU() 非线性激活函数层</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NeuralNetwork</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(NeuralNetwork, self).__init__()</span><br><span class="line">        self.flatten = nn.Flatten()</span><br><span class="line">        self.linear_relu_stack = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">28</span>*<span class="number">28</span>, <span class="number">512</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">512</span>, <span class="number">512</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">512</span>, <span class="number">10</span>),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.flatten(x)</span><br><span class="line">        logits = self.linear_relu_stack(x)</span><br><span class="line">        <span class="keyword">return</span> logits</span><br></pre></td></tr></table></figure>
<h4 id="步骤-3实例化一个对象并将其移至对应设备打印结构">步骤
3、实例化一个对象，并将其移至对应设备，打印结构</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = NeuralNetwork().to(device)</span><br><span class="line"><span class="built_in">print</span>(model)</span><br></pre></td></tr></table></figure>
<pre><code>NeuralNetwork(
  (flatten): Flatten(start_dim=1, end_dim=-1)
  (linear_relu_stack): Sequential(
    (0): Linear(in_features=784, out_features=512, bias=True)
    (1): ReLU()
    (2): Linear(in_features=512, out_features=512, bias=True)
    (3): ReLU()
    (4): Linear(in_features=512, out_features=10, bias=True)
  )
)</code></pre>
<h4
id="步骤-4在输入上调用模型会返回一个-10-维张量其中包含每个类的原始预测值">步骤
4、在输入上调用模型会返回一个 10
维张量，其中包含每个类的原始预测值。</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.rand(<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>, device=device)</span><br><span class="line">logits = model(X)</span><br><span class="line">logits</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[ 0.0394, -0.1041,  0.1203,  0.0809,  0.1222,  0.0305,  0.0539, -0.0241,
          0.0910,  0.0014]], device=&#39;cuda:0&#39;, grad_fn=&lt;AddmmBackward0&gt;)</code></pre>
<h3
id="softmax函数logits-被缩放到值-0-1-dim-参数指示该维度上的值的总和必须为-1">Softmax函数：logits
被缩放到值 [0, 1]。 dim 参数指示该维度上的值的总和必须为 1 。</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pred_probab = nn.Softmax(dim=<span class="number">1</span>)(logits) </span><br><span class="line"><span class="built_in">print</span>(pred_probab)</span><br><span class="line">y_pred = pred_probab.argmax(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Predicted class: <span class="subst">&#123;y_pred&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[0.0996, 0.0863, 0.1080, 0.1038, 0.1082, 0.0987, 0.1011, 0.0935, 0.1049,
         0.0959]], device=&#39;cuda:0&#39;, grad_fn=&lt;SoftmaxBackward0&gt;)
Predicted class: tensor([4], device=&#39;cuda:0&#39;)</code></pre>
<h3 id="神经网络模型参数">神经网络模型参数：</h3>
<p>神经网络内的许多层都是参数化的，即具有在训练期间优化的相关权重和偏差。
子类 nn.Module 会自动跟踪模型对象中定义的所有字段，并使用模型的
parameters() 或 named_parameters() 方法使所有参数都可以访问。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Model structure: &quot;</span>, model, <span class="string">&quot;\n\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, param <span class="keyword">in</span> model.named_parameters():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Layer: <span class="subst">&#123;name&#125;</span> | Size: <span class="subst">&#123;param.size()&#125;</span> | Values : <span class="subst">&#123;param[:<span class="number">2</span>]&#125;</span> \n&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Model structure:  NeuralNetwork(
  (flatten): Flatten(start_dim=1, end_dim=-1)
  (linear_relu_stack): Sequential(
    (0): Linear(in_features=784, out_features=512, bias=True)
    (1): ReLU()
    (2): Linear(in_features=512, out_features=512, bias=True)
    (3): ReLU()
    (4): Linear(in_features=512, out_features=10, bias=True)
  )
) 


Layer: linear_relu_stack.0.weight | Size: torch.Size([512, 784]) | Values : tensor([[ 0.0354, -0.0090,  0.0262,  ..., -0.0218, -0.0343,  0.0239],
        [-0.0130,  0.0023, -0.0083,  ..., -0.0314,  0.0088,  0.0303]],
       device=&#39;cuda:0&#39;, grad_fn=&lt;SliceBackward0&gt;) 

Layer: linear_relu_stack.0.bias | Size: torch.Size([512]) | Values : tensor([ 0.0199, -0.0234], device=&#39;cuda:0&#39;, grad_fn=&lt;SliceBackward0&gt;) 

Layer: linear_relu_stack.2.weight | Size: torch.Size([512, 512]) | Values : tensor([[-0.0136,  0.0326, -0.0428,  ..., -0.0377, -0.0250,  0.0003],
        [-0.0187, -0.0297, -0.0096,  ...,  0.0277, -0.0320,  0.0395]],
       device=&#39;cuda:0&#39;, grad_fn=&lt;SliceBackward0&gt;) 

Layer: linear_relu_stack.2.bias | Size: torch.Size([512]) | Values : tensor([-0.0206, -0.0259], device=&#39;cuda:0&#39;, grad_fn=&lt;SliceBackward0&gt;) 

Layer: linear_relu_stack.4.weight | Size: torch.Size([10, 512]) | Values : tensor([[-0.0047, -0.0406, -0.0102,  ..., -0.0346,  0.0284,  0.0111],
        [-0.0308, -0.0165, -0.0334,  ...,  0.0257,  0.0339,  0.0208]],
       device=&#39;cuda:0&#39;, grad_fn=&lt;SliceBackward0&gt;) 

Layer: linear_relu_stack.4.bias | Size: torch.Size([10]) | Values : tensor([-0.0353,  0.0320], device=&#39;cuda:0&#39;, grad_fn=&lt;SliceBackward0&gt;) </code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Pytorch系列笔记</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch学习笔记3——Transform数据变换</title>
    <url>/2021/12/13/af1b6d3a1966/</url>
    <content><![CDATA[<h1 id="三transform">三、Transform</h1>
<p>通常而言，数据不会以处理好的形式出现，所以我们需要在训练前对数据进行预处理，以适应训练</p>
<p>所有 TorchVision 的 Dataset 都会有两个参数—— transform
用于修改特征，target_transform
用于修改标签——它们接受包含转换逻辑的可调用对象（其实就是接受函数对象）。
torchvision.transforms 模块提供了几种常见的转换。</p>
<h3 id="示例">1、示例：</h3>
<p>如下代码为例，我们所拿到的FashionMNIST的特征是一个PIL
Image的格式，它的标签是一个Integer整数。但是我们训练的时候，希望特征是一个正则化后的张量，而标签是一个One-Hot向量张量。所以分别采用ToTensor和Lambda函数来进行处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> torchvision.transforms <span class="keyword">import</span> ToTensor, Lambda</span><br><span class="line"></span><br><span class="line">ds = datasets.FashionMNIST(</span><br><span class="line">    root=<span class="string">&quot;data&quot;</span>,</span><br><span class="line">    train=<span class="literal">True</span>,</span><br><span class="line">    download=<span class="literal">True</span>,</span><br><span class="line">    transform=ToTensor(),</span><br><span class="line">    target_transform=Lambda(<span class="keyword">lambda</span> y: torch.zeros(<span class="number">10</span>, dtype=torch.<span class="built_in">float</span>).scatter_(<span class="number">0</span>, torch.tensor(y), value=<span class="number">1</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>ToTensor() 函数可以将一个 PIL image 或者 NumPy ndarray 转换至一个
FloatTensor，同时放缩图像的像素值范围至0-1.</p>
<p>Lambda可以用于定义任何一个用户定义的lambda表达式，使其成为函数，在上述定义的表达式中：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Lambda(lambda y: torch.zeros(10, dtype=torch.float).scatter_(0, torch.tensor(y), value=1))</span><br></pre></td></tr></table></figure>
先初始化了一个维度为10的零向量，然后利用scatter_函数，将某一个维度的值赋为1</p>
<h4 id="scatter函数">Scatter函数</h4>
<p>scatter(dim, index, src) 的参数有 3 个，通过一个张量或标量 src
来修改另一个张量，哪个元素需要修改、用 src 中的哪个元素来修改由 dim 和
index 决定 - dim：沿着哪个维度进行索引 - index：用来 scatter 的元素索引
- src：用来 scatter 的源元素，可以是一个标量或一个张量</p>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Pytorch系列笔记</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch学习笔记2——Dataset介绍</title>
    <url>/2021/12/13/9d4aeea992ce/</url>
    <content><![CDATA[<h1 id="二dataset">二、Dataset</h1>
<p>Pytorch 使用 torch.utils.data.DataLoader 和 torch.utils.data.Dataset
来允许我们使用其预先加载好的数据，或是自己准备的数据集。</p>
<p>Dataset存储样本及其相应的标签，DataLoader在数据集周围包装一个iterable，以便于访问样本。</p>
<p>一些常用的Datasets可以在这边进行查询
https://pytorch.org/tutorials/beginner/basics/data_tutorial.html</p>
<h3 id="下载数据集示例">1、下载数据集示例</h3>
<h4 id="有以下四个参数">有以下四个参数</h4>
<h5 id="root-是训练集测试集数据存储的位置">1、root :
是训练集/测试集数据存储的位置</h5>
<h5 id="train-表明是训练集还是测试集">2、train:
表明是训练集还是测试集</h5>
<h5 id="download-表明如果数据集在root不存在是否从网络下载">3、download：
表明如果数据集在root不存在，是否从网络下载</h5>
<h5 id="transform-和-target_transform-指定特征和标签转换">4、transform
和 target_transform 指定特征和标签转换</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> torchvision.transforms <span class="keyword">import</span> ToTensor</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">training_data = datasets.FashionMNIST(</span><br><span class="line">    root=<span class="string">&quot;data&quot;</span>,</span><br><span class="line">    train=<span class="literal">True</span>,</span><br><span class="line">    download=<span class="literal">True</span>,</span><br><span class="line">    transform=ToTensor()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<pre><code>Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/train-images-idx3-ubyte.gz
Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/train-images-idx3-ubyte.gz to data\FashionMNIST\raw\train-images-idx3-ubyte.gz


100.0%


Extracting data\FashionMNIST\raw\train-images-idx3-ubyte.gz to data\FashionMNIST\raw

Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/train-labels-idx1-ubyte.gz
Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/train-labels-idx1-ubyte.gz to data\FashionMNIST\raw\train-labels-idx1-ubyte.gz


100.6%


Extracting data\FashionMNIST\raw\train-labels-idx1-ubyte.gz to data\FashionMNIST\raw

Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/t10k-images-idx3-ubyte.gz
Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/t10k-images-idx3-ubyte.gz to data\FashionMNIST\raw\t10k-images-idx3-ubyte.gz


100.0%


Extracting data\FashionMNIST\raw\t10k-images-idx3-ubyte.gz to data\FashionMNIST\raw

Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/t10k-labels-idx1-ubyte.gz
Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/t10k-labels-idx1-ubyte.gz to data\FashionMNIST\raw\t10k-labels-idx1-ubyte.gz


119.3%

Extracting data\FashionMNIST\raw\t10k-labels-idx1-ubyte.gz to data\FashionMNIST\raw</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">test_data = datasets.FashionMNIST(</span><br><span class="line">    root=<span class="string">&quot;data&quot;</span>,</span><br><span class="line">    train=<span class="literal">False</span>,</span><br><span class="line">    download=<span class="literal">True</span>,</span><br><span class="line">    transform=ToTensor()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>可以使用Index来访问数据集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img, label = training_data[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h4
id="pytorch中squeeze和unsqueeze函数">pytorch中squeeze()和unsqueeze()函数</h4>
<p>torch.squeeze()
主要对数据的维度进行压缩，去掉维数为1的的维度，比如是一行或者一列，一个一行三列（1,3）的数去掉第一个维数为一的维度之后就变成（3）行</p>
<p>torch.unsqueeze()
给指定位置加上维数为一的维度，比如原本有个三行的数据（3），在0的位置加了一维就变成一行三列（1,3）。a.unsqueeze(N)
就是在a中指定位置N加上一个维数为1的维度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(img.shape)</span><br><span class="line"><span class="built_in">print</span>(img.squeeze().shape)</span><br></pre></td></tr></table></figure>
<pre><code>torch.Size([1, 28, 28])
torch.Size([28, 28])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.imshow(img.squeeze())</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<figure>
<img src="output_14_0.png" alt="png" />
<figcaption aria-hidden="true">png</figcaption>
</figure>
<h3 id="创建自定义的数据集">2、创建自定义的数据集</h3>
<p>一个自定义的数据集类必须要实现以下三个函数： <strong>init</strong>,
<strong>len</strong>, and <strong>getitem</strong></p>
<h4
id="首先是init函数当实例化数据集对象的时候初始化目录标签文件等等">1）首先是Init函数，当实例化数据集对象的时候，初始化目录、标签文件、等等</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def __init__(self, annotations_file, img_dir, transform=None, target_transform=None):</span><br><span class="line">    self.img_labels = pd.read_csv(annotations_file, names=[&#x27;file_name&#x27;, &#x27;label&#x27;])</span><br><span class="line">    self.img_dir = img_dir</span><br><span class="line">    self.transform = transform</span><br><span class="line">    self.target_transform = target_transform</span><br></pre></td></tr></table></figure>
<h4 id="len__函数返回数据集中样例的数量">2)
__len__函数返回数据集中样例的数量</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def __len__(self):</span><br><span class="line">    return len(self.img_labels)</span><br></pre></td></tr></table></figure>
<h4
id="getitem__函数根据给定的idx从数据集中加载并且返回一个样例">3）__getitem__函数根据给定的idx从数据集中加载并且返回一个样例</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def __getitem__(self, idx):</span><br><span class="line">    img_path = os.path.join(self.img_dir, self.img_labels.iloc[idx, 0])</span><br><span class="line">    image = read_image(img_path)</span><br><span class="line">    label = self.img_labels.iloc[idx, 1]</span><br><span class="line">    if self.transform:</span><br><span class="line">        image = self.transform(image)</span><br><span class="line">    if self.target_transform:</span><br><span class="line">        label = self.target_transform(label)</span><br><span class="line">    return image, label</span><br></pre></td></tr></table></figure>
<h3
id="使用dataloaders来为训练准备数据">3、使用DataLoaders来为训练准备数据</h3>
<p>先前定义的Dataset能够一次检索一个样本的数据集功能和标签。但是在训练模型时，我们通常希望以“batches”的方式传递样本，在每个epoch重新排列数据以减少模型过度拟合，并使用Python的多处理来加速数据检索。</p>
<p>DataLoader
就是帮助我们完成上述事情的一个东西，下面就是将数据装载进DataLoader的过程，可以迭代访问数据集中的内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line">train_dataloader = DataLoader(training_data, batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line">test_dataloader = DataLoader(test_data, batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>下面的每次迭代都会返回一批训练实例和训练标签（分别包含batch_size=64个特征和标签）。因为我们指定了shuffle=True，所以在对所有批进行迭代之后，数据将被洗牌。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_dataloader</span><br></pre></td></tr></table></figure>
<pre><code>&lt;torch.utils.data.dataloader.DataLoader at 0x1f88dccf4f0&gt;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">iter</span>(train_dataloader)</span><br></pre></td></tr></table></figure>
<pre><code>&lt;torch.utils.data.dataloader._SingleProcessDataLoaderIter at 0x1f88e0796d0&gt;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">next</span>(<span class="built_in">iter</span>(train_dataloader))</span><br></pre></td></tr></table></figure>
<pre><code>[tensor([[[[0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000],
           [0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000],
           [0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000],
           ...,
           [0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000],
           [0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000],
           [0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000]]],
 
 
         [[[0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000],
           [0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000],
           [0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0078, 0.0000],
           ...,
           [0.0000, 0.0000, 0.4510,  ..., 0.8157, 0.0549, 0.0000],
           [0.0000, 0.0000, 0.0000,  ..., 0.4196, 0.0000, 0.0000],
           [0.0000, 0.0078, 0.0275,  ..., 0.0000, 0.0000, 0.0000]]],
 
 
         [[[0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000],
           [0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000],
           [0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000],
           ...,
           [0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000],
           [0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000],
           [0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000]]],
 
 
         ...,
 
 
         [[[0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000],
           [0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000],
           [0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000],
           ...,
           [0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000],
           [0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000],
           [0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000]]],
 
 
         [[[0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000],
           [0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000],
           [0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000],
           ...,
           [0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000],
           [0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000],
           [0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000]]],
 
 
         [[[0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000],
           [0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000],
           [0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000],
           ...,
           [0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000],
           [0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000],
           [0.0000, 0.0000, 0.0000,  ..., 0.0000, 0.0000, 0.0000]]]]),
 tensor([3, 9, 0, 2, 7, 4, 4, 5, 1, 5, 3, 0, 6, 9, 7, 7, 6, 4, 1, 7, 7, 7, 3, 7,
         4, 4, 9, 9, 5, 1, 4, 2, 2, 0, 9, 3, 9, 9, 9, 8, 2, 4, 9, 3, 2, 0, 0, 0,
         5, 7, 5, 7, 1, 9, 8, 7, 0, 4, 9, 0, 2, 3, 8, 7])]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_features, train_labels = <span class="built_in">next</span>(<span class="built_in">iter</span>(train_dataloader))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Feature batch shape: <span class="subst">&#123;train_features.size()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Labels batch shape: <span class="subst">&#123;train_labels.size()&#125;</span>&quot;</span>)</span><br><span class="line">img = train_features[<span class="number">0</span>].squeeze()</span><br><span class="line">label = train_labels[<span class="number">0</span>]</span><br><span class="line">plt.imshow(img, cmap=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Label: <span class="subst">&#123;label&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Feature batch shape: torch.Size([64, 1, 28, 28])
Labels batch shape: torch.Size([64])</code></pre>
<figure>
<img src="output_31_1.png" alt="png" />
<figcaption aria-hidden="true">png</figcaption>
</figure>
<pre><code>Label: 5</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Pytorch系列笔记</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch学习笔记1——Tensor介绍</title>
    <url>/2021/12/13/81937a6b0d26/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>
<h2 id="一tensor-的初始化">一、Tensor 的初始化</h2>
<h3 id="从数据初始化">1、从数据初始化</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = [[<span class="number">1</span>, <span class="number">2</span>],[<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">x_data = torch.tensor(data)</span><br><span class="line">x_data</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[1, 2],
        [3, 4]])</code></pre>
<h3 id="从nparray初始化">2、从nparray初始化</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np_array = np.array(data)</span><br><span class="line">x_np = torch.from_numpy(np_array)</span><br><span class="line">x_np</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[1, 2],
        [3, 4]], dtype=torch.int32)</code></pre>
<h3
id="从另一个tensor初始化新的tensor会继承作为参数的tensor的-形状和数据类型除非显式声明">3、从另一个Tensor初始化，新的Tensor会继承作为参数的Tensor的
形状和数据类型，除非显式声明</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x_ones = torch.ones_like(x_data) <span class="comment"># retains the properties of x_data</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Ones Tensor: \n <span class="subst">&#123;x_ones&#125;</span> \n&quot;</span>)</span><br><span class="line"></span><br><span class="line">x_rand = torch.rand_like(x_data, dtype=torch.<span class="built_in">float</span>) <span class="comment"># overrides the datatype of x_data</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Random Tensor: \n <span class="subst">&#123;x_rand&#125;</span> \n&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Ones Tensor: 
 tensor([[1, 1],
        [1, 1]]) 

Random Tensor: 
 tensor([[0.8288, 0.8223],
        [0.4349, 0.4734]]) </code></pre>
<h3
id="使用随机值进行初始化-rand-ones-zeros函数">4、使用随机值进行初始化
rand() ones() zeros()函数</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shape = (<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">rand_tensor = torch.rand(shape)</span><br><span class="line">ones_tensor = torch.ones(shape)</span><br><span class="line">zeros_tensor = torch.zeros(shape)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Random Tensor: \n <span class="subst">&#123;rand_tensor&#125;</span> \n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Ones Tensor: \n <span class="subst">&#123;ones_tensor&#125;</span> \n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Zeros Tensor: \n <span class="subst">&#123;zeros_tensor&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Random Tensor: 
 tensor([[0.5132, 0.3130, 0.5135, 0.7438],
        [0.9011, 0.3348, 0.6246, 0.7321]]) 

Ones Tensor: 
 tensor([[1., 1., 1., 1.],
        [1., 1., 1., 1.]]) 

Zeros Tensor: 
 tensor([[0., 0., 0., 0.],
        [0., 0., 0., 0.]])</code></pre>
<h2
id="二tensor的三个重要属性shapedtypedevice">二、Tensor的三个重要属性:shape,dtype,device</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tensor = torch.rand(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Shape of tensor: <span class="subst">&#123;tensor.shape&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Datatype of tensor: <span class="subst">&#123;tensor.dtype&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Device tensor is stored on: <span class="subst">&#123;tensor.device&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Shape of tensor: torch.Size([3, 4])
Datatype of tensor: torch.float32
Device tensor is stored on: cpu</code></pre>
<h2 id="三tensor的相关操作">三、Tensor的相关操作</h2>
<p>在默认情况下，Tensor将会被创建于CPU上，我们可以使用以下方法将其复制至GPU中，但是大型的Tensor在拷贝的过程中所耗费的代价是比较昂贵的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    tensor = tensor.to(<span class="string">&#x27;cuda&#x27;</span>)</span><br><span class="line"></span><br><span class="line">tensor.device</span><br></pre></td></tr></table></figure>
<pre><code>device(type=&#39;cuda&#39;, index=0)</code></pre>
<h3 id="一些常规操作">1、一些常规操作：</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tensor = torch.ones(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;First row: &#x27;</span>, tensor[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;First column: &#x27;</span>, tensor[:, <span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Last column:&#x27;</span>, tensor[..., -<span class="number">1</span>])  <span class="comment"># 等价于 tensor[:,-1]</span></span><br><span class="line">tensor[:,-<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(tensor)</span><br></pre></td></tr></table></figure>
<pre><code>First row:  tensor([1., 1., 1., 1.])
First column:  tensor([1., 1., 1., 1.])
Last column: tensor([1., 1., 1., 1.])
tensor([[1., 1., 1., 0.],
        [1., 1., 1., 0.],
        [1., 1., 1., 0.],
        [1., 1., 1., 0.]])</code></pre>
<h3 id="torch.cat-和-torch.stack">2、Torch.cat() 和 Torch.stack()</h3>
<h4
id="torch.cat-沿着一个维度进行堆叠不会改变原tensor的维度即原来是2维矩阵堆叠完还是二维矩阵">torch.cat()
沿着一个维度进行堆叠,不会改变原Tensor的维度，即原来是2维矩阵，堆叠完还是二维矩阵</h4>
<p>示例：dim=0的时候，原来的4x4的矩阵 A 会变成
[[A],[A],[A]]纵向叠加，即12x4的矩阵，示例：dim=1的时候，原来的4x4的矩阵
A 会变成 [A,A,A]横向叠加，即4*12的矩阵</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t1 = torch.cat([tensor, tensor, tensor], dim=<span class="number">0</span>)</span><br><span class="line">t1</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[1., 1., 1., 0.],
        [1., 1., 1., 0.],
        [1., 1., 1., 0.],
        [1., 1., 1., 0.],
        [1., 1., 1., 0.],
        [1., 1., 1., 0.],
        [1., 1., 1., 0.],
        [1., 1., 1., 0.],
        [1., 1., 1., 0.],
        [1., 1., 1., 0.],
        [1., 1., 1., 0.],
        [1., 1., 1., 0.]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t1 = torch.cat([tensor, tensor, tensor], dim=<span class="number">1</span>)</span><br><span class="line">t1</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[1., 1., 1., 0., 1., 1., 1., 0., 1., 1., 1., 0.],
        [1., 1., 1., 0., 1., 1., 1., 0., 1., 1., 1., 0.],
        [1., 1., 1., 0., 1., 1., 1., 0., 1., 1., 1., 0.],
        [1., 1., 1., 0., 1., 1., 1., 0., 1., 1., 1., 0.]])</code></pre>
<h4
id="torch.stack-沿着一个维度进行堆叠但是会在原tensor的维度上增加一个维度即原来是2维矩阵堆叠完会变成3维矩阵">torch.stack()
沿着一个维度进行堆叠,但是会在原Tensor的维度上增加一个维度，即原来是2维矩阵，堆叠完会变成3维矩阵</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t1 = torch.stack([tensor, tensor, tensor], dim=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(t1.shape)</span><br><span class="line"><span class="built_in">print</span>(t1)</span><br><span class="line">t1 = torch.stack([tensor, tensor, tensor], dim=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(t1.shape)</span><br><span class="line"><span class="built_in">print</span>(t1)</span><br><span class="line">t1 = torch.stack([tensor, tensor, tensor], dim=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(t1.shape)</span><br><span class="line"><span class="built_in">print</span>(t1)</span><br></pre></td></tr></table></figure>
<pre><code>torch.Size([3, 4, 4])
tensor([[[1., 1., 1., 0.],
         [1., 1., 1., 0.],
         [1., 1., 1., 0.],
         [1., 1., 1., 0.]],

        [[1., 1., 1., 0.],
         [1., 1., 1., 0.],
         [1., 1., 1., 0.],
         [1., 1., 1., 0.]],

        [[1., 1., 1., 0.],
         [1., 1., 1., 0.],
         [1., 1., 1., 0.],
         [1., 1., 1., 0.]]])
torch.Size([4, 3, 4])
tensor([[[1., 1., 1., 0.],
         [1., 1., 1., 0.],
         [1., 1., 1., 0.]],

        [[1., 1., 1., 0.],
         [1., 1., 1., 0.],
         [1., 1., 1., 0.]],

        [[1., 1., 1., 0.],
         [1., 1., 1., 0.],
         [1., 1., 1., 0.]],

        [[1., 1., 1., 0.],
         [1., 1., 1., 0.],
         [1., 1., 1., 0.]]])
torch.Size([4, 4, 3])
tensor([[[1., 1., 1.],
         [1., 1., 1.],
         [1., 1., 1.],
         [0., 0., 0.]],

        [[1., 1., 1.],
         [1., 1., 1.],
         [1., 1., 1.],
         [0., 0., 0.]],

        [[1., 1., 1.],
         [1., 1., 1.],
         [1., 1., 1.],
         [0., 0., 0.]],

        [[1., 1., 1.],
         [1., 1., 1.],
         [1., 1., 1.],
         [0., 0., 0.]]])</code></pre>
<h3 id="算术运算">3、算术运算</h3>
<h4 id="计算矩阵乘法的几种方式">计算矩阵乘法的几种方式</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(tensor)</span><br><span class="line">y1 = tensor @ tensor.T</span><br><span class="line">y2 = tensor.matmul(tensor.T)</span><br><span class="line">y3 = torch.rand_like(tensor)</span><br><span class="line">torch.matmul(tensor, tensor.T, out=y3)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[1., 1., 1., 0.],
        [1., 1., 1., 0.],
        [1., 1., 1., 0.],
        [1., 1., 1., 0.]])





tensor([[3., 3., 3., 3.],
        [3., 3., 3., 3.],
        [3., 3., 3., 3.],
        [3., 3., 3., 3.]])</code></pre>
<h4
id="element-wise-product-点对点乘积矩阵对应元素相乘得到结果">element-wise
product 点对点乘积（矩阵对应元素相乘得到结果）</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z1 = tensor * tensor</span><br><span class="line">z2 = tensor.mul(tensor)</span><br><span class="line"></span><br><span class="line">z3 = torch.rand_like(tensor)</span><br><span class="line">torch.mul(tensor, tensor, out=z3)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[1., 1., 1., 0.],
        [1., 1., 1., 0.],
        [1., 1., 1., 0.],
        [1., 1., 1., 0.]])</code></pre>
<h3 id="in-place-操作">4、In-Place 操作</h3>
<p>像一些会将结果存储到操作数里的计算，我们将之称为In-Place操作，它们会在操作符后面加上后缀
"_"</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(tensor, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">tensor.add_(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(tensor)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[1., 1., 1., 0.],
        [1., 1., 1., 0.],
        [1., 1., 1., 0.],
        [1., 1., 1., 0.]]) 

tensor([[6., 6., 6., 5.],
        [6., 6., 6., 5.],
        [6., 6., 6., 5.],
        [6., 6., 6., 5.]])</code></pre>
<h3 id="bridge-with-numpy机制">5、Bridge with NumPy机制</h3>
<p>Tensors和Numpy在计算机底层可能共享同一块内存，改变其中一个变量就会影响另外一个，需要注意</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = torch.ones(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t: <span class="subst">&#123;t&#125;</span>&quot;</span>)</span><br><span class="line">n = t.numpy()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n: <span class="subst">&#123;n&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>t: tensor([1., 1., 1., 1., 1.])
n: [1. 1. 1. 1. 1.]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t.add_(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t: <span class="subst">&#123;t&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n: <span class="subst">&#123;n&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>t: tensor([2., 2., 2., 2., 2.])
n: [2. 2. 2. 2. 2.]</code></pre>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Pytorch系列笔记</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Transformer系列笔记4——Swin Transformer思想与架构</title>
    <url>/2021/12/09/aba242d32ac9/</url>
    <content><![CDATA[<h4
id="论文名称swin-transformer-hierarchical-vision-transformer-using-shifted-windows">论文名称：《Swin
Transformer: Hierarchical Vision Transformer using Shifted
Windows》</h4>
<h4
id="论文地址httpsarxiv.orgabs2103.14030">论文地址：https://arxiv.org/abs/2103.14030</h4>
<h4 id="模型swin-transformer">模型：Swin Transformer</h4>
<h3 id="一论文摘要与swin-transformer背景介绍">一、论文摘要与Swin
Transformer背景介绍</h3>
<p>​
论文摘要部分即指出了Transformer在视觉领域应用与NLP领域的一些较大的差别，首先就是在视觉领域，视觉实体的规模尺度会存在较大的变化，举例而言，想要识别同一张图像中的同一距离的果实和汽车，两者的规模尺度大小可能会存在较大的不同。第二点就是相比于文字而言，图像像素的分辨率更高，信息量更多，计算更为复杂，需要消耗更多的计算资源与训练时间。相比于先前的Vision
Transformer的架构，Swin Transformer使用Shifted
Windows这样一个技巧，不仅大大加速了计算速度，和图像的尺度呈线性计算复杂度，并且其也仍然能够考虑到不同窗口之间的信息交互，在识别质量上也提高了2-3个百分点。故而成为了应用性非常广泛的一个架构。那么具体而言，如何加速计算，并且仍然能够考虑不同窗口的信息交互，后面会详细讲解。</p>
<h3 id="二swin-transformer整体架构介绍">二、Swin
Transformer整体架构介绍</h3>
<p>​ 在上一篇笔记中，讲过了ViT网络架构，相比于ViT网络架构，Swin
Transformer考虑了<strong>多尺度下的图像</strong>，可以看到如下图所示：其通过不断的下采样，在多个图像的尺度维度进行检测，这样的话直观上可以很好的解决我们先前说的视觉实体的规模尺度的大小不同的问题。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115120312596.png" /></p>
<p>​ 同样，我们先来看一下Swin
Transformer整体的一个架构流程，如下所示：可以看到，我们假设输入的图像是高为H，宽为W，RGB三通道24位真彩图，首先其会有一个Patch
Partition层，图像宽高减少为原来的1/4，维度由3变至48.
然后后面跟着四个阶段的运算，除了第一个阶段中经过的是Linear
Embedding层，后续每个阶段开始都会经过Patch
Merging也就是对图像进行下采样，然后经过堆叠的Swin Transformer
Block。此处值得注意的是：我们观察到，Swin Transformer
Block的堆叠次数都是偶数，原因在于在该架构中，Block是成对出现的，看到下图的右侧部分，有两个不同的Block，我们暂且将之称为Block1和Block2，如果Swin
Transformer Block堆叠2次那么就是Block1+Block2,如果Swin Transformer
Block堆叠6次那么就是Block1+Block2+Block1+Block2+Block1+Block2。</p>
<p>​ 在每一个Block中，LN就是Layer
Norm层，这个层在先前的Transformer架构中已经出现过多次了，然后MLP是多层感知级，通常由全连接层构成，在Swin
Transformer的Block中，比较新的就是W-MSA模块和SW-MSA模块，也就是论文标题中所提到的Shift-Window-Multihead-Self-Attention机制。此机制我们在后续一个个模块时会进行详细讲解。</p>
<p>​
在整体的流程中，还有一个内容值得我们注意，也就是上面显示的每经过一个阶段，矩阵的维度变化。我们发现，每过一个阶段特征图的宽和高都会减半，而随之特征图数量就会翻倍。其实每一个不同的阶段就是在不同的图像尺度下去进行内容模式的识别观察。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/cvbvbng.png" /></p>
<h3 id="三swin-transformer细节介绍">三、Swin Transformer细节介绍</h3>
<h4 id="patch-partition-linear-embedding介绍">1、Patch Partition &amp;
Linear Embedding介绍</h4>
<p>​
如下图所示，对于输入的Images来说，我们假设输入的图像为H*W*3，那么在Patch
Partition的过程中会将其分割成4*4大小的块，然后将每一个块在维度方向进行展平，也就是说先前的H*W*3的矩阵经过此步骤后，长宽会变成H/4
* W/4，至于最后一个维度，将会变为3*16 =
48维，因为我们将其分割成4*4大小的块后，是在维度方向对其进行展平的。展平后，再通过Stage1的一个Linear
Embedding层，该层就是对原来的第三维度为48维的三维矩阵进行一个编码（其实就是再进行一个映射），然后三维矩阵的最后一个维度的大小就会变为C。具体C为多少，是不同类型的Swin
Transformer的一个参数，后文中会详细提及。在这两层的实际实现中，其实都是通过卷积来实现维度的变化以及编码的，比如在Patch
Partition中就可以使用大小为4*4,步长为4的16个卷积核来对原图进行卷积得到结果。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115120418491.png" /></p>
<h4 id="patch-merging">2、Patch Merging</h4>
<p>​ Patch
Merging层所起到的作用就是将图片下采样，然后在深度方向进行拼接。主要由如下图所示的几步组成：</p>
<p>首先是以2 *
2的格子为一组，将每组中相同位置的像素抽出，形成一个新的矩阵。以下图为例，原特征矩阵为4
* 4，那么以2 * 2格子为1组，会形成4组新的矩阵，每组的矩阵大小为2 *
2，也就是原来的一半。然后将这4组新形成的矩阵，在深度方向做连接，然后完成LayerNorm，最后再在深度维度进行一个线性映射，将深度维度减半。此时就完成了最终的Patch
Merging层的输出。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115120447510.png" /></p>
<p>​
对比该模块的输入与输出，可以发现，输出的H和W是输入的一半，深度维度是输入的2倍。符合先前全流程示意图中的H/4
* W/4 * C 变成了H/8 * W/8 *
2C，成功的将图像空间上的尺寸缩小，由较好的保留了信息。</p>
<h4 id="w-msa模块">3、W-MSA模块</h4>
<p>​ W-MSA 全称为Windows Multi-head
Self-Attention也就是窗口化的Self-Attention机制，此处以在一个4*4的特征图上做为例子，在上一篇Vision
Transformer中的MSA模块，4*4中的每个像素都要去和其他像素进行关联度的计算，那么在W-MSA中，其将原4*4的特征图首先分割成了4个2*2的Window窗口，然后再在每个窗口内部进行单独的Self-Attention的计算。也就是说，每个像素只需要和自己所属Window内部的像素进行关联度的计算即可。这样一来，确实大大减少了计算量，但是你会发现窗口之间的像素也无法进行通信了，导致我们的感受野变小，对于最终的结果产生影响。优劣势还是非常的明确的。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115120506850.png" /></p>
<p>​
在原论文中，给出了MSA和W-MSA的计算复杂度的推导结果公式，我们假设每个窗口含有M
*
M个像素，计算图像的宽高为h和w，C即为矩阵的第三维度的大小（也就是深度）。详细的推导此处省略。我们从公式中应该可以看出，相比于MSA平方的复杂度（对于hw），W-MSA相对于hw的复杂度是线性的。能够大大的提高计算效率。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115120516476.png" /></p>
<h4 id="sw-msa模块">4、SW-MSA模块</h4>
<p>​
相比于W-MSA而言，SW-MSA才是本篇论文中的重点模块，该模块弥补了W-MSA窗口与窗口间无法进行信息交互的缺陷，同时也保证了和W-MSA一样的计算复杂度。</p>
<p>​
如下图所示，我们先前说过，在Swin-Transformer中，堆叠的Block都是偶数次，是两个不同的Block的组合。我们可以看到，下图的Layerl所示是第一次的Block堆叠，使用的是W-MSA，然后在Layerl+1中，我们将window进行了重新的分割，然后在每个window中完成计算，新的window中有些仍然是老的window的一部分，但有些新的window已经含有老的多个window的信息了，也就是完成了window间的信息的交互。</p>
<p>那么现在就让我们来一一解决以下两个问题：</p>
<p>​ 1、这个是如何进行重新的分割的呢？</p>
<p>​
2、这样子重新分割以后，由于要计算的Window数目变成了9个，如果需要并行计算的话，需要将每个window都填充至4*4，这样子就会加大我们的计算量。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115120536278.png" /></p>
<p>​ 首先是如何分割的问题：Shifted
Window顾名思义，我们将原来的分割线向右和向下偏移一定的像素，然后对原图形成的分割线，就是新的window的划分线。以上面的示意图为例，就是将原来的分割线向右以及向下移动了2个像素点，就得到了新的划分。这个移动的距离，一般来说是窗口的一半，也就是<span
class="math inline">\(Math.floor(M/2)\)</span>。</p>
<p>​ 接下来是第二个问题，原论文中给出了如下的示意图：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115120606229.png" /></p>
<p>​
我们将所有window中的一些window进行一个划分，0所在的部分标志为A，1，2所在的标志为C，3，6所在的标志为B，如图1所示，然后进行一个平移，也就是变成图2的形式，这样子的话我们发现又可以将其组成4个新的4
*
4的window进行self-Attention的计算，计算量和以前一致。到此为止，你可能会问，我们不是要按照原来划分的9个window进行计算吗？如果按照现在这个平移过的4
*
4的window进行计算，原先window和window之间的边缘都是跳跃的，而且我们本来就是要原来每个window内部单独计算的，只是为了减轻计算量才进行的平移，所以计算某一个新的4
*
4的混合window的时候，自然不希望内部的两个原来的window之间信息有交互和混合。（就比如说，我们平移后，变成了4号块自己算自己的，5、3号块合起来算，1、7号块合起来算，2、0、6、8号块合起来算，4号块是没有问题的，内部像素本身就是连续的，但是5、3号块一起算就会出现问题，5号块和3号块边缘处的像素是不连续的，而且理论上而言，我们是要单独计算3、5号块各自的Self-Attention的内部像素关联度的，所以我们在计算区域5的时候不要引入区域3的信息）</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115120637174.png" /></p>
<p>​
所以，平移以后对4个新的4*4的window进行的Self-Attention是我们先前提到过的Masked
MSA,也就是让每一个新形成的window中，根据原来的分割规则给它套上一个mask。这样子的话，虽然它们在一起训练，但是通过这个mask，仍然使得原来的9个window划分规则中，不同的window之间的像素是不会计算关联度的，或者说关联度为0.</p>
<p>​
举例来说，如下图所示：我们计算区域5和区域3的这块的Self-Attention的时候，原先是计算了16个α值，那么我们等它计算完以后，将图中蓝色框圈出来的系数全都减去100，这个减100的含义是什么呢？原先计算出的α系数，一般都是比较小量级的，减去100以后，必定是一个比较大的负数，那么经过SoftMax的计算以后，系数就会变成0，也就实现了区域5和区域3之间的像素如果计算关联度，那么就是0。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115120650353.png" /></p>
<p>​ 最后的话，我们要注意，计算完以后将对应的小块移回原位置。</p>
<h4 id="relative-position-bias介绍">5、Relative Position Bias介绍：</h4>
<p>​
在论文中还简单介绍了这样一种相对位置偏移的计算机制。这种机制应用于计算Self-Attention的时候。如下公式所示：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115120718204.png" /></p>
<p>​
其给出了一组数据，在不同的学习网络中，是否使用偏移、或者是使用相对/绝对位置偏移来计算Attention会导致的结果误差。我们可以发现相对位置偏差能够将结果提升1个百分点左右。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115120725660.png" /></p>
<p>​
那么相对位置偏差是怎么确定的呢？如下所示，假设我们的特征图是左侧的2*2的格子，下方是我们熟知的绝对位置索引，相对位置索引如右侧上面一排所示，其实就是当前计算格子的绝对位置索引减去其他格子的绝对位置索引。然后将四个像素的相对位置索引展开后拼接在一起形成一个新的矩阵。这个矩阵就是二维的相对位置索引矩阵。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/iiioio.png" /></p>
<p>​
在作者的源码中，其使用的是1维的的相对位置索引矩阵，我们不能简单的将x,y相加，不然可能导致不同位置的相对位置索引一致，导致出现问题。所以作者在源码中经过了一个简单处理。我们先把所有的行列标加上M-1，然后再将行标乘2M-1，然后再将行列标相加，得到的矩阵。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115120758495.png" /></p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115120804811.png"
alt="image-20220115120804811" />
<figcaption aria-hidden="true">image-20220115120804811</figcaption>
</figure>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115120807646.png"
alt="image-20220115120807646" />
<figcaption aria-hidden="true">image-20220115120807646</figcaption>
</figure>
<p>​ 然后我们需要把Relative Position Index通过一张Bias
Table映射成relative position
bias才是用于计算Self-Attention最终用于计算的Bias值，也就是公式里的矩阵B。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115120814669.png" /></p>
<h3 id="四swin-transformer-模型扩展参数">四、Swin Transformer
模型扩展参数</h3>
<p>​
论文中给出了以下一张表格，里面是四种不同的Swin模型的各个阶段的参数。其中有Swin-T,Swin-S,Swin-B,Swin-L四种不同的Swin
Transformer模型，分别代表Tiny。</p>
<p>​ 我们解析某一列的参数，concat 4 * 4
就代表要将高和宽下采样4倍，96-d就代表经过Linear
Embedding层以后的C大小。接下来的括号内的东西就代表堆叠的block内的参数，window
size = 7*7,通过该Block之后输出维度为96，Multi_Head的Head = 3。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/bvbcf123.png" /></p>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Transformer系列笔记</category>
      </categories>
      <tags>
        <tag>Transformer</tag>
        <tag>Swin Transformer</tag>
        <tag>Computer Vision</tag>
      </tags>
  </entry>
  <entry>
    <title>Transformer系列笔记3——Vision Transformer思想与架构</title>
    <url>/2021/12/08/5899e5598f03/</url>
    <content><![CDATA[<p>论文名称：《An Image is Worth 16x16 Words: Transformers for Image
Recognition at Scale》</p>
<h4
id="论文地址httpsarxiv.orgabs2010.11929">论文地址：https://arxiv.org/abs/2010.11929</h4>
<h4 id="模型vision-transformer-vit">模型：Vision Transformer (ViT)</h4>
<h3 id="一论文摘要与vision-transformer背景介绍">一、论文摘要与Vision
Transformer背景介绍</h3>
<p>​
自从Transfomer机制出现以后，已经成为了NLP领域的业界标准流程，但是在CV领域的应用较少。CV领域中往往都是会将其和CNN结合使用，或是代替CNN架构中的一部分。这篇论文就提出了其实在CV领域中，Transformer并不需要依赖于CNN来进行使用，其提出的Vision
Transformer架构，在基于一些大体量数据的预训练的网络参数然后再迁移学习到一些训练任务时，能够取得非常好的效果，并且也能节省训练的计算资源。所以Vision
Transformer是应用于CV领域的，不简单依托于CNN架构的一类Transformer架构的衍生内容。在此论文中，其应用于了CV领域的图象识别任务。</p>
<h3 id="二vision-transformer网络架构">二、Vision
Transformer网络架构</h3>
<p>​
如下图所示，左侧为ViT网络的概览，可以看到，该网络将图片分为一小块一小块的，将每一个小块视为一个向量(被称为Flattened
Patches),然后图中的Linear Projection of
这层可以被视为是一个Embedding层，将每一块图像Embedding成为一个对应的向量，然后再在这一系列向量前面，新增一个用于分类的向量，叫做Class
Token,再给每一个向量加上一个表示位置信息的向量。随后将这些向量输入进Transformer
Encoder中，我们知道，Encoder对于一个输入序列中的每一个向量，都会输出一个对应的向量，我们仅取Class
Token输入对应的输出向量，将其放入MLP
Head模块（这是一个最终用于分类的层结构）中，然后再由MLP
Head模块输出分类类别。Transformer
Encoder内部的块结构与Transformer的结构类似，其中MLP是新的模块，后续会详细再讲。到此为止就是整个ViT网络基本的架构。接下来会按照顺序，一个一个模块的进行详细的介绍。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115115915557.png" /></p>
<h4 id="linear-projection-of-flattened-patchesembedding层">1、Linear
Projection of Flattened Patches（Embedding层）</h4>
<p>​
对于标准的Transformer的Encoder模块，一般要求输入的是向量序列，也就是应该是一个二维矩阵[num_token,token_dim]。在该网络架构的代码实现中，可以直接通过一个卷积层来实现，比如说ViT-B/16，B代表Base，16代表分割以16*16为单位分割源图像。在这个网络中，使用卷积核大小为16*16，步长为16。</p>
<p>​
如果我们使用的图片是[224,224,3]的大小，那么经过卷积以后就会变成[14,14,768]的大小，然后展平就会最终变成[196,768]的二维矩阵。</p>
<p>​ 在输入到Encoder之前，还需要加上 用于分类的向量class token和position
embedding，这两者都是可训练参数。</p>
<p>​ 拼接[class]token:Cat([1,768],[196,768]) -&gt;[197,768]</p>
<p>​ 叠加Position Embedding: [197,768] -&gt; [197,768]</p>
<p>​ Position
Embedding在此处是通过直接叠加相加的方法完成的，所以矩阵的维度不会发生变化，同时，原论文中给出了不同维度的Position
Embedding的效果，我们发现1维和2维的效果差不多，但是都比没有Position
Embedding的结果要好，所以在实现过程中就可以实现一维的Pisition
Embedding进行叠加。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115115949427.png" /></p>
<p>​ 那么，具体叠加的一维的Position
Embedding应该是什么呢？如下图所示，我们对于每个位置计算其和其他位置的余弦相似度。即可得到叠加的具体数值。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115120001864.png" /></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115120004895.png" /></p>
<h4 id="transformer-encoder层">2、Transformer Encoder层</h4>
<p>​ 其和Transformer中Encoder类似，由许多个Block组成</p>
<p>​ 我们先看Encoder
Block的结构，其中基本结构与原始的Transformer的Encoder
Block类似，但是其中有一个不太一样的MLP Block结构。MLP
Block的结构显示如右侧，其中是几个Linear层，然后配合一些Dropout和激活函数。MLP
Block的第一个Linear层，会将原始的输入扩大4倍，就例如如果Linear层的输入是197
* 768的，那么该层的输出是197 *
3072，然后第二个Linear层又会将输出变回197*768的大小。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115120029921.png" /></p>
<h4 id="mlp-head层">3、MLP Head层</h4>
<p>​
此层在训练不同的数据集时，组成模块不太一样。如果训练ImageNet21K或一些更大的数据集的时候，该层由Linear+tanh激活函数+Linear层组成。但是如果迁移到ImageNet1K或者一些小规模的数据集上，那其实只需要一个Linear层即可。具体的内容可以查看论文的源码部分。</p>
<h3 id="三以vit-b16-为例的vision-transformer架构">三、以ViT-B/16
为例的Vision Transformer架构</h3>
<p>​
我们可以看到先前所讲的各个模块组合在一起以后，整个网络的一个架构。图中的Pre-Logits部分其实就是一个全连接层+激活函数，视情况可以舍弃。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115120118127.png" /></p>
<h3 id="四不同vit模型的参数">四、不同ViT模型的参数</h3>
<p>​ 在论文的Table1中有给出三个模型（Base/ Large/ Huge）的参数</p>
<ul>
<li><p>Layers 是Transformer Encoder中重复堆叠Encoder
Block的次数。</p></li>
<li><p>Hidden Size是通过Embedding层后每个向量的长度（token 的
dim）。</p></li>
<li><p>MLP Size 是Transformer Encoder中MLP
Block第一个全连接的节点个数，一般来说是Hidden Size的4倍。</p></li>
<li><p>Heads 代表Transformer中Multi-Head Attention的heads数。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115120147916.png" /></p></li>
</ul>
<h3 id="五hybrid混合模型">五、Hybrid混合模型</h3>
<p>​
引用：https://blog.csdn.net/qq_37541097/article/details/118242600</p>
<p>在论文中其也提及了Hybrid混合模型，其就是先前摘要中提到的将传统CNN特征提取和Transformer进行结合的做法。</p>
<p>​ 其首先用传统的CNN提取特征，然后再用Vit模型进一步得到最终的结果。</p>
<p>​
整体的网络架构如下：以ResNet50作为特征提取器的混合模型，但这里的Resnet有些不同。首先这里的R50的卷积层采用的StdConv2d不是传统的Conv2d，然后将所有的BatchNorm层替换成GroupNorm层。同时在原Resnet50网络中，stage1重复堆叠3次，stage2重复堆叠4次，stage3重复堆叠6次，stage4重复堆叠3次，但在这里的R50中，把stage4中的3个Block移至stage3中，所以stage3中共重复堆叠9次。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115120211640.png" /></p>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Transformer系列笔记</category>
      </categories>
      <tags>
        <tag>Transformer</tag>
        <tag>Vision Transformer</tag>
        <tag>Computer Vision</tag>
      </tags>
  </entry>
  <entry>
    <title>Transformer系列笔记2——原始Transformer架构与Seq2Seq问题</title>
    <url>/2021/12/07/84769e08d06a/</url>
    <content><![CDATA[<h3 id="一相关背景介绍">一、相关背景介绍</h3>
<p>​
Transformer架构最广泛用在Seq2Seq问题上，也就是Sequence-to-Sequence。区别于GAN所对应的Pix2Pix的问题，Seq2Seq的问题也会有非常多的应用和变式，其应用场景也是非常的广。</p>
<p>​
Seq2Seq问题是指输入一个序列，输出一个序列，同时输出序列的长度由训练好的模型进行决定。比较经典的问题就是语音识别、机器翻译、语音翻译等领域。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115112932803.png" /></p>
<p>​
同时，Seq2Seq也可以用于Chatbot聊天机器人，比如说如下所示：我们可以将Person1和Person2的一组对话视为一个input和一个对应的response，两者都是序列。或者一些其他的Question&amp;Answering问题都可以广泛的应用Seq2Seq的模型解决思想。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115112939154.png" /></p>
<p>​ 具体的一些相关论文可以参照下图所示的网址进一步了解。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115112946229.png" /></p>
<p>​ 同时，还有更多的可以应用Seq2Seq的例子，比如说对于一个Syntactic
Parsing问题，也就是语法解析，我们也可以将其视为Seq2Seq的形式，来对其进行思考。输入是一句话，毫无疑问是一个Seq序列。但是，我们所需要的输出结果看上去像是一个树形结构【deep
learning组成名词短语，very powerful 组成形容词短语，is 和 very
powerful又组成动词短语，最后deep learning和 is very
powerful组成一个句子】，但其实，如下图所示，我们可以将图最上方的这个句子作为输出结果，这样就将一个类似图结构的内容转换成了Seq的形式，同时也包含了所有我们需要的结果信息，然后用Seq2Seq的思想去训练模型即可。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115112954818.png" /></p>
<p>​
再比如，Seq2Seq应用于图像领域的目标检测，感兴趣可以查看以下这篇论文。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115113003795.png" /></p>
<h3
id="二seq2seq2结局方案origin-transformer">二、Seq2Seq2结局方案——Origin
Transformer</h3>
<p>​
对于一般的Seq2Seq问题，笼统而言，我们一般就是将输入序列经过一个Encoder然后再通过一个Decoder就得到我们的输出序列。但是这个Encoder和Decoder内部的结构就大有讲究，最经典的架构就是Transformer。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115113028194.png" /></p>
<h4 id="encoder">1、Encoder</h4>
<p>​
首先我们关注Transformer的Encoder部分。下面是从输入输出的结果来看，Encoder的输入是一个序列，输出是一个编码过后的序列。（其实只从输入输出来看，像RNN、CNN都可以做到输入一个序列，输出一个序列，但是此篇讲的是Transformer）</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115113035456.png" /></p>
<p>​
Transfomer中的Encoder现在一般都由这样的架构组成，如下图所示，由非常多的Block组成，每一个Block并不是指一层网络，可能是有许多曾网络组成。那么输入经过许多个Block的处理，然后输出。那么在Transformer中，每一个Block内部的架构如右侧所示：输入一排向量，先经过Self-attention的机制，输出一排向量，然后这一排向量再经过全连接层，输出一排向量，这一排带红色框的向量就是Block的输出。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115113045808.png" /></p>
<p>​
但实际上，在原来的Transformer中，Block内的结构稍微更复杂一些，其还增加了一个residual的过程，如下所示：</p>
<p>​
输入的某个向量b经过Self-attention以后，得到向量a,此向量a还要与向量b相加，得到一个新的向量a+b，然后再做Layer
Norm,得到一个深蓝色的向量c。（左上角的那个框框代表的就是，接下去接右侧的过程）</p>
<p>​
然后这个Norm输出的深蓝色的向量c，经过FC层，得到新的向量d，此处还有一个residual的架构，c和d相加，得到新的向量e，然后e再做一次Layer
Norm才会得到最终这个Block输出的结果向量。</p>
<p>（LayerNorm本身的过程如图中央所示，先计算向量数据的均值和标准差，然后依据公式xi’
= (xi-m)/σ即可完成归一化。）</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115113058827.png" /></p>
<p>​
讲完每一个Block内完成的事情，我们就可以看Transfomer中给出的这个完整的带细节的架构示意图，其实两者中有部分过程是重叠的，只是表示形式不一样。</p>
<p>​
首先将输入经过嵌入层，完成编码。如果对嵌入层没有印象，可以查看如下的文章。然后通过Positional
Encoding向输入中增加序列不同地方的位置信息。然后经过多次结构的核心部分Nx。这个Nx其实就是我们刚才提到的一个Block。其中，Multi-Head
Attention就是Self-Attention的一种扩展的架构，然后Add&amp;Norm就是上述的Residual
+ LayerNorm的过程。Feed
Forward就是上图中通过FC层的过程。所以这张图中Nx内部的这个框框就是一个Block的过程，然后整个Transformer
Encoder就由许多个这样的Block组成。【像先前所讲的】</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115113109977.png" /></p>
<p>​ 其实Transformer
Encoder的架构也是可以灵活改变的，此处只是讲了最初提出的Transformer时候文章中Encoder的架构。</p>
<h4 id="decoder">2、Decoder</h4>
<p>​
然后的话我们关注Transformer的Decoder部分。Decoder分为两种，一种是Autoregressive（AT）的Decoder,还有一种是Non-Autoregressive（NAT）的Decoder。首先是Autoregressive的Decoder的介绍：</p>
<p>​
Decoder的输入，有两个内容，一个是Encoder输出的序列，还有一个是START标识符号所对应的One-hot编码，这两样东西经过Decoder后，输出一个各种字的概率分布，其中概率最大的那个字就会被作为最后的输出字符。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115113200035.png" /></p>
<p>​ 然后我们将START 和 机
组成的one-hot向量的序列输入，再经过Decoder，得到一个概率分布，然后选出概率分布中最高的那个字“机”。以此类推，直到完成所有的输出。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115113209026.png" /></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115113211451.png" /></p>
<p>​ 在此处其实存在两个问题
，一个问题是按照上述的过程，其实Decoder后面每一步的输入都来自于自己前一步的输出，就比如说，中间某一步输入是“机器”，输出了“学”，然后下一步输入是“机器学”，输出是“习”。那么，我们要如何避免一步错步步错的情况发生呢？也就是说，如果其中有一步发生了问题，我们应当怎么让机器在后面的步骤中仍然输出正确的结果。第二个问题是，如果按照上述的步骤生成下去，生成出来的序列是无穷无尽的，它永远不会停止，那么机器怎么去决定输出序列的长度呢？这两个问题，后文会有提及，我们先继续讲述Decoder内部到底经历了什么。</p>
<p>​
我们先来看一张Encoder和Decoder的对比图：从此图而言，我们发现Decoder除了中间那一块被盖住的，以及最后输出层的一些内容以外，Block内部的内容其实和Encoder是类似的。一个比较重要的差别点就是其使用的是Masked
Multi-Head Attention。</p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115113222282.png"
alt="image-20220115113222282" />
<figcaption aria-hidden="true">image-20220115113222282</figcaption>
</figure>
<p>​ 我们先来看一下，这个Masked Multi-Head
Attention是什么意思呢？图1是我们熟悉的Self-Attention，每一个输出的向量都是含有输入的所有向量的咨询的，右图是Masked
Self
Attention机制，也就是在生成b1的时候，是不能使用a1之后的输入向量的，只能使用a1的资讯，生成b2的时候，不能使用a2之后的输入向量，只能使用a1,a2的资讯，以此类推。</p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115113244478.png"
alt="image-20220115113244478" />
<figcaption aria-hidden="true">image-20220115113244478</figcaption>
</figure>
<p>下面是一个更为具体的示意图：</p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115113256453.png"
alt="image-20220115113256453" />
<figcaption aria-hidden="true">image-20220115113256453</figcaption>
</figure>
<p>​
那么为什么要使用这样的架构呢？原因其实很简单，因为如果不这样子的话，AT形式的Decoder是没法的运作的。因为先前讲的AT的Decoder运作方式，输出的字是一个一个产生的。第一步只有一个输入的“START”标识符对应的One-Hot向量，生成一个字以后，再将START标识符和第一个字输入，得到第二个字，依次类推。所以在生成的时候，它只能参考它前面的输入的序列的资讯，没法获得它之后的资讯。</p>
<p>​
然后我们来看一下Encoder间和Decoder间是如何传递资讯的呢？也就是刚才那张图中，暂时被灰色遮住的部分：我们会发现，在这个红色框框框起来的模组中，有两个输入的箭头来自于Encoder，一个输入的箭头来自于Decoder的前一步的输出。</p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115113305054.png"
alt="image-20220115113305054" />
<figcaption aria-hidden="true">image-20220115113305054</figcaption>
</figure>
<p>​ 那么具体来说，是怎么工作的呢，如下所示：此步中的Multi-Head
Attention指的是一个Cross-Attention的过程，具体如下所示：在Decoder解析的第一步时，输入是来自Encoder的一个序列，以及Decoder上一步的输出（因为Decoder上一步无输出，此步为第一步，所以这个应该是一个START标识符，表示句子的开始）。</p>
<p>​
然后Encoder这边输出的序列，a1,a2,a3向量分别乘以一个权重矩阵，形成k1,v1,k2,v2,k3,v3，Deocder这侧的START标识符对应的One-hot编码经过Masked-Self-Attention得到一个向量，然后该向量乘上一个权重矩阵，得到向量q,计算q和k1,k2,k3的相关性并且归一化，得到系数α1’，α2’，α3’.</p>
<p>​
得到系数α1’，α2’，α3’后，分别和v1,v2,v3相乘相加，得到向量v，然后再经过FC就是该步骤Cross
attention的输出，至于后面就是需要再经过上述网络中描述的Add&amp;Norm，也就是Residual和Layer
Norm的过程，才完成Decoder中一个Block的过程。</p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115113324988.png"
alt="image-20220115113324988" />
<figcaption aria-hidden="true">image-20220115113324988</figcaption>
</figure>
<p>​ 然后第二步以此类推，如下图所示，此处就不再赘述。</p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115113331325.png"
alt="image-20220115113331325" />
<figcaption aria-hidden="true">image-20220115113331325</figcaption>
</figure>
<p>​
讲到这里的话，Decoder的基本架构也都已经清晰了，我们来解决一下先前的两个遗留问题之一，也就是机器怎么决定输出的序列的长度的？</p>
<p>​
在AT的Decoder中，我们其实可以在输出的字符集中增加一个叫做END的字符，它就代表一个句子的结束，如果某次Decoder输出的概率分布中，END字符的概率较高，就说明该句子结束了。</p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115113340249.png"
alt="image-20220115113340249" />
<figcaption aria-hidden="true">image-20220115113340249</figcaption>
</figure>
<p>​
那么什么又是NAT的Decoder呢？我们先前看到AT的Decoder是一个个输出字符的，NAT的Decoder则是一次性的输入全是START的序列，然后一次性得到输出的字符序列。那么NAT的Decoder又是如何决定输出序列的长度的呢？有两种办法，一个是专门训练一个分类器或者预测器，去预测输出序列的长度，另一个就是我们先假设这个输出的序列不会超过每个定值，比如说300个字符，那么我们就输入一个300个START组成的序列，然后在输出的字符序列中，忽略END字符后面的字符即可。</p>
<p>​
相比AT来说，NAT有着并行化，更稳定的优势，但是NAT的效果往往比AT要差一些。</p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115113351438.png"
alt="image-20220115113351438" />
<figcaption aria-hidden="true">image-20220115113351438</figcaption>
</figure>
<h3 id="三如何训练transformer">三、如何训练Transformer</h3>
<p>​
首先，当我们丢入第一个START字符的时候，希望Decoder输出的Distribution分布，和我们的Ground
Truth的结果，能够越接近越好，也就是要最小化cross entropy的值。</p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115113410387.png"
alt="image-20220115113410387" />
<figcaption aria-hidden="true">image-20220115113410387</figcaption>
</figure>
<p>​
由于我们会输出好多次字符，所以我们最终是希望，能够最小化每次输出的Distribution和Ground
Truth的cross
entropy。不要忘记，最后一步输出段落的结尾符号，也要考虑在内。【此处有一个题外话，在实现的时候，其实有些时候可以将START的标识符和END标识符表示为同一个One-Hot编码，因为反正START标识符只会出现在句子的头部，仍然是可以分辨的，不需要区分START和END这两个字符】</p>
<p>​
同时，此处我们在训练的时候，Decoder的Input不是上一步输出的内容，而是给它正确的答案。这件事情就被我们叫做Teacher
Focing。但是这样子和在实际生产使用的时候存在一个不匹配的问题，这个问题我们之后会有所讨论。</p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115113420273.png"
alt="image-20220115113420273" />
<figcaption aria-hidden="true">image-20220115113420273</figcaption>
</figure>
<h3
id="四关于训练seq2seq类似模型的tips">四、关于训练Seq2Seq类似模型的Tips：</h3>
<h4 id="copy-mechanism">1、Copy Mechanism</h4>
<p>​
这一个机制在聊天机器人或文档摘要等领域应用的比较广泛，举例来说，有的时候输出的某些内容可以从输入中Copy进行完成，这样就避免机器去学习一些奇怪的词汇，比如说在聊天机器人中库洛洛这样一个人名信息。感兴趣可以继续查看相关的论文</p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115113453661.png"
alt="image-20220115113453661" />
<figcaption aria-hidden="true">image-20220115113453661</figcaption>
</figure>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115113456022.png"
alt="image-20220115113456022" />
<figcaption aria-hidden="true">image-20220115113456022</figcaption>
</figure>
<h4 id="guided-attention">2、Guided Attention</h4>
<p>​
由于有的时候机器可能会忽略输入的某一些部分，此时就可以使用该种手段，该手段通常应用于语音合成、语音辨识领域。</p>
<p>其就是要求机器在做Attention的时候以一个固定的方式，也就是说如果你对于某一个任务已经有了一些既定的发现，就可以将这种限制加入到训练的过程中，引导机器完成Attention的计算过程。</p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115113509972.png"
alt="image-20220115113509972" />
<figcaption aria-hidden="true">image-20220115113509972</figcaption>
</figure>
<h4 id="beam-search">3、Beam Search</h4>
<p>​
BeamSearch是为了解决如下的一个问题：如下图所示，举例而言，比如说我们输出的字符只有A和B两种，那么Decoder的输出序列，就可以表示为如下图所示的一颗数状结构。红色的路径是Decoder按照先前的贪婪规则得到的输出。但其实，有一条比红色路径更好的输出，就是绿色的路径。</p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115113522389.png"
alt="image-20220115113522389" />
<figcaption aria-hidden="true">image-20220115113522389</figcaption>
</figure>
<p>​
可是，我们如果想要找到一个训练过程中这样一条绿色的最优路径是比较难的，因为我们不可能去穷举搜索每一条路径，因为在字符集比较大的情况下，几层叠加的可能就已经非常之多。这个时候就可以使用Beam
Search这样一种技术。具体如何进行可以Google搜索详情</p>
<h4 id="optimizing-evaluation-metric">4、Optimizing Evaluation
Metric</h4>
<p>​
我们在训练的时候，目标是最小化每个一一对应的中文字的输出的分布和Ground
Truth，而在评估一个模型好坏的时候，我们往往会使用输出的整句和GroundTruth之间的BLEU
score来进行评估，所以我们的验证集应当使用BLEU
score。那么我们的训练过程中为什么不使用BLEU
score呢？简单来说就是如果在训练过程中我们要做两个句子之间的BLEU
score，是根本没有办法做微分的也就没有办法做梯度下降去最优化求解。</p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115113543303.png"
alt="image-20220115113543303" />
<figcaption aria-hidden="true">image-20220115113543303</figcaption>
</figure>
<h4 id="scheduled-sampling">5、Scheduled Sampling</h4>
<p>​
这个方法是为了解决我们先前提出的两个问题中的第一个问题，以及在那之后提出的一个训练与实际应用过程中的那个Mismatch(也就是训练的时候Decoder的输入使用的是Ground
Truth,可是输出的时候不行)。简单直接的想法，就是训练的时候，我们往输入中加入一些噪声，就可以了。具体而言的话，也有许多论文是做这个方向的，如果有兴趣的话可以自行查阅。</p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115113600427.png"
alt="image-20220115113600427" />
<figcaption aria-hidden="true">image-20220115113600427</figcaption>
</figure>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Transformer系列笔记</category>
      </categories>
      <tags>
        <tag>Transformer</tag>
        <tag>Self Attention</tag>
        <tag>Seq2Seq</tag>
      </tags>
  </entry>
  <entry>
    <title>Transformer系列笔记1——Self Attention机制</title>
    <url>/2021/12/06/59e48d4d462f/</url>
    <content><![CDATA[<h3 id="一背景介绍问题引入">一、背景介绍问题引入</h3>
<p>​
在先前的网络架构中，我们一般输入的都是一个向量，但是有的时候我们需要考虑更为复杂的输入，如下图所示，比如说一个向量的集合，并且向量集合的长度还会发生变化。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115111555364.png" /></p>
<p>​
一般按来说对于输入是向量集合的话，我们先要对其进行编码处理，一种编码方案为One-hot
Encoding,称为独热向量编码，另一种编码方案为Word
Embedding方法，称为词嵌入方式。</p>
<p>为了更好的理解，输入为一个向量的集合，下面有一些相关的例子：</p>
<p>​
<strong>示例1：</strong>比如说，输入是一段语音，我们可以将一段1s中的语音视为一个向量的集合输入，每25ms视为一个window窗口，称为1帧，将里面的信息提取出来以后，就成为一个向量。我们将这个窗口每次向后移动10ms，每移动10ms就重新取一次样，也就是多输出一个向量。这样预处理的话，其实就是一段1s的语音我们可以把它视作为100个向量的一个集合输入。
（在上述处理的过程中，至于为什么25ms视为一个window，每次要向后移动10ms，这些都需要视具体的语音任务而定，有兴趣可以进一步看语音处理方面相关的文章）</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115111649129.png" /></p>
<p>​
<strong>示例2</strong>：比如说一个图，也可以被视作一个向量的集合，每个节点都被当作一个向量，这个向量中编码了关于这个节点所有的相关信息。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115112432503.png" /></p>
<p>​
那么对于这样复杂的输入而言，输出可能是什么呢？如下图所示，有三种可能，第一个是对于每个输入的向量，都输出一个label结果，比如说POS
tagging任务。第二个是整体就输出一个label结果，比如说Sentiment
analysis任务。又或者是第三个所示的seq2seq的任务，比如说语句翻译，或者是语音识别的任务。此篇文章聚焦于第一种情况探讨Self-Attention机制与整体的架构。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115112440152.png" /></p>
<h3
id="二self-attention解决方案引入">二、Self-Attention解决方案引入：</h3>
<p>​
为了解决上面我们说的对于每个输入的vector都输出一个label结果的事情，最简单也最为直观的方法就是如下图所示，假设输入的向量集合长度为4，那么我们将每个输入的向量单独考虑，然后进行结果的输出。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115112458834.png" /></p>
<p>​
但是这样一来，我们相当于没有考虑向量与向量之间的关系，那么这种架构下我们可能考虑上下文吗？答案是可以的，如下图所示：我们可以将前后的向量也输入到当前的全连接层中，这就考虑到了上下文信息。但是这样一来问题又发生了，如果我们想要考虑整个序列的上下文呢？那么这个窗口的长度到底应该选多少呢？要知道我们输入的向量的个数是会变化的。同时，如果将每个向量都要连接到每个FC中的话，需要训练的参数就会大大增加，随之而来的就是非常容易过拟合。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115112507468.png" /></p>
<p>​
在这样一个问题背景下，Self-Attention机制应运而生。如下面两张图片所示，我们可以理解为，每一个单独的向量经过Self-Attention机制计算后，得到一个新的向量，这个新的向量中是含有所有的上下文信息的。同时Self-Attention也可以做好多层，也就是说我们可以像第二张图一样，先走一次Self-Attention然后过FC层，然后再走一次Self-Attention层，然后再过全连接层，然后输出。使得Self-Attention发扬光大的是一篇叫做《Attention
is All you
Need》的论文，那么Self-Attention内部，到底是如何考虑进上下文之间的关系的呢？</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115112528529.png" /></p>
<h3 id="三self-attention架构介绍">三、Self-Attention架构介绍</h3>
<p>​
我们首先从结果来看Self-Attention做了一件什么事情，它的输入可以是原始input，也可以是隐藏层。然后经过该结构后，就可以将向量a1变成一个带着上下文信息的向量b1。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115112544934.png" /></p>
<p>​
首先，我们以生成向量b1为例，记录整一个过程。如下图所示，首先我们需要考虑a1和另外三个向量的相关性，然后用一个变量α去进行衡量。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115112553361.png" /></p>
<p>​
那么如何计算得到这个α的值呢，我们就需要一个如下所示的模块，这个模块输入两个向量，一个向量乘以矩阵Wq得到向量q，一个乘以矩阵Wk得到向量k，然后我们再把q和k做点积，就得到了α，这个α就代表输入的两个向量之间的相关性。至于Wq和Wk内部是什么我们先不用管，因为其内部的参数是我们需要用训练集训练网络得到的。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115112601252.png" /></p>
<p>​
所以，我们就能够依据上述这个框架计算出a1分别和a1,a2,a3,a4的相关性α(1,1),α(1,2),α(1,3),α(1,4)，我们将之称为Attention
Score。具体写成公式的形式就是下图下面的半部分。然后的话呢我们需要将之通过Soft-max函数，做一个归约化，使得他们的和为1，得到α’(1,1),α’(1,2),α’(1,3),α’(1,4)。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115112614866.png" /></p>
<p>​
有了α’(1,1),α’(1,2),α’(1,3),α’(1,4)之后，我们先将a1,a2,a3,a4乘上矩阵Wv得到v1,v2,v3,v4，然后用对应的α’和v做叉积，从v中提取信息，最终将所有对应的叉积相加，就得到了最终的结果b1。形式化的公式写在下图的右上方。然后b2,b3,b4也是同样的过程去进行计算。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115112623695.png" /></p>
<p>​
按照我们介绍的顺序b1,b2,b3,b4我们需要一一算出，其实这一计算过程是可以通过矩阵乘法并行执行的。首先，我们将a1,a2,a3,a4拼接组合成一个大的矩阵，称为I。将I分别乘上矩阵Wq，Wk，Wv之后，就会得到大的矩阵Q,K,V。从结果上而言，大的矩阵Q,K,V就是先前一个个向量计算时候得到的结果向量q1,q2,q3,q4拼接组合而成。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115112631291.png" /></p>
<p>​
我们现在拥有Q,K,V三个矩阵，我们可以用矩阵K的转置乘上矩阵Q就会得到一个α的矩阵，其从结果上而言等价于一个个α计算得到的结果组成的矩阵。具体的推导过程见下图，还是比较好理解的，只是把一些重复的矩阵运算进行了合并而已。得到对应的矩阵A以后，我们对每一列做SoftMax归一化操作，得到矩阵A’。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115112638932.png" /></p>
<p>​
最后我们将矩阵A’和矩阵V相乘，就能生成结果矩阵O。O就是b1,b2,b3,b4向量的拼接。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115112647706.png" /></p>
<p>​
最后，我们可以将整个过程表示如下图：Wq,Wk,Wv三个矩阵内部的参数就是我们需要训练的参数，A’就是我们常说的Attention
Matrix.</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115112657080.png" /></p>
<h3
id="四self-attention架构扩展改进">四、Self-Attention架构扩展改进</h3>
<h4 id="multi-head-self-attention-多头注意力机制">1、Multi-head
Self-Attention 多头注意力机制</h4>
<p>​
在上述的计算过程中，我们就是用qi去找相关的ki，但是相关可能会存在很多种，所以我们应该需要有不同的q，然后不同的q去负责不同的相关性，于是乎出现了Multi-head
Self-Attention架构。如下所示，相比于Self-Attention，其只是将计算得到的qi和ki进行拆分。我们先从a乘上矩阵Wq变成q，然后再将q乘上两个不同的矩阵W(q,1)，W(q,2)，分别变成两个不同的向量q1和q2。k和v也是同样的进行操作。然后的话用q1,k1,v1去按照之前的方法计算出一个b1出来，再用q2,k2,v2去计算出一个b2出来</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115112728011.png" /></p>
<p>最后再将b1和b2组合起来，乘上一个权重矩阵，得到最终的结果向量b.</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115112737330.png" /></p>
<h4 id="positional-encoding">2、Positional Encoding</h4>
<p>​
我们会发现，在先前的Self-Attention架构中，其并没有考虑输入向量组之间向量的远近对于其相关性的影响。就比如a1如果和a2换了位置，也不会影响a1和a4的相关性度量。所以我们会想要有如下的想法：对于输入向量集合中的每个向量来说，都先加上一个不同的向量e，然后再去进行先前的操作。这个e可以是人工指定的，也可以是机器学到的规律。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115112754051.png" /></p>
<p>​
关于e究竟需要是怎么样的东西效果才会好，有许许多多的文章研究。此处只是讲解一个基本的做法，具体感兴趣可以查看下面的论文。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115112802708.png" /></p>
<h3 id="五self-attention应用">五、Self-Attention应用</h3>
<p>​
Self-Attention机制应用广泛，最多的就是应用在Transformer架构和BERT架构中，广泛的用于NLP领域。但除了NLP领域，其实其在很多领域也适用。</p>
<p>​
比如说下图所示的语音处理领域，我们最开始就说过如何将一段语音看作是一个向量集合作为输入，然后就可以采用Self-Attention的机制，进行相关的任务。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115112819190.png" /></p>
<p>​
或者在图像处理的领域，我们可以将一张RGB图的每一个像素点的RGB三个值，视为一个向量输入，然后一张Image就可以被视为一个ImageWidth*ImageHeight长度的向量的集合。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115112827842.png" /></p>
<p>​
以下两篇是使用了Self-Attention架构的有关与图像生成和图像检测的论文，后续可能会出相关的论文阅读笔记。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115112836400.png" /></p>
<p>​
那么Self-Attention和CNN到底有啥区别呢？其实按照我们上面对图像的理解，CNN可以看作是一个只有一小部分感知域的Self-Attention。因为CNN的其中一个特征，就是它有独特的感知域，只感知某像素周围一部分和该像素的关联，而Self-Attetion则是会考虑整个序列，也就是该像素和所有像素之间的关联。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115112848232.png" /></p>
<p>​ 有人做过研究，在《On the Relationship between Self-Attention and
Convolutional
Layers》这篇论文中，以严格的数学证明了CNN是Self-Attention的子集。也就是说在一定条件下，Self-Attention可以和CNN实现完全相同的效果。</p>
<p>​ 同时，在《An Image is Worth 16x16 Words: Transformers for Image
Recognition at
Scale》这篇文章中，作者也比较了两者的差别。训练数据越多，Self-Attention最后拟合的效果越好，而CNN在训练数据较少时，效果较好。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115112858420.png" /></p>
<p>​
此处还有一些Self-Attention用于RNN和Graph领域的内容，由于与我所学习的领域相关性不大，所以就暂且忽略了，感兴趣可以去李宏毅老师的Attention的课程最后找到对应的论文内容。</p>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Transformer系列笔记</category>
      </categories>
      <tags>
        <tag>Transformer</tag>
        <tag>Self Attention</tag>
      </tags>
  </entry>
  <entry>
    <title>GAN系列笔记6——评估GAN的相关方法指标</title>
    <url>/2021/12/05/59cf77767a4c/</url>
    <content><![CDATA[<h3 id="前言">前言：</h3>
<p>​
本篇笔记为观看李宏毅老师的GAN相关课程后所记录，文中所有图片及内容均来源于李宏毅老师的课程，此处只是搬运+以自己的理解进行记录。全文讲述了如何对GAN生成的图像结果进行一个更为客观的评估的相关方法。</p>
<h3 id="一传统方法如何评估结果好坏">一、传统方法如何评估结果好坏？</h3>
<p>​
在传统方法中，我们一般会采用计算<strong>Likelihood</strong>的方法来进行衡量。我们训练出了一个Generator，然后我们就会用生成器的生成分布概率去进行计算其生成真实数据的可能性。具体的执行步骤就是，先采样部分真实数据点，然后计算G想要生成每个真实图像数据点的概率，然后求和平均即可得到Likelihood。但是在GAN中，这种方法是行不通的，因为GAN训练好以后是一个网络，是没法算出其产生出某一张图像的概率的。（像传统，如果这个Generator是一个高斯生成模型，是可以进行计算的）</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105752191.png" /></p>
<h3 id="二kernel-density-estimation">二、Kernel Density Estimation</h3>
<p>​
有一种解决方案如下：输入一堆数据Data，经过生成器后，会产生对应的一堆高维向量（其实就是图像），我们将每一个高维向量视为一个高斯分布的均值，这样一来每一个sample就被近似为了一个高斯分布。然后我们再将这些高斯分布进行融合，就能够得到一个高斯混合模型。这一高斯混合模型是可以计算形成某个图像的概率的。但是使用这次步骤做出来的也会有许多难点和问题，比如不知道需要用多少高斯分布去拟合，不知道需要采样多少点。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105815158.png" /></p>
<p>​
同时，退一万步讲，其实使用Likelihood来进行估计就不是一个很严谨的事情，Likelihood低，对应的图像质量也可能高。Likelihood高，对应的图像质量也可能低。如下图所示，就是两种可能的情况。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105822595.png" /></p>
<h3 id="三常用评估方法">三、常用评估方法：</h3>
<p>​
现在的文献，大部分常常看到的用于评估GAN的方法是，使用一个已经训练好的Classifier（可以是一个VGG，也可以是Inception
Net），来判断这个生成器生成的图像质量好坏。</p>
<p>我们往往有以下两个评估原则，如下图所示：</p>
<p>​ <strong>原则1</strong>:将一个generated
image输入分类器，查看分类器输出的属于各个类的概率，如果概率比较集中，说明生成器生成的图片效果比较好，因为分类器可以很明确的分出来。</p>
<p>​ <strong>原则2</strong>:将一系列generated
image输入分类器，查看分类器输出的各个类各存在几张图像，如果分完类以后每个类别的实例差不多的话，说明生成器效果较好，如果数量偏向于某种类别，说明生成器会生成偏向于某一个类别的图像。所以我们希望分出来的分布能够尽量的平滑。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105839124.png" /></p>
<p>​ 有了上述原则以后，我们就可以使用下图所示的Inception
Score来进行指标的量化。其中的第一项代表原则1，第二项代表原则2.</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105847271.png" /></p>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>GAN系列笔记</category>
      </categories>
      <tags>
        <tag>GAN</tag>
        <tag>GAN Evaluation</tag>
      </tags>
  </entry>
  <entry>
    <title>GAN系列笔记5——GAN应用于特征提取（InfoGAN，VAEGAN，BiGAN）</title>
    <url>/2021/12/04/554e29d255b4/</url>
    <content><![CDATA[<h3 id="前言">前言：</h3>
<p>​
本篇笔记为观看李宏毅老师的GAN相关课程后所记录，文中所有图片及内容均来源于李宏毅老师的课程，此处只是搬运+以自己的理解进行记录。全文讲述了InfoGAN、VAEGAN、BiGAN，以及GAN在特征提取领域相关的应用。</p>
<h3 id="一infogan">一、InfoGAN</h3>
<p>​
我们在先前的GAN的介绍中说到过，对于一个训练好的GAN，我们是希望输入一个向量，然后GAN会给我们生成一个Object（图像或者是序列等）。然后我们期望，我们输入的向量，每一个维度可能就会代表输出的图像的某一个特征。这其实是非常理想的情况，但实际上，可能当你改变输入向量某一个维度的值的时候，输出的内容并没有按照某个特征进行变化。如果用图示意的话，如下图所示：两幅图是在低维空间中高维特征的分布示意图，我们本身期望其应该是左图的分布，这样当某个纵轴不变，横轴的数值变化时，高维某个相对应特征也会随之变化，但实际上分布可能像右图一样。InfoGAN就是想要解决这样一个问题。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105527683.png" /></p>
<p>​ InfoGAN的框架如下图所示：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105540261.png" /></p>
<p>​
首先会将输入向量z，拆成两部分，一部分是向量c，一部分是向量z’，然后输入G后产生图像x，同时，我们需要训练一个分类器，这个分类器要能从x中识别出，产生这个x所使用的向量c的部分的编码，原本需要训练的判别器也是需要训练的缺一不可。然后我们宏观的看一下这一个架构，Generator和Classifier这一套就像是一个类AutoEncoder的东西，只不过其和正常的AutoEncoder刚好相反。正常的AutoEncoder的编码器是输入图片，输出特征编码向量，然后解码器是再反解回图片。而此处的编码器部分是GAN的Generator部分，输入向量，生成图片，然后decoder部分需要从图片中识别出code。在这个架构中，Discriminator是必须的，不然的话训练Generator的结果很有可能就是会把向量c直接附在图片x的信息中间，这样的话Classifier必定能够反解出c，但是这样的话生成的x是不是一张真实的图片就尚未可知了。有了Discriminator就可以保证生成的x是真实。</p>
<p>​
同时，Discriminator和Classifier在实际训练时往往共享参数，因为它们的输入都是x，只是最后一层输出层不一样而已。</p>
<p>​
那么，加上这样一个Classifier以后，为什么先前的原先GAN的输入对输出的影响不明确这个问题就能解决了呢？如下图所示：</p>
<p>​
因为我们需要分类器能从x中恢复出编码c，所以向量c这一部分必定需要对x的图像的某些维度有明确的影响。也就是说，完成GAN训练以后，c部分的每一个维度，都会对x的图像的某一个特征有明确的影响对应，那么z'部分相对应的可能就是那些较为随机的维度。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105550729.png" /></p>
<p>​
在这里可能会存在一个疑问，我们怎么划分向量z到c和z’呢？哪些维度应该被划分为c？哪些应该被划分为z’？此处要注意：我们并不是先对z进行手动划分的，是在训练完成之后，那部分能被恢复的向量编码维度，才会被称为c。</p>
<h3 id="二vae-gan">二、VAE GAN</h3>
<p>​ VAE GAN可以看作用GAN强化VAE
AutoEncoder。网络架构如下图所示：这样的网络架构完成了两件事，一个是原本的希望重构损失越小越好，另一个是Discriminator会保证Generator生成的图片越真实越好。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105607065.png" /></p>
<p>​
从VAE角度，因为我们如果只考虑VAE的重建损失，往往产生的图片是不真实的，是会很模糊的。新增了Discriminator可以让输出图像更加真实。</p>
<p>​
从GAN角度，其不只考虑判别器的反馈，因为其知道真实图片长什么样，需要最小化生成图像和原图的误差，所以VAE
GAN训练起来会更加稳定。</p>
<p>​ 如下所示是VAE
GAN训练的算法：整体的算法如下所示，在每一轮迭代中，首先是图像的生成：有三类x需要生成：1、第一类x是从数据库中直接采样出来的图片。2、第二类是由数据库中采样出的图片经过Encoder再经过Decoder后重建的图片3、第三类图片是，由随机的概率分布生成的编码z通过Encoder以后产生的图像。（注意图中第10行公式En应为De，图片有误）</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105620194.png" /></p>
<p>​
然后我们先更新训练EN的参数，希望重建误差越小越好，同时也希望x经过Encoder产生出来的z跟P(z)产生出来的z越接近越好，也就是两者KL散度越小越好。</p>
<p>​
然后更新训练De的参数，希望重建误差越小越好，同时也希望将第2类和第3类图片，丢入判别器以后，得到的值越大越好。</p>
<p>​
最后更新训练Discriminator的参数，希望第1类图像进入判别器以后值越大越好，同时也希望将第2类和第3类图片，丢入判别器以后，得到的值越小越好。</p>
<h3 id="三bigan">三、BiGAN</h3>
<p>​
BiGAN的架构如下所示：它修改了传统AutoEncoder的部分，然后新增了判别器。在这个网络中有一个Encoder，输入一张图片x，输出code
z。有一个Decoder，输入一个code z，输出一张图片。但是这个输入的code
z并不是先前Encoder输出的z，而是从一个事先准备好的分布中取样得到的z。然后我们有一个判别器，输入
向量z和 图像x，要让判别器判断，这一对
（向量z，图像x）是来自于编码器的输入输出，还是来自于解码器的输入输出。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105637394.png" /></p>
<p>​
训练算法如下所示，整体而言描述和其他的描述语言比较一致，比较好理解，此处就不多赘述，</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105645100.png" /></p>
<p>​
那么为什么BiGAN能够这样子去进行训练呢？其实BiGAN就是干了一件这样的事情：如果我们把Encoder的输入输出看作是一个Join起来的分布，Decoder的输入输出看作是一个Join起来的分布，那么判别器所干的事情就是区分P和Q之间的分布的差距。想要尽可能的去优化Encoder和Decoder，使得P和Q逐渐变得接近。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105653272.png" /></p>
<p>​
如果这个模型训练到最优，就应当是Encoder和Decoder可以互相解。那其实你会发现就是做了如下这么一件事情：训练一个AutoEncoder和一个Inverse的AutoEncoder。确实没错，如果如下所示的这样一个网络训练到最优，其和使用BiGAN训练到最优的结果是一样的，但是实际上BiGAN和AutoEncoder都没法训练到最优。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105700505.png" /></p>
<p>​
所以在不是收敛到最优的情况下，BiGAN会比下面这个架构训练好很多。生成的图片会真实很多，会比AutoEncoder架构生成的图像清晰很多。两者的特性不太一样。举个例子，比如可能用BiGAN，你输入一个鸟的图片，经过Encoder，Decoder后生成的图像也会是一只清晰的真实的鸟，但可能跟输入的鸟不一样，而如果用AutoEncoder架构，输入一个鸟的图片，经过Encoder，Decoder后生成的图像会和原图像比较像，但是会比较模糊，是一个不是很清晰真实的图像。</p>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>GAN系列笔记</category>
      </categories>
      <tags>
        <tag>GAN</tag>
        <tag>InfoGAN</tag>
        <tag>VAEGAN</tag>
        <tag>BiGAN</tag>
      </tags>
  </entry>
  <entry>
    <title>GAN系列笔记4——GAN训练过程中的一些Tips与改进的GAN网络（含LSGAN、WGAN、EBGAN）</title>
    <url>/2021/12/03/ce02100bd0a0/</url>
    <content><![CDATA[<h3 id="一tips1-有关如何更有效的训练判别器">一、Tips1
有关如何更有效的训练判别器</h3>
<p>​
在第三份笔记中，我们讲到其实在训练GAN的过程中，我们就是在计算最小化JS
divergence的这样一个过程。但是其实JS
divergence其实存在一个非常严重的问题，根源在于generation
data的分布和real
data的分布往往是没有任何重叠的，这个没有任何重叠的问题是由以下两个因素导致的：</p>
<p>1、data本质导致。Data本身，我们认为是一个图像是一个高维空间中的一个点，<span
class="math inline">\(P_G\)</span>和<span
class="math inline">\(P_{data}\)</span>在这个高维空间中都是属于low-dim
manifold。所以基本是不存在重叠的部分的。</p>
<p>2、实际操作的时候，我们是先进行的采样，然后再用discriminator去量他们之间的divergence，而且采样的样例也不会太多。所以离散的采样也会导致，两堆采样的点基本上是不可能重叠的，应该是没有交集的。</p>
<p>​ 那么，为什么当<span class="math inline">\(P_G\)</span>和<span
class="math inline">\(P_{data}\)</span>没有重合部分的时候，用JS
divergence衡量会出问题呢？精确一点来说，应该是会对你训练时候，造成比较大的障碍。首先我们你需要知道一个事实，有关JS
divergence，就是如果两个分布没有任何重合，那么计算出来的JS
divergence值就是log2，无论其相距多远。如下图所示，更直观一些：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115104959639.png" /></p>
<p>​
对于这三组数据而言，因为算出来的目标函数都是一样的，所以判别器会认为G0跟G1是一样差的，也就没法把G0更新到G1.这样子的话就会给判别器的训练带来一定的困难</p>
<p>​ 这个问题，其实以一个直观的方法来讲就如下图所示：假设蓝点是generated
data，绿色是real
data，两组点没有交集，我们现在训练一个判别器（其实就是一个binary
classifier）,如果这个判别器训练的太好的话呢，就会导致如下图所示的红色实线的情况，蓝色点上方的区域导数都是零，这就会使的Generator在梯度下降的时候，没法继续下去，generated
data也就没法像real
data靠近。如果这个判别器训练的不行的话，又很容易导致分辨不出两组data。所以，在原始GAN早期，训练是比较不容易的一件事情。因为你没有办法去分辨，到底什么是训练的太好，什么是训练的不行。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105009691.png" /></p>
<h3 id="二least-square-gan-lsgan">二、Least Square GAN ( LSGAN )</h3>
<p>​
承接上一段落的内容，为了使得上述描述的梯度为0，最后导致蓝色点不会像绿色点靠近情况出现，所以就出现了LSGAN。它就是将之前Discriminator所作的classifier分类问题，改变成了regression回归问题。从操作上来讲，就是将输出的sigmoid激活函数，变成了linear函数。这样的话，就会使得我们的判别器的得分曲线如下图所示：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105022595.png" /></p>
<h3 id="三wasserstein-gan-wgan">三、Wasserstein GAN ( WGAN )</h3>
<p>​ 相比于原始的GAN，就是把原来用来衡量的JS divergence换成了Earth
Mover’s Distance.</p>
<p>​ 首先我们来介绍一下Earth Mover’s
Distance是什么东西，如下所示：下图是一个最简单的示例，我们有两个概率分布P和Q，然后你要想办法把概率分布P移到Q的地方去。如果P和Q如下图所示，都是一个一维空间上的分布，那非常简单，Earth
Mover’s Distance就是它们之间的距离d。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105043352.png" /></p>
<p>​
然后让我们再来考虑一个更为复杂的情形：现在P和Q的概率分布如图所示，那么你会发现我要想把P变成Q，我会有许多种挪动的方式。左边是一种挪动方式，右边是一种挪动方式，每一种挪动方式都会算出一个不同的距离，每一种挪动方式，我们就称之为一种“moving
plan”。那么，我们会使用所有的moving
plan中计算出最小的那个距离，来将其定义为Earth Mover’s
Distance。（通俗一点就是，所有方案算一遍，要最小的那个方案）</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105052710.png" /></p>
<p>​
比如说，同一堆东西我们用同样的颜色来表示，下图所示的P到Q的挪动方式，就是该示例最佳的一个moving
plan。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105101411.png" /></p>
<p>​ 下面这张图是一个更为官方与公式化的定义，我们可以把一个moving
plan表示成像左图一样的一个矩阵，对应的交叉的区域就表示该块挪动的量。那么你会发现，左边矩阵中每一行值相加应该都会等于其对应的P的那一条区域的值，每一列值相加起来都会等于其对应的Q的那一条区域的值。所以，给定这样一个moving
plan，应该怎么去计算这个方案对应的移动距离呢？就用到下图中B(γ)的公式，遍历所有的xp和xq，其实就是遍历矩阵的每一个值，然后做乘积、求和。</p>
<p>​ 最终，如果我们想要求解P和Q的Earth Mover’s
Distance，那么就需要穷举所有的moving
plan，然后找到所有B(γ)最小的那一个值,就是P和Q的Earth Mover’s
Distance.所以你会发现求解这样一个距离还需要解一个最优化问题.</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105115495.png" /></p>
<p>​ OK,到此为止,我们已经知道了Earth Mover’s
Distance是怎么样一个东西,那么就先来讨论一下,为什么我们用这个距离来进行衡量?有什么样的好处?
如下图所示,原来的JS Divergence计算出来的,对于G0,
G50来说,两个差距一致,生成器就没法从G0 Update到G50,但是如果我们使用W
Distance,d50是会比d0好的,那也就是说对于Generator来说,会慢慢的从G0 Update
到G50,也就是之前导致训练不起来的因素会被规避掉.</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105125389.png" /></p>
<p>​ 那么在训练过程中,WGAN到底应该如何使用Earth Mover’s Distance呢?
我们将原来的V(G,D)函数替换成如下公式即可:</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105135075.png" /></p>
<p>​
这个公式其实比较好理解,推导过程非常复杂我们再次略过.就是我们需要让从real
data中产生出来的值越大越好,generate
中产生的值越小越好.同时,会有一个额外的constrain,就是D这个函数必须是一个
1-Lipschitz函数,我们暂时先不管这个
名词是什么,只需要先知道,这个代表的就是说D需要是一个非常平滑的函数.从直观的角度,为什么需要增加这个限制呢?如下图所示,如果不增加这个限制,就会像下图所示的红色曲线一样,Discriminator永远都不会收敛,两边分化会越来越大.generated
data部分会变成无穷小,real data 就会变得无穷大.</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105142990.png" /></p>
<p>​ 那么实际上1-Lipschitz函数是什么呢?定义如下:
右边蓝色函数就不是,而绿色函数就是.</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105150180.png" /></p>
<p>​ 那我们应该怎么去进行训练呢? 原始的方法就是使用Weight Clipping
方法,但是其实这个方法并没有完全能够限制住D是一个1-Lipschitz函数,但可以相对来说让你的D变得平滑一些.</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105158514.png" /></p>
<p>​ 所以后面就出现了 Improved WGAN ( WGAN-GP )来解决这个问题:
它的作者提出了这样一个观察:
就是说D是一个1-Lipschitz函数是和右侧的不等式等价的，也就是说要对于所有网络可能的输入x来说，如果将它给判别起求它的梯度的Norm范式是小于等于1的话，就可以。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105204998.png" /></p>
<p>​ 那么我们现在的方法，就是在整个的式子后面近似补上一项，</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105211649.png" /></p>
<p>​
在我们的目标函数中加上这样一项以后，在网络训练的过程中，网络就会希望尽可能的满足下面这个式子，但是问题又来了，我们没办法对所有的x做积分，但是如果想要D是一个1-Lipschitz函数，是需要对所有的x来说的。所以我们又进行了部分的近似：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105219880.png" /></p>
<p>​
如下所示，将最后补充的那一项变更成如下的一项，意思是我们只从一个叫做<span
class="math inline">\(P_{penalty}\)</span>的分布中进行取样，我们只保证从这个分布中取出来的x能够满足，其他的就先不保证了。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105229709.png" /></p>
<p>​ 那么<span
class="math inline">\(P_{penalty}\)</span>长什么样子呢？如下图所示，我们从<span
class="math inline">\(P_{data}\)</span>中取一个点，从<span
class="math inline">\(P_{G}\)</span>中随机取一个点，然后在两点的直线上随机采样一个点。这样子采出得到的点所形成的一个分布我们就认为是<span
class="math inline">\(P_{penalty}\)</span>。如图所示，其实就是大概是图中蓝色部分区域。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105307969.png" /></p>
<p>​ 那为什么我们不用考虑整个Image Space空间中的x，只需要考虑<span
class="math inline">\(P_{penalty}\)</span>分布上的x了呢？原因其实只是通过实验做出来，这样子效果是好的。其实从直观的角度上也可以有理解，因为我们之前说过其实训练过程就是<span
class="math inline">\(P_{G}\)</span>向<span
class="math inline">\(P_{data}\)</span>慢慢靠近的这么一个过程，那么也就是说其实只有<span
class="math inline">\(P_{penalty}\)</span>这块部分区域的点的梯度才会影响。</p>
<p>​
同时，我们还要再做一个改进。我们刚才目标函数补充的那一项，将其进一步修改。我们希望训练过程中，梯度越接近1越好。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105332353.png" /></p>
<p>​
其实在刚才的WGAN-GP的过程中，做了很多的近似，很多结果也是由实验得出的，那么Spectrum
Norm提出了一种方法，真的可以限制判别器学习完以后，在每一个位置的Gradient
Norm都是可以小于1的。</p>
<p>​
在最后，我们回到WGAN的算法，看看在实际的过程中，怎么从GAN变成WGAN：整体而言就是修改下图中黑框框的四个部分，1个是在LearningD的过程中，将目标函数部分的sigmoid输出移除掉，同时要记得使用weight
cliipping 获得gradient penalty来进行限制。再就是在Learning
G的过程中，将目标函数进行部分的修改，就可以了。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105348387.png" /></p>
<h3 id="四energy-based-gan-ebgan">四、Energy-Based GAN ( EBGAN )</h3>
<p>​
其与原始GAN唯一的不同在于其修改了DIscriminator的架构，Discriminator原本来说是一个Binary
Classifier，但是在EBGAN中，将其变成了一个Auto
Encoder自动编码器，Generator是跟原来一样的。架构如下图所示：</p>
<p>​
整一个Discriminator仍旧会输出一个Scalar分数，但现在这个分数是从何而来的呢？他是基于Auto
Encoder的重建误差得到的。之所以这样做，EBGAN是基于以下一个假设的：越真实的Image它经过AutoEncoder以后，重建误差越小，越虚假的Image重建误差越大。那么EBGAN的好处在于这个Discriminator是可以预训练的，因为AutoEncoder的训练并不需要用到negative的样例。只需要给positive的样例，然后最小化重建误差就可以了。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105401559.png" /></p>
<p>​ 相比于原来的GAN来说，因为Origin
GAN它不能预训练Discriminator，所以一开始DIscriminator就会很弱，训练起来就会很慢。而EBGAN的Discriminator一开始就相对比较强。</p>
<p>​ 在训练EBGAN的时候，需要注意以下一点：以下图为示例，我们会想要让real
data最后得到的值比较大，generate
data得到的值比较小，但是我们不能让generate
data得到的值无限小，不加限制。因为这样的话就会让Discriminator对于generate
data的输入而言，其全部输出noise，这样的话既可以把输出分数压的很低。所以我们需要一个margin，让genrate
data对应的分数，只要小于margin以下的值就可以，不需要再变得更小。而至于margin的值就是一个我们需要调整的超参数。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115105412942.png" /></p>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>GAN系列笔记</category>
      </categories>
      <tags>
        <tag>GAN</tag>
        <tag>LSGAN</tag>
        <tag>WGAN</tag>
        <tag>EBGAN</tag>
      </tags>
  </entry>
  <entry>
    <title>GAN系列笔记3——GAN的数学理论支撑</title>
    <url>/2021/12/02/147dd3a9b3ed/</url>
    <content><![CDATA[<h3 id="前言">前言：</h3>
<p>​
本篇笔记为观看李宏毅老师的GAN相关课程后所记录，文中所有图片及内容均来源于李宏毅老师的课程，此处只是搬运+以自己的理解进行记录。全文讲述了GAN的理论数学部分的支撑，将直观的GAN训练过程背后的原理，为什么能这么做，训练的时候又需要注意的点是为什么这些内容进行了讲解。</p>
<h3
id="一我们通常说的生成问题从本质上来看是什么呢">一、我们通常说的生成问题，从本质上来看是什么呢？</h3>
<p>​ 从生成一张图片x来说，图片x其实就是在图片高维空间中的一个点。比如说64
* 64的图像，其实质就是64*64维空间中的某一个点。</p>
<h3
id="二gan训练的过程到底是在干什么呢">二、GAN训练的过程到底是在干什么呢？</h3>
<p>​
在1中，我们发现其实在图像的高维空间中，存在意义的图像的点其实是很稀疏的，那么训练的时候，其实是提供了一堆有意义的图像的高维点，然后想要通过GAN来找到这些点的分布情况，也就是说，找到在图像高维空间中，有意义的图像的点所遵循的分布是怎么样的。这种分布情况，我们人是无法直接找到的。</p>
<p>​
找到这种分布情况以后，其实生成的过程就是在概率分布中较高概率的位置进行取样，得到的可能就是能够令我们满意的图像。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115104004253.png" /></p>
<h3
id="三在gan之前我们的训练所依据的理论是什么">三、在GAN之前，我们的训练所依据的理论是什么？</h3>
<p>​ 使用Maximum Likelihood Estimation
最大似然估计。整体的思想与过程如下图所示：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115104025964.png" /></p>
<p>​ 首先我们有一个数据集分布，也就是我们通常使用的训练集<span
class="math inline">\(P_{data}\)</span>。</p>
<p>​ 我们还有一个分布<span
class="math inline">\(P_G\)</span>，其是θ的函数，就是我们要训练的用于生成的概率分布。我们的目标其实就是说想要找到一个θ值让<span
class="math inline">\(P_G\)</span>去接近<span
class="math inline">\(P_{data}\)</span>就可以了。但是怎样量化计算这个概率分布的接近呢？</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115104038477.png" /></p>
<p>​ 我们可以先从<span
class="math inline">\(P_{data}\)</span>中采集m个样本，然后带入到<span
class="math inline">\(P_{G}\)</span>这个概率分布里面，希望得到的对应的概率越大越好。然后我们可以将所有的几率相乘，就会得到L。最终目标就是要找最好的θ使得能够让这个L最大。</p>
<p>​ 其实所谓的Maximum Likelihood 等同于机器学习中的 Minimize KL
Divergence.下图的话是数学公式相关的推导过程，</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115104119273.png" /></p>
<p>​ 那么现在问题来了，我们怎么去定义一个general 的<span
class="math inline">\(P_G\)</span>。如果这个<span
class="math inline">\(P_G\)</span>是符合高斯分布或者其他简单分布的话，是没有问题的。但是如果<span
class="math inline">\(P_G\)</span>要符合这些分布然后再去拟合<span
class="math inline">\(P_{data}\)</span>的话，显然就会受到很多的限制。所以我们需要一个更general的分布来去拟合<span
class="math inline">\(P_{data}\)</span>。但是如果<span
class="math inline">\(P_{G}\)</span>不受限制，是一个很复杂的很general的分布的话，上述计算式子中<span
class="math inline">\(P_{G}(X;\theta)\)</span>这一项就很难计算出来，所以我们才有了下述的想法。</p>
<h3
id="四在gan中我们所依据的理论是什么">四、在GAN中，我们所依据的理论是什么？</h3>
<p>​
GAN中的Generator是一个网络，我们假设输入的是一个符合正态分布的各种采样点，这些点通过G以后，会产生一个新的分布，这个新的分布其实就是<span
class="math inline">\(P_G(x)\)</span>。随后我们的目标也是让这个<span
class="math inline">\(P_G(x)\)</span>和<span
class="math inline">\(P_{data}(x)\)</span>这两个分布越接近越好。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115104254669.png" /></p>
<p>​ 从公式来看，就是最小化<span
class="math inline">\(P_G\)</span>和<span
class="math inline">\(P_{data}\)</span>之间的某一种差异。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115104316362.png" /></p>
<p>​ 看到这里，如果我们知道<span
class="math inline">\(P_G\)</span>和<span
class="math inline">\(P_{data}\)</span>的公式，那么我们是能够很方便的代入Divergence的公式中，然后用类似于梯度下降的方法，去最小化它。但是问题是，我们现在并不知道<span
class="math inline">\(P_G\)</span>和<span
class="math inline">\(P_{data}\)</span>的公式，也就是根本无法计算这个Div。这就是GAN神奇之处：</p>
<p>虽然我们没法知道<span class="math inline">\(P_G\)</span>和<span
class="math inline">\(P_{data}\)</span>的公式，但是我们是可以从中进行采样的。从<span
class="math inline">\(P_{data}\)</span>中进行采样无非就是从我们的训练集中取数据出来，从<span
class="math inline">\(P_G\)</span>中进行采样，无非就是从正态分布中采样然后丢到Generator中，得到的数据。如下所示</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115104340643.png" /></p>
<p>​
那么其实GAN训练Discriminator的目的，就是为了能够通过Discriminator来计算出<span
class="math inline">\(P_G\)</span>和<span
class="math inline">\(P_{data}\)</span>的Divergence。从宏观上来看，是怎么完成这样一件事情的呢？</p>
<p>​ 我们前面说过训练的Discriminator在训练过程中，就是要学会给从<span
class="math inline">\(P_{data}\)</span>的中采样出的数据高分，给从<span
class="math inline">\(P_{G}\)</span>中采样出的数据低分。所以我们当时在训练Discriminator的时候，就写了一个目标函数，V(G,D)来完成上述的目标,然后要训练D的参数，找到一组D的参数使得V(D,G)最大。神奇的事情就是，这个V其实就是J-S
Divergence有非常密切的关系。</p>
<p>​ 从直观上讲，如果<span class="math inline">\(P_{data}\)</span>和<span
class="math inline">\(P_G\)</span>采样出来的数据靠的很近，那Discriminator自然无法区分，也就是没有办法找到一个D使得V变得很大，这个时候其实意味着就是<span
class="math inline">\(P_{data}\)</span>和<span
class="math inline">\(P_G\)</span>很接近，也就是说这两个概率分布数据的Divergence其实是很小的。所以如何达到一个最大的V值，会跟这两堆数据的Divergence是肯定存在关系的。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115104420420.png" /></p>
<p>以下是详细的推导，证明为什么V会跟Divergence有关系？</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115104429437.png" /></p>
<p>​ 我们把积分里的每一项都分开来算，为每一项都找一个最好的D(x)。</p>
<p>【因为D(X)假设可以是任何函数，也就是D(x)的输出可以是任意值】</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115104440904.png" /></p>
<p>​ 将这个公式回代到V中，将原来V中的D(x) 用我们得到的结果进行替代：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115104448302.png" /></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115104454398.png" /></p>
<p>​
所以推导到此，我们就得出了一个结论，当我们train一个Discriminator的时候，我们让目标函数最大化，让目标函数最大化其实就是让<span
class="math inline">\(P_{data}\)</span>和<span
class="math inline">\(P_G\)</span>这两个概率分布sample出来的数据之间的J-S
Divergence最小。</p>
<p>​ 所以整个问题的逻辑变成了现在这样子：我们本来是要使得<span
class="math inline">\(P_G\)</span>和<span
class="math inline">\(P_{data}\)</span>的Div最小，现在的话呢，由于我们max
V(D,G)和J-S Divergence相关，所以可以用max V(D,G)这一项把原来的Div
这一项替换掉。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115104505340.png" /></p>
<p>​ 于是乎就变成了我们要解的问题就是如下图所示的一个式子：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115104513342.png" /></p>
<p>​
从直观上理解，我们可以从下面这个示例上来理解：我们假设现在只有G1，G2，G3这三个生成器可以选，D的横坐标变化我们假设就是选择了不同的Discriminator,
V(G1,D)的函数如下所示：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115104521610.png" /></p>
<p>​
我们先来以一个实例，来理解一下我们要实现的目标。首先就是当G固定的时候，要找到一个D，使得V(G,D)最大，所以按照我们的示例，可以在选择不同的G的时候，找到三个对应的点，这三个对应的点所对应的横坐标D，就是能够使得，在当前的G下，让V（G,D）最大的那个D。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115104529086.png" /></p>
<p>​
然后我们要找一个G，最小化各种不同的G的最大V(G,D)，按照上图的示例，那么我们就应该选择G3，因为在三个V(G,D)的红点中，V(G3,D)对应的值最低，所以G3才是能够使得各种不同的G的最大V(G,D)最小。</p>
<p>​
从意义的角度来看，其实如下图所示，V(G,D)中的这个最大值的函数值，其实就是用这个<span
class="math inline">\(P_G\)</span>和<span
class="math inline">\(P_{data}\)</span>之间的Divergence。这也就很好理解，在这么多的G中，我们要选择那个最小的，来最小化Divergence.</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115104536101.png" /></p>
<p>​
现在的话，就是要找到一个解决方案，怎么样去数学上或者是程序上，求解这个目标。其实这就是我们最开始讲过的迭代的训练GAN的这样一个过程。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115104548084.png" /></p>
<p>​
接下去我们进一步的解释，为什么这样一个迭代训练的过程，就是在解上面提到的一个min
max的问题。</p>
<p>​ 为了简化min,max的求解，使得更好理解，我们先不想max
V(G,D)里面的事情，我们直接设maxV(G,D) 为
L(G),因为外面那层min是跟D没关系的。</p>
<p>​
那问题就变成了如下图所示，那其实就很简单，就是用梯度下降去进行优化。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115104602866.png" /></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115104605809.png" /></p>
<p>​ 所以整体的求解最优化问题的算法应该是像下图一样：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115104613127.png" /></p>
<p>​ 其实在这个迭代的过程中，并不是非常准确的在减少JS
divergence,因为在求解的过程中，其实G是在一代一代变化的，也就是我们看到的从G0到G1到G2这样子，那么每次G变化以后呢，其实V(G,D)应该都会发生变化。我们说其完成了Decrease
js divergence这件事呢，是基于一个默认近似的，就是我们默认D0* 和 D1*
近似相等，也就是说G0和G1之间不会有太大的变化，也就是说G的每一代的更新不会太大。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115104624268.png" /></p>
<p>​
<strong>也就是因为有这样一个假设，所以你每一轮迭代训练生成器的时候，不能够update太多次，而在train判别器的时候，理论上应该训练到底，使得判别器达到最优。</strong></p>
<p>​
<strong>然后我们在实际做的时候，如下图所示，我们的目标函数其实和理论的V还有一定的区别，理论的V是期望值，但是实际上不太可能做的到这一点，所以我们其实是用离散的采样来进行代替的。</strong></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115104649400.png" /></p>
<p>​
所以最后回顾一下训练GAN的算法，对于有一些步骤其实可以理解的更为深入。比较重要的其实就是之前提过的，在每一轮迭代中，你其实可以使用梯度下降去更新很多遍的判别器的参数，但是在更新生成器参数的时候，只能更新一次，如果更新的太大了，G0
不约等于G1了，那么你在做的事情也就是不会在minimize js
divergence了，就和理论不符合了。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115104659145.png" /></p>
<p>​
最后还有一个需要提及的内容，在原论文中，其实训练Generator的参数的目标函数并不是我们上面所写的，而是会把某一项进行部分的改变如下所示。但其实两种参数都可以进行训练。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115104707603.png" /></p>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>GAN系列笔记</category>
      </categories>
      <tags>
        <tag>GAN</tag>
        <tag>Theoretical Basis</tag>
      </tags>
  </entry>
  <entry>
    <title>GAN系列笔记2——常见GAN变种（ConditionalGAN，PatchGAN，CycleGAN等）</title>
    <url>/2021/12/01/85bccde5409d/</url>
    <content><![CDATA[<h3 id="前言">前言：</h3>
<p>​
本篇笔记为观看李宏毅老师的GAN相关课程后所记录，文中所有图片及内容均来源于李宏毅老师的课程，此处只是搬运+以自己的理解进行记录。全文讲述了一些常见的GAN的变种，以及它们的一些核心的思想，包括Conditional
GAN用于Text-To-Image和Image-To-Image的任务，期间有提及一些改进诸如Patch
GAN。然后简单讲述了StackGAN的思想以及应用场景。之后，是对非监督学习条件生成领域的一些探讨，这一部分最常见的就是风格迁移的应用。讲述了两大类实现非监督学习条件生成的方法思想，第一类是直接生成，其中介绍了CycleGAN和变体StarGAN。第二类是投射至相同公共空间的方法，其中包含了解决此方法中一个关键问题的各种思想方案。看完本篇笔记，你应当会对Conditinal
GAN和Unsupervised Conditional
Generation领域及该领域下的CycleGAN思想有一个大概的了解，随后你可以选择感兴趣的GAN网络，再去详细的阅读原论文，研究细节部分。</p>
<h3 id="一conditional-gan">一、Conditional GAN</h3>
<p>​
条件GAN所要完成的目标就是你可以通过一些限制条件，来让GAN网络生成的图像符合你的要求。比较经典的就是Text-To-Image和Image-To-Image两种任务。</p>
<h4 id="text-to-image任务">1、Text-To-Image任务</h4>
<p>​
该任务目标是，你输入一段话，然后根据输入的语义来生成一张图片。这样一个任务其实我们可以用传统的监督学习方法来完成它，如下所示：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114223140981.png" /></p>
<p>​
但是使用这种传统的方法，会出现一些问题，比如说，训练网络完成以后你输入文字"train"，而在我们的训练集里面，关于"train"的图片有很多种，比如说一些正面的火车照片，或者是一些侧面的火车照片。最后会导致的结果就是，这个监督学习生成的结果又要像正面的火车，又要像侧面的火车，最后就会变成一个很多图片的平均，也就是会生成一个非常模糊的图像。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114223153376.png" /></p>
<p>​ 所以我们需要用到Conditional
GAN的技术。在前一篇文章中讲过，GAN本身最后实现的一个效果是，输入一个随机的分布向量，或者说Noise，然后其会生成一个对象（图片或其他）。那么在Conditional
GAN中呢，从最终实现的效果而言，其实就是多吃了一个内容c，这个内容c也就是我们所指定的条件。在Text-To-Image的任务中，内容c也就是我们所指定的文本信息。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114223205025.png" /></p>
<p>​
那么Discriminator方面，跟普通的GAN又需要有啥区别呢？如下图所示，对于判别器而言，其输入也需要新增一个内容，也就是我们指定的条件c。</p>
<p>​
我们为什么需要这么干呢？如果判别器仍然和原来一样，那么其实你会发现，因为判别器只会看生成的图片x是否够真实，而不会看x和内容c匹不匹配。也就是说，如果你输入”cat“作为内容c，但是生成器画了一个很好很真实的火车图片，判别器仍然会给高分。这样到最后的结果其实就是，你会发现你指定的条件c和生成出来的图片完全不匹配，虽然这些生成的图片都很真实。</p>
<p>​ Ok，所以我们回到Conditional
GAN判别器的架构，最后输出的值里面，其实含有两部分信息的含义。一个是图像x是不是够真实，一个是内容条件c和图像x是否匹配。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114223223659.png" /></p>
<p>​
所以在这种判定条件下，什么样的情况要给高分呢？什么样的情况要给低分呢？</p>
<p>​ Case1 : x真实 + c 和 x 匹配 【高分】</p>
<p>​ Case2 : x虚假 【低分】</p>
<p>​ Case3 : x真实 + c 和 x 不匹配 【低分】</p>
<p>​
所以你会发现，相比普通GAN中的判别器，它多了一种要给低分的情况，这个在之后整个的伪代码中会有所体会。伪代码如下所示：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114223235243.png" /></p>
<p>​
整体而言整个过程还是比较好理解的，首先也是从数据库里拿m个正面的样例，然后采样m个noise信号，将这m个信号和生成器生成的数据组合成一组数据。然后再随机的从数据库中取m个图片。注意，这一步目的是取一组真实的图片，但是给这些图片贴上不正确的标签c，后面在目标函数中会有所体现。</p>
<p>​
整个目标函数有3项，第一项和第二项与GAN类似，也就是刚才上面提到的Case1和Case2。第三项其实就是对应上面提到的Case3，如果向Discriminator中投入ci和随机取的与ci并不匹配的图像，那么判别器也应当给其低分。然后用梯度上升，最大化目标函数即可，这就完成了训练判别器的部分。</p>
<p>​ 在训练生成器的部分，就和GAN几乎一样了，我们就此省略不再细谈。</p>
<p>​ 说完Conditional GAN的整体的训练算法伪代码，再来讨论一下Conditinal
GAN 的判别器部分的网络架构应该如何搭建，Conditinal
GAN的判别器部分有以下两种常见的网络架构：</p>
<h5 id="架构1最为常见">1、架构1：最为常见</h5>
<p>​
如下图所示的架构是最为常见的一种架构，先有两个网络，分别将x和c做embedding编码，然后将两个编码输入判别器网络中，其会输出一个分数，就代表我们先前说的x是否真实，或者c和x是否匹配。但是这种架构其实并不能分清楚，到底是因为哪种问题，所以才导致了低分。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115002938439.png" /></p>
<h5
id="架构2有部分论文采用但是也是蛮有道理的一个架构">2、架构2：有部分论文采用，但是也是蛮有道理的一个架构</h5>
<p>​
此种架构，先把对象x输入一个判别器网络中，然后直接输出一个分数，这个分数代表x是否真实。然后再将条件c和对象x输入另一个判别器网络中，输出一个分数，代表c和x是否匹配。最后再将两个分数综合起来，得到最终判别器的分数。这样子的话，我们就可以知道，到底导致低分是什么原因。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115002950662.png" /></p>
<h4 id="image-to-image-任务">2、Image-To-Image 任务</h4>
<p>​ 和这个任务相关的一篇论文其实是非常经典的一篇论文，CVPR
2017的《Image-to-Image Translation with Conditional Adversarial
NetWorks》，有兴趣也可以去阅读原论文。下图是原论文中的一些应用的截图：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115003023803.png" /></p>
<p>​
和先前的Text-To-Image的任务一样，如果采用传统的监督学习的方法，很有可能产生的图像会非常模糊，所以就需要Conditional
GAN来完成。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115003031956.png" /></p>
<p>​ 如下所示就是使用Conditional
GAN的生成器和判别器的一个示意结果图，其实跟Text-To-Image是一样的，此处就不多赘述了。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115003040918.png" /></p>
<p>​
但是其实以这种方法生成出来的图片，也会存在一些小的问题，参见之后的第二幅图。就是比如说它可能会在图像的某些地方产生奇奇怪怪的内容。你可以仔细观察GAN生成图像的左上角，出现了奇怪的内容。这是由于什么产生的呢？就是Generator其实只关心一个是我产生出来的图像好不好，另一个是和输入图像是不是匹配，但不太会关心一个点：就是说和产生的图片和原来的有监督学习中的目标图像是不是相似。</p>
<p>​
所以，我们往往会加上一个额外的限制，就是我们希望Generator生成的图片和原来的图像越接近越好，也就是说既考虑了原来监督学习中的as
close as possible，也考虑了GAN的评分机制。如下所示：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115003054587.png" /></p>
<p>​ 下面这个就是上面所讲的三种方法不同的生成效果示意图</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115003103515.png" /></p>
<p>​ 同时，在《Image-to-Image Translation with Conditional Adversarial
NetWorks》这篇论文中，它的Discriminator经过了一些额外的设计。这就是其引入的Patch
GAN。Patch GAN解决了一件什么事情呢？</p>
<p>​ 如果你要用Conditional
GAN产生的图片非常的大，很有可能产生的结果会很差。原因是什么呢？如果图片很大，代表其展开后维度非常的高，那就需要有非常多的参数去训练它，参数一旦非常多，训练以后很容易导致过拟合的情况发生。所以，作者提出了PatchGAN的想法，如下图所示，左边是传统的Discriminator，右边是PatchGAN的。</p>
<p>​
PatchGAN的Discriminator并不是直接检查整张图像，而是只检查一个小窗口内的图像。得出一个分数。然后再综合所有窗口得出的分数。至于检查的小窗口的尺寸为多大，是一个需要调整的超参数，原论文中也对其有一定的分析，此处不多赘述。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115003123825.png" /></p>
<h3 id="二stack-gan">二、Stack GAN</h3>
<p>​ StackGAN来源于这篇论文：ICCV2017《StackGAN: Text to Photo-Realistic
Image Synthesis with Stacked Generative Adversarial
Networks》。简单而言，其只是将Conditional
GAN的生成分成了好几个阶段，用于能够生成分辨率更高的图片。这是原论文中所显示的流程图</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115003145750.png" /></p>
<p>​
简单而言，步骤如下，首先输入一段文本描述，通过Embedding嵌入层后，经过一系列的Conditioning
Augmentation的处理，将各种信息连接在一起，然后在生成器部分，首先生成第一阶段的结果图片。然后在输入到第一阶段的判别器中。当第一阶段的生成器和判别器完成训练以后，我们再将第一阶段的生成结果，与描述文本作为输入，开始训练第二阶段的GAN网络。步骤与第一阶段的GAN网络类似，最终可以得到更高分辨率的第二阶段的结果图像。具体细节部分，我暂时也没有完整的阅读过原论文，暂且只是领会一下这种方法的大致思路。</p>
<h3 id="三unsupervised-conditional-generation">三、Unsupervised
Conditional Generation</h3>
<p>​
非监督的条件生成，通常用于风格迁移。在风格迁移的应用场景中，我们往往能够收集到许多Domain
X的信息，也能收集到许多Domain Y的信息，但是不一定能够拥有Domian
X和Domain Y的一一对应的pair
数据。像类似这样子的场景中，非监督的条件生成就是一个非常好的解决方案。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115003209328.png" /></p>
<p>​ 非监督的条件生成，我们往往会有两种方法思路去完成，如下所示：</p>
<p>​ 方法1是Direct Transformation
直接转换，此种直接通过一个生成器进行转换的方法，往往两个域内的图像不能够有太过巨大的差距，通常用于做纹理或者颜色上的一些改变，以达到风格的变化。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115003225024.png" /></p>
<p>​ 方法2是Projection to Common Space
投射到公共空间，此种方法通过将两个Domain投射到一个公共空间中，完成转换。具体而言，对于下述的任务来说，先将DomainX真实人脸的信息通过一个Domain
X的编码器转换到公共空间，也就是我们的脸部属性空间，然后再将脸部属性空间，通过一个Domain
Y的解码器，解码出我们的DomainY动漫人脸的信息。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115003237748.png" /></p>
<p>接下去我们会对两种方法进行详细的讨论：</p>
<h4 id="direct-transformation内含cyclegan网络讲解"><strong>1、Direct
Transformation（内含CycleGAN网络讲解）</strong></h4>
<p>​
我们要训练一个生成器，能够完成将图片从DomainX直接转换至DomainY的任务，但是该生成器产生的图片我们怎么去评价呢？在有监督学习中，我们有一对一的数据，但是在无监督学习中，对于这个输入而言，我们并没有pair可以提供给它。所以此时，我们需要一个Discriminator，这个判别器用于判断一个图片，是否属于DomainY，然后输出一个分数。</p>
<p>​
那么这样一来，Generator的目标就是如何将DomainX的图片转换成一个新的图片，能够骗过Discriminator，而Discriminator也要努力鉴别这个图像到底是不是属于DomainY。下图，就是整个过程的一个直观的示意图。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115003304210.png" /></p>
<p>​
在这样一个过程中，好像问题已经解决了，实则不然。你会发现，生成器只学会了怎么生成一个DomainY的图片去骗过判别器，但是我们并没有给它限制，说要让这个生成器生成的DomainY的图片和原来的DomainX的图片要相似啊。那万一，输入是一张DomainX的风景图，生成器输出了一张DomainY的人像图，不照样能够获得很高的分数，这当然就不对啦。</p>
<p>​
所以，我们就希望生成器生成的DomainY的输出，应该和DomainX的输入应当会存在一定的关系才对，而不是毫无关系可言。针对于这个问题而言，有许多解决方案，叙述如下，其中最著名的就是熟知的cycleGAN。</p>
<h5 id="解决方案1不管这个问题">1）解决方案1：不管这个问题</h5>
<p>​
听上去这个解决方案非常的扯淡，但其实在某种条件下它确实work。具体而言是什么意思呢？当我们的网络层数不是很深的时候，其实网络本身也倾向于不对input做太大的改变，有人也做过实验，不去管这个问题，在某些情况下也不会得到太差的结果，得到的结果和input其实也类似。</p>
<p>​
但是，如果我们的网络比较深的话，经过非常多的非线性变换与线性变换，其实就并不好说，最后输出的output，会和input相差不大了。这个时候的话，我们可能就需要其他的解决方案。</p>
<h5
id="解决方案2利用预训练的编码器网络如下图所示">2）解决方案2：利用预训练的编码器网络，如下图所示：</h5>
<p>​
我们利用两个预训练好的DomainX和DomainY的编码器网络，在GAN训练的时候呢，生成器训练的目标任务又多了一项。之前生成器只需要生成图片，努力的去骗过Discriminator就可以，也就是说只要生成的图片越来越像DomainY的图片就可以，但是我现在希望生成器生成的图片，经过DomainY预训练的编码器网络后，生成的特征向量A，和原图经过DomainX预训练的编码器网络后生成的特征向量B，也尽可能地相似。这样一来，你会发现，如果两个编码后的内容越接近越好的话，DomainX在转换至DomainY的时候，产生的图片，应该是保留了原来DomainX图片的某些特征的。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115003341802.png" /></p>
<h5 id="解决方案3cyclegan">3）解决方案3：CycleGAN</h5>
<p>​ 原论文题目为《Unpaired Image-to-Image Translation using
Cycle-Consistent Adversarial
Networks》，有兴趣的同学可以看原论文，其主要大致思想如下图所示：</p>
<p>​
我们不仅训练一个DomainX到DomainY的生成器，同时也训练一个DomainY到DomainX的生成器，生成器X-&gt;Y在原有的需要骗过Dy的基础上，还需要使得原始输入图像和经过两个生成器后产生的图像越接近越好，这也就是我们常说的Cycle
consistency，循环一致性。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115003358128.png" /></p>
<p>​ 对于CycleGAN来说，我们可以训练双向的一个网络，两个一起去做训练。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115003406257.png" /></p>
<p>​ 其实CycleGAN也存在一些问题，在论文《CycleGAN, a Master of
Steganography》中，其作者提到，在DomianX的输入图像经过两个生成器的过程中，出现问题。具体而言，输入的图像的有些信息会在经过第一个生成器的时候被隐藏起来，此处的被隐藏起来也就是指人肉眼观察不到，而当其经过第二个生成器的时候，又会被还原出来。如下图红色方框中所示。这就意味着，生成器网络有隐藏信息的能力，我们如果只控制input和经过两个生成器的output的一致性，中间产生的我们真正要的图像还是有可能丢失原图的部分信息。这是一个尚待研究的问题。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115003414078.png" /></p>
<p>​
此处的话补充一下另外一个网络，是在CycleGAN的基础上进行的一个升级，叫做StarGAN。其应用领域在于，当你需要多个Domain的信息风格互相转换的时候，怎么进行网络的学习与处理。</p>
<p>​
按照之前CycleGAN的思路，如果我们想要在4个Domain内做互相转换，需要在两两之间训练一组生成器。StarGAN就是可以之训练一个生成器，就完成在多个Domain之间的信息互相转换。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115003422218.png" /></p>
<p>​ 原论文为《StarGAN: Unified Generative Adversarial Networks for
Multi-Domain Image-to-Image
Translation》，其主要思想及训练过程如下：</p>
<ul>
<li><p>A)步骤，首先训练判别器，判别器会完成两件事，一是要判别这个图像他是真实的还是虚假的，二是要做一个分类的问题，它是属于哪一个Domain，给出两个结果。</p></li>
<li><p>B)C)步骤,
在训练生成器时，要完成这样一个任务。首先输入我们的输入图片，以及目标Domain，然后生成器会生成一个Fake
Image，我们将这个Fake
Image和原来的Domain作为输入，再次送入生成器中，会得到一张Reconstructed
Image，我们希望这张重建的图像和输入的图像之间的差距越小越好，其实这就是Cycle
Consistency类似的思想。</p></li>
</ul>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115003432585.png" /></p>
<ul>
<li><ol start="4" type="A">
<li>步骤，同时在训练生成器的时候，还有一个目标，就是要让这个Fake
Image骗过我们之前训练好的Discriminator，使得Discriminator的输出越大越好。</li>
</ol></li>
</ul>
<p>​
下图是一个训练应用实例的示意图，在StarGAN的实际训练过程中，其实域可以是由一组编码决定的。就比如说00101代表一个域，10011也代表一个域。然后00101有一个参照表，也就是label，代表相对的含义。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115003446510.png" /></p>
<h4 id="projection-to-common-space">2、Projection to Common Space</h4>
<p>​
在此类方法，如果我们想要完成DomainX和DomainY两种风格的互相转换，我们其实需要的就是如下图所示的2个Encoder和2个Decoder。例如，如果要从X转换至Y，那么图像应当先通过EncoderX，得到一个Face
Attribute，应该是一个Latent
Vector，然后再经过DecoderY，最终得到DomainY的图像。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115003534380.png" /></p>
<p>​
这样来看，如果我们拥有一对一的pair数据，那么其实完成这个任务非常的容易，只需要正常的监督学习训练即可。但是我们现在是无监督场景下的训练，应当如何完成训练呢？</p>
<p>​
我们可以像下图所示这样进行训练，其实就是训练了两个自动编码器，通过最小化重建误差来进行优化。然后在此基础上我们可以加两个判别器。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115003544456.png" /></p>
<p>​
如此而言，我们确实可以得到2个Encoder和2个Decoder。但是这两组AutoEncoder（VAEGAN）是完全没有关系的。这意味着什么呢？你看上图中，中间的这个Latent
vector，两边共用一个，其实来说，两边训练出来以后，得到的中间的这个特征向量，每一个维度所代表的含义会是完全不同的。其实就变成了如下图所示的这样子一个效果。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115003552083.png" /></p>
<p>​
所以最终导致的结果就是：你将一个DomainX的图片丢入X编码器，得到一个向量，然后将向量丢入Y解码器，可能生成的是一个完全不相关的DomainY的图片。</p>
<p>​ 接下来我们就是要解决这个问题，也会有比较多的文献解决方案：</p>
<h5
id="解决方案1共用部分隐藏层参数">1）解决方案1：共用部分隐藏层参数</h5>
<p>​
共用EncoderX和EncoderY的后面几层，同时也共用DecoderX和DecoderY的前面几层。这样子做其实就是希望，接近中间这个特征向量的层共用参数以后，两边的编码能够在中间的特征向量的维度上达成一致。</p>
<p>​
这种解决方案比较极端的情况时，可以让EncoderX和EncoderY共用所有参数，DecoderX和DecoderY共用所有参数，只是在训练和使用的时候，我输入一个标签，代表这个是X
Domain还是Y Domain。这个方法用于CoupleGAN和UNIT</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115003616483.png" /></p>
<h5 id="解决方案2domain-discriminator">2）解决方案2：Domain
Discriminator</h5>
<p>​ 我们在网络架构中，新增一个Domain
Discriminator。在训练的过程中，EncoderX和EncoderY还有一个任务，就是说他们所生成的中间的特征向量，还要能骗过Domain
Discriminator，让这个判别器无法鉴别，这个特征向量到底是从EncoderX来的，还是从EncoderY来的。如此一来，完成训练后，相当于说是两个编码器产生的中间的特征向量应该遵循着类似的分布，能够在中间的特征向量的维度表示上达成一致。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115003651260.png" /></p>
<h5
id="解决方案3利用cycle-consistency的类似思想">3）解决方案3：利用Cycle
Consistency的类似思想</h5>
<p>​
如图红线路径所示，图像经过EncoderX，产生特征向量，经过DecoderY产生Image，再将这个Image作为输入进入EncoderY，产生特征向量，经过DecoderX产生output，然后最小化input和output的重建误差即可。该方法被用于ComboGAN。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115003717264.png" /></p>
<h5
id="解决方案4利用semantic-consistency的类似思想">4）解决方案4：利用Semantic
Consistency的类似思想</h5>
<p>​
按照图中红线路径，input输入经过EncoderX，产生特征向量A，经过DecoderY产生Image，再将这个Image作为输入进入EncoderY，产生特征向量B。然后最小化A和B的差别即可。相比于CycleConsistency，此种思想直接在特征向量的空间中去考虑相似度，避免了比如说可能input和output表象上很像，但其实中间特征向量代表维度仍然不同这种问题。该种思想在DTN和XGAN网络中使用。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115003743216.png" /></p>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>GAN系列笔记</category>
      </categories>
      <tags>
        <tag>GAN</tag>
        <tag>ConditionalGAN</tag>
        <tag>PatchGAN</tag>
        <tag>CycleGAN</tag>
      </tags>
  </entry>
  <entry>
    <title>GAN系列笔记1——GAN的基本理念与思想</title>
    <url>/2021/11/30/9fbfb5044884/</url>
    <content><![CDATA[<h3 id="前言">前言：</h3>
<p>​
本篇笔记为观看李宏毅老师的GAN相关课程后所记录，文中所有图片及内容均来源于李宏毅老师的课程，此处只是搬运+以自己的理解进行记录。全文按照李宏毅老师讲课的逻辑进行记录，先从GAN的基本理论概念讲起，中间提及了Structure
Learning的问题，然后回答了GAN中的两个经典的问题，然后对VAE和GAN的结果做了简单的比较，最后做了总结，看完以后应该会对GAN有一个完整的概念与理解。全文共4800字左右。</p>
<h3 id="一basic-idea-基本概念">一、Basic Idea 基本概念</h3>
<p>​
GAN是完成了一个Generation的任务，从目标上而言，其实就是我们要训练一个NN的generator，这个generator可以完成下述任务：你给机器一个随机的向量，机器就可以给你输出你想要的物体（可以是图像也可以是其他）。（当然，这种类型的generator看上去是没什么用的，因为你不知道随机向量到底会生成什么样子的东西，但通常向量的每个维度可能就是用于控制输出图像的一个特征部分，现在暂时我们只专注于完成这样一个随机的任务部分）。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114214941737.png" /></p>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114214945273.png"
alt="image-20220114214945273" />
<figcaption aria-hidden="true">image-20220114214945273</figcaption>
</figure>
<figure>
<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114214948402.png"
alt="image-20220114214948402" />
<figcaption aria-hidden="true">image-20220114214948402</figcaption>
</figure>
<p>​
GAN比较神奇的点在于其还会同时训练一个Discriminator，即判别器。从目标上而言，其要完成如下任务:输入一个图像，输出一个值，这个值越大，代表图像越真实。值越小，代表图像越虚假。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114214959500.png" /></p>
<p>​
那么在GAN中，Generator和Discriminator的关系其实就是对抗竞争，或者说互相帮助互相进步的关系。如下图所示：第一代的生成器生成的东西，交给第一代判别器。第一代生成器在第一代判别器的反馈下，进化为第二代的生成器，然后判别器也随之进化为第二代，循环往复下去（有一种道高一尺，魔高一丈的感觉）</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114215010569.png" /></p>
<p>​
一个更好的比方，下图中，Generator和Discriminator就像是学生和老师在对话一样，在这个过程中，学生逐渐进步。老师的要求标准也越来越高。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114215031820.png" /></p>
<p>​
在这样一个过程中，留下两个疑问：Generator做生成为什么不自己学提高水平呢？Discriminator这么会批评，为什么不自己做生成呢？【解释与回答见第四章】</p>
<p>​ 现在我们先来讨论一下整个训练的算法伪代码过程，如下所示：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114215049291.png" /></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114215052840.png" /></p>
<p>​
首先我们初始化生成器和判别器，然后在每一个训练迭代阶段，进行两件事：</p>
<p>​
1、我们将Generator固定住，训练Discriminator的参数。具体而言，我们首先随机的输入一些向量，通过G生成一些随机的generated
objects，然后再从真实数据库中取出一些objects，将这两部分图片作为D的输入，来训练D。目的是要让D看到generated
objects
就给出尽可能接近0的分数，让D看到真实的objects就给出尽可能接近1的分数。(其实就是给两部分图片打个标，然后训练一个分类器，如上图所示)</p>
<p>​
2、固定住Discriminator的参数，调整生成器的参数。具体而言就是：将一个随机的vector丢入生成器里，生成一张图片，将图片放入判别器中，得到一个分数，我们训练此步的目标是要使最后输出的那个分数越接近1越好。从代码上，这个要怎么进行操作呢？我们往往会将生成器的NN和判别器的NN合并成一个大的网络，锁住判别器部分层的参数，这相当于这个大的网络中间有一层很宽的隐藏层（就是输出图片那一层），然后我们要使得最后生成的结果越大越好，就是Gradient
Ascent，其实就是在Objective
Function上加一个负号，就可以完成这个任务。</p>
<p>​ 下述是更为正式的算法伪代码：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114215114053.png" /></p>
<p>要注意，在这个算法中，有一些超参数是需要手工去调整以找到最佳效果的：</p>
<p>​ 1、输入的向量的维度，5维、10维、……</p>
<p>​ 2、在每一个迭代过程中：更新判别器的次数，可以是1~n次。</p>
<p><strong>算法中的一些解释：</strong></p>
<p>​ 1、更新判别器参数的时候的Objective Function：</p>
<p>​ 第一项：<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114215147446.png" />代表真实数据集的图像进到判别器中的分数均值。</p>
<p>​ 第二项：<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114215201515.png" />代表生成的图像进到判别器中的分数被1减去后的均值。</p>
<p>​
我们要让这个目标函数最大，其实就是完成了最开始说的，真实数据集图像进到判别器中，分数越接近1越好，生成图像进入，分数越接近0越好。</p>
<p>​ 2、更新生成器参数的时候的Objective Function：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114215238651.png" /></p>
<p>​
其实就是随机向量通过生成器，再通过判别器后，得到的均值越大越好。然后用梯度上升方法，去最大化这个目标函数。</p>
<h3 id="二structure-learning">二、Structure Learning</h3>
<p>​ 首先，什么是Structure
Learning？机器学习本身其实就是找到一个函数f，去完成X-&gt;Y这样一件事情。回归问题，其实就是输出一个分数。分类问题就是输出一个类别，结构化学习其实就是输出一个更复杂的比如说一个序列，一个矩阵，一个图，一个树等等这样的问题。往往这种复杂的结构是由很多个组件组成，并且这些组件之间是有关联关系的。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114215309664.png" /></p>
<p>​ 为什么Structure
Learning是很Challenging的呢？其实就是如下图所说的，一个的话是它可以被视为One-shot
Learning或者是Zero-shot Learning。那什么是One-Shot Learning
或者说Zero-shot
Learning呢？例如，在分类作业中，我们如果需要训练，每个类别都需要给出一系列的数据范例。而One-Shot
Learning 或者Zero-shot
Learning就是指，可能有些类别完全没有范例，或者说只有很少的范例。</p>
<p>​ Structure
Learning里面，输出的是一个结构体，也就是说很有可能训练的句子里面是完全不会有重复的东西的。如果我们把所有的可能输出都视为一个类的话，输出的空间是很巨大的。并且大多数的类都是没有任何训练数据的。所以机器需要一定的创造性。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114215320786.png" /></p>
<p>​ 第二点的话，在Structure
Learning中，机器必须学会规划。机器可以一个个组件的去产生，但是它一定要学会组件和组件之间的关系与限制。需要全局的去进行考虑。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114215331213.png" /></p>
<h3 id="三structure-learning的一些解决方案">三、Structure
Learning的一些解决方案</h3>
<p>​ 在传统的方法分类中，其实有两类：一类是Bottom Up的方法，一类是Top
Down的方法。自底而上的方法主要是学习怎么去生成Component，然后再进行合并，这个很像Generator做的事情，但是这样很容易失去大局观。自上而下的方法是学会评估一个物体，然后找到最好的那个，这个很像Discriminator做的事情，但是这样做的问题是很难做生成。【为什么这么说见第四章】其实GAN就是解决Structure
Learning的一个解决方案，他就像是把两种方法做了结合。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114215356504.png" /></p>
<h3
id="四为什么generator不能自己学为什么discriminator不能自己生成">四、为什么Generator不能自己学？为什么Discriminator不能自己生成？</h3>
<h4 id="generator为什么不能自己学">1、Generator为什么不能自己学？</h4>
<p>​
在传统的有监督学习中，我们只要有大量的真实图片数据，以及他们对应的标签，我就可以完成生成图片这样一个任务。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114215423815.png" /></p>
<p>​
但是问题就来了，我们怎么给这些真实图片数据打标签呢？如果是随机赋给他们一些向量标签，那最后的训练是会很困难的。因为比如说我们看两个1的图片比较相似，当然希望向量中有一部分的标签内容是类似的，而不是说这两个1的图片对应的向量标签完全不一致。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114215433669.png" /></p>
<p>​
也就是说，我们总是希望这个input和output的内容是存在一些联系的，而不是毫无联系。说到这里，其实问题还是可以解决的，怎么去解决这个编码问题呢？</p>
<p>​
正巧，我的上一篇文章中讲了各种自动编码器的相关知识，这个编码问题，我们可以训练一个NN编码器来进行解决。这个编码器完成一件什么事呢？给它一个图片，它输出一个向量，来表示这个图片的相关特征。具体而言，自动编码器怎么进行训练，详见自动编码器的文章，如下：这里的话也给一张李宏毅老师课程的截图示意：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114215447872.png" /></p>
<p>​
仔细想来，其实这个Decoder干的是不是就是Generator的事情？是的！因为它也是接收一个Vector向量，输出一张图片，如下图所示：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114215456226.png" /></p>
<p>​
这样看来，其实理论上来讲，只要我们训练好了一个自动编码器，把Decoder部分拿出来，就是一个生成器。然后我们随便给一个向量，他就会输出一个对应的图像。</p>
<p>​
但是Auto-Encoder存在什么样的问题呢？如下图所示：比如说，我们已知a向量可以产生一个图片，b向量可以产生一个图片，那么0.5<em>a+0.5</em>b会产生什么呢？很有可能会产生Noise，因为这样的生成器本身是一个神经网络，不是线性的。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114215508501.png" /></p>
<p>​
说到这里，其实还没有正面回答Generator为什么不能自己学这个问题，但大家不要着急。我们继续说，这个问题其实我们可以用VAE来解决，也就是上篇文章末尾重点讲过的变分自动编码器。</p>
<p>​
如下图所示：有了变分编码器，因为变分自动编码器是对一个概率分布进行了编码，而不是固定的。所以我们能够将这个decoder训练的更为稳定。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114215517660.png" /></p>
<p>​ 那么，现在看来，好像Auto-Encoder就能解决Structure
Learning这样一个任务了，那为什么我们还需要GAN这个技术呢？接下去要说的就是Auto-Encoder这套技术所缺少的内容。</p>
<p>​
在Auto-Encoder的技术中，我们实现的目标是：让生成的图片和目标图像越像越好。那么问题来了，什么叫越像越好？正常来说，我们就是把这个图像展开成一个vector，然后逐像素的计算距离差。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114215528542.png" /></p>
<p>​
我们先前说过，自动编码器是不能让它完整的保留所有的信息的，不然就失去了编码的意义，机器只要学习复制就可以了。所以自动编码器的生成器部分，生成的目标总是和源图像会有一些差距，会有一些取舍。这个时候，取舍在哪里就很重要！如下图所示：右上角是目标图像，下面四个是生成的图像。生成图像第一排，只偏差了1个像素，第二排，偏差了6个像素。从计算相似度而言，第一排优于第二排，但是从人的感知而言，第二排优于第一排。所以我们如果只是单纯的计算距离差，让两者越像越好，就有可能会产生第一排的结果。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114215538491.png" /></p>
<p>​ 在做Structure
Learning的过程中，我们说过组件和组件之间的关系是很重要的，需要考虑全局观念。这个偏差出来的多的像素本身没有错误，有错的是它如果是有像素值的，那么它周边的组件，也应当是有填充的，而不是空白的。这个像素要和周围的像素一致，这个其实就是组件和组件的一种关联。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114215546546.png" /></p>
<p>​
但是我们训练一个生成器的时候，当我们训练一个网络的时候，是很难把组件和组件的关系放进去的。因为在NN网络这个架构里面，如果前一层的权重都已经确定了，最后的输出之间是独立的。每个输出神经元之间没法互相进行配合。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114215603961.png" /></p>
<p>​
其实像这种也可以解决，只不过需要更深的网络结构。更深的网络结构能够帮助你把这种组件与组件之间的相关性考虑进去。所以，如果有一个GAN网络，一个Auto-Encoder网络，要完成一个目标，往往Auto-Encoder的网络需要更深，才能达到和GAN类似的效果。</p>
<p>​
其实讲到这里，都没有明确的回答Generator为什么不能自己学这个问题，但是其实已经回答掉了。因为我们刚才讲的，Auto-Encoder就是训练了一个单的Generator，是抛弃了Discriminator的一个架构。如果这样子让Generator自己学，当然可以，只不过会存在上述所说的种种问题和难处。</p>
<h4
id="discriminator为什么不能自己产生image">2、Discriminator为什么不能自己产生Image？</h4>
<p>​
Discriminator总的来说干了一件什么事呢？它其实就是输入一个对象，输出一个分数，这个分数表示这个对象多好或多差，进行评估。对于Discriminator来说，它要考虑组件和组件之间的关系就很容易了，因为他是看到整个图片的。</p>
<p>​
那么我们其实是可以用Discriminator来产生Image的，只不过会非常的卡，非常的慢，为什么这么说呢，我们先看，如果硬要用Discriminator来产生Image，步骤应该是怎样的：</p>
<p>​
假设我们已经训练好了一个好的判别器，那么我们只需要执行如下公式即可：</p>
<p>​ 穷举所有的x，然后一个个丢到判别器里，让它看是不是高分。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114215739478.png" /></p>
<p>​
虽然这看上去不是很合理，对于穷举而言。但是这其实并不是关键所在。我们现在先假设这个方法确实可行，那难道就可以了吗？别忘了，我们先前的假设：“假设我们已经训练好了一个好的判别器”，那么我们怎么训练这个判别器呢？这才是问题的关键！</p>
<p>​
理论上讲很简单，我给他好的样例，让他输出高分，烂的样例，让他输出低分。但是实际上呢，我们手上只有好的样例。如果只有这样的训练实例，会导致网络看到啥都给高分。所以，怎么去产生不好的样例，产生怎样不好的样例，就是一个很关键的问题：</p>
<p>​
如果不好的样例就只是一些噪音，那其实机器很容易会给一些尚可的模糊的图片打高分，这并不是我们希望看到的。如下图所示。所以<strong>只有差的样例足够的好，才能让机器真正的学会评判好的图片和坏的图片</strong>，</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114215749015.png" /></p>
<p>​ 所以现在如何生成足够好的
差的样例就很重要，那么我们就需要一个生成差的样例的过程，在没有Generator的前提下，这就是一个鸡生蛋蛋生鸡的循环问题了。所以如果真的想要完成这件事情，只能通过一个迭代的形式去完成：</p>
<p>​
我先学一个最差的Discriminator出来，然后用这个去做生成，生成出来的样例用来训练更好的Discriminator，循环往复。你会发现这个过程好像跟GAN差不多，但是如果没有generator，要比GAN累好多，慢很多。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114215808954.png" /></p>
<p>​
这时候再来看如果我们把Generator加上，GAN就是利用Generator来求解这个argmax的问题，用于生成一些负面的样例。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114215815222.png" /></p>
<h3 id="五比较vae和gan的结果">五、比较VAE和GAN的结果：</h3>
<p>​
下图是各个GAN和VAE在不同参数下，所表现出来的性能分数的值的区间。还附带了一个VAE和GAN生成人物头像的直观结果。</p>
<p>1、VAE比较稳定，给它不同的参数，所表现出来的性能相差不大。</p>
<p>2、GAN相对而言比较吃参数，但是只要参数正确，所生成的最好结果也是远远优于VAE产生的结果的。<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/2222sdsa.png" /></p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114215842339.png" /></p>
<h3 id="六总结">六、总结</h3>
<p>1）生成器：</p>
<p>​ 优势：很快就能生成一个东西</p>
<p>​ 劣势：很难察觉组件和组件之间的关系，只是模仿一个表象</p>
<p>2）判别器：</p>
<p>​ 优势：可以考虑大局观</p>
<p>​ 劣势：生成一个东西非常的困难</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114222543440.png" /></p>
<p>3）GAN的优势：</p>
<p>1、从判别器的角度而言，使用Generator来进行negative
example的生成，更为高效。</p>
<p>2、从生成器的角度而言，它虽然仍然是一个组件一个组件的生成对象，但是相比传统的计算L1,L2的损失而言，它会从Discriminator那边得到全局视野的反馈，更能理解组件与组件之间的关系。</p>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>GAN系列笔记</category>
      </categories>
      <tags>
        <tag>GAN</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习基础系列笔记2——数据表征与自动编码器</title>
    <url>/2021/11/24/379e9f408368/</url>
    <content><![CDATA[<h2 id="数据表征与自动编码器">数据表征与自动编码器</h2>
<h3 id="前言">前言：</h3>
<p>​
本文简单讲解了数据表征与自动编码器的相关知识，主要来说涵盖数据表征的概念与理解，简单自动编码器的组成，堆叠式自动编码器的组成与训练方法，卷积、循环、去噪、稀疏自动编码器的简单介绍，以及变分自动编码器较为详细的概念与一个有趣的应用。</p>
<h3 id="什么是数据表征">1、什么是数据表征？</h3>
<p>以下是两组数字顺序：</p>
<p>​ 40，27，25，36，81，57，10，73</p>
<p>​ 1，2，3，4，5，6，7，8，9，10，11，12，13，14，15，16，17</p>
<p>​
简单来看，第一行的数据更少，信息量更小，但是其实第二行的数据具有很好的递增特征，反而更容易进行记忆。数据中的类似于这种的模式被我们称为数据表征。模式可以更好的帮助我们有效的存储信息。</p>
<h3 id="一个简单自动编码器的组成">2、一个简单自动编码器的组成</h3>
<p>​
自动编码器由两部分组成：将输入转换为潜在表征的编码器（识别网络），以及将内部表征转换为输出的解码器（生成网络）。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114205901462.png" alt="image-20220114205901462" style="zoom:150%;" /></p>
<p>​
上述示例就是一个由3个神经元组成的隐藏层（编码器），以及由6个神经元组成的输出层（解码器）。输出又通常称为重构，自动编码器会试图重构输入，且成本函数包含一个重构损失，重构和输入不一致的时候会进行惩罚。</p>
<p>​
注意：自动编码器的输出数量应等于输入数量。同时，自动编码器本身其实是一个在学习数据潜在表征，然后再由表征还原数据的一个过程。它通常用于降维或者无监督的预训练。</p>
<h3 id="堆叠式自动编码器">3、堆叠式自动编码器</h3>
<p>​
自动编码器可以有许多个隐藏层，就成为了堆叠式自动编码器（深度自动编码器）。但是我们需要注意不能使编码器太过于强大了。为什么呢？仍然以下述为例：</p>
<p>​ 40，27，25，36，81，57，10，73</p>
<p>​ 1，2，3，4，5，6，7，8，9，10，11，12，13，14，15，16，17</p>
<p>​
如果编码器太过于强大了，可能他就会准确的记住每一个数字（也就是做了一个简单的一一映射，而没有去学习潜在的模式）。就好比一个记忆力非常好的人看到这两串数字，说我不需要去看这个数字里面到底存在什么样的模式，只要直接背就完了，没有区别。</p>
<p>​
<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114205946184.png" alt="image-20220114205946184" style="zoom: 150%;" /></p>
<p>​
上图是一个常见的堆叠式自动编码器的示意图，往往会是这样一个类三明治结构。下图是一组输入与重构的可视化结果：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114210006336.png" /></p>
<p>​ 为了更好的帮助理解自动编码器降维的用处，我们举一个简单的例子：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114210017508.png" /></p>
<p>​
在上图中这样一个简单的自动编码器网络中，其实质就是将一组3维数据通过编码器降到了2维。然后在通过解码器将2维数据重构至3维。实际操作过程中，构建好这样一组自动编码器网络后，你可以先使用解码器将数据降维，然后做一些学习，然后再将数据进行重构，能够帮助进行更好的实例泛化。</p>
<p>​
同样，为了更好的帮助理解自动编码器用于无监督预训练的用处，我们也举一个简单的例子：</p>
<p>​
先我们学过如果要处理一个复杂的有监督任务，但是没有很多标记好的数据，那么可以在网上寻找已知的类似任务的神经网络，并且重用其较低层的网络，然后用少量数据对高层网络进行训练即可。这样其就不必从底层特征开始学起，只会重用原有网络的底层特征检测。</p>
<p>​
讲到这里，应该明白了，自动编码器其实也是同一个原理。刚才说了，自动编码器的第一步是编码器，编码器的本质是寻找数据的潜在表征，那不也就相当于做了底层的特征检测嘛，而且训练数据还是可以不需要标签的。</p>
<p>​ <img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114210030274.png" /></p>
<p>​</p>
<p>​
所以，如上图所示，如果我们手上有一个大型数据集，但是难受的是大部分的数据都是未标记状态的，只有少数打上了标签。那么我们可以先使用所有的数据来训练一个自动编码器，训练完以后，将编码器部分的网络复制到我们新的神经网络中，然后在此基础上构建高层的神经网络，这样的话只要再用少部分带标记的数据训练一下该神经网络的高层部分就可以得到一个较好的效果了。</p>
<p>### 4、如何训练堆叠式自动编码器：</p>
<p>一般情况下，我们有两种方式可以用于训练自动编码器。</p>
<p>​ 1.
将解码器层的权重与编码器层的权重绑定起来。这样的话可以将模型中整体的训练参数减半，并且加快训练速度并且降低了过拟合的风险。</p>
<ol start="2" type="1">
<li><p>一次训练一个浅层自动编码器然后将他们进行堆叠。（这种技术现在用的较少），示意图如下：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114210104140.png" /></p>
<p>​
示意图本身已经较清楚的讲解了整个过程，我再做一遍简略的讲述。比如说，我们现在要训练最右侧这样一个堆叠式自动编码器，他的编码器部分有两层，我们将其分为两阶段来看这个问题。首先按训练第一个自动编码器，将隐藏层1的参数训练好。然后再训练第二个自动编码器，将隐藏层2的参数训练好。注意，在训练第二个自动编码器的时候，用到的输入其实是训练好的第一个自动编码器将输入编码后的结果。以公式的形式表达的话就是：</p>
<p>​ 我们假设输入为i，第一个自动编码器的编码函数为 <strong>f_encoder1()
</strong>,解码函数为<strong>f_decoder1()</strong>,第二个自动编码器的编码函数为<strong>f_encoder2()</strong>,解码函数为<strong>f_decoder2()</strong>。</p>
<p>​ 那么在训练第一个自动编码器的时候，输入为i，重构输出为
<strong>f_decoder1(f_encoder1(i))</strong>。在训练第二个自动编码器的时候，输入为<strong>f_encoder1(i)</strong>，重构输出为<strong>f_decoder2(
f_encoder2( f_encoder1(i) ))</strong></p></li>
</ol>
<h3 id="其他类型的自动编码器">5、其他类型的自动编码器</h3>
<p>​ <strong>(1) 卷积自动编码器</strong></p>
<p>​
用于为图像构建自动编码器。一般编码器层是由卷积层和池化层组成的常规CNN。会减少输入的空间尺寸，增加深度即特征图的数量。解码器则进行相反的操作。</p>
<p>​ <strong>(2)循环自动编码器</strong></p>
<p>​
用于为序列构建自动编码器，例如时间序列或文本。编码器通常为序列到向量的RNN，能够将输入序列压缩为单个向量。其可以处理任何长度的序列。</p>
<p>​ <strong>(3)去噪自动编码器</strong></p>
<p>​
到目前为止，为了让自动编码器不过于强大，也就是为了让他学习一些数据的浅层特征，我们通过限制编码曾大小让它成为不完整的自动编码器。其实，我们还可以通过向其输入中添加噪声，训练它来恢复无噪声输入，也可以让其学习数据的有用特征。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114210254970.png" /></p>
<p>​
可以在编码器的输入中叠加高斯噪声，也可以加一层dropout层。去噪编码器不仅可以用于降维数据可视化或者无监督预训练，也可以用于图像去噪。</p>
<p>​ <strong>(4)稀疏自动编码器</strong></p>
<p>​
使用稀疏性来对编码器进行约束，使其对良好的特征进行提取学习。通过在成本函数中添加适当的函数项，来强迫自动编码器减少编码层中活动神经元的数量。</p>
<p>​
另一种方法是在每次训练迭代时测量编码层的实际稀疏度，并在测量稀疏度预目标稀疏度不同时对模型进行惩罚。</p>
<p>​ <strong>(5)变分自动编码器</strong></p>
<p>​ 变分自动编码器较为特殊，具体而言有两大特点：</p>
<p>​
<strong>特点1</strong>:概率自动编码器：意思是即使在训练好以后，它们的输出部分也会由概率决定。</p>
<p>​
<strong>特点2</strong>:生成式自动编码器：指它们可以生成看上去像是从训练集中采样的新实例。</p>
<p>​
在先前讲到的自动编码器中，我们往往以一个数值来表示一个特征维度的值，如下
所示，将人脸图像编码成了一个六维向量，每个维度一个值。</p>
<p>​ <img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114210408918.png" /></p>
<p>​
在上面的示例中，我们使用单个值来描述输入图像在潜在特征上的表现。但在实际情况中，我们可能更多时候倾向于将每个潜在特征表示为可能值的范围。</p>
<p>​
而变分自编码器便是用“取值的概率分布”代替原先的单值来描述对特征的观察的模型，如下图的右边部分所示，经过变分自编码器的编码，每张图片的微笑特征不再是自编码器中的单值而是一个概率分布。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114210429150.png" /></p>
<p>​
所以在变分自动编码器中，我们现在将给定输入的每个潜在特征表示为概率分布。当从潜在状态解码时，我们将从每个潜在状态分布中随机采样，生成一个向量作为解码器模型的输入。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114210436379.png" /></p>
<p>​ 那么如何训练变分自动编码器呢？其成本函数由应当如何设计？</p>
<p>​
变分自动编码器学习的是隐变量（特征）Z的概率分布，因此在给定输入数据X的情况下，变分自动编码器的推断网络输出的应该是Z的后验分布p（z|x）。
但是这个p（z|x）后验分布本身是不好求的。所以有学者就想出了使用另一个可伸缩的分布q（z|x）来近似p（z|x）。通过深度网络来学习q（z|x）的参数，一步步优化q使其与p(z|x)十分相似，就可以用它来对复杂的分布进行近似的推理。</p>
<p>​
这个时候就出现了成本函数的设计理念，成本函数由两部分组成，第一部分是通常的重构损失，我们可以使用交叉熵来衡量。第二部分是潜在损失。它就是上述提到的目标分布q和编码的实际分布p之间的KL散度。通过简化后，就可以得到以下公式：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114210448726.png" /></p>
<p>​ L1是潜在损失，n是编码的维度，u(j)和sigma(j)
是第j个分量的均值和标准差。向量u和sigma由编码器进行输出。KL散度及如何通过KL散度推导出简化的公式部分本文进行了省略，详细可以看引用（2）。</p>
<p>​ 最后提一下整个变分自动编码器的网络结构如下：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114210503507.png" /></p>
<p>​
编码器产生平均编码u和标准差sigma，然后实际编码是从u和sigma的高斯分布中进行随机采样之后得到的。解码器正常解码采样得到的编码即可。</p>
<h4 id="一些有趣的应用">一些有趣的应用：</h4>
<p>​
变分自动编码器使得语义插值成为了可能，可以在编码级别进行插值，而非在数据级别进行插值。总体而言就是如下图所示的一个过程：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114210518169.png" /></p>
<p><strong>文中引用与部分图片来源：</strong></p>
<p>1）《机器学习实战
基于Scikit-learn、keras、tensorflow》机械工业出版社</p>
<p>2）
一文理解变分自编码器（VAE）https://zhuanlan.zhihu.com/p/64485020</p>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Basic系列笔记</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Basic Concepts</tag>
        <tag>Auto Encoder</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习基础系列笔记1——One-Hot编码与Word Embedding</title>
    <url>/2021/11/23/3ad8cb19bc7a/</url>
    <content><![CDATA[<h3 id="一one-hot-encoding独热向量">一、One-Hot Encoding独热向量</h3>
<p>​
独热向量是指使用N位0或1来对N个状态进行编码，每个状态都有它独立的表示形式，并且其中只有一位为1，其他位都为0。</p>
<p>​ 比如我们现在要编码apple，我们用5位向量来进行编码，如下所示：</p>
<ul>
<li><p>apple [1 0 0 0 0]</p></li>
<li><p>bag [0 1 0 0 0]</p></li>
<li><p>cat [0 0 1 0 0]</p></li>
<li><p>dog [0 0 0 1 0]</p></li>
<li><p>elephant [0 0 0 0 1]</p></li>
</ul>
<p>​
如果我们现在想要编码其他另外的单词，那就需要更多位参与编码，但是这五个单词的编码前5位仍然能够是这样，只不过后面省略号省略的部分都为0罢了。</p>
<p>​
使用这种独热向量的表示形式能够很好的对各种内容进行编码，但是它并没有考虑编码内容与内容之间的关联。就比如说，在上述例子中，cat，都属于动物，他们之间应当存在联系，apple
和 其它四个内容没有联系。但是，从上述的编码中我们没法看出cat。</p>
<p>​ 同时使用独热向量形成的特征矩阵会非常的稀疏，占用的空间非常的大。</p>
<h3 id="二word-embedding-词嵌入">二、Word Embedding 词嵌入</h3>
<p>​ Word
Embedding就是为了解决One-hot编码的缺陷，其用一个向量来对一个词进行表示。其具有很强的表达关联特征的能力。</p>
<p>​ 比如说，我们以如下为例，我们现在要使用两种编码表示公主、王妃</p>
<ol type="1">
<li>使用One-Hot:</li>
</ol>
<p>​ 公主 [1 0]</p>
<p>​ 王妃 [0 1]</p>
<ol start="2" type="1">
<li><p>使用 Word Embedding:</p>
<p>公主 = 0.5 * 皇帝 + 0.125 * 宫里 + 0.5 * 女</p>
<p>王妃 = 0.3 * 皇帝 + 0.375 * 宫里 + 0.5 * 女</p>
<p>​
因为我们就以三个额外的维度来进行编码，所以两者应当表示为三维的向量。于是，公主表示为
[0.5 0.125 0.5]，王妃表示为
[0.3,0.375,0.5]。这样一来，我们就可以知道公主和王妃在内在中，存在着某种意义上的关联。</p>
<p>​
当然在上述例子中，系数都是举个例子随便写的，我们想要表达的意思就是，比如我们将要词映射到一个二维的特征空间中，每个词就可以表示成一个二维的点，那么我们就能知道词和词之间存在的某些关系。同理，如果词映射到一个三维的特征空间，那就是表示成三维空间中的一个点。</p>
<p>​
如下图所示，就是一个直观的例子，我们将这么多词映射到二维空间中，就可以找到它们在二维空间的分布，找到其内在的词与词之间的关系，比如说，在图中我们就看到了三个明显的聚类。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114205646350.png" /></p>
<p>​ 那么Word
Embedding一般是怎么做的呢？其就是一个全连接的神经网络层。如下所示：左边是一个以2×6的one-hot矩阵为输入，中间层节点数为3的全连接的神经网络层。从右边可以看出，这个计算过程就相当于从
w i,j
矩阵中取出第1,2行，跟字向量的查表操作是一样的（从表中找出对应的向量）。这样子编码得到的对应向量就是3维的。如果你想要编码得到n维的向量，那么中间层就应该为节点数为n的全连接神经网络层。一般我们在神经网络中看到的Embedding层就是这样子设计的。</p>
<p>​ <img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114205700989.png" /></p>
<p>因此，Embedding层其实就是以one
hot为输入、中间层节点为字向量维数的全连接层！而这个全连接层的参数，就是一个“字向量表”！这其实就是将读热编码后的稀疏矩阵经过一个线性变化（其实就是查表）将其转换成一个密集矩阵的过程。</p>
<p>最后总结一下，Embedding层最终完成的工作：</p>
<ul>
<li>将稀疏矩阵经过线性变换（查表）变成一个密集矩阵</li>
<li>这个密集矩阵用了N个特征来表示所有的词。密集矩阵中表象上是一个词和特征的关系系数，实际上蕴含了大量的词与词之间的内在关系。</li>
<li>它们之间的权重参数，用的是嵌入层学习来的参数进行表征的编码。在神经网络反向传播优化的过程中，这个参数也会不断的更新优化。</li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Basic系列笔记</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Basic Concepts</tag>
        <tag>Info Encoding</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习基础系列笔记0——常见概念与函数（更新中）</title>
    <url>/2021/11/22/6afd3e085246/</url>
    <content><![CDATA[<h3
id="softmax和cross-entropy交叉熵函数">1、SoftMax和Cross-Entropy交叉熵函数</h3>
<p>​ 我们常常使用交叉熵（cross
entropy）来进行判别分布的相似性，交叉熵公式如下图所示：公式中pi和qi<img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/wpsCF9D.tmp.jpg"
alt="img" />为真实的样本分布和生成器的生成分布。</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114201037115.png" /></p>
<p>​
<strong><em>*Soft-Max*</em></strong>内部对输入进行的处理如下图所示，我们假设输入y1,y2,y3，我们先将三个输入计算exp(y1),exp(y2),exp(y3),然后求和，然后计算输出。</p>
<p>​ <img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114201047994.png" /></p>
<h3 id="kl散度">2、KL散度</h3>
<h3 id="sigmoid-function-s型激活函数">3、Sigmoid Function ( S型激活函数
)</h3>
<p>​ <img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114201125789.png" /></p>
<h3 id="rectified-linear-unit-relu激活函数">4、Rectified Linear Unit (
ReLu激活函数 )</h3>
<p>​ <img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114201156330.png"
alt="image-20220114201156330" /><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114201159496.png" /></p>
<h3 id="update-epoch-batch-size-training-data">5、Update / Epoch / Batch
Size / Training Data<br />
</h3>
<ul>
<li><p><strong>Update</strong>:
每做一次梯度下降，更新一次参数，就叫做一次Update</p></li>
<li><p><strong>Batch Size</strong>:
每次用来计算梯度下降更新参数用到的训练集中样本的个数</p></li>
<li><p><strong>Training Data</strong>:
所有的训练数据集样本，我们在训练时往往会将其分为一个Batch一个Batch，每次使用一个Batch来计算梯度，更新参数。</p></li>
<li><p><strong>Epoch</strong>:
每当使用过一轮所有的训练数据集样本以后，叫做一个Epoch</p></li>
</ul>
<p>整个的Optimization的过程如下所示：</p>
<p>​ <img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114201333605.png" /></p>
<p>下面是一些帮助理解的例子：</p>
<p><img
src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220114201341888.png" /></p>
<h3 id="backbone-head-neck-bottleneck">6、BackBone / Head / Neck /
BottleNeck</h3>
<ul>
<li>BackBone：翻译为主干网络，其是神经网络的主干部分。这个主干网络大多时候指的是提取特征的网络，其作用就是提取图片中的信息，以供后面的网络使用。这些网络经常使用的是ResNet、VGG等，而不是由我们自己设计的网络，因为这些主干网络已经证明了它们在分类等问题上的特征提取能力是很强的。在用这些网络作为backbone的时候，都是直接加载官方已经训练好的模型参数，后面接着我们自己的网络。让网络的这两个部分同时进行训练，因为加载的backbone模型已经具有提取特征的能力了，在我们的训练过程中，会对参数进行微调，使得其更适合于我们自己的任务。</li>
<li>Head：是获取网络输出内容的网络，head利用之前网络提取的这些特征，做出预测。</li>
<li>Neck:
是放在Backbone和Head之间的，是为了更好的利用Backbone提取的特征</li>
<li>Bottleneck:
瓶颈，通常指的是网络输入的数据维度和输出的维度不同，输出的维度比输入的小了许多.</li>
</ul>
<h3 id="ablation-study">7、Ablation Study</h3>
<p>​
消融研究，消融研究通常是指删除模型或算法的某些“功能”，并查看其如何影响性能。</p>
<p>​
在论文中一般来说会提出多个创新方法，或者新型结构模块，或注意力模块等。这些东西在一起为模型的性能作出了贡献。然而为了了解每个部分单独能发挥的作用，常常会在论文中提出消融研究。</p>
<p>​
例如某论文提出了方法A,B,C。而该论文是基于某个baseline的改进。因此，在消融研究部分，会进行以下实验，baseline
，baseline+A，baseline+B, baseline+C,
baseline+A+B+C等实验的各个评价指标有多少，从而得出每个部分所能发挥的作用有多大。</p>
<p>​ 比较简单来说，就是控制变量法，来判断某一个模块是否真的有作用。</p>
]]></content>
      <categories>
        <category>②  深度学习笔记</category>
        <category>Basic系列笔记</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Basic Concepts</tag>
      </tags>
  </entry>
</search>
