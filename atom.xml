<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fantast&#39;s Blog</title>
  
  
  <link href="https://blog.fantast.top/atom.xml" rel="self"/>
  
  <link href="https://blog.fantast.top/"/>
  <updated>2022-10-17T07:27:22.000Z</updated>
  <id>https://blog.fantast.top/</id>
  
  <author>
    <name>Fantast</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>事务</title>
    <link href="https://blog.fantast.top/2022/10/17/db76227bad93/"/>
    <id>https://blog.fantast.top/2022/10/17/db76227bad93/</id>
    <published>2022-10-17T07:09:19.000Z</published>
    <updated>2022-10-17T07:27:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一">一、</h3>]]></content>
    
    
    <summary type="html">Chap8——Mysql 事务</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Mysql日志与备份</title>
    <link href="https://blog.fantast.top/2022/10/17/02940cc83ca0/"/>
    <id>https://blog.fantast.top/2022/10/17/02940cc83ca0/</id>
    <published>2022-10-17T07:09:19.000Z</published>
    <updated>2022-10-17T07:27:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一">一、</h3>]]></content>
    
    
    <summary type="html">Chap11——Mysql 日志与备份</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Mysql逻辑架构和存储引擎</title>
    <link href="https://blog.fantast.top/2022/10/17/6d0d3039dfe2/"/>
    <id>https://blog.fantast.top/2022/10/17/6d0d3039dfe2/</id>
    <published>2022-10-17T07:09:19.000Z</published>
    <updated>2022-10-18T09:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一逻辑架构">一、逻辑架构：</h3><p>​ 使用经典的C/S架构，服务端程序使用的是mysqld服务，服务端大致分为三个步骤：</p><ul><li>连接管理（连接池）</li><li>解析和优化（SQL接口、解析器、优化器）</li><li>存储引擎（存储引擎和文件系统、日志文件）</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017154005406.png" /></p><h4 id="connectors">1、Connectors:</h4><p>​MySQL是一个网络i程序，本质上就是在TCP连接上，通过MySql协议跟Mysql服务器进行数据的交互</p><h4 id="连接管理">2、连接管理：</h4><p>​用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，<strong>都将依赖于此时读到的权限。</strong></p><p>​<strong>TCP连接池</strong>：用于限制连接数，可以采用长连接模式来复用TCP连接，解决上述问题</p><p>​<strong>线程池</strong>：TCP连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017161445894.png" style="zoom:50%;" /></p><h4 id="服务层">3、服务层：</h4><ul><li><p>SQL接口：</p><ul><li>接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT ...FROM就是调用SQL Interface</li></ul></li><li><p>Parser解析器：</p><ul><li>在解析器中对 SQL语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。</li><li><strong>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建语法树，并根据数据字典丰富查询语法树，会验证该客户端是否具有执行该查询的权限</strong></li></ul></li><li><p>Optimizer优化器：</p><ul><li><p>SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL语句的执行路径，生成一个执行计划。这个执行计划表明应该使用哪些索引进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。</p></li><li><p>它使用“ 选取-投影-连接”策略进行查询</p></li><li><pre><code>  SELECT id,name FROM student WHERE gender = &#39;女&#39;;</code></pre></li><li><p>这个SELECT查询先根据WHERE语句进行选取，而不是将表全部查询出来以后再进行gender过滤。这个SELECT查询先根据id和name进行属性投影，而不是将属性全部取出以后再进行过滤，将这两个查询条件连接起来生成最终查询结果。</p></li></ul></li><li><p>Caches &amp; Buffers： 查询缓存组件</p><ul><li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等。这个查询缓存可以在不同客户端之间共享</li></ul></li></ul><h4 id="引擎层">4、引擎层</h4><p>​ 插件式存储引擎层（ StorageEngines），真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作</p><h4 id="存储层">5、存储层：</h4><p>​所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在文件系统上，以文件的方式存在的，并完成与存储引擎的交互</p><h3 id="二sql执行流程">二、SQL执行流程：</h3><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017163209630.png" /></p><h4 id="查询缓存">1、查询缓存：</h4><p>​ 因为查询缓存往往效率不高，所以在 MySQL8.0之后就抛弃了这个功能。三大场景原因如下：</p><ul><li>在MySQL中的查询缓存，不是缓存查询计划，而是查询对应的结果。这就意味着查询匹配的鲁棒性大大降低，<strong>只有相同的查询操作才会命中查询缓存。</strong>两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。因此MySQL 的查询缓存命中率不高。</li><li>如果<strong>查询请求中包含某些系统函数、用户自定义变量和函数</strong>、一些系统表，如mysql 、 information_schema、 performance_schema数据库中的表，那这个请求就不会被缓存。</li><li>此外，既然是缓存，那就有它缓存失效的时候。<strong>MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，</strong>如对该表使用了INSERT、 UPDATE 、DELETE 、TRUNCATE TABLE 、ALTER TABLE 、DROP TABLE 或 DROPDATABASE语句，那<strong>使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！</strong>对于更新压力大的数据库来说，查询缓存的命中率会非常低。</li></ul><h4 id="解析器">2、解析器：</h4><ul><li><p>词法分析</p><ul><li>MySQL需要识别出SQL语句里面的字符串分别是什么，代表什么。是代表关键字还是表名</li></ul></li><li><p>语法分析</p><ul><li>根据词法分析的结果，语法分析器（比如：Bison）会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</li></ul></li><li><p>如果SQL语句正确，会生成一个语法树：</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017165049678.png" /></p></li></ul><h4 id="优化器">3、优化器：</h4><p>​ 在优化器中会确定 SQL语句的执行路径，优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序，还有表达式简化、子查询转为连接、外连接转为内连接等。</p><p>​在查询优化器中，可以分为<strong>逻辑查询优化阶段</strong>和<strong>物理查询优化阶段</strong>。</p><ul><li>逻辑查询优化就是通过改变SQL语句的内容来使得SQL查询更高效，同时为物理查询优化提供更多的候选执行计划。通常采用的方式是对SQL语句进行等价变换，对查询进行重写，而查询重写的数学基础就是关系代数。<strong>对条件表达式进行等价谓词重写、条件简化，对视图进行重写，对子查询进行优化，对连接语义进行了外连接消除、嵌套连接消除等</strong></li><li>物理查询优化是基于关系代数进行的查询重写，而关系代数的每一步都对应着物理计算，这些物理计算往往存在多种算法，因此需要计算各种物理路径的代价，从中选择代价最小的作为执行计划。在这个阶段里，对于单表和多表连接的操作，需要高效地使用索引，提升查询效率。</li></ul><h4 id="执行器">4、执行器：</h4><p>​在执行之前需要判断该用户是否具备权限。如果没有，就会返回权限错误。如果具备权限，就执行SQL查询并返回结果。</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017165434638.png" /></p><h4 id="语法顺序">5、语法顺序：</h4><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017170108824.png" /></p><h3 id="三数据库缓冲池">三、数据库缓冲池：</h3><p>​InnoDB存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘I/0需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS会申请占用内存来作为数据缓冲池，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的BufferPoo1之后才可以访问。</p><p>​ <strong>目的</strong>：减少与磁盘直接进行I/O的时间</p><h4 id="缓冲池">1、缓冲池：</h4><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017171714267.png" /></p><p>​缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟。所以InnoDB存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中，<strong>也就是说即使我们只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中。</strong>将整个页加载到内存中后就可以进行读写访问了，<strong>在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其缓存起来，这样将来有请求再次访问该页面时，就可以省去磁盘IO的开销了。</strong></p><p><strong>缓存原则：</strong></p><p>​ 优先对使用频次高的数据进行加载</p><p><strong>缓冲池的预读特性：</strong></p><p>​缓冲池的作用就是提升I/0效率，而我们进行读取数据的时候存在一个“局部性原理”，也就是说我们使用了一些数据，大概率还会使用它周围的一些数据，因此采用“预读”的机制提前加载，可以减少未来可能的磁盘I/O操作。</p><h4 id="缓冲池如何读取数据">2、缓冲池如何读取数据：</h4><p>​缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017172013707.png" /></p><p>​ 如果我们执行 SQL语句的时候更新了缓存池中的数据，那么这些数据会马上同步到磁盘上吗？</p><p>​实际上，当我们对数据库中的记录进行修改的时候，<strong>首先会修改缓冲池中页里面的记录信息，然后数据库会以一定的频率刷新到磁盘上。</strong></p><p>​注意并不是每次发生更新操作，都会立刻进行磁盘回写。缓冲池会采用一种叫做checkpoint的机制将数据回写到磁盘上，这样做的好处就是提升了数据库的整体性能。比如，当缓冲池不够用时，需要释放掉一些不常用的页，此时就可以强行采用checkpoint的方式，<strong>将不常用的脏页回写到磁盘上，然后再从缓冲池中将这些页释放掉。这里脏页（dirtypage）指的是缓冲池中被修改过的页，与磁盘上的数据页不一致。</strong></p><h4 id="多个buffer-pool实例">3、多个Buffer Pool实例：</h4><p>​ BufferPool本质是InnoDB向操作系统申请的一块连续的内存空间，在多线程环境下，访问BufferPool中的数据都需要加锁处理。<strong>在BufferPool特别大而且多线程并发访问特别高的情况下，单一的BufferPool可能会影响请求的处理速度。</strong>所以在BufferPool特别大的时候，我们可以把它们拆分成若干个小的BufferPool，<strong>每个BufferPool都称为一个实例，它们都是独立的，独立的去申请内存空间，独立的管理各种链表。所以在多线程并发访问时并不会相互影响，从而提高并发处理能力。</strong></p><h4 id="一些数据一致性问题">4、一些数据一致性问题</h4><figure><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017172737298.png"alt="image-20221017172737298" /><figcaption aria-hidden="true">image-20221017172737298</figcaption></figure><p>​ 假设我们修改BufferPool中的数据成功，但是还没来得及将数据刷入磁盘MySQL就挂了怎么办？按照上图的逻辑，此时更新之后的数据只存在于BufferPool中，如果此时MySQL宕机了，这部分数据将会永久地丢失；怎么办呢？</p><p>​ 使用Redo Log和Undo Log来解决</p><h3 id="四存储引擎">四、存储引擎：</h3><h4id="innodb引擎具备外键支持功能的事务存储引擎">1、InnoDB引擎：具备外键支持功能的事务存储引擎</h4><ul><li>默认事务型引擎，设计用于处理大量的短期事务，确保事务的完整提交和回滚</li><li>其为处理巨大数据量的最大性能设计</li><li>InnoDB写的处理效率会差一些，其会占用更多的磁盘空间来保存数据和索引</li><li>MyISAM只缓存索引，不缓存真实数据。InnoDB不仅缓存索引，还缓存真实数据，对内存要求较高，内存大小对性能有决定性的影响。</li></ul><h4id="myisam引擎主要的非事务处理存储引擎">2、MyISAM引擎：主要的非事务处理存储引擎</h4><ul><li>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM不支持事务、行级锁、外键，有一个毫无疑问的缺陷就是崩溃后无法安全恢复。</li><li>优势是访问的速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应用</li><li>应用场景：只读应用或者以读为主的业务</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221018172423185.png" /></p><h4 id="archive引擎用于数据归档">3、Archive引擎：用于数据归档</h4><h4id="csv引擎可以快速便捷和外界进行数据交换">4、CSV引擎：可以快速便捷和外界进行数据交换</h4><h4 id="memory引擎置于内存的表">5、Memory引擎：置于内存的表</h4><p>​ Memory采用的逻辑介质是内存，响应速度很快，但是当mysqld守护进程崩溃的时候数据会丢失。如下应用场景：</p><ol type="1"><li>目标数据比较小，而且非常频繁的进行访问，在内存中存放数据，如果太大的数据会造成内存溢出。</li><li>如果数据是临时的，而且必须立即可用得到，那么就可以放在内存中。</li><li>存储在Memory表中的数据如果突然间丢失的话也没有太大的关系。</li></ol>]]></content>
    
    
    <summary type="html">Chap8——Mysql 逻辑架构和存储引擎相关内容</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Mysql索引及调优原则</title>
    <link href="https://blog.fantast.top/2022/10/17/210c29af78f2/"/>
    <id>https://blog.fantast.top/2022/10/17/210c29af78f2/</id>
    <published>2022-10-17T07:09:19.000Z</published>
    <updated>2022-10-18T12:45:45.994Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一为什么使用索引优缺点">一、为什么使用索引&amp;优缺点：</h3><p>​避免全表扫描，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据。</p><p>​如上图所示，数据库没有索引的情况下，数据分布在硬盘不同的位置上面，<strong>读取数据时，摆臂需要前后摆动查找数据，这样操作非常消耗时间。</strong></p><p>​索引是一种数据结构，每个节点缓存的是一个Key-Value结构，Key是列的值，Value是该Key所在行对应的指针（文件位置）。</p><h4 id="优点">优点：</h4><ul><li>降低数据库的IO成本，提高数据检索的效率</li><li>加速表和表之间的连接。对于有依赖关系的子表和父表联合查询时，提高速度</li><li>显著减少查询中分组和排序的时间，降低CPU消耗</li></ul><h4 id="缺点">缺点：</h4><ul><li>创建和维护需要耗费时间</li><li>索引需要占据磁盘空间。</li><li>索引提高查询速度的同时，会降低更新表的速度。</li></ul>]]></content>
    
    
    <summary type="html">Chap9——Mysql 索引及调优原则</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>电子信息工程中数学模型与方法——单元2 系统辨识</title>
    <link href="https://blog.fantast.top/2022/10/12/f71a1b069441/"/>
    <id>https://blog.fantast.top/2022/10/12/f71a1b069441/</id>
    <published>2022-10-12T00:14:20.782Z</published>
    <updated>2022-09-28T01:09:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一模型智能">一、模型智能</h2><h3 id="什么是智能">1、什么是智能？</h3><p>​ 智能有三个层次（某IBM科学家）：感知智能，执行智能，认知智能</p><ul><li>感知智能：感知环境状态</li><li>执行智能：采取行动</li><li>认知智能：建模、分析与决策，认知智能是最高级智能</li></ul><p>认知智能是动物和人建立/改进环境模型（规律的表述），使用模型处理信息并做出预测和决策的能力</p><ul><li><p>理想人工智能:人工智能是研究模拟和扩展动物和人的智能的理论和方法，包含感知智能、执行智能和认知智能。</p></li><li><p>当前人工智能：现在的所谓人工智能大都是开发基于图像和声音的感知技术。所以当前的人工智能还在感知智能的层次</p></li></ul><p>下图为自动控制流程：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220923163300371.png" style="zoom:67%;" /></p><ul><li><strong>一个系统的最优控制器一定是该系统的数学模型!</strong></li></ul><h3 id="基于智能建模的智能建造技术">2、基于智能建模的智能建造技术：</h3><ul><li><p>流程工业包括石化、化工、发电、钢铁、水泥、造纸、采矿等，是国民经济的基础</p></li><li><p>催生一个巨大的流程工业智能制造市场，在流程工业实现全面自动化生产，即智能制造，可以节能1%-10%，提高收益0.1% - 2%，减少污染物生成5% - 50%</p></li></ul><p>计划调度、诊断监控、实时优化、模型预测控制、常规PID控制、设备仪表及DCS系统</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220923163633152.png" /></p><p><strong>过程模型的建立/维护，是实现每一层自动/闭环的关键</strong></p><p><strong>模型智能：</strong>模型智能是一个计算机算法（软件），对于一类给定过程，可以对其自动建模、自动维护模型、并自动使用模型进行预测、控制、优化及诊断</p><h4 id="系统辨识的渐进法">1）系统辨识的渐进法：</h4><ul><li>多变量、闭环、自动系统辨识（建模）技术<ul><li>• 自动最优激励信号设计，多变量、闭环、自动测试</li><li>• 自动确定模型阶次</li><li>• 自动模型参数估计（计算）</li><li>• 自动模型检验，给出每个模型A, B, C, D评级</li></ul></li></ul><h4 id="pid闭环参数整定">2）PID闭环参数整定</h4><p>​PID控制器以其结构简单、稳定性好、调整方便而成为应用最广泛的一类工业控制器。</p><ul><li>问题核心：PID控制器参数整定困难</li><li>参数整定方法：</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220923164457568.png" style="zoom:67%;" /></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220923164619424.png" /></p><h4 id="模型预测控制">3）模型预测控制：</h4><p>​模型预测控制：是指利用对象的历史信息和模型信息，通过在未来时段上优化过程输出来计算最佳输入序列的一类算法。</p><p>​ <strong>关键环节：</strong>预测模型、滚动优化、反馈校正</p><p>​ 减少波动以后就可以卡边操作</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220923164911006.png" style="zoom:67%;" /></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220923165006259.png" /></p><h4 id="总结">3、总结：</h4><ul><li>动态模型是智能制造的关键，模型才是智能</li><li>团队经过多年研发，流程工业系统的智能建模、控制及优化技术已成熟，包括:(1) 基础控制层; (2) 先进控制层; (3) 实时优化层</li><li>可在各流程工业普及应用，节能减排、提高收益</li></ul><h2id="二系统辨识动态数据建模的理论和方法">二、系统辨识——动态数据建模的理论和方法：</h2><h3id="系统辨识介绍系统辨识的关键步骤">1、系统辨识介绍（系统辨识的关键步骤）</h3><ul><li><p>系统 System：系统是以有序形式排列的对象的集合，用于某种目的</p></li><li><p>过程 Process:过程是用于在流程工业中制造均质材料或能源产品的加工厂。加工工业包括：石油、化工、电力、造纸、玻璃、采矿、金属、水泥、药品、食品</p></li><li><p>模型 Model:模型是一个系统（过程）基本方面的表示，表示该系统的知识</p></li><li><p>数学模型 Mathematical Models:用微分方程和代数方程描述系统变量之间的关系。工程领域的主要部分涉及使用数学模型进行设计、模拟、预测和控制/优化。</p></li><li><p>系统辨识：系统或过程识别是使用测试数据对系统（过程）进行数学建模的领域。从技术上讲，Zadeh（1962）将系统识别定义为：在输入和输出的基础上，确定特定类别系统（模型）内的系统模型。</p></li><li><p><strong>系统辨识的过程</strong></p></li></ul><figure><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220923173506705.png"alt="image-20220923173506705" /><figcaption aria-hidden="true">image-20220923173506705</figcaption></figure><p><strong>系统辨识的关键步骤</strong>：</p><p>1）识别测试，辨识实验的设计 Identification tests/experiments：生成信息，输入输出数据</p><p>2）模型结构选择 Model order/structure selection：线性或非线性，什么结构（MIMO），什么顺序？</p><p>3）参数估计Parameter estimation ：使用一些优化技术确定模型参数。</p><p>4） 模型验证Model validation:：检查获得的模型是否足够好，是否能够使用（目的），如果不够，给出补救方法。</p><h3 id="动态系统和信号的模型">2、动态系统和信号的模型：</h3><h4id="单输入单输出连续时间模型siso-continuous-time-models">1）单输入单输出连续时间模型：SISOContinuous-Time Models</h4><p>​ 最常用的是<strong>微分方程</strong>和<strong>传递函数</strong>：</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927194052145.png" /></p><p>​ <imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927194102312.png" /></p><p>还可以用<strong>脉冲响应模型</strong>进行描述：<strong>引入延迟算子</strong></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927194118895.png" /></p><h4 id="单输入单输出离散时间模型">2）单输入单输出离散时间模型：</h4><p>一个使用保持电路的计算机控制系统采样过程</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927194329943.png" /></p><ul><li><p>Zero-Order Hold 即零阶保持器，只有一个设置<ahref="https://so.csdn.net/so/search?q=采样&amp;spm=1001.2101.3001.7020">采样</a>时间的参数，表示的是以采样时间间隔进行数据的采集；</p></li><li><p>Unit Delay即单位延迟模块，有两个输入参数，类似于<ahref="https://so.csdn.net/so/search?q=寄存器&amp;spm=1001.2101.3001.7020">寄存器</a>，第一个是设置初始值，第二个是采样时间。</p></li><li><p>Zero-Order Hold模块是以当前时间点以后的值为准，而UnitDelay是以当前时间之前的值为准。</p></li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927221208577.png" style="zoom:67%;" /></p><ul><li>在<strong>离散时间模型中</strong>引入延迟算子就能得到相应的离散传递函数：</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927221358771.png" style="zoom:50%;" /></p><ul><li><p>对一个n阶的差分方程使用0阶保持器：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927221507779.png" style="zoom:67%;" /></p></li></ul><h4 id="信号的几种模型描述方式">3）信号的几种模型描述方式</h4><h5 id="频域框架有限序列的信号的周期图">-频域框架：有限序列的信号的周期图：</h5><ul><li>通过傅里叶变化：可以得到信号的周期图</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927221626122.png" style="zoom:50%;" /></p><ul><li><p><strong>信号的周期图：periodogram</strong> ——反映了信号在各个频域点上能量贡献的大小</p></li><li><p>Parsevals恒等式： 左侧是时间域，右侧是频域</p></li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927221815400.png" /></p><p>​ 信号在时间域内拥有的总能量等于其在频域内各个频率的能量的总和</p><h5 id="概率框架信号功率谱-signal-spectra">- 概率框架：信号功率谱 signalspectra</h5><ul><li><p>随机过程：一组信号，在每个时刻都是一个随机变量。</p></li><li><p>平稳随机过程：这个随机过程，其均值属性不随时间变化</p></li><li><p>自相关函数和功率谱</p></li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927222142483.png" style="zoom:50%;" /></p><ul><li>给定两个平稳随机过程v(t)s(t)：互相关函数，和互功率谱（是互相关函数的傅里叶变换）：</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927222301599.png" style="zoom: 50%;" /></p><ul><li>如果给定一个随机过程的实现v(t),可以用时间算子代替数学期望可以估计自相关函数，从而估计功率谱</li></ul><p>但这样一个过程是有一个假设的，这个假设就是 Ergodicprocess（个态遍历）也就是：当N趋于正无穷，时间平均值趋于整体平均</p><h5 id="白噪声信号white-noise-process">- 白噪声信号White noiseprocess:</h5><p>​ 零均值和方差 R 的独立同分布随机变量序列。</p><p>​<strong>特点</strong>：白噪声没有记忆，t时间的信号值和t时间前的值完全无关，也就是可以导出下图中说的重要规则：</p><p><strong>每个平稳随机过程 {v(t)}都可以通过稳定的最小相位滤波器对白噪声滤波来生成</strong></p><p>​ <imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927222909082.png" /></p><h3 id="有扰动情况下的线性过程描述">3、有扰动情况下的线性过程描述：</h3><p>​假设v(t)是稳定随即过程，利用上述的结论，我们可以使用下述这个形式来表示有扰动情况下的线性过程的描述。之后关键就是在这个模型下进行利用实验数据估计G(q)和H(q)</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927223152305.png" style="zoom:50%;" /></p><h2 id="三系统辨识辨识实验设计">三、系统辨识——辨识实验设计</h2><h3 id="辨识实验identification-test的必要性">1、辨识实验IdentificationTest的必要性</h3><ul><li>辨识实验（控制）的目的是激发和收集（控制）相关信息。</li><li>测试期间使用测试信号/激励。</li><li>辨识实验是一种成本，但不要干扰正常生产。</li><li>良好的辨识实验是成功识别/控制的关键。</li><li>没有良好的辨识实验就是数据输入垃圾输出。</li></ul><p><strong>辨识实验是有代价的</strong>：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927223723009.png" style="zoom:50%;" /></p><h3 id="preliminary-tests-预测试">2、Preliminary Tests 预测试</h3><p>目的是为了获得先验知识</p><h4 id="收集历史数据collect-historic-data-p3">1）收集历史数据Collecthistoric data P3</h4><p><strong>一般来说，历史数据对于模型来说不够丰富，或者换句话说，信噪比太低（例如90％的噪声，10％的信号）</strong></p><ul><li>获得过程的第一印象。</li><li>过程的输出 (CV) 代表未测量的干扰。</li><li>MV 的动作代表操作员的控制。</li><li>简单又便宜。 数据库可用于大多数流程。</li><li>与操作者交谈并向他们学习。</li></ul><h4 id="阶跃实验short-step-test-p4">2）阶跃实验Short step test P4</h4><ul><li>将每个操作变量上下操作一些次数</li><li>检查主要时间常数、增益和延迟</li><li>检查并调整 MV PID 回路。</li><li>控制工程师可以通过观察过程阶跃响应直观地了解过程动态。</li><li>低成本测试。</li></ul><h4id="阶梯实验了解对象的非线性程度">3）阶梯实验：了解对象的非线性程度</h4><ul><li>将阶梯信号应用于某些 MV。</li><li>目的是检查非线性。</li><li>高成本测试，通常不允许</li></ul><h3 id="系统辨识中常见的实验信号">3、系统辨识中常见的实验信号</h3><p>实验信号有两个方面的因素需要考虑：信号波形和频谱的要求 wave form andfrequency content</p><ul><li>信号波形（时域）要求： -<ul><li>在正常操作中不会引起干扰（比较脉冲和阶跃）。</li><li>不激发过程非线性（比较脉冲和步骤）。</li><li>操作员友好（比较脉冲和阶跃）。</li></ul></li><li>信号频率成分（功率谱）设计：<ul><li>测试信号的功率谱会影响控制性能。</li><li>用于控制目的的最佳频谱设计。</li></ul></li></ul><h4 id="prbs-二进制伪随机信号">1）PRBS 二进制伪随机信号：</h4><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927224849434.png" /></p><ul><li><p>Clock是时钟脉冲</p></li><li><p>State是移位寄存器</p></li><li><p>移位寄存器产生的序列，最大的周期为 M 即 2^n-1 称为M序列</p></li><li><p>统计特性：（均值、自相关函数、频谱图）</p></li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927225042867.png" /></p><p>​该实验信号模型可以很好的模拟一个白噪声信号，但是这种信号切换频率太快，对工业的装置影响太大。同时其对于中低频信号不友好，比较偏重于高频。而系统辨识需要中低频信号</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927225345044.png" style="zoom:67%;" /></p><p>​ 所以需要调整我们的PRBS来产生低通特性的PRBS信号：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927225321648.png" style="zoom:67%;" /></p><h4 id="gbngeneralized-binary-noise-广义二值化信号">2）GBN(generalizedbinary noise) 广义二值化信号</h4><p>​ 信号翻转的概率，按照如下图：Generation rule进行信号的生成：</p><p>​ psw为切换概率</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927225457178.png" /></p><p>​<strong>通过降低切换概率，增加切换时间来获得低通的信号，来进行辨识信号实验。</strong></p><h4 id="pbrs和gbn对比">3）PBRS和GBN对比：</h4><ul><li>相比于PRBS来说，PRBS在一些特殊的2pi的点等于0，不接近实际，而GBN不会。同时，PRBS有最长周期，而GBN没有，可以随意选择</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927225706274.png" /></p><h4id="持续激励的测试信号persistent-excitation-of-a-test-signal">4）持续激励的测试信号：Persistentexcitation of a test signal</h4><ul><li>N阶的持续激励信号：需要满足以下条件：</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927225916291.png" style="zoom:50%;" /></p><ul><li>N阶持续激励的频域解释：n阶持续激励的频域解释是信号的频谱在区间（-pi,pi）内至少n个频率中不为零</li><li>PRBS和GBN信号的区别：</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927230015132.png" /></p><h3 id="模型辨识的测试最终测试">4、模型辨识的测试，最终测试</h3><h4 id="mpc控制的测试设计">1） MPC控制的测试设计</h4><ul><li>测试时间：<ul><li>小系统或低噪音：（6~10）*（稳定时间 settling time）</li><li>大型系统或高噪音：(12 ~ 20) *(稳定时间 settling time)</li></ul></li><li>信号类型：GBN -</li><li>信号步长：根据预先测试和与操作员的讨论确定。从小开始，可以在测试过程中进行调整-</li><li>信号平均切换时间（功率谱）：</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927230237868.png" style="zoom:50%;" /></p><ul><li><p>GBN信号可以同时做若干个实验，不同实验互不相关。</p></li><li><p>每个测试的MV个数，以及测试信号的相关性：</p><ul><li>每次测试的 MV 数量：开环测试最多 10 个 MV； 在闭环测试中所有MV。</li><li>测试信号之间的相关性：通常独立；对于条件不佳的过程（例如高纯度蒸馏塔），某些 MV之间的强相关性可能会有所帮助。</li></ul></li></ul><h4 id="闭环实验测试">2）闭环实验测试：</h4><ul><li>大多数工业应用使用开环测试。</li><li>20年前，业界不相信的过程是 可使用闭环数据识别。</li><li>可以在设定点或 MV 处应用测试信号</li><li><strong>闭环测试对过程操作的干扰较小</strong></li><li>闭环测试易于进行。</li><li>来自闭环测试数据的模型更适合控制。</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927230553891.png" /></p><h2id="四系统辨识最小二乘的系统辨识方法">四、系统辨识——最小二乘的系统辨识方法</h2><h3 id="最小二乘的原则p20页-由高斯提出">1、最小二乘的原则：P20页由高斯提出</h3><h3id="基于最小二乘估计线性过程的模型arx模型">2、基于最小二乘，估计线性过程的模型——ARX模型</h3><p>用n阶差分方程描述：</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927230958268.png" /></p><p>引入误差项：</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927231012557.png" /></p><p>首先进行等式重组：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927231103308.png" style="zoom: 50%;" /></p><p>在系统辨识实验测试后，我们可以得到数据集，并且使用数据来填充等式：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927231138550.png" style="zoom:50%;" /></p><p>最后，通过最小化如下的目标函数来估计模型参数：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927231216488.png" style="zoom:50%;" /></p><p>如下为解：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927231234423.png" style="zoom:50%;" /></p><h3 id="工业实例">3、工业实例：</h3><figure><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927231336491.png"alt="image-20220927231336491" /><figcaption aria-hidden="true">image-20220927231336491</figcaption></figure><h3 id="最小二乘估计的属性">4、最小二乘估计的属性：</h3><p><strong>估计器的理想（良好）属性：</strong></p><ul><li>无偏估计 Unbiased estimator</li><li>一致的估计器 Consistent estimator</li><li>有效或最小方差估计器 Efficient or minimum variance estimator:</li></ul><p><strong>原始的最小二乘估计器是无偏的</strong></p><p><strong>ARX模型是有偏的，因为A2不保持</strong></p><h2 id="五最小二乘模型的扩展">五、最小二乘模型的扩展：</h2><h3 id="输出误差方法-output-error-method">1、输出误差方法 Output-errormethod</h3><p>​ 其存在一个大的数值问题：输出误差在 A(q) 参数中是非线性的。不存在解析（封闭形式）解决方案，也无法保证全局最小值。</p><h4 id="关于一致性的证明">1）关于一致性的证明：</h4><ul><li>真实过程由 (5.1.4) 给出，其中 v(t) 是零均值的平稳随机过程。</li><li>模型阶数 n 正确。</li><li>输入持续兴奋，阶数高于 2n。</li><li><strong>测试是开环的。</strong></li><li>最小化收敛到所有 N 的全局最小值。</li><li>A(q) 和 B(q) 没有公因数。</li></ul><h3 id="预测误差方法-prediction-error-methods">2、预测误差方法Prediction error methods</h3><p>该方法实现：1）闭环测试的一致性（无偏性） 2)开环和闭环的效率（最小方差）。</p><p>ARMAX 模型：</p><ul><li>一些控制设计方法的良好模型结构。、</li><li>数值优化是必要的，不能保证全局最小值</li></ul><p>BOX-Jenkins模型：</p><h4 id="预测误差方法的属性">预测误差方法的属性：</h4><ul><li>假设：（1）过程稳定； (2)模型结构正确； (3) 测试信号持续激励； (4)最小化收敛到其全局最小值</li></ul><h3 id="阶次选择-order-selection">3、阶次选择 Order Selection</h3><ul><li>目的：找到模型阶次，以便模型对其使用最准确（在控制中）。<ul><li>粗阶选择方法：检查协方差矩阵的秩，绘制 Hankel 矩阵的奇异值。对于嘈杂的数据不准确。</li><li>准确的方法：首先估计具有递增阶数的模型，然后使用错误准则选择最佳阶数。</li></ul></li><li>主要议题：什么策略？什么数据集？<ul><li>在识别文献中，预测误差准则常用于模型阶数选择。 -</li><li>交叉验证的缺点是成本高。 使用估计数据进行模型阶数选择更经济。</li><li>使用估计数据的错误标准是使用验证数据的错误标准的有偏估计。</li></ul></li></ul><p><strong>输出误差小并不能保证仿真误差小</strong></p><ul><li><p>仍然需要证明 FOE 是对验证数据的 OE 标准的无偏估计。</p></li><li><p>我们可以将这种使用不同标准进行模型估计和订单选择的交叉标准方法称为方法。</p></li></ul><h3 id="模型验证-model-validation">4、模型验证 Model Validation</h3><p>检查获得的模型是否足以使用（控制），如果没有，提供补救措施（做什么</p><p>将模型属性与过程知识进行比较。 粗略估计过程增益，主要时间常数。</p><p>使用模型阶跃响应图。 检查不同方法的一致性。 估计 FIR、ARX、ARMAX 和Box-Jenkins 模型并比较它们的阶跃响应和频率响应</p><h4 id="残差分析">1) 残差分析：</h4><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220928090759861.png" style="zoom:50%;" /></p><ul><li>一个批评意见：控制的识别没有解决。 （这类模型是否适用于控制）<ul><li>前三种方法或多或少是定性测试。</li><li>残差分析是检查模型是否与测试数据充分吻合。</li><li>没有一种方法可以判断模型是否适合控制。</li><li>如果一个模型通过了残差分析，它只告诉给定数据获得了好的模型。但是数据是否足够好（用于控制）？</li></ul></li></ul>]]></content>
    
    
    <summary type="html">本篇笔记为电子信息工程中数学模型与方法——单元2 系统辨识的相关知识整理，用于学在浙大考试。</summary>
    
    
    
    <category term="⓾ 课程笔记" scheme="https://blog.fantast.top/categories/%E2%93%BE-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="电子信息工程数学模型与方法" scheme="https://blog.fantast.top/categories/%E2%93%BE-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    
    
    <category term="course" scheme="https://blog.fantast.top/tags/course/"/>
    
  </entry>
  
  <entry>
    <title>电子信息工程中数学模型与方法——单元3 电磁系统</title>
    <link href="https://blog.fantast.top/2022/09/30/2742f0d23b8a/"/>
    <id>https://blog.fantast.top/2022/09/30/2742f0d23b8a/</id>
    <published>2022-09-30T04:13:19.000Z</published>
    <updated>2022-10-02T07:29:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一概述和基本理论">一、概述和基本理论</h2><h3 id="麦克斯韦方程组">1、麦克斯韦方程组：</h3><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221002113642895.png" /></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221002113659170.png" /></p><h3 id="平面电磁波">2、平面电磁波：</h3><ul><li><p>波 : 扰动、能量、或物理信息在空间上传播的一种物理现象；</p></li><li><p>电磁波 : 传播电磁能量的波；</p></li><li><p>平面电磁波 :波前（等相位面）是平行面且与传播方向垂直的固定频率电磁波；</p></li><li><p>亥姆亥兹方程（Helmholtz’s equation）</p></li></ul><p><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150037334.png" /></p><ul><li>电场强度表达式：</li></ul><p><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150210202.png" /></p><p><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150222274.png" /></p><ul><li><p>磁场强度表达式：</p><figure><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150256704.png"alt="image-20221002150256704" /><figcaption aria-hidden="true">image-20221002150256704</figcaption></figure></li></ul><h3 id="特征阻抗">3、特征阻抗：</h3><p>电场强度和磁场强度的幅值比值定义为某种材料的特征阻抗</p><p><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150355839.png" /></p><h3 id="电磁辐射天线辐射">4、电磁辐射—天线辐射</h3><p>​ 分为近场和远场，近场又分为两个</p><p><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150510352.png" /></p><p>​ 在比较远的地方可以等价于一个平面波的形式</p><p><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150516797.png" /></p><h3 id="电磁辐射赫兹偶极子">5、电磁辐射—赫兹偶极子：</h3><h3 id="电磁辐射半波长偶极子">6、电磁辐射—半波长偶极子</h3><h3 id="电磁辐射天线应用-p24-26">7、电磁辐射—天线应用 P24-26</h3><figure><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150915273.png"alt="image-20221002150915273" /><figcaption aria-hidden="true">image-20221002150915273</figcaption></figure><ul><li>移动手机 P26-27</li><li>笔记本电脑 P28-29</li><li>无线可穿戴设备 P30-31</li><li>无线电识别天线 P32-33<ul><li>无线电识别：一种用来在一定距离无线识别的电子贴片技术。</li></ul></li><li>工作范围：P３４　　近场和远场</li><li>工作模式：被动（Passive Tag 主动（ Active Tag 半被动（ Semi passiveTag)<ul><li>被动：<ul><li>没有电源，使用从读卡器上的能量来充能并且传输数据到读卡器</li><li>更小，更廉价</li><li>往往只有很短的读取距离</li></ul></li><li>主动：<ul><li>有电源，tag先传输，然后是reader</li><li>更长的读取距离，100m或以上</li><li>昂贵，使用时间较有限</li></ul></li></ul></li></ul><h3 id="电磁感应无线传能">8、电磁感应—无线传能</h3><h3 id="电磁感应全息成像">9、电磁感应—全息成像</h3><h3 id="电磁辐射穿透性-p39">10、电磁辐射—穿透性 P39</h3><h2 id="二电磁散射系统建模和可视化">二、电磁散射系统建模和可视化</h2><h3 id="电磁散射基本理论-狄拉克格林函数">1、电磁散射基本理论狄拉克格林函数</h3><h3 id="瑞利散射">2、瑞利散射</h3><p>​ 半径比光或其他电磁辐射的波长小很多（ （&lt;0.1 𝜆）的 微小颗粒（例如单个原子或分子）对入射光束的散射。</p><p>​瑞利散射在光通过<strong>透明的固体和液体时都会发生，但以气体最为显著。</strong></p><figure><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002152515412.png"alt="image-20221002152515412" /><figcaption aria-hidden="true">image-20221002152515412</figcaption></figure><ul><li>总的辐射能量与波数的四次方成正相关，与波长的四次方成反相关。频率越高，瑞利散射越强</li><li>公式见P7</li></ul><h3 id="米氏散射">3、米氏散射：</h3><p>​ <strong>当 微粒半径的大小接近于或大于入射光线的波长 λ的时候</strong>，大部分的入射光线会沿着前进的方向进行散射，这种现象被称为米氏散射。​<strong>散射场几乎与波长无关；前向波比较大 ;物体大小越大，前向波越大</strong></p><p>​这种大微粒包括灰尘，水滴，来自污染物的颗粒物质，如烟雾等。即s是形成所谓的丁达尔效应</p><p><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002152726428.png" /></p><ul><li>为什么天空是蓝色、红色（傍晚）、白色（云）？</li></ul><p>​ 瑞利散射：波长的四次方成反相关，即频率越高，瑞利散射越强</p><p><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002152752906.png" /></p><h3 id="应用微波近场扫描显微成像">4、应用：微波近场扫描显微成像：</h3><p><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002152904823.png" /></p>]]></content>
    
    
    <summary type="html">本篇笔记为电子信息工程中数学模型与方法——单元3 电磁散射、逆问题系统建模及可视化的相关知识整理，用于学在浙大考试。</summary>
    
    
    
    <category term="⓾ 课程笔记" scheme="https://blog.fantast.top/categories/%E2%93%BE-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="电子信息工程数学模型与方法" scheme="https://blog.fantast.top/categories/%E2%93%BE-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    
    
    <category term="course" scheme="https://blog.fantast.top/tags/course/"/>
    
  </entry>
  
  <entry>
    <title>电子信息工程中数学模型与方法——单元1 工业智能</title>
    <link href="https://blog.fantast.top/2022/09/19/e947a7cc4335/"/>
    <id>https://blog.fantast.top/2022/09/19/e947a7cc4335/</id>
    <published>2022-09-19T02:40:19.000Z</published>
    <updated>2022-09-19T08:09:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2id="一以模型为核心的工业智能工信融合与工业智能">一、以模型为核心的工业智能——工信融合与工业智能</h2><h3 id="工业文明发展和工信融合-p9">1、工业文明发展和工信融合 P9</h3><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220919140907698.png" alt="image-20220919140907698" style="zoom:33%;" /></p><ul><li>我国工业面临的形式和发展目标 P13</li><li>什么是两者领域的深度融合？ P14</li></ul><h3 id="智能人类智能和工业智能">2、智能：人类智能和工业智能</h3><ul><li>人类心智的八个范畴 P19</li><li>什么是智能？什么是智慧？智能的进化属性？理解工程科学的智能 P20</li><li>工业智能的八个范畴 P24</li><li>人擅长做的：感知、决策和执行</li></ul><h3 id="控制视角和控制前沿">3、控制视角和控制前沿</h3><ul><li>工业系统信息物理深度融合面临的主要挑战 P28<ul><li>综合认知难、融合表达难、协同调控难、安全防护难</li></ul></li><li>实时、精准的综合信息感知 P29</li><li>工业大数据的综合表达与认知 P30</li><li>人-机-物协同的智能控制与优化 P31</li><li>三元空间的一体化安全防护 P32</li><li>智能工厂的内涵 P41</li><li>无人驾驶和无人工厂 共性和区别 P42</li><li>工厂智能化的技术分级：范围、能力、效益 L0-L5 P43</li></ul><h3 id="流程工业的智能化之路">4、流程工业的智能化之路</h3><ul><li>工业运行方式的变迁 P46 47<ul><li>流程工业是形成人类物质文明的基础工业</li><li>流程工业的行业特点、新需求等</li><li>人工控制——少量仪表——中控系统——现代化大型控制室</li></ul></li><li>设计型技术和运行型技术：P48<ul><li>设计型技术：产品和工艺设计-&gt;高附加值产品、新工艺</li><li>运行型技术：生产和制造-&gt;高效、高适应性生产。不增加太多投资的情况下取得显著的经济效益，投资小见效快是最集中体现流程企业操作运行“智能”的技术关键</li><li>流程工业生产运行的新需求：高效、柔性。</li></ul></li><li>什么是智能？工厂的指挥、智慧工厂的工作流 P52</li><li>无人化工厂的技术核心：P53<ul><li>人工智能：算力、数据、算法</li><li>工业智能：建模、控制、优化</li><li>大工业：工艺、流程、设备</li></ul></li><li>无人化工厂的新目标：P54</li></ul><h2id="二以模型为核心的工业智能过程系统建模与分析运行">二、以模型为核心的工业智能——过程系统建模与分析运行：</h2><h3 id="引言">1、引言</h3><ul><li>机理模型（白箱）：P59</li><li>数据模型（黑箱）：P59</li></ul><h3 id="过程系统简介">2、过程系统简介</h3><ul><li>过程系统的结构</li><li>流程工业的典型生产过程：（反应 + 分离 很重要）<ul><li>化工过程是由一个个加工过程组成的，可以分为两类：化学反应过程，物理加工过程。</li><li>化学反应过程对应的设备为反应器，物理加工过程对应的设备为单元操作。</li><li>所有单元操作都属于动量、热量、质量的传递速率控制过程</li><li>单元操作的种类：P68</li><li>过程系统工程：以数学模型、计算机辅助为基础的效能分析、设计放大、操作调整</li></ul></li><li>田纳西过程：P69<ul><li>操作变量：用于调节生产运行状态的手段。通常是阀门开度或者电机转速。</li><li>测量变量（生产装置的眼睛）：现场仪表或实验室分析手段所能测量的流量、温度、压力、液位、组分等变量。通过测量变量可以了解生产过程的工作状</li><li>运行约束：运行约束一般包括设备操作范围的约束，产品约束，安全约束等。</li><li>优化目标：常见的优化目标包括提高产品收率、降低生产能耗等。</li></ul></li></ul><h3 id="模型描述和求解">3、模型描述和求解</h3><ul><li><p>装置与流股： P77</p><ul><li>全流程的机理模型是由单个装置的机理模型+连接关系组合而成的</li><li>装置与装置之间的连接称为流股Stream（包括物质流股和能量流股）</li><li>物质流股S由流量、组分、温度、压力来描述。能量流股H由热量和温度来描述。</li></ul></li><li><p>连接关系与全流程模型 P78</p></li><li><p>仿真问题与反问题：</p><ul><li><p>仿真问题：可用于回溯分析，what-if分析（就是如果输入调整，输出会如何改变）</p></li><li><p>仿真问题反问题：</p><ul><li><p>要求输出流股(产品)的状态为Y，相应的输入流股(进料)条件是怎样的？(操作问题)</p></li><li><p>设备参数应该如何选择？(设计问题)</p></li><li><p>获得了输入流股、输出流股等数据，如何反推设备参数？(参数估计问题)</p></li></ul></li></ul></li><li><p>序贯求解</p><ul><li>当进料条件为X时，产品的状态是怎样的？</li><li>当流程中存在回路Recycle时，需要先断开某个流股（割裂流股），才能够序贯求解。回路的存在使得求解过程更加复杂</li><li><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220919154605965.png" /></li><li>优化问题：怎样的进料条件，使得A产品产量最高/生产能耗最低/有害物质产出最少？</li></ul></li><li><p>物质流 &amp; 能量流 &amp; 信息流：P83</p></li><li><p>单个装置的建模：装置的方程 P84</p></li><li><p>全流程机理模型的层次化特征：</p><ul><li>上述两类方程及流程单元的连接构成层次化特征，多层次的模型造成了机理模型的复杂性。</li><li><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220919155241488.png" /></li></ul></li><li><p>完整模型的序贯求解：P91</p><ul><li>上述多层次结构中的每个层次的模型通常都没有closedform的解。也就是说序贯求解的思路需要在每个层次上，需要迭代求解那个层次的方程组。因此，完整模型序贯求解的工作流呈现出一种“洋葱结构”。</li></ul></li><li><p>机理模型联立求解：</p><ul><li>对于复杂耦合流程的优化问题，采用序贯法求解时迭代过程嵌套层数多，内外层信息传递复杂、收敛难度大。采用联立方程法求解可以避免这一问题</li><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220919155604175.png" style="zoom:50%;" /></li></ul></li></ul><h3 id="不同类型的命题">4、不同类型的命题</h3><ul><li>仿真或WHAT-IF分析 P95</li><li>灵敏度分析：灵敏度分析一般是各种优化问题求解的前置步骤</li><li>设计优化、操作优化：包括设备操作范围的约束、产品约束、安全约束</li><li>参数估计：参数估计需要使用实际装置的测量数据𝑦0。实际的测量数据存在噪声、静差等，需要先进行校正和滤波，然后再用于参数估计</li><li>稳态与动态：稳态是指各生产变量基本保持不变的平稳的运行状态动态是指两个稳态之间的过渡过程</li><li>动态优化问题：动态优化的结果不再是一个数值，而是一个时间序列𝑢(𝑡)</li></ul><h3 id="数学建模的步骤">5、数学建模的步骤</h3><ul><li>模型建立：工艺分析和简化装置数学模型的建立 P103<ul><li>（建模假设、模型变量建立、机理方程的建立）</li></ul></li><li>命题求解：数学模型的变换和化简，模型的编程实现，数学规划命题的求解P103</li><li>结果分析：求解结果是否正确，是否符合预期目标 P103</li></ul><p>​ 代数建模语言(Algebraic modeling language,AML)：用于大规模数学计算(一般是数学规划)中的数学元素进行描述，并提供求解器接口的一类高级脚本语言。</p><p>​ 非线性方程组求解和优化：迭代法数值计算</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220919160136072.png" style="zoom:50%;" /></p><p>​初值（初始迭代点）对非线性规划问题的求解影响很大，考虑以下的优化命题：</p><h3 id="模型降阶和融合">6、模型降阶和融合：</h3><p>​ 高保真度模型，低保真度模型</p><ul><li><p>模型复杂度和性能的关系：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220919160736180.png" style="zoom:67%;" /></p></li><li><p>模型简化思路 P119</p></li><li><p>代理模型的建立 P121</p></li><li><p>机理数据融合模型 —— 灰箱模型 P122</p><ul><li>不同的融合思路 —— P123</li></ul></li></ul>]]></content>
    
    
    <summary type="html">本篇笔记为电子信息工程中数学模型与方法——单元1 工业智能的相关知识整理，用于学在浙大考试。</summary>
    
    
    
    <category term="⓾ 课程笔记" scheme="https://blog.fantast.top/categories/%E2%93%BE-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="电子信息工程数学模型与方法" scheme="https://blog.fantast.top/categories/%E2%93%BE-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    
    
    <category term="course" scheme="https://blog.fantast.top/tags/course/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 字符集底层原理，用户与权限管理</title>
    <link href="https://blog.fantast.top/2022/09/13/50a88c64ec31/"/>
    <id>https://blog.fantast.top/2022/09/13/50a88c64ec31/</id>
    <published>2022-09-13T07:09:19.000Z</published>
    <updated>2022-10-17T07:23:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一字符集与底层原理">一、字符集与底层原理</h3><p>mysql5.7默认server字符集为 latin，不支持中文</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%character%&#x27;;</span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220913152542290.png" /></p><ul><li>当创建数据库时不显示地指定字符集，则继承mysql服务器的默认字符集</li><li>当创建数据表时不显示地指定字符集，则继承所在数据库的默认字符集</li></ul><h4 id="已有库表的字符集修改">已有库表的字符集修改：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table emp1 convert to character set &#x27;utf8&#x27;</span><br></pre></td></tr></table></figure><h4 id="各级别的字符集">各级别的字符集：</h4><ul><li>服务器级别 character_set_server</li><li>数据库级别 character_set_database</li><li>表级别</li><li>列级别</li></ul><h4 id="字符集和比较规则">字符集和比较规则</h4><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220913221630290.png" /></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220913221612265.png" /></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220913221723119.png" /></p><h4id="请求到响应过程中字符集的变化">请求到响应过程中字符集的变化：</h4><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220914222210985.png" /></p><p><strong>这个过程中涉及到三个变量：</strong></p><p>character_set_client 和 character_set_connection 和character_set_results</p><p><strong>一般来说客户端：类unix操作系统使用utf8编码，windows使用gbk编码</strong></p><p><strong>开发中通常把上述三个系统变量设置成和客户端使用的字符集一致的情况，这样就减少了很多无谓的字符集转换</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET NAMES utf8mb4</span><br></pre></td></tr></table></figure><h3 id="二sql大小写规范">二、SQL大小写规范</h3><ul><li>MySQL在windows下是大小写不敏感的</li><li>MySQL在Linux下数据库名、表名、列名、别名大小写规则是这样的：<ul><li>1、数据库名、表名、表的别名、变量名是严格区分大小写的；</li><li>2、关键字、函数名称在SQL中不区分大小写；</li><li>3、列名（或字段名）与列的别名（或字段别名）在所有的情况下均是忽略大小写的；</li></ul></li></ul><h3 id="三sql编写建议">三、SQL编写建议：</h3><ul><li>关键字和函数名称<strong>全部大写</strong></li><li>数据库名、表名、表别名、字段名、字段别名等<strong>全部小写</strong></li><li>SQL语句必须以分号结尾</li></ul><h3 id="四sql_mode的合理设置">四、SQL_MODE的合理设置：</h3><p>​ 其会影响支持的SQL语法以及它执行的数据验证检查。</p><h4 id="宽松模式-严格模式">1、宽松模式 &amp; 严格模式</h4><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-06%2009.25.12.png" /></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-06%2009.25.57.png" /></p><p><strong>虽然MYSQL等数据库总想把关于数据库的所有操作都自己包揽下来，包括数据的校验等等，但是其实有些校验最好在开发层完成</strong></p><h3 id="五数据库在文件系统中的表示">五、数据库在文件系统中的表示：</h3><h4 id="innodb存储引擎模式">1、Innodb存储引擎模式</h4><h5 id="表结构">1） 表结构：</h5><p>​ 为了保存表结构， InnoDB在数据目录下对应的数据库子目录下创建了一个专门<strong>用于描述表结构的文件</strong>，文件名是这样，该文件以二进制格式存储</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表名.frm</span><br></pre></td></tr></table></figure><h5 id="表中数据和索引">2）表中数据和索引：</h5><ul><li>系统表空间：<ul><li>默认情况下，InnoDB会在数据目录下创建一个名为ibdata1 、大小为12M的文件，这个文件就是对应的系统表空间在文件系统上的表示。注意这个文件是自扩展文件，当不够用的时候它会自己增加文件大小。</li></ul></li><li>独立表空间：<ul><li>在mysql5.6以后，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是<strong>为每一个表建立一个独立表空间</strong>，也就是说我们创建了多少个表，就有多少个独立表空间。使用独立表空间来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同，只不过添加了一个.ibd的扩展名而已，所以完整的文件名称长这样：</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表名.ibd</span><br></pre></td></tr></table></figure><h4 id="myisam存储引擎模式">2、MyISAM存储引擎模式：</h4><h5 id="表结构与innodb一致">1）表结构：与Innodb一致</h5><h5 id="表中数据和索引-1">2）表中数据和索引：</h5><p>​在MyISAM中的索引全部都是二级索引，该<strong>存储引擎的数据和索引是分开存放的</strong>。假如test表使用MyISAM存储引擎的话，那么在它所在数据库对应的atguigu目录下会为test 表创建这三个文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test.frm 存储表结构</span><br><span class="line">test.MYD 存储数据 (MYData)</span><br><span class="line">test.MYI 存储索引 (MYIndex)</span><br></pre></td></tr></table></figure><h3 id="六用户和权限管理">六、用户和权限管理：</h3><h4 id="创建修改与删除用户">1、创建、修改与删除用户</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#x27;kangshifu&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE mysql.user SET USER=&#x27;li4&#x27; WHERE USER=&#x27;wang5&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP USER &#x27;kangshifu&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure><h4 id="密码相关策略内容">2、密码相关策略内容</h4><ul><li>使用root用户登录Mysql后，可以这样修改自己的密码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET PASSWORD=&#x27;new_password&#x27;;</span><br></pre></td></tr></table></figure><ul><li>修改其他用户密码：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET PASSWORD FOR &#x27;username&#x27;@&#x27;hostname&#x27;=&#x27;new_password&#x27;;</span><br></pre></td></tr></table></figure><ul><li>密码过期策略：</li></ul><p>​在MySQL中，数据库管理员可以手动设置账号密码过期，也可以建立一个自动密码过期策略。过期策略可以是全局的，也可以为每个账号设置单独的过期策</p><ul><li>密码重用策略：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET PERSIST password_history = 6; #设置不能选择最近使用过的6个密码</span><br><span class="line">SET PERSIST password_reuse_interval = 365; #设置不能选择最近一年内的密码</span><br></pre></td></tr></table></figure><h4 id="权限列表种类">3、权限列表种类：</h4><ul><li>Mysql的权限种类：<ul><li>CREATE和DROP 创建删除数据库和表</li><li>SELECT、INSERT、UPDATE和DELETE 在数据库现有表上操作</li><li>SELECT 检索权限</li><li>INDEX 允许创建或删除索引</li><li>ALTER 更改表结构和重命名</li><li>GRANT 允许授权给其他用户</li></ul></li><li>授予权限的原则：<ul><li>只授予满足需要的最小权限</li><li>创建用户时限制登陆主机IP</li></ul></li><li>授予权限方式有两种<ul><li>把角色赋予给用户授权</li><li>直接给用户授权</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT 权限1,权限2,…权限n ON 数据库名称.表名称 TO 用户名@用户地址 [IDENTIFIED BY ‘密码口令’];</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GRANTS FOR &#x27;user&#x27;@&#x27;主机地址&#x27;;</span><br></pre></td></tr></table></figure><ul><li>收回权限</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE 权限1,权限2,…权限n ON 数据库名称.表名称 FROM 用户名@用户地址;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#收回全库全表的所有权限</span><br><span class="line">REVOKE ALL PRIVILEGES ON *.* FROM joe@&#x27;%&#x27;;</span><br><span class="line">#收回mysql库下的所有表的插删改查权限</span><br><span class="line">REVOKE SELECT,INSERT,UPDATE,DELETE ON mysql.* FROM joe@localhost;</span><br></pre></td></tr></table></figure><h4 id="权限表">4、权限表</h4><h5 id="user表">1）User表</h5><p>​记录用户账号和权限信息，分为用户列、权限列、安全列、资源控制列（限制用户使用的资源，比如每小时允许执行的查询操作次数等）</p><h5 id="db表">2）db表</h5><p>​DB表中存储了用户对某个数据库的操作权限,决定用户能从哪个数据库中存取</p><h5id="tables_priv表和columns_priv表">3）tables_priv表和columns_priv表</h5><p>​tables_priv表用来对表设置操作权限，columns_priv表用来对表的某一列设置权限</p><h5 id="procs_priv表">4）procs_priv表：</h5><p>​ procs_priv表可以对存储过程和存储函数设置操作权限</p><h4 id="访问控制">5、访问控制：</h4><ul><li>连接核实阶段</li></ul><p>​服务器<strong>只有在user表记录的Host和User字段匹配客户端主机名和用户名，并且提供正确的密码时才接受连接</strong>。如果连接核实没有通过，服务器就完全拒绝访问；否则，服务器接受连接，然后进入请求核实阶段等待用户请求。</p><ul><li>请求核实阶段</li></ul><p>​对此连接上进来的每个请求，服务器检查该请求要执行什么操作、是否有足够的权限来执行它，这正是需要授权表中的权限列发挥作用的地方。这些权限可以来自user、db、table_priv和column_priv表。</p><p>​确认权限时，MySQL<strong>首先检查user表</strong>，如果指定的权限没有在user表中被授予，那么MySQL就会<strong>继续检查db表</strong>，db表是下一安全层级，其中的权限限定于数据库层级，在该层级的SELECT权限允许用户查看指定数据库的所有表中的数据；如果在该层级没有找到限定的权限，则MySQL<strong>继续检查tables_priv表以及columns_priv表</strong>，如果所有权限表都检查完毕，但还是没有找到允许的权限操作，MySQL将返回错误信息，用户请求的操作不能执行，操作失败。</p><h4 id="角色管理">6、角色管理</h4><ul><li><p>创建角色、给角色赋予权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE ROLE &#x27;role_name&#x27;[@&#x27;host_name&#x27;] [,&#x27;role_name&#x27;[@&#x27;host_name&#x27;]]...</span><br><span class="line"># 创建角色之后，默认这个角色是没有任何权限的，我们需要给角色授权。给角色授权的语法结构是</span><br><span class="line">GRANT privileges ON table_name TO &#x27;role_name&#x27;[@&#x27;host_name&#x27;];</span><br><span class="line"># 上述语句中privileges代表权限的名称，多个权限以逗号隔开</span><br><span class="line"># 查看角色权限：</span><br><span class="line">SHOW GRANTS FOR &#x27;manager&#x27;;</span><br><span class="line"># 只要你创建了一个角色，系统就会自动给你一个“ USAGE ”权限，意思是连接登录数据库的权限。</span><br></pre></td></tr></table></figure></li><li><p>回收角色权限、删除角色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 角色授权后，可以对角色的权限进行维护，对权限进行添加或撤销。添加权限使用GRANT语句，与角色授权相同。撤销角色或角色权限使用REVOKE语句。撤销角色</span><br><span class="line">REVOKE privileges ON tablename FROM &#x27;rolename&#x27;;</span><br><span class="line"># 删除角色</span><br><span class="line">DROP ROLE role [,role2]...</span><br></pre></td></tr></table></figure></li><li><p>给用户赋予角色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 角色创建并授权后，要赋给用户并处于激活状态才能发挥作用</span><br><span class="line">GRANT role [,role2,...] TO user [,user2,...];</span><br></pre></td></tr></table></figure></li><li><p>激活角色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET DEFAULT ROLE ALL TO user@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>撤销角色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE role FROM user</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">Chap7——Mysql 架构相关，包含字符集底层原理，用户与权限管理</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 视图，存储过程与函数</title>
    <link href="https://blog.fantast.top/2022/09/12/108274e25ef3/"/>
    <id>https://blog.fantast.top/2022/09/12/108274e25ef3/</id>
    <published>2022-09-12T10:09:19.000Z</published>
    <updated>2022-09-12T12:30:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一视图">一、视图</h3><p>​<strong>视图一方面可以帮我们使用表的一部分而不是所有的表，另一方面也可以针对不同的用户制定不同的查询视图。比如，针对一个公司的销售人员，我们只想给他看部分数据，而某些特殊的数据，比如采购的价格，则不会提供给他。再比如，人员薪酬是个敏感的字段，那么只给某个级别以上的人员开放，其他人的查询视图中则不提供这个字段。</strong></p><ul><li><p>视图是一种虚拟表，本身是不具有数据的，占用很少的内存空间</p></li><li><p>视图建立在已有表的基础上, 视图赖以建立的这些表称为基表</p></li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220912195718829.png" /></p><ul><li><p>视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化，反之亦然。</p></li><li><p>视图，是向用户提供基表数据的另一种表现形式。<strong>通常情况下，小型项目的数据库可以不使用视图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，它可以帮助我们把经常查询的结果集放到虚拟表中，提升使用效率。理解和使用起来都非常方便</strong></p></li></ul><h3 id="二创建视图">二、创建视图：</h3><ul><li>创建单表视图</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW empvu80</span><br><span class="line">AS</span><br><span class="line">SELECT employee_id, last_name, salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id = 80;</span><br></pre></td></tr></table></figure><ul><li>创建多表联合视图：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW empview</span><br><span class="line">AS</span><br><span class="line">SELECT employee_id emp_id,last_name NAME,department_name</span><br><span class="line">FROM employees e,departments d</span><br><span class="line">WHERE e.department_id = d.department_id;</span><br></pre></td></tr></table></figure><ul><li>可以利用视图来对数据进行格式化：</li></ul><p>​比如我们想输出员工姓名和对应的部门名，对应格式为emp_name(department_name)，就可以使用视图来完成数据格式化的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW emp_depart</span><br><span class="line">AS</span><br><span class="line">SELECT CONCAT(last_name,&#x27;(&#x27;,department_name,&#x27;)&#x27;) AS emp_dept</span><br><span class="line">FROM employees e JOIN departments d</span><br><span class="line">WHERE e.department_id = d.department_id</span><br></pre></td></tr></table></figure><h3 id="三更新视图的数据">三、更新视图的数据</h3><p>​支持使用INSERT、UPDATE和DELETE语句对视图中的数据进行插入、更新和删除操作</p><h4 id="关于一些不可更新的视图">关于一些不可更新的视图</h4><p>​要使视图可更新，视图中的行和底层基本表中的行之间必须存在一对一的关系。另外当视图定义出现如下情况时，视图不支持更新操作：</p><ul><li>在定义视图的时候指定了“ALGORITHM =TEMPTABLE”，视图将不支持INSERT和DELETE操作；</li><li>视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT操作；</li><li>在定义视图的SELECT语句中使用了JOIN联合查询，视图将不支持INSERT和DELETE操作；</li><li>在定义视图的SELECT语句后的字段列表中使用了数学表达式或子查询，视图将不支持INSERT，也</li><li>不支持UPDATE使用了数学表达式、子查询的字段值；</li><li>在定义视图的SELECT语句后的字段列表中使用DISTINCT 、聚合函数、GROUPBY 、HAVING 、 UNION 等，视图将不支持INSERT、UPDATE、DELETE；</li><li>在定义视图的SELECT语句中包含了子查询，而子查询中引用了FROM后面的表，视图将不支持INSERT、UPDATE、DELETE；</li><li>视图定义基于一个不可更新视图</li><li>常量视图</li></ul><h3 id="四视图的优缺点与总结">四、视图的优缺点与总结：</h3><ul><li>优点</li></ul><p>1、操作简单，<strong>将经常使用的查询操作定义为视图，开发人员不需要关心视图对应的数据表的结构、表与表之间的关联关系等</strong></p><p>2、减少数据冗余，其存储的是查询语句，本身不存储数据</p><p>3、数据安全，将用户对数据的访问限制在某些数据的结果集上，具有一定的隔离性。</p><p>4、适应多变的需求，分解复杂的查询逻辑。可以先将复杂的逻辑查询分解，创建多个视图，再将这多个视图结合起来，完成复杂的查询逻辑。</p><ul><li>缺点：</li></ul><p>1、如果实际数据表的结构变更了，我们就需要及时对相关的视图进行相应的维护。特别是嵌套的视图（就是在视图的基础上创建视图），维护会变得比较复杂，可读性不好，容易变成系统的潜在隐患。因为创建视图的 SQL查询可能会对字段重命名，也可能包含复杂的逻辑，这些都会增加维护的成本。</p><h3 id="五存储过程与函数">五、存储过程与函数：</h3><ul><li>存储过程就是一组经过预先编译的 SQL 语句的封装。</li><li>执行过程：存储过程预先存储在 MySQL服务器上，需要执行的时候，客户端只需要向服务器端发出调用存储过程的命令，服务器端就可以把预先存储好的这一系列 SQL语句全部执行。</li></ul>]]></content>
    
    
    <summary type="html">Chap5——Mysql 视图，存储过程与函数</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 变量与游标.触发器</title>
    <link href="https://blog.fantast.top/2022/09/12/2c85f3f81b49/"/>
    <id>https://blog.fantast.top/2022/09/12/2c85f3f81b49/</id>
    <published>2022-09-12T10:09:19.000Z</published>
    <updated>2022-09-12T14:23:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一系统变量">一、系统变量：</h3><p>​系统变量由系统定义，不是用户定义，属于服务器层面。启动MySQL服务，生成MySQL服务实例期间，MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特征。这些系统变量的值要么是编译MySQL时参数的默认值，要么是配置文件（例如my.ini等）中的参数值。</p><h4id="全局系统变量-global关键字-会话系统变量-session关键字">1、全局系统变量global关键字 &amp; 会话系统变量 session关键字</h4><p>​每一个MySQL客户机成功连接MySQL服务器后，都会产生与之对应的会话Session。会话期间，MySQL服务实例会在MySQL服务器内存中生成与该会话对应的<strong>会话系统变量</strong>，这些会话系统变量的初始值是全局系统变量值的复制。</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220912221138151.png" /></p><ul><li><p>全局系统变量针对于所有会话（连接）有效，<strong>但不能跨重启</strong></p></li><li><p>会话1对某个全局系统变量值的修改会导致会话2中同一个全局系统变量值的修改</p></li></ul><p>​ <strong>在MySQL中有些系统变量只能是全局的，例如 max_connections用于限制服务器的最大连接数；有些系统变量作用域既可以是全局又可以是会话，例如 character_set_client用于设置客户端的字符集；有些系 统变量的作用域只能是当前会话，例如pseudo_thread_id 用于标记当前会话的 MySQL 连接 ID</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查看所有全局变量</span><br><span class="line">SHOW GLOBAL VARIABLES;</span><br><span class="line">#查看所有会话变量</span><br><span class="line">SHOW SESSION VARIABLES;</span><br><span class="line">或</span><br><span class="line">SHOW VARIABLES;</span><br></pre></td></tr></table></figure><p>​ MySQL 中的系统变量以两个“@” 开头，其中“@<span class="citation"data-cites="global">@global</span>”仅用于标记全局系统变量，“@<spanclass="citation"data-cites="session">@session</span>”仅用于标记会话系统变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#查看指定的系统变量的值</span><br><span class="line">SELECT @@global.变量名;</span><br><span class="line">#查看指定的会话变量的值</span><br><span class="line">SELECT @@session.变量名;</span><br><span class="line">#或者</span><br><span class="line">SELECT @@变量名;</span><br><span class="line"></span><br><span class="line">#为某个全局变量赋值</span><br><span class="line">#方式1</span><br><span class="line">SET @@global.变量名=变量值;</span><br><span class="line">#方式2：</span><br><span class="line">SET GLOBAL 变量名=变量值;</span><br><span class="line">#为某个会话变量赋值</span><br><span class="line">#方式1：</span><br><span class="line">SET @@session.变量名=变量值;</span><br><span class="line">#方式2：</span><br><span class="line">SET SESSION 变量名=变量值;</span><br></pre></td></tr></table></figure><h4 id="会话用户变量与局部变量">2、会话用户变量与局部变量：</h4><ul><li>会话用户变量：作用域和会话变量一样，只对当前连接会话有效。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#方式1：“=”或“:=”</span><br><span class="line">SET @用户变量 = 值;</span><br><span class="line">SET @用户变量 := 值;</span><br><span class="line">#方式2：“:=” 或 INTO关键字</span><br><span class="line">SELECT @用户变量 := 表达式 [FROM 等子句];</span><br><span class="line">SELECT 表达式 INTO @用户变量 [FROM 等子句];</span><br></pre></td></tr></table></figure><ul><li>局部变量：只在 BEGIN 和 END语句块中有效。局部变量只能在存储过程和函数中使用。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">#声明局部变量</span><br><span class="line">DECLARE 变量名1 变量数据类型 [DEFAULT 变量默认值];</span><br><span class="line">DECLARE 变量名2,变量名3,... 变量数据类型 [DEFAULT 变量默认值];</span><br><span class="line">#为局部变量赋值</span><br><span class="line">SET 变量名1 = 值;</span><br><span class="line">SELECT 值 INTO 变量名2 [FROM 子句];</span><br><span class="line">#查看局部变量的值</span><br><span class="line">SELECT 变量1,变量2,变量3;</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h3 id="二游标">二、游标</h3><p>​游标，提供了一种灵活的操作方式，让我们能够对结果集中的每一条记录进行定位，并对指向的记录中的数据进行操作的数据结构。游标让SQL 这种面向集合的语言有了面向过程开发的能力。</p><p>​游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标充当了指针的作用，我们可以通过操作游标来对数据行进行操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE get_count_by_limit_total_salary(IN limit_total_salary DOUBLE,OUT</span><br><span class="line">total_count INT)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE sum_salary DOUBLE DEFAULT 0; #记录累加的总工资</span><br><span class="line">DECLARE cursor_salary DOUBLE DEFAULT 0; #记录某一个工资值</span><br><span class="line">DECLARE emp_count INT DEFAULT 0; #记录循环个数</span><br><span class="line">#定义游标</span><br><span class="line">DECLARE emp_cursor CURSOR FOR SELECT salary FROM employees ORDER BY salary DESC;</span><br><span class="line">#打开游标</span><br><span class="line">OPEN emp_cursor;</span><br><span class="line">REPEAT</span><br><span class="line">#使用游标（从游标中获取数据）</span><br><span class="line">FETCH emp_cursor INTO cursor_salary;</span><br><span class="line">SET sum_salary = sum_salary + cursor_salary;</span><br><span class="line">SET emp_count = emp_count + 1;</span><br><span class="line">UNTIL sum_salary &gt;= limit_total_salary</span><br><span class="line">END REPEAT;</span><br><span class="line">SET total_count = emp_count;</span><br><span class="line">#关闭游标</span><br><span class="line">CLOSE emp_cursor;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h3 id="三触发器">三、触发器</h3><p><strong>应用场景：</strong></p><p>​ 在实际开发中，我们经常会遇到这样的情况：有 2个或者多个相互关联的表，如商品信息和库存信息分别存放在 2个不同的数据表中，我们在添加一条新商品记录的时候，为了保证数据的完整性，必须同时在库存表中添加一条库存记录。​这样一来，我们就必须把这两个关联的操作步骤写到程序里面，而且要用事务包裹起来，确保这两个操作成为一个原子操作，要么全部执行，要么全部不执行。要是遇到特殊情况，可能还需要对数据进行手动维护，这样就很容易忘记其中的一步，导致数据缺失。​这个时候，咱们可以使用触发器。你可以创建一个触发器，让商品信息数据的插入操作自动触发库存数据的插入操作。这样一来，就不用担心因为忘记添加库存数据而导致的数据缺失了。</p><p>​</p><p><strong>概述</strong>：</p><p>​ 触发器是由事件来触发某个操作，这些事件包括INSERT 、UPDATE 、DELETE事件。所谓事件就是指用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生了，就会自动激发触发器执行相应的操作。</p><ul><li>优点：<ul><li>触发器可以确保数据的完整性。</li><li>触发器可以帮助我们记录操作日志。</li><li>可以具体记录什么时间发生了什么。比如，记录修改会员储值金额的触发器，就是一个很好的例子。这对我们还原操作执行时的具体场景，</li><li>触发器还可以用在操作数据前，对数据进行合法性检查。</li></ul></li><li>缺点：<ul><li>着触发器有可能不受应用层的控制。这对系统维护是非常有挑战的。</li><li>相关数据的变更，可能会导致触发器出错。特别是数据表结构的变更，都可能会导致触发器出错，进而影响数据操作的正常运行。这些都会由于触发器本身的隐蔽性，影响到应用中错误原因排查的效率。</li></ul></li></ul><p><strong>注意</strong>：</p><p>​ 如果在子表中定义了外键约束，并且外键指定了ON UPDATE/DELETECASCADE/SETNULL子句，此时修改父表被引用的键值或删除父表被引用的记录行时，也会引起子表的修改和删除操作，此时基于子表的UPDATE和DELETE语句定义的触发器并不会被激活。</p>]]></content>
    
    
    <summary type="html">Chap6——Mysql 变量流程控制与游标.触发器</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 约束</title>
    <link href="https://blog.fantast.top/2022/09/10/ee0ee8e192df/"/>
    <id>https://blog.fantast.top/2022/09/10/ee0ee8e192df/</id>
    <published>2022-09-10T10:09:19.000Z</published>
    <updated>2022-09-12T11:13:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一约束">一、约束</h3><p>​ 约束是表级的强制规定,可以通过如下命令查看表的约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM information_schema.table_constraints</span><br><span class="line">WHERE table name=&#x27;’&#x27;表名称&#x27;；</span><br></pre></td></tr></table></figure><h3 id="二非空约束">二、非空约束</h3><p>​ 单列约束，不能组合非空值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test(</span><br><span class="line">id INT NOT NULL,</span><br><span class="line">    email CHAR</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ALTER TABLE test</span><br><span class="line">MODIFY email CHAR NOT NULL;</span><br><span class="line"></span><br><span class="line">ALTER TABLE test</span><br><span class="line">MODIFY id INT NULL;</span><br></pre></td></tr></table></figure><h3 id="三唯一性约束">三、唯一性约束</h3><p>​ 单列约束，允许出现多个NULL值，可以多个列的组合唯一</p><ul><li>唯一性约束允许列值为空。</li><li>在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。</li><li><strong>MySQL会给唯一约束的列上默认创建一个唯一索引。</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE USER(</span><br><span class="line">    id INT NOT NULL,</span><br><span class="line">    CNAME VARCHAR(25) UNIQUE,  # 列级约束语法</span><br><span class="line">    NAME VARCHAR(25),</span><br><span class="line">    PASSWORD VARCHAR(16),</span><br><span class="line">    # 使用表级约束语法</span><br><span class="line">    CONSTRAINT uk_name_pwd UNIQUE(NAME,PASSWORD) # 用户名和密码组合不能重复</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>复合唯一约束</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table student_course(</span><br><span class="line">    id int,</span><br><span class="line">    sid int,</span><br><span class="line">    cid int,</span><br><span class="line">    score int,</span><br><span class="line">    unique key(sid,cid) #复合唯一</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="四主键约束">四、主键约束</h3><ul><li>主键约束相当于唯一约束+非空约束的组合，主键约束列不允许重复，也不允许出现空值。</li><li>主键约束对应着表中的一列或者多列（复合主键）</li><li>MySQL的主键名总是PRIMARY，就算自己命名了主键约束名也没用。</li><li>当创建主键约束时，系统默认会在所在的列或列组合上建立对应的主键索引</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE emp4(</span><br><span class="line">    id INT PRIMARY KEY AUTO_INCREMENT ,</span><br><span class="line">    NAME VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table student_course(</span><br><span class="line">    sid int,</span><br><span class="line">    cid int,</span><br><span class="line">    score int,</span><br><span class="line">    primary key(sid,cid) #复合主键</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">alter table 表名称 drop primary key;</span><br></pre></td></tr></table></figure><h3 id="五auto_increment">五、AUTO_INCREMENT</h3><ul><li>一个表最多只能有一个自增长列</li><li>当需要产生唯一标识符或顺序值时，可设置自增长</li><li>自增长列约束的列必须是键列（主键列，唯一键列）</li><li>自增约束的列的数据类型必须是整数类型</li><li>如果自增列指定了 0 和null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table 表名称(</span><br><span class="line">    字段名 数据类型 primary key auto_increment,</span><br><span class="line">    字段名 数据类型 unique key not null,</span><br><span class="line">    字段名 数据类型 unique key,</span><br><span class="line">    字段名 数据类型 not null default 默认值,</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意：自增主键的持久化：</strong></p><p>​ 在MySQL 5.7系统中，对于自增主键的分配规则，是由InnoDB数据字典内部一个 计数器 来决定的，而该计数器只在 内存中维护，并不会持久化到磁盘中。当数据库重启时，该 计数器会被初始化。</p><p>​ MySQL 8.0将自增主键的计数器持久化到 重做日志中。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值</p><h3 id="六外键约束">六、外键约束</h3><p><strong>从表的外键列，必须引用/参考主表的主键或唯一约束的列</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">create table dept( #主表</span><br><span class="line">    did int primary key, #部门编号</span><br><span class="line">    dname varchar(50) #部门名称</span><br><span class="line">);</span><br><span class="line">create table emp(#从表</span><br><span class="line">    eid int primary key, #员工编号</span><br><span class="line">    ename varchar(5), #员工姓名</span><br><span class="line">    deptid int, #员工所在的部门</span><br><span class="line">    foreign key (deptid) references dept(did) #在从表中指定外键约束</span><br><span class="line">    #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>约束等级</strong>：</p><ul><li>Cascade方式：在父表上update/delete记录时，同步update/delete掉子表的匹配记录</li><li>Set null方式：在父表上update/delete记录时，将子表上匹配记录的列设为null，但是要注意子表的外键列不能为not null</li><li>No action方式：如果子表中有匹配的记录，则不允许对父表对应候选键进行update/delete操作</li><li>Restrict方式 ：同no action， 都是立即检查外键约束</li><li>Set default方式（在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置成一个默认的值，但Innodb不能识别</li></ul><p><strong>对于外键约束，最好是采用: ON UPDATE CASCADE ON DELETERESTRICT 的方式。</strong></p><p><strong>在 MySQL里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL操作，有可能会不适 合。比如大型网站的中央数据库，可能会因为外键约束的系统开销而变得非常慢 。所以， MySQL 允许你不使用系统自带的外键约束，在 应用层面完成检查数据一致性的逻辑。也就是说，即使你不用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。</strong></p><p><strong>一些提示：【 强制】不得使用外键与级联，一切外键概念必须在应用层解决。说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的student_id 则为外键。如果更新学 生表中的 student_id，同时触发成绩表中的student_id 更新，即为级联更新。外键与级联更新适用于 单 机低并发 ，不适合分布式 、 高并发集群 ；级联更新是强阻塞，存在数据库 更新风暴的风险；外键影响 数据库的 插入速度 。</strong></p><h3 id="七检查约束与默认值约束">七、检查约束与默认值约束</h3><h4 id="check约束">1 CHECK约束</h4><p>​ 检查某个字段的值是否符合xx要求，一般指的是值的范围</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE temp(</span><br><span class="line">    id INT AUTO_INCREMENT,</span><br><span class="line">    NAME VARCHAR(20),</span><br><span class="line">    age INT CHECK(age &gt; 20),</span><br><span class="line">    PRIMARY KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="default-约束">2 DEFAULT 约束</h4><p>给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table 表名称(</span><br><span class="line">    字段名 数据类型 primary key,</span><br><span class="line">    字段名 数据类型 unique key not null,</span><br><span class="line">    字段名 数据类型 unique key,</span><br><span class="line">    字段名 数据类型 not null default 默认值,</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>一些问题</strong>：</p><ul><li>为什么不想要 null 的值<ul><li>1）不好比较。null是一种特殊值，比较时只能用专门的is null 和 is notnull来比较。碰到运算符，通 常返回null。</li><li>2）效率不高。影响提高索引效果。因此，我们往往在建表时 not nulldefault '' 或 default 0</li></ul></li></ul>]]></content>
    
    
    <summary type="html">Chap4——Mysql 约束</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>2022-2023秋冬大计基答疑整理——沈睿班</title>
    <link href="https://blog.fantast.top/2022/09/09/66d597ae86a9/"/>
    <id>https://blog.fantast.top/2022/09/09/66d597ae86a9/</id>
    <published>2022-09-09T02:00:00.000Z</published>
    <updated>2022-10-19T11:03:28.495Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用指南">1、使用指南：</h2><h3id="如何在本文档内搜索相关问题">1）如何在本文档内搜索相关问题？：</h3><ul><li><strong>方法1</strong>：使用博客上方内置的<strong>搜索功能</strong>，点击搜索后，输入相关关键词即可。<strong>需要注意的是，由于本文档是基于整个博客进行更新的，所以该搜索功能是在整个博客内进行搜索，请从中找到本篇文章，即《2022-2023秋冬大计基答疑整理—沈睿班》的搜索结果进入即可</strong>，如果没有本篇文章的搜索结果即代表没有相关内容。如果对其他博文感兴趣也可以随意浏览。</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220908105925826.png" style="zoom:67%;" /></p><ul><li><strong>方法2</strong>：以firefox浏览器为例，在浏览器中打开本网页后，按<strong>CTRL+F</strong>键,会看到浏览器底部会出现如下搜索栏,在左侧"在此页面中查找"处输入你想要搜索的内容即可进行相关内容的搜索。其他不同浏览器的搜索框使用方法可以访问如下链接：https://www.163.com/dy/article/H6K7CURU0552EUN3.html</li></ul><h3id="如果对本文档内容有所疑问如何提出">2）如果对本文档内容有所疑问如何提出？：</h3><p>​如果你发现本文档内有问答有错误或不严谨的地方，你可以通过以下方法提出</p><ul><li><p><strong>方法1</strong>：你可以直接截图发至钉钉群内，<spanclass="citation"data-cites="助教提出你的疑问">@助教提出你的疑问</span>。</p></li><li><p><strong>方法2</strong>：使用博客页面下方内置的评论功能，此功能需要你先注册<ahref="https://github.com">github</a>账号，随后以github账号登录进行评论。评论后助教会进行更正或以同样形式回答。</p></li></ul><h3 id="其他便捷功能">3）其他便捷功能：</h3><ul><li>1、你可以使用左侧的导航栏帮助你快速定位你所在的问题目录</li><li>2、你可以通过点击左侧导航栏下方的"叉叉"图标，来关闭左侧导航栏。</li><li>3、你可以通过点击左侧导航栏下方的"箭头"图标，来快速返回至该文档的最上方。箭头图标旁的百分比代表你目前正在浏览的部分是整份文档的何处位置。</li></ul><h2 id="正文">2、正文：</h2><h3id="问1vmware官网哪里点进去有软件下载">问1：vmware官网哪里点进去有软件下载？</h3><ul><li>https://customerconnect.vmware.com/downloads/#all_products</li></ul><hr /><h3id="问2window10的iso镜像文件哪里可以下载">问2：window10的iso镜像文件哪里可以下载？</h3><ul><li><p>需要校园网内网访问，是学校的官方软件平台</p></li><li><p>http://download.ms.zju.edu.cn/SW_DVD9_Win_Pro_10_21H1_64BIT_ChnSimp_Pro_Ent_EDU_N_MLF_X22-55090.ISO</p></li></ul><hr /><h3id="问3安装vmware时出现如下错误">问3：安装VMWare时出现如下错误：</h3><p>写入文件时 DIFXAPI.dll时出错，请确认您有访问该目录的权限</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220918171424902.png" /></p><ul><li>一般这种情况是因为你电脑上开着一些杀毒软件导致的，比如说360安全卫士，电脑管家这种，可以先关闭杀毒软件后尝试安装。</li></ul><hr /><h3id="问4绑定pta账号时绑定码是多少">问4：绑定PTA账号时，绑定码是多少？</h3><ul><li>不同时间的班不一样，见下：<ul><li>周四1、2节：248374</li><li>周四3、4节：717242</li><li>周四7、8节：834958</li></ul></li></ul><hr /><h3id="问5判断题计算机存储模式规定存储单元以位bit为单位8个二进制位构成1个字节byte">问5：判断题：计算机存储模式规定，存储单元以位（bit）为单位，8个二进制位构成1个字节（Byte）。</h3><ul><li>答案：错误。存储单元以字节为单位，即Byte</li></ul><hr /><h3id="问6判断题高速缓存器cache介于cpu与主存之间用于解决内存与外存的速度匹配问题以提高存储速度">问6：判断题：高速缓存器Cache介于CPU与主存之间，用于解决内存与外存的速度匹配问题，以提高存储速度。</h3><ul><li>答案：错误。不是为了解决内存与外存的速度匹配问题，而是为了解决内存和CPU的速度匹配问题。因为现代CPU频率比较高，内存的发展跟不上CPU访问主存的速度，这样的话把CPU最有可能访问的数据放在cache中，CPU可以在很短的时间内得到数据</li></ul><hr /><h3id="问7如果某一计算机的内存单元总共可存储256个字节的容量则这些内存单元的地址编号可以从1000hh表示16进制到h">问7：如果某一计算机的内存单元总共可存储256个字节的容量，则这些内存单元的地址编号可以从1000H（H表示16进制）到（）H。</h3><ul><li>答案：10FFH。这一类题目涉及到十六进制运算，搞清楚这块的计算就可以应付许多题目。首先你需要学会16进制和10进制的转换。即十进制的256，在16进制中是多少？答案是100H.所以，内存的地址编号应该就是从1000H+ 100H - 1 = 10FFH.</li><li>题外话：在一些其他题目中，注意区分字节和位，字节是Byte，位是bit，简写一个是B，一个是b。1Byte= 8bit</li></ul><hr /><h3id="问8某系统的进程状态如下图所示其中3表示等待某个事件1表示进程被选中问a是_状态2表示____________c表示___________">问8：某系统的进程状态如下图所示，其中3表示等待某个事件，1表示进程被选中，问：a是_<strong><em>状态，2表示</em></strong>____________，c表示___________。</h3><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221019185521467.png" /></p><ul><li>答案：运行，时间片到，等待I/O</li><li>分析：这个是考察进程的状态转移的一道题目，大家可以通过熟悉下图来完成相关的题目。下图是详细版的一个进程状态转移的说明。值得注意的是：</li><li>运行态→阻塞态是一种进程自身做出的<strong>主动行为</strong></li><li>阻塞态→就绪态是不是进程自身能控制的，是一种<strong>被动行为</strong>。</li><li>注意：<strong>不能由阻塞态直接转换为运行态</strong>，<strong>也不能由就绪态直接转换为阻塞态</strong>（因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221019185634225.png" /></p><hr /><h3id="问9在windows中用户使用______管理硬件资源设置">问9：在Windows中，用户使用（______）管理硬件资源设置。</h3><ul><li>答案：控制面板.</li></ul><hr />]]></content>
    
    
    <summary type="html">本文档用于2022-2023秋冬大计基沈睿老师班的答疑整理，该文档会由助教定期根据群里有价值的提问进行汇总整理，随后更新至该文档中。为提高问答效率，请大家在群内提问前访问本网页，可以先在本文档中搜索是否有类似相关问题，如果没有再前往群内进行提问。</summary>
    
    
    
    <category term="⓽ 其他内容" scheme="https://blog.fantast.top/categories/%E2%93%BD-%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql DDL与DCL操作、增删改与数据类型</title>
    <link href="https://blog.fantast.top/2022/09/07/60ff079d7c8c/"/>
    <id>https://blog.fantast.top/2022/09/07/60ff079d7c8c/</id>
    <published>2022-09-07T10:09:19.000Z</published>
    <updated>2022-09-10T14:15:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一一些ddl与dcl操作">一、一些DDL与DCL操作：</h3><h4 id="数据库相关操作">1、数据库相关操作：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE mytest1 CHARACTER SET &#x27;utf8&#x27;;</span><br><span class="line">ALTER DATABASE mytest1 CHARACTER SET &#x27;utf8mb4&#x27;;</span><br><span class="line">DROP DATABASE IF EXISTS mytest1;  //删除数据库</span><br></pre></td></tr></table></figure><h4 id="数据表相关操作">2、数据表相关操作：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS myempl(</span><br><span class="line">id INT,</span><br><span class="line">emp_name VARCHAR(15),</span><br><span class="line">hire_date DATE); # 创建表</span><br><span class="line"></span><br><span class="line">DESC myempl;  # 查看表结构</span><br><span class="line"></span><br><span class="line"># 通过现有表建立新表，会导入现有表数据</span><br><span class="line">CREATE TABLE myemp3</span><br><span class="line">AS </span><br><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line"># 结合子查询，通过现有表执行</span><br><span class="line">CREATE TABLE myemp3</span><br><span class="line">AS </span><br><span class="line">SELECT e.employee_id emp_id,e.last_name lname,d.department name</span><br><span class="line">FROM employees e JOIN departments d</span><br><span class="line">ON e.department id = d. department id;</span><br><span class="line"></span><br><span class="line"># 修改表</span><br><span class="line"># ====== 添加一个字段 ====== </span><br><span class="line">ALTER TABLE myemp1</span><br><span class="line">ADD salary DOUBLE(10,2);  # 默认添加到表中的最后一个字段</span><br><span class="line"></span><br><span class="line">ALTER TABLE myemp1</span><br><span class="line">ADD salary DOUBLE(10,2) FIRST;  # 添加到表中的第一个字段</span><br><span class="line"></span><br><span class="line"># 修改一个字段</span><br><span class="line">ALTER TABLE myemp1</span><br><span class="line">MODIFY salary DOUBLE(10,2) DEFAULT &#x27;aaa&#x27;;  # 添加到表中的第一个字段</span><br><span class="line"></span><br><span class="line"># 重命名一个字段</span><br><span class="line">ALTER TABLE dept80</span><br><span class="line">CHANGE department_name dept_name varchar(15);</span><br><span class="line"></span><br><span class="line"># 删除一个字段</span><br><span class="line">ALTER TABLE myemp1 DROP salary</span><br><span class="line"></span><br><span class="line"># 重命名表</span><br><span class="line">RENAME TABLE myemp1</span><br><span class="line">TO myemp11</span><br><span class="line"></span><br><span class="line"># 删除表</span><br><span class="line">DROP TABLE myemp1 IF EXISTS</span><br><span class="line"></span><br><span class="line"># 清空表</span><br><span class="line">TRUNCATE TABLE myemp1;</span><br><span class="line">#【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 TRIGGER，有可能造成事故，故不建议在开发代码中使用此语句。</span><br></pre></td></tr></table></figure><h3 id="二ddl-和-dml的说明">二、DDL 和 DML的说明</h3><p>​ DDL的操作一旦执行，就不可回滚。</p><p>​DML的操作默认情况，一旦执行，也是不可回滚的。但是，如果在执行DL之前，执行了SETautocommit=FALSE，则执行的DML操作就可以实现回滚。</p><h3 id="三mysql8-ddl的原子化">三、MYSQL8 ——DDL的原子化：</h3><p>​在MySQL8.0版本中，InnoDB表的DDL支持事务完整性，即DDL操作要么成功要么回滚。DDL操作回滚日志写入到datadictionary数据字典表mysql.innodb_ddlIlog（该表是隐藏的表，通过showtables无法看到）中，用于回滚操作。通过设置参数，可将DDL操作日志打印输出到MySQL错误日志中。</p><h3 id="四增删改">四、增删改</h3><h4 id="增">1、增</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO departments(department_id, department_name)</span><br><span class="line">VALUES (80, &#x27;IT&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO emp(emp_id,emp_name)</span><br><span class="line">VALUES (1001,&#x27;shkstart&#x27;),</span><br><span class="line">(1002,&#x27;atguigu&#x27;),</span><br><span class="line">(1003,&#x27;Tom&#x27;);</span><br><span class="line"></span><br><span class="line"># 通过SELECT来增加</span><br><span class="line">INSERT INTO sales_reps(id, name, salary, commission_pct)</span><br><span class="line">SELECT employee_id, last_name, salary, commission_pct</span><br><span class="line">FROM employees</span><br><span class="line">WHERE job_id LIKE &#x27;%REP%&#x27;;</span><br></pre></td></tr></table></figure><h4 id="删">2、删</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM departments</span><br><span class="line">WHERE department_name = &#x27;Finance&#x27;;</span><br></pre></td></tr></table></figure><h4 id="改">3、改</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE employees</span><br><span class="line">SET department_id = 70</span><br><span class="line">WHERE employee_id = 113;</span><br></pre></td></tr></table></figure><h4 id="mysql8-计算列">4、MYSQL8 计算列：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tb1(</span><br><span class="line">    id INT,</span><br><span class="line">    a INT,</span><br><span class="line">    b INT,</span><br><span class="line">    c INT GENERATED ALWAYS AS (a + b) VIRTUAL</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="五数据类型详解">五、数据类型详解：</h3><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220910112143456.png" style="zoom:67%;" /></p><h4 id="整型">1、整型</h4><ul><li><p>TINYINT 1字节一般用于枚举数据，比如系统设定取值范围很小且固定的场景</p></li><li><p>SMALLINT 2字节可以用于较小范围的统计数据，比如统计工厂的固定资产库存数量</p></li><li><p>MEDUIMINT 3字节 用于较大整数的计算，比如车站每日的客流量</p></li><li><p>INT4字节取值范围足够大，一般情况下不用考虑超限问题，用得最多。比如商品编号</p></li><li><p>BIGINT 8字节只有当你处理特别巨大的整数时才会用到。比如双十一的交易量、大型门户网站点击量、证券公司衍生产品持仓等</p></li><li><p>可选属性</p><ul><li>UNSIGNED 无符号属性</li><li>ZEROFILL 零填充</li></ul></li></ul><h4 id="浮点类型">2、浮点类型</h4><ul><li>FLOAT</li><li>DOUBLE</li></ul><p>​如果用到浮点数，要特别注意误差问题，因为浮点数是不准确的，所以我们要避免使用“=”来​判断两个数是否相等。同时，在一些对精确度要求较高的项目中，千万不要使用浮点数，不然会导致结果错误，甚至是造成不可挽回的损失</p><h4 id="定点数类型">3、定点数类型：</h4><ul><li><p>DECIMAL(M,D)</p></li><li><p>表示高精度小数。其中，M被称为精度，D被称为标度。0&lt;=M&lt;=65，0&lt;=D&lt;=30，D&lt;M。例如，定义DECIMAL（5,2）的类型，表示该列取值范围是-999.99~999.99。</p></li><li><p>DECIMAL的存储空间并不是固定的，由精度值M决定，总共占用的存储空间为M+2个字节。也就是说，在一些对精度要求不高的场景下，比起占用同样字节长度的定点数，浮点数表达的数值范围可以更大一些。</p></li><li><p>定点数在MySQL内部是以字符串的形式进行存储，这就决定了<strong>它一定是精准的</strong>。</p></li></ul><h4 id="位类型">4、位类型</h4><ul><li>BIT(M)</li><li>如果没有指定(M)，默认是1位。这个1位，表示只能存1位的二进制值。这里(M)是表示二进制的位数，位数最小值为1，最大值为64。</li></ul><h4 id="日期与时间类型">5、日期与时间类型</h4><ul><li><p>YEAR 类型通常用来表示年</p></li><li><p>DATE 类型通常用来表示年、月、日</p></li><li><p>TIME 类型通常用来表示时、分、秒</p></li><li><p>DATETIME 类型通常用来表示年、月、日、时、分、秒</p></li><li><p>TIMESTAMP 类型通常用来表示带时区的年、月、日、时、分、秒</p></li><li><p>DATETIME占用8个字节</p></li><li><p>TIMESTAMP占用4个字节，TIMESTAMP底层存储的是毫秒值</p></li><li><p>DATETIME 和 TIMESTAMP差别：</p><ul><li>TIMESTAMP存储的时间范围比DATETIME要小很多，只能存储“1970-01-0100:00:01 UTC”到“2038-01-19 03:14:07UTC”之间的时间。存储数据的时候需要对当前时间所在的时区进行转换，查询数据的时候再将时间转换回当前的时区。因此，使用TIMESTAMP存储的同一个时间值，在不同的时区查询时会显示不同的时间</li><li>TIMESTAMP会根据用户的时区不同，显示不同的结果。而DATETIME则只能反映出插入时当地的时区，其他时区的人查看数据必然会有误差的,需要额外做处理</li></ul></li></ul><h4 id="文本字符串类型">6、文本字符串类型</h4><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220910143332516.png" /></p><ul><li>何时使用CHAR？何时使用VARCHAR？<ul><li><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220910143612992.png" /></li><li>情况1：存储很短的信息。比如门牌号码101，201....这样很短的信息应该用char，因为varchar还要占个byte用于存储信息长度，本来打算节约存储的，结果得不偿失。</li><li>情况2：固定长度的。比如使用uuid作为主键，那用char应该更合适。因为他固定长度，varchar动态根据长度的特性就消失了，而且还要占个长度信息。</li><li>情况3：十分频繁改变的列，因为varchar的每次存储都需要有额外的计算，得到长度等工作。如果一个非常频繁改变的话，会又较多的小号用于计算。</li><li>情况4：具体存储引擎的情况：<ul><li>InnoDB存储引擎，建议使用VARCHAR类型。因为对于InnoDB数据表，内部的行存储格式并没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），而且主要影响性能的因素是数据行使用的存储总量，由于char平均占用的空间多于varchar，所以除了简短并且固定长度的，其他考虑varchar。这样节省空间，对磁盘I/O和数据存储总量比较好。</li></ul></li></ul></li><li>关于TEXT字段：<ul><li>TEXT文本类型，可以存比较大的文本段，搜索速度稍慢，因此如果不是特别大的内容，建议使用CHAR，VARCHAR来代替。还有TEXT类型不用加默认值，加了也没用。而且text和blob类型的数据删除后容易导致“空洞”，使得文件碎片比较多，所以频繁使用的表不建议包含TEXT类型字段，建议单独分出去，单独用一个表。</li></ul></li><li>关于ENUM和SET<ul><li>设置字段值时，ENUM类型只允许从成员中选取单个值，不能一次选取多个值。</li><li>SET类型在选取成员时，可以一次选择多个成员，这一点与ENUM类型不同。</li></ul></li></ul><h4 id="二进制字符串">7、二进制字符串</h4><p>BINARY VARBINARY BLOB</p><ul><li>使用TEXT和BLOB时的注意事项：<ul><li>BLOB和TEXT值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值会在数据表中留下很大的"空洞"，以后填入这些"空洞"的记录可能长度不同。为了提高性能，建议定期 使用OPTIMIZE TABLE 功能对这类表进行碎片整理。</li><li>如果需要对大文本字段进行模糊查询，MySQL提供了前缀索引。但是仍然要在不必要的时候避免检索大型的BLOB或TEXT值。例如，SELECT *查询就不是很好的想法，除非你能够确定作为约束条件的WHERE子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的值。</li><li>把BLOB或TEXT列分离到单独的表中。在某些环境中，如果把这些数据列移动到第二张数据表中，可以让你把原数据表中的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会减少主表中的碎片，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行 SELECT* 查询的时候不会通过 网络传输大量的BLOB或TEXT值。</li></ul></li></ul><h4 id="json类型">8、JSON类型：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO test_json (js)</span><br><span class="line">VALUES (&#x27;&#123;&quot;name&quot;:&quot;songhk&quot;, &quot;age&quot;:18, &quot;address&quot;:&#123;&quot;province&quot;:&quot;beijing&quot;,</span><br><span class="line">&quot;city&quot;:&quot;beijing&quot;&#125;&#125;&#x27;);</span><br></pre></td></tr></table></figure><h4 id="空间类型">9、空间类型：</h4><p>​ MySQL空间类型扩展支持地理特征的生成、存储和分析。这里的地理特征表示世界上具有位置的任何东西，可以是一个实体，例如一座山；可以是空间，例如一座办公楼；也可以是一个可定义的位置，例如一个十字路口等等。MySQL中使用Geometry（几何）来表示所有地理特征。Geometry指一个点或点的集合，代表世界上任何具有位置的事物。</p><h4 id="总结">10、总结：</h4><ul><li>任何字段如果为非负数，必须是 UNSIGNED</li><li>【强制】小数类型为 DECIMAL，禁止使用 FLOAT 和DOUBLE。说明：在存储的时候，FLOAT 和 DOUBLE都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过DECIMAL 的范围，建议将数据拆成整数和小数并分开存储。</li><li>【强制】如果存储的字符串长度几乎相等，使用 CHAR定长字符串类型。</li><li>【强制】VARCHAR 是可变长字符串，不预先分配存储空间，长度不要超过5000。如果存储长度大 于此值，定义字段类型为TEXT，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</li></ul>]]></content>
    
    
    <summary type="html">Chap3——Mysql DDL操作、增删改与数据类型</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Mysql各类函数与子查询</title>
    <link href="https://blog.fantast.top/2022/09/05/22f2ef21dade/"/>
    <id>https://blog.fantast.top/2022/09/05/22f2ef21dade/</id>
    <published>2022-09-05T09:03:19.000Z</published>
    <updated>2022-09-07T10:08:31.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一函数">一、函数</h3><h4 id="流程控制函数">1、流程控制函数</h4><ul><li>CASE WHEN THEN</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id,salary, CASE WHEN salary&gt;=15000 THEN &#x27;高薪&#x27;</span><br><span class="line">WHEN salary&gt;=10000 THEN &#x27;潜力股&#x27;</span><br><span class="line">WHEN salary&gt;=8000 THEN &#x27;屌丝&#x27;</span><br><span class="line">ELSE &#x27;草根&#x27; END &quot;描述&quot;</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure><ul><li>IF &amp;&amp; IFNULL</li></ul><h4 id="加密与解密函数">2、加密与解密函数</h4><ul><li><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220905172002244.png" /></li></ul><h4 id="mysql信息函数">3、MYSQL信息函数</h4><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220905172039855.png" /></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220905172112542.png" /></p><h4 id="一些其他单行函数">4、一些其他单行函数：</h4><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220905172140390.png" /></p><h4 id="聚合函数">5、聚合函数：</h4><p>​ <strong>输入一组数据的集合，输出单个值</strong></p><ul><li>常用的聚合函数：AVG SUM MAX MIN</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT AVG(salary),SUM(salary),AVG(salary)*107</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT MAX(salary),MIN(salary)</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure><ul><li>COUNT</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(employee_id),COUNT(salary),COUNT(2* salary)</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure><ul><li><p>COUNT计算指定字段，是不计算该字段为空值的记录数目的</p></li><li><p>所以如果想要计算表中有多少条记录，可以使用COUNT(*)</p></li></ul><p><strong>需求：查询公司中平均奖金率</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 错误的做法，因为有可能commission_pct为null</span><br><span class="line">SELECT AVG(commission_pct)</span><br><span class="line">FROM employees;</span><br><span class="line"># 正确的做法：</span><br><span class="line">SELECT SUM(commission_pct) / COUNT(IFNULL(commission_pct,0))</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure><ul><li>GROUP BY 的使用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT department_id,AVG(salary)</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br></pre></td></tr></table></figure><ul><li>如果要使用多个列进行GROUP BY 分组操作：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT department_id,job_id,AVG(salary)</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id,job_id</span><br></pre></td></tr></table></figure><p><strong>提示结论</strong>：</p><ul><li><p>出现在SELECT中的非聚合函数字段，都必须出现在GROUPBY里面。</p></li><li><p>GROUP BY 声明在FROM后面、WHERE后面，ORDERBY前面、LIMIT前面</p></li><li><p>在GROUP BY中使用 WITH ROLLUP，使用WITHROLLUP关键字之后，在所有查询出的分组记录之后增加一条记录，该记录计算查询出的所有记录的总和，即统计记录数量。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT department_id,AVG(salary) AS avg_sal</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id WITH ROLLUP;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 当使用ROLLUP时，不能同时使用ORDER BY子句进行结果排那，即ROLLUP和ORDER BY是互相排斥的。</span><br><span class="line">SELECT department_id,AVG(salary) AS avg_sal</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">ORDER BY avg_sal ASC;</span><br></pre></td></tr></table></figure><ul><li>Having的使用（用于过滤数据）<ul><li>如果过滤条件中使用了聚合函数，必须使用HAVING来替换WHERE</li><li>如果过滤条件中没有聚合函数，则过滤条件声明在HAVING或WHERE中都可以</li></ul></li></ul><p><strong>查询各个部门中最高工资比10000高的部门信息：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT department_id,MAX(salary)</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING MAX(salary) &gt; 10000</span><br></pre></td></tr></table></figure><h4 id="where-和-having的区别">6、WHERE 和 HAVING的区别：</h4><ul><li>区别1：WHERE可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件；HAVING必须要与GROUPBY配合使用，可以把分组计算的函数和分组字段作为筛选条件。</li><li>区别2：如果需要通过连接从关联表中获取需要的数据，WHERE是先筛选后连接，而HAVING是先连接后筛选。这一点，就决定了在关联查询中，WHERE比HAVING更高效。因为WHERE可以先筛选，用一个筛选后的较小数据集和关联表进行连接，这样占用的资源比较少，执行效率也比较高。HAVING则需要先把结果集准备好，也就是用未被筛选的数据集进行关联，然后对这个大的数据集进行筛选，这样占用的资源就比较多，执行效率也较低。</li></ul><h4 id="sql底层执行原理">7、SQL底层执行原理：</h4><p>Select语句的完整结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># sql92</span><br><span class="line">SELECT ... , ... , ... (存在聚合函数)</span><br><span class="line">FROM ... , ... , ...</span><br><span class="line">WHERE 多表连接条件 AND 不包含聚合函数的过滤条件</span><br><span class="line">GROUP BY ...</span><br><span class="line">HAVING 包含聚合函数的过滤条件</span><br><span class="line">ORDER BY ... (ASC/DESC)</span><br><span class="line">LIMIT ...,...</span><br><span class="line"></span><br><span class="line"># sql92</span><br><span class="line">SELECT ... , ... , ... (存在聚合函数)</span><br><span class="line">FROM ... JOIN ... ON 多表连接条件</span><br><span class="line">JOIN ... ON ...</span><br><span class="line">WHERE 不包含聚合函数的过滤条件</span><br><span class="line">GROUP BY ...</span><br><span class="line">HAVING 包含聚合函数的过滤条件</span><br><span class="line">ORDER BY ... (ASC/DESC)</span><br><span class="line">LIMIT ...,...</span><br></pre></td></tr></table></figure><ul><li>SQL语句如何执行，执行过程？<ul><li>FROM—&gt; ON( 多表连接条件)—&gt; ( LEFT / RIGHT JOIN根据左外右外连接补充数据 ) —&gt; WHERE（筛选数据）</li><li>—&gt; GROUP BY（分组） —&gt; HAVING（分组后筛选） —&gt;SELECT（选择） —&gt; ORDER BY（排序） —&gt;</li><li>LIMIT （限制条数）</li></ul></li></ul><h3 id="二子查询">二、子查询</h3><p>​很多时候查询需要从结果集中获取数据，或者<strong>需要从同一个表中先计算得出一个数据结果，然后与这个数据结果（可能是某个标量，也可能是某个集合）进行比较。</strong></p><p>​ <strong>虽然有的时候子查询可以通过两个连续的SQL查询或自连接实现同样的功能，但是子查询性能更优。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &gt; (</span><br><span class="line"> SELECT salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name = &#x27;Abel&#x27;</span><br><span class="line"> );</span><br></pre></td></tr></table></figure><p>​ <strong>子查询在主查询之前一次执行完成</strong></p><p>​ <strong>将子查询放在比较条件的右侧</strong></p><p>​ <strong>单行操作对应单行子查询，多行操作对应多行子查询</strong></p><h4id="内查询返回的结果条目数单行多行子查询">1、内查询返回的结果条目数（单行、多行子查询）：</h4><ul><li><p>单行子查询（内查询返回单行数据）</p></li><li><p>多行子查询：应当使用多行比较操作符： IN ， ANY ， ALL</p><ul><li><p>返回其它job_id中比job_id为 'IT_PROG'部门任一工资低的员工的员工号</p></li><li><p>```mysql SELECT employee_id,last_name,job_id,salary FROMemployees WHERE job_id &lt;&gt; 'IT_PROG' AND salary &lt; ANY ( SELECTsalary FROM employees WHERE job id = 'IT PROG' );<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2、内查询是否被执行多次（相关子查询、不相关子查询）：</span><br><span class="line"></span><br><span class="line">- 相关子查询</span><br><span class="line"></span><br><span class="line">  - 内查询返回的值与外查询相关</span><br><span class="line"></span><br><span class="line">  - 如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，**因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为关联子查询。**</span><br><span class="line"></span><br><span class="line">    ```mysql</span><br><span class="line">    # 查询工资大于本部门平均工资的员工信息</span><br><span class="line">    # 张三在部门A，李四在部门B，那么张三来查和李四来查，内查询查的是各自部门的平均工资，返回的是不一样的，也就是内查询执行了多次</span><br></pre></td></tr></table></figure></p></li></ul></li></ul><p>​ <strong>执行流程</strong>：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220907113232810.png" style="zoom: 67%;" /></p><p><strong>查询员工中工资大于本部门平均工资的员工的lat_name，salary和其department_id</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT last_name,salry,department_id</span><br><span class="line">FROM employees AS e1</span><br><span class="line">WHERE salry &gt; (</span><br><span class="line">SELECT AVG(salary) as avg_sal</span><br><span class="line">FROM employees as e2</span><br><span class="line">WHERE e2.department_id = e1.department_id</span><br><span class="line">GROUP BY department_id )</span><br></pre></td></tr></table></figure><p><strong>查询员工的id,salary,按照department_name排序</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee id, salary</span><br><span class="line">FROM employees AS e</span><br><span class="line">ORDER BY(</span><br><span class="line">SELECT department_name</span><br><span class="line">FROM departments AS d</span><br><span class="line">WHERE e.department_id = d.department_id </span><br><span class="line">) ASC;</span><br></pre></td></tr></table></figure><ul><li><p>不相关子查询</p><ul><li><p>内查询返回的值与外查询无关</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查询工资大于本公司平均工资的员工信息</span><br><span class="line"># 张三在部门A，李四在部门B，那么张三来查和李四来查，内查询查的都是全公司的平均工资，返回的是一样的，也就是内查询执行了一次</span><br></pre></td></tr></table></figure></li></ul></li><li><p>相关子查询结论：<strong>在SELECT语句中，除了GROUP BY 和LIMIT之外，其他地方都可以声明子查询</strong></p></li></ul><h4id="相关子查询中的exists-和-not-exists关键字">3、相关子查询中的EXISTS 和NOT EXISTS关键字</h4><ul><li><p>如果在子查询中不存在满足条件的行：</p><ul><li><p>条件返回 FALSE</p></li><li><p>继续在子查询中查找</p></li></ul></li><li><p>如果在子查询中存在满足条件的行：</p><ul><li>不在子查询中继续查找</li><li>条件返回 TRUE</li></ul></li></ul><p><strong>查询公司管理者的employee_id，last_name，job_id，department_id信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee id, last name, job id, department id</span><br><span class="line">FROM employees e1</span><br><span class="line">WHERE EXISTS(</span><br><span class="line">SELECT *</span><br><span class="line">FROM employees e2</span><br><span class="line">WHERE e1.employee_id= e2.manager_id</span><br><span class="line"> );</span><br><span class="line"># 将外查询中的第1条记录送入子查询中，执行查找，如果存在则返回TRUE</span><br><span class="line"># 将外查询中的第2条记录送入子查询中，执行查找，如果存在则返回TRUE</span><br><span class="line"># 将外查询中的第...条记录送入子查询中，执行查找，如果存在则返回TRUE   </span><br><span class="line"># 相关子查询的执行过程就是如上所述</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Chap2——Mysql数据库函数与子查询精简复习版</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Mysql基本查询内容</title>
    <link href="https://blog.fantast.top/2022/09/03/7e7267227ba3/"/>
    <id>https://blog.fantast.top/2022/09/03/7e7267227ba3/</id>
    <published>2022-09-03T06:43:19.000Z</published>
    <updated>2022-09-05T09:03:55.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一些非关系型数据库">1、一些非关系型数据库</h4><h5 id="键值型数据库">键值型数据库：</h5><p>​查找速度极快，但无法使用条件过滤。最典型的应用场景为内存缓存，Redis是最流行的键值型数据库</p><h5 id="文档型数据库">文档型数据库：</h5><p>​存放并获取文档，文档作为基本单位，一个文档为一条记录，可以是XML或JSON格式，MongoDB是最常见的文档型数据库</p><h5 id="搜索引擎数据库">搜索引擎数据库：</h5><p>​ 核心是“倒排索引”。</p><h5 id="列式数据库">列式数据库：</h5><p>​ 大量降低系统IO，适合于分布式文件系统</p><h5 id="图形数据库">图形数据库：</h5><p>​ 利用了图这种数据结构存储实体对象之间的关系 比如Neo4J</p><h4 id="er模型与表记录">2、ER模型与表记录</h4><ul><li>ER模型，三个主要概念：<strong>实体集、属性、联系集</strong></li><li>ORM思想：Object Relational Mapping 对象关系映射 【 数据库中的一个表对应编程语言中的一个类】</li></ul><h5 id="一对一关系">1) 一对一关系：</h5><p>​实际应用中不多，因为1对1的关系实际上可以建立成一张表。<strong>主要应用于优化性能。</strong>比如说设计学生表，把他拆解为基础信息表和不常用信息表，这样子快速查询时只需要查询基础信息表即可，提升查询速度</p><h5 id="一对多关系多对多关系等">2) 一对多关系、多对多关系等</h5><h4 id="sql分类">3、SQL分类：</h4><ul><li>DDL：数据定义语言（CREATE ALTER TRUNCATE等）</li><li>DML：数据操作语言（INSERT DELETE等）</li><li>DCL：数据控制语言（COMMIT ROLLBACK SAVEPOINT GRANT REVOKE）</li></ul><h4 id="sql使用规范与规则">4、SQL使用规范与规则</h4><ul><li>MYSQL在Windows环境下是大小写不敏感的</li><li>MYSQL在Linux环境下：数据库名、表名、变量名严格区分大小写</li><li>在Linux环境下：关键字、函数名、列名忽略大小写</li></ul><h4 id="select基础操作">5、SELECT基础操作：</h4><ul><li>列的别名</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id AS emp_id,last_name AS lname,salary * 12 AS sal</span><br><span class="line">FROM employees</span><br></pre></td></tr></table></figure><ul><li>去除重复：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT department_id</span><br><span class="line">FROM employees</span><br><span class="line">/** 将department_id 和 salary视作一个整体去重**/</span><br><span class="line">SELECT DISTINCT department_id,salary</span><br><span class="line">FROM employees</span><br></pre></td></tr></table></figure><ul><li>空值NULL如何参与运算</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT salary AS &quot;月工资&quot;,salary * (1 + IFNULL(commission_pct,0)) * 12 AS &quot;年工资&quot;</span><br><span class="line">FROM employees</span><br></pre></td></tr></table></figure><ul><li>显示表结构,显示表字段的相关信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESCRIBE employees</span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220903195253736.png" /></p><h4id="比较运算符使用关键是null值参与比较时规则">6、比较运算符使用：（关键是NULL值参与比较时规则）</h4><ul><li><p>= 运算符：</p><ul><li><p>在MYSQL中，如果数值和字符串比较，字符串存在隐式转换，如果转换数值不成功，则看作0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT 0 = &#x27;a&#x27;  # 为 1</span><br><span class="line">FROM DUAL;</span><br></pre></td></tr></table></figure></li><li><p>只要有NULL参与比较，则结果均为NULL</p></li></ul></li><li><p>若使用安全等于运算符 &lt;=&gt; 会有所不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;=&gt; NULL  #为0   </span><br><span class="line">NULL&lt;=&gt;NULL #为1</span><br></pre></td></tr></table></figure></li><li><p>LEAST  GREATEST 运算符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT LEAST(first_name,last_name)</span><br><span class="line">FROM employees</span><br></pre></td></tr></table></figure></li><li><p>IN  NOT IN运算符： 离散值查找</p></li></ul><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT last_name</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id IN (10,20,30)</span><br></pre></td></tr></table></figure></p><ul><li><p>LIKE 模糊查询：</p><ul><li>% 0个及以上的字符占位符</li><li>_ 1个字符占位符</li></ul></li><li><p>REGEXP 使用正则表达式进行匹配</p></li></ul><h4 id="排序与分页">7、排序与分页：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id</span><br><span class="line">FROM employees</span><br><span class="line">ORDER BY salary DESC;</span><br></pre></td></tr></table></figure><ul><li><p>可以使用列的别名进行排序，但不可以使用列的别名在WHERE中</p></li><li><p>可以使用不在SELECT中的字段进行排序操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id,salary,salary*12 AS annual_sal</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id &lt; 50</span><br><span class="line">ORDER BY annual_sal;</span><br></pre></td></tr></table></figure></li><li><p>数据库查询操作的执行顺序：</p><ul><li>FROM + WHERE部分最优先</li><li>执行SELECT 部分，确定要查询的字段</li><li>执行ORDER BY部分</li><li>执行LIMIT部分</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIMIT $&#123;offset&#125;,$&#123;count&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="多表查询">8、多表查询：</h4><ul><li>连接条件，笛卡尔积，A表中的每一条记录都去对应B表中的每一条记录，进行组合。</li><li>如果查询语句中出现了多个表中都存在的字段，则必须指明此字段所在的表。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee id，department name #两个表的连接条件</span><br><span class="line">FROM employees,departments</span><br><span class="line">WHERE employees.&#x27;department_id&#x27;=departments.department_id</span><br></pre></td></tr></table></figure><ul><li><p>可以给表起别名，在SELECT和WHERE中使用表的别名。注意：如果给表起了别名，一旦在SELECT或WHERE中使用表名的话，则必须使用表的别名，而不能再使用表的原名。</p></li><li><p>如果有n个表实现多表的查询，则需要至少n-1个连接条件</p></li><li><p>自连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee _id, last name, employee id, last_name</span><br><span class="line">FROM employees emy, employees mgr</span><br><span class="line">WHERE emp.manager_id = mgr. employee_id</span><br></pre></td></tr></table></figure></li><li><p>内连接：合并具有同一列的两个以上的表的行，结果集中不包含一个表与另一个表不匹配的行</p></li><li><p>外连接：合并具有同一列的两个以上的表的行，结果集中除了包含一个表与另一个表匹配的行之外，还查询到了左表或右表中不匹配的行。</p><ul><li>左外连接 &amp; 右外连接</li><li>两个表在连接过程中除了返回满足连接条件的行以外还返回左表（右表）中不满足条件的行，</li></ul></li><li><p>示例：查询<strong>所有的</strong>员工的last_name，department_name信息</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT last name, department name</span><br><span class="line">FROM employees e LEFT OUTER JOIN departments d</span><br><span class="line">ON e.department_id = d.department_id</span><br></pre></td></tr></table></figure><ul><li>示例：查询<strong>有部门的</strong>员工的last_name，department_name信息(内连接)，使用JOIN ON语法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT last name, department name</span><br><span class="line">FROM employees e INNER JOIN departments d</span><br><span class="line">ON e.department_id = d.department_id</span><br></pre></td></tr></table></figure><h4 id="union关键字">9、UNION关键字</h4><p>​ 用于合并两个结果集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FROM ... </span><br><span class="line">UNION</span><br><span class="line">SELECT ... FROM ...</span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220905112924821.png" /></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220905112945650.png" /></p><p>​<strong>注意：执行UNIONALL语句时所需要的资源比UNION语句少。如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复的数据，则尽量使用UNIONALL语句，以提高数据查询的效率。</strong></p><h4 id="种sql的-join操作">10、7种SQL的 JOIN操作：</h4><p>​ 有些具体数据库不支持的操作，可以通过UNION或UNIONALL来合并支持操作的结果集</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220905112815584.png" style="zoom: 80%;" /></p><h4 id="natural-join-和-using-连接sql99新特性">11、NATURAL JOIN 和 USING连接（SQL99新特性）</h4><ul><li>Natural Join它会帮你自动查询两张连接表中所有柯同的字段，然后进行等值连接。</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220905113547787.png" /></p><ul><li>以下两条语句等价：</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220905113555008.png" /></p><ul><li>Using 优化：<ul><li>USING指定了具体的相同的字段名称，你需要在USING的括号（）中填入要指定的同名字段。同时使用JOIN...USING可以简化JOINON的等值连接。它与下面的SQL查询结果是相同的：</li></ul></li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220905113740065.png" /></p>]]></content>
    
    
    <summary type="html">Chap1——Mysql数据库基础与概述精简复习版，包含基本查询，多表查询，排序分页等</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>设计模式1</title>
    <link href="https://blog.fantast.top/2022/09/03/2ceecb19279d/"/>
    <id>https://blog.fantast.top/2022/09/03/2ceecb19279d/</id>
    <published>2022-09-03T06:43:19.000Z</published>
    <updated>2022-09-13T02:04:34.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="section">1、</h4>]]></content>
    
    
    <summary type="html">设计模式</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Java开发经验——0823日志1</title>
    <link href="https://blog.fantast.top/2022/08/15/ebbd271e8df3/"/>
    <id>https://blog.fantast.top/2022/08/15/ebbd271e8df3/</id>
    <published>2022-08-15T13:27:23.000Z</published>
    <updated>2022-09-07T14:27:41.000Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="7bff88e0012b18d8d7d0270af5c6c0fe7b6a1bc7f11bd1a7e92faf07212330a7">5b75cfd994443fd8ef220370f00a3fa4461ecbc081186bae611d070e9fac23e9bc70aee727e83acc5bb7a91a891e516e4a7b3fd9cf39579ef096d21236333396f794cc835ab3097bfe35b4dda2385dd584508e057a30d7bd06ec04e2dc73c3f8741b5b7dcee0a1f3f9360ff2a0478348e84408b422a74ae1ebbe1e485c4ee94a138d82b3a03cca25d37b022cc57a256448a271bcd406eee952fa793fc4adb35c08aacffa6f8e5d5cc8d24ff852792129bfe885e0d7571801eda5c0b47272d7d8ab0040619816e92492992688e9ac6eb9d76d9d79289134f74441c8418384a7d25782a07e65f33f29b7f808a5fe498f44ad90f1f44347298e83b2397e634e01ec7584df70b79831bd9194f968e34dc0808f303675c9f345d47c6fc7efa752356cdd6f54ae0c9b3ab34d456302d54140c0bf1cdf6f407761262135cfc21706c5ab18d3a0b036a6b3a5c2368a07c1aaa77dc2f28175a783cb7939565efad831c619303b3bd0890a79e95a3478c502d3da62609a3fe137013b832d36616f780effe126cf07d8311919e28fd941e7d35d1af90faf67e78c9234fe80b85296b8498c02bdc9ea6a2ef507f0c3320bd6e382b42e39f7fdb6169d557bf0085443e9ca26c3f422631a258e6154f5c3f5ef4eaae9912be7235917368017516bedb052299f1d5bfd82433462771cdd533407252baf3085ba5f3bf7d582d45757552e911824002deeb436402f16b79f1226c7127348134c450b6d11470ebff8ca358da7e05059565f3c023fbc1f2c584742ad8d921b7e1a54d081d8c26f6a56e70120a79058ff1710cbb4afb58a684c38c109ce21a71628f99242043c8de76703cc715314eb06</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Java开发经验——0823日志1</summary>
    
    
    
    <category term="⓻ 经验整理类笔记" scheme="https://blog.fantast.top/categories/%E2%93%BB-%E7%BB%8F%E9%AA%8C%E6%95%B4%E7%90%86%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Java开发经验——0815日志1</title>
    <link href="https://blog.fantast.top/2022/08/15/bb402ab73028/"/>
    <id>https://blog.fantast.top/2022/08/15/bb402ab73028/</id>
    <published>2022-08-15T13:27:23.000Z</published>
    <updated>2022-09-07T14:27:33.000Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="1d61c0fc9529643c45934df25f1801317a5a9ec15f14590d9a4e5a71a20a39cd">5b75cfd994443fd8ef220370f00a3fa4461ecbc081186bae611d070e9fac23e9bc70aee727e83acc5bb7a91a891e516e3ed3f53ca3563506c209cec7f7dd47cf43d7f8ad90a64f771f2c739c94cc8635d2692fd7a86e1afabd60f14467bb6285dd9e4985732f2300fef62c7f85acda2d8014669dc425265465c14a8300636aff0ba4fa04a6095d3cadf517a55e8f51e38db73692bd140f1cc7f31b2d0bc19da8c1dd8a14b5cdc5d1e82f7b88e1025db02739a66c7ddc9ed3f40a4b60f3cea054940df4527fc090191c611597601f26dc9f070070b296626315afe89dbb6c682f6ff8439f43dd46d4bd7bfc0489b3c60f6f9940d72965ba74687751d978a3e4ad8bb332486e98d449ef121e6ef93f1c9f3c4c181958863dfc33587f8d0532f026eb797c3f38c400d667187e7d75e598da336a177ff7ab5956c8a690c743a19cec437c9a7c36b993fb460b129f1e605559bc32bc64ee995b0f5a33eeb1741c82a71ce0e4be7fb99fa6d017e86af11a322d5318e1bdcd86c649e9a4aa52f7cefa377f139797d78470cf275fba9751ff4e5d8b51f88084aefabc50bb0c5c877cf841d2899bc11935d14ed4b4a7618a87b3f9459a57800ebe5725760821930ee2e4bfc42467ba96e164965bd93e264f0e8eef715cd59fc65348f48e98c1f075f0b2073b43db94ea80bdcb44cdd0db24edd6bab5c91618292f0d69e70a75cfec38dc653f1a742aadc54ae7c9757ce0c09409dd7068fa8d9d664996eda7c76711fdf73023fa6576c00284367ac83c6335812f919ea091dba2856d27296e86e3a8fafcca69138f59103bdc711bae1e5d82a1a9d2ee8fdd760d31f7b9b85028b44f28766c3289c6be836a86690e4f9a4eda49791a043037ce46e3b6d72a666ac59635cd7dc3ffbe61aa9caf46f6b459eb56e851f667d53b3353b748a1f484cc95504a63e8b9880a1e10bc5390889d1ce07c0c55808cd360bccfb60c97325eb8559f62c365485b0d9707e35ea8dbd387eaf70a258cd2d55f4b2439821921e81eeffc0077e8a760bafc921cd29bca02d0db79896f3a459f9b1b61b767ccb84cdc315bc7706af0a0d9762a17208c382d6048d54c828c40f3a0b5015c9154aca60bcf8fe776d8cddc87cd4eb0bfe42e2191dc00d5e6e887d11ed873071c046797004d767611a4a32f3948be4bb0414759e9fdcdda1e33da668279b1ff5c1e4bf03478e5cfa1b1c83d0da7a0b45195fc063f6958e29c48afd02e85c165433da66112822589345ef7aa2cf37b1d1de830821262f4bc0daa002da156ba87ef20c825f5a3a212d8fa2a884d08af7ddd678f022a2613c59546cf7d3644b1e0c9cb890a3ec14ace7d9452bda6019a9625e348c6c7cb3deaad044682f29e2ef7d61fa84402f7115d4b7b088ba52afd3314d72891262011fce124d4cec399413efd5d51c7eea8099a88cfa40b1951a32a66607cb422dc0af05c88c74149b14be30574112cdeb834a1a76918ed1c23f1bc39b80324b0458c0cf515f6f3f207443bdc2bd6840b2984ddef36e71a441b6a03a0894f6fd9682cadd0c42f290d4727363aa1529b2aeba36f993bebf34b167a23b9c55ccaa81b0fdb07610ffe25e8d4c58ae96de382622d0d7353fd5e803d0ebd632a245057f5e192ff4522cb8877c8bc1ef933390d35d212f2eb</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Java开发经验——0815日志1</summary>
    
    
    
    <category term="⓻ 经验整理类笔记" scheme="https://blog.fantast.top/categories/%E2%93%BB-%E7%BB%8F%E9%AA%8C%E6%95%B4%E7%90%86%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Java实现多人实时通信系统</title>
    <link href="https://blog.fantast.top/2022/08/14/4cdc462e541f/"/>
    <id>https://blog.fantast.top/2022/08/14/4cdc462e541f/</id>
    <published>2022-08-14T11:09:19.000Z</published>
    <updated>2022-09-07T01:19:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一架构体系">一、架构体系</h3><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220814172432459.png" /></p>]]></content>
    
    
    <summary type="html">里面包含了Java实现多人实时通信系统的架构体系图</summary>
    
    
    
    <category term="⓪ 项目笔记" scheme="https://blog.fantast.top/categories/%E2%93%AA-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    
    <category term="java项目" scheme="https://blog.fantast.top/categories/%E2%93%AA-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/java%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Java" scheme="https://blog.fantast.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java精简系列笔记8——网络编程</title>
    <link href="https://blog.fantast.top/2022/08/13/d7802ff9ffde/"/>
    <id>https://blog.fantast.top/2022/08/13/d7802ff9ffde/</id>
    <published>2022-08-13T06:13:19.000Z</published>
    <updated>2022-09-05T04:27:31.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一inetaddress类">一、InetAddress类:</h3><ul><li><p>获取本机的InetAddress对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InetAddress.getLocalHost();</span><br></pre></td></tr></table></figure></li><li><p>根据主机名 获得InetAddress对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InetAddress.getByName(&quot;DESKTOP-ICFPFA0&quot;)</span><br></pre></td></tr></table></figure></li><li><p>根据域名 获得InetAddress对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InetAddress.getByName(&quot;www.baidu.com&quot;);</span><br></pre></td></tr></table></figure></li><li><p>根据InetAddress对象 获取对应的 地址 或者 主机名/域名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inet.getHostAddress(); </span><br><span class="line">inet.getHostName(); </span><br></pre></td></tr></table></figure></li></ul><h3 id="二socket编程">二、Socket编程</h3><p>Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输。</p><p>当我们需要通讯时：</p><ul><li><p>socket.getOutputStream()</p></li><li><p>socket.getInputStream()</p></li></ul><h3id="三基于socket的tcp字节流编程">三、基于Socket的TCP字节流编程：</h3><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220813170808297.png" style="zoom:67%;" /></p><p>服务器和客户端的互相通信</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketTCPServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.程序监听在9999端口，等待链接</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.当没有客户端连接时，程序会阻塞，等待连接</span></span><br><span class="line">        <span class="comment">//如果有客户端连接，则会返回一个socket对象，程序继续执行</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.通过socket读取客户端写入到数据通道的数据，显示</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((readLen = inputStream.read(buf)) != -<span class="number">1</span>)&#123;   </span><br><span class="line">            <span class="comment">//该读取语句会阻塞，知道client方调用了socket.shutdownOutput();即告知此次消息已经发送结束</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buf,<span class="number">0</span>,readLen));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.通过输出流，写入数据到数据通道</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        outputStream.write(<span class="string">&quot;hello,client&quot;</span>.getBytes());</span><br><span class="line">        socket.shutdownOutput(); <span class="comment">//让对方知道你该次的消息已经发送完毕</span></span><br><span class="line"></span><br><span class="line">        outputStream.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketTCPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.连接服务端（ip，端口）</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(),<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2.连接上后，生成Socket，通过socket.getOutputStream（）</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//3.通过输出流，写入数据到数据通道，发送完数据后应当有一个结束标记</span></span><br><span class="line">        outputStream.write(<span class="string">&quot;hello,server&quot;</span>.getBytes());</span><br><span class="line">        socket.shutdownOutput();  <span class="comment">//让对方知道你该次的消息已经发送完毕，非常重要</span></span><br><span class="line"></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((readLen = inputStream.read(buf)) != -<span class="number">1</span>)&#123;  </span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buf,<span class="number">0</span>,readLen));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.关闭流对象和socket</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3id="四基于socket的tcp字符流编程">四、基于Socket的TCP字符流编程：</h3><p>和字节流编程有少许差别，需要使用转换流。</p><p>服务器和客户端的互相通信：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketTCPServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.程序监听在9999端口，等待链接</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.当没有客户端连接时，程序会阻塞，等待连接</span></span><br><span class="line">        <span class="comment">//如果有客户端连接，则会返回一个socket对象，程序继续执行</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.通过socket读取客户端写入到数据通道的数据，显示</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> bufferedReader.readLine();</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.通过输出流，写入数据到数据通道</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream));</span><br><span class="line">        bufferedWriter.write(<span class="string">&quot;hello,client&quot;</span>);</span><br><span class="line">        bufferedWriter.newLine(); <span class="comment">// 插入换行符，代表写入的内容结束了</span></span><br><span class="line">        bufferedWriter.flush(); <span class="comment">//需要手动刷新，否则不会写入数据通道</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        outputStream.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketTCPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.连接服务端（ip，端口）</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(),<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2.连接上后，生成Socket，通过socket.getOutputStream（）</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//3.通过输出流，写入数据到数据通道，发送完数据后应当有一个结束标记</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream));</span><br><span class="line">        bufferedWriter.write(<span class="string">&quot;hello,server&quot;</span>);</span><br><span class="line">        bufferedWriter.newLine(); <span class="comment">// 插入换行符，代表写入的内容结束了</span></span><br><span class="line">        bufferedWriter.flush(); <span class="comment">//需要手动刷新，否则不会写入数据通道</span></span><br><span class="line"></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> bufferedReader.readLine();</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.关闭流对象和socket</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="五tcp编程网络上传文件">五、TCP编程——网络上传文件：</h3><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220814095756722.png" style="zoom:67%;" /></p><ul><li><p>常用依赖类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fileupload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamUtil</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输入流对象转字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> is</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] streamToByteArray(InputStream is) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>(); <span class="comment">//创建输出流对象</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = is.read(b)) !=-<span class="number">1</span>)&#123;   <span class="comment">//相当于使用ByteArrayOutputStream做了中转</span></span><br><span class="line">            bos.write(b,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">byte</span>[] array = bos.toByteArray();</span><br><span class="line">        bos.close();</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输入流对象转字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> is</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">streamToString</span><span class="params">(InputStream is)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is)); <span class="comment">//创建输出流对象</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = reader.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            builder.append(line + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>客户端程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fileupload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileTCPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.连接服务端（ip，端口）</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(),<span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\1.jpg&quot;</span>;</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath));</span><br><span class="line">        <span class="type">byte</span>[] fileBytes = StreamUtil.streamToByteArray(bufferedInputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.连接上后，生成Socket，通过socket.getOutputStream();</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bufferedOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(outputStream);</span><br><span class="line">        bufferedOutputStream.write(fileBytes);</span><br><span class="line">        bufferedInputStream.close();</span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取服务器返回的信息</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> StreamUtil.streamToString(inputStream);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.关闭流对象和socket</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>服务器对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fileupload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileTCPServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.程序监听在9999端口，等待链接</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.当没有客户端连接时，程序会阻塞，等待连接</span></span><br><span class="line">        <span class="comment">//如果有客户端连接，则会返回一个socket对象，程序继续执行</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.通过socket读取客户端写入到数据通道的数据，显示</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] fileBytes = StreamUtil.streamToByteArray(bufferedInputStream);</span><br><span class="line">        <span class="type">String</span> <span class="variable">savaPath</span> <span class="operator">=</span> <span class="string">&quot;src\\new.jpg&quot;</span>;</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bufferedOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(savaPath));</span><br><span class="line">        bufferedOutputStream.write(fileBytes);</span><br><span class="line">        bufferedOutputStream.close();</span><br><span class="line"></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream));</span><br><span class="line">        bufferedWriter.write(<span class="string">&quot;file upload success&quot;</span>);</span><br><span class="line">        bufferedWriter.flush();</span><br><span class="line">        bufferedWriter.newLine();</span><br><span class="line"></span><br><span class="line">        bufferedWriter.close();  <span class="comment">//在close的时候，也会调用flush方法</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="六常用命令">六、常用命令</h3><ul><li>netstat -an | more</li><li>netstat -anb | more</li></ul><h3 id="七udp编程">七、UDP编程</h3><p><strong>DatagramSocket和DatagramPacket类</strong></p><ul><li>UDP数据报通过数据报套接字DatagramSocket发送和接收，系统不保证UDPUDP数据报通过数据报套接</li><li>DatagramSocket 发送和接收，系统不保证UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。</li><li>DatagramPacket对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号。</li><li>UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220814165451640.png" style="zoom:67%;" /></p><ul><li><p>基本流程：</p><ul><li>建立发送端，接收端</li><li>发送数据前，建立数据包 DatagramSocket 对象</li><li>调用DatagramSocket的发送、接收方法</li><li>关闭DatagramSocket</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPClientA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个DatagramSocket对象，准备接收数据</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">8000</span>);</span><br><span class="line">        <span class="comment">// 2、构建一个DatagramPacket对象，准备接受数据</span></span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf,buf.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、调用接收方法，没有接收到数据包的时候，程序会阻塞。</span></span><br><span class="line">        socket.receive(packet);</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> packet.getLength();</span><br><span class="line">        <span class="type">byte</span>[] data = packet.getData();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(data,<span class="number">0</span>,length);</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPClientB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个DatagramSocket对象，准备发送数据</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">8002</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、构建一个DatagramPacket对象，准备发送</span></span><br><span class="line">        <span class="type">byte</span>[] data = <span class="string">&quot;hello clientA&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data,data.length, InetAddress.getLocalHost(),<span class="number">8000</span>);</span><br><span class="line">        socket.send(packet);</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">本篇笔记为java精简系列笔记网络编程</summary>
    
    
    
    <category term="⓸ 编程语言类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B8-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="java精简系列笔记" scheme="https://blog.fantast.top/categories/%E2%93%B8-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B1%BB%E7%AC%94%E8%AE%B0/java%E7%B2%BE%E7%AE%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="https://blog.fantast.top/tags/java/"/>
    
  </entry>
  
</feed>
