<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fantast&#39;s Blog</title>
  
  
  <link href="https://blog.fantast.top/atom.xml" rel="self"/>
  
  <link href="https://blog.fantast.top/"/>
  <updated>2022-11-04T15:02:11.767Z</updated>
  <id>https://blog.fantast.top/</id>
  
  <author>
    <name>Fantast</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>云原生快速入门系列Chap2——Kubernetes入门</title>
    <link href="https://blog.fantast.top/2022/11/04/8e7c78160822/"/>
    <id>https://blog.fantast.top/2022/11/04/8e7c78160822/</id>
    <published>2022-11-04T09:43:19.000Z</published>
    <updated>2022-11-04T15:02:11.767Z</updated>
    
    <content type="html"><![CDATA[<h4 id="kubernetes基础概念">1、Kubernetes基础概念：</h4><ul><li><p>工程部署的演变：传统部署——虚拟机部署——容器化部署</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221104180722605.png" /></p></li><li><p>当容器化部署时代到来，微服务模块非常多的情境下，可能一台服务器上会有几十个容器，且不同的容器都部署在几十台服务器上，这个时候我们就需要一个<strong>大规模的容器编排管理系统</strong>。Kubernetes为你提供了一个可弹性运行分布式系统的框架。 Kubernetes会满足你的扩展要求、故障转移、部署模式等。</p></li><li><p>Kubernetes的特性如下：</p><ul><li><strong>服务发现和负载均衡</strong>：如果进入容器的流量很大，Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。</li><li><strong>存储编排</strong>：Kubernetes允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。</li><li><strong>自动部署和回滚</strong>：你可以自动化 Kubernetes来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器</li><li><strong>自动完成装箱计算</strong>：Kubernetes 允许你指定每个容器所需CPU 和内存（RAM）。 当容器指定了资源请求时，Kubernetes可以做出更好的决策来管理容器的资源。</li><li><strong>自我修复</strong>：Kubernetes重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。</li><li><strong>密钥与配置管理</strong>：Kubernetes允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。</li></ul></li></ul><h4 id="kubernetes架构">2、Kubernetes架构：</h4><ul><li>K8s基于一个服务器集群进行安装：N个主节点+M个工作节点（N&gt;=1）</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221104181719685.png" /></p><ul><li><strong>Control Plane控制平面【相当于集团中心，Master节点】</strong>：控制平面的组件对集群做出全局决策(比如调度)，以及检测和响应集群事件。控制平面组件可以在集群中的任何节点上运行。<ul><li>apiserver【相当于集团秘书部，一切对外活动都交给她中转】:API 服务器是Kubernetes 控制面的前端。它可通过部署多个实例进行伸缩。你可以运行kube-apiserver 的多个实例，并在这些实例之间平衡流量。</li><li>scheduler【调度者】：责监视新创建的、未指定运行<ahref="https://kubernetes.io/zh/docs/concepts/architecture/nodes/">节点（node）</a>的容器，选择节点让容器在上面运行。调度决策考虑的因素包括单个 Pod 和 Pod集合的资源需求、硬件/软件/策略约束等等。</li><li>etcd【相当于集团资料中心】：etcd是兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes所有集群数据的后台数据库。</li><li>controller-manager(c-m)【集团决策者】：在主节点上运行 <ahref="https://kubernetes.io/zh/docs/concepts/architecture/controller/">控制器</a>的组件。从逻辑上讲，每个<ahref="https://kubernetes.io/zh/docs/concepts/architecture/controller/">控制器</a>都是一个单独的进程，但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。</li><li>cloud-controller-manager(c-c-m)【外联部，可选】：仅运行特定于云平台的控制回路。如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境，所部署的环境中不需要云控制器管理器。</li></ul></li><li><strong>Node组件【相当于分工厂，Worker节点】</strong>：节点组件在每个节点上运行，维护运行的Pod 并提供 Kubernetes 运行环境<ul><li><p>kubelet【厂长，监工】：一个在集群中每个<ahref="https://kubernetes.io/zh/docs/concepts/architecture/nodes/">节点（node）</a>上运行的代理。它保证<ahref="https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/#why-containers">容器（containers）</a>都运行在 <ahref="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pod</a>中。kubelet 接收一组通过各类机制提供给它的 PodSpecs，确保这些 PodSpecs中描述的容器处于运行状态且健康。负责该节点中应用的启停以及销毁，能够探测到不同应用的状态，然后汇报给api-server。</p></li><li><p>kube-proxy【门卫导航，网络访问入口】：是集群中每个节点上运行的网络代理，实现 Kubernetes <ahref="https://kubernetes.io/zh/docs/concepts/services-networking/service/">服务（Service）</a>概念的一部分。可以告知想要访问谁怎么访问，kube-proxy维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod进行网络通信。</p></li></ul></li><li>交互形式：</li></ul><p><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221104230011339.png" /></p>]]></content>
    
    
    <summary type="html">云原生快速入门系列笔记，Kubernetes入门</summary>
    
    
    
    <category term="⑧ 工程类笔记" scheme="https://blog.fantast.top/categories/%E2%91%A7-%E5%B7%A5%E7%A8%8B%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="云原生入门" scheme="https://blog.fantast.top/categories/%E2%91%A7-%E5%B7%A5%E7%A8%8B%E7%B1%BB%E7%AC%94%E8%AE%B0/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="Cloud Native" scheme="https://blog.fantast.top/tags/Cloud-Native/"/>
    
  </entry>
  
  <entry>
    <title>云原生快速入门系列Chap1——云平台+容器化</title>
    <link href="https://blog.fantast.top/2022/11/03/a1fb45edd54f/"/>
    <id>https://blog.fantast.top/2022/11/03/a1fb45edd54f/</id>
    <published>2022-11-03T09:43:19.000Z</published>
    <updated>2022-11-04T10:06:28.873Z</updated>
    
    <content type="html"><![CDATA[<h4 id="公有云和私有云">1、公有云和私有云：</h4><ul><li><p>公有云：</p><ul><li>公有云资源（例如服务器和存储空间）由第三方云服务提供商拥有和运营，这些资源通过Internet 提供</li><li><strong>成本更低</strong>：无需购买硬件或软件，仅对使用的服务付费。</li><li><strong>无需维护</strong>：维护由服务提供商提供。</li><li><strong>近乎无限制的缩放性</strong>：提供按需资源，可满足业务需求。</li><li><strong>高可靠性</strong>：具备众多服务器，确保免受故障影响。</li><li>可用性： N个9 全年的故障时间： 365<em>24</em>3600*(1-99.9999%)</li></ul></li><li><p>私有云：</p><ul><li><p>私有云由专供一个企业或组织使用的云计算资源构成。在私有云中，<strong>服务和基础结构始终在私有网络上进行维护，硬件和软件专供组织使用。</strong>私有云的使用对象通常为政府机构、金融机构以及其他具备业务关键性运营且希望对环境拥有更大控制权的中型到大型组织。</p></li><li><p><strong>灵活性更强</strong>：组织可自定义云环境以满足特定业务需求。</p></li><li><p><strong>控制力更强</strong>：资源不与其他组织共享，因此能获得更高的控制力以及<strong>更高的隐私级别。</strong></p></li><li><p><strong>可伸缩性更强</strong>：与本地基础结构相比，私有云通常具有更强的可伸缩性。</p></li></ul></li><li><p>没有一种云计算类型适用于所有人。多种不同的云计算模型、类型和服务已得到发展，可以满足组织快速变化的技术需求。</p></li></ul><h4 id="私有网络vpc">2、私有网络VPC</h4><p>​ 集群内服务器之间互相访问，一般都是用私有IP进行访问，速度更快.</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221031170245325.png" /></p><p>​在实际的服务器集群中,可以自己先新建一个专有网络(其实就是可以在内部创建局域网,然后再通过交换机创建子网等),划分相应的网段.比如说192.168.o.0/16.</p><p>​ 不同VPC之间的主机不能直接通信,VPC提供了一个隔离域.</p><h4 id="docker容器化概念">3、Docker容器化概念</h4><ul><li>统一标准，应用构建、分享和运行。</li><li>资源隔离：cpu内存资源隔离与限制，访问设备隔离与限制，网络隔离与限制等</li><li>虚拟化技术：<ul><li>在Docker容器化技术还没有出现的时候，人们使用的是虚拟化技术。基于虚拟机的部署方式，基础镜像非常大，创建使用稍微复杂，启动速度较慢，移植与分享不方便，虽然其隔离性非常的好。</li><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221101161243475.png" style="zoom:67%;" /></li></ul></li><li>基于虚拟化的Docker容器化技术：<ul><li>基础镜像MB级别，创建简单，启动速度快，移植与分享方便</li><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221101161359831.png" style="zoom:67%;" /></li><li>架构如图所示：Registry镜像仓库，Containers容器，Images镜像</li><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221101161524606.png" style="zoom:67%;" /></li></ul></li></ul><h4 id="docker容器化常用命令">4、Docker容器化常用命令</h4><h5 id="镜像相关">1）镜像相关</h5><p>​ Docker Hub常用的镜像网站</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx  <span class="comment">#下载最新版</span></span><br><span class="line">docker pull nginx:1.20.1 <span class="comment">#下载指定版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 下载来的镜像都在本地</span></span><br><span class="line">docker images  <span class="comment">#查看所有镜像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除镜像</span></span><br><span class="line">docker rmi 镜像名:版本号 / 镜像<span class="built_in">id</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="容器启动停止相关">2）容器启动停止相关：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># -d：后台运行</span></span><br><span class="line"><span class="comment"># --restart=always   该容器开机自启，应用开机自启</span></span><br><span class="line"><span class="comment"># -p 外部端口:内部端口  端口映射 </span></span><br><span class="line">docker run --name=mynginx -d --restart=always -p 88:80 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看正在运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="comment"># 查看所有容器</span></span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除停止的容器</span></span><br><span class="line">docker <span class="built_in">rm</span>  容器<span class="built_in">id</span>/名字</span><br><span class="line">docker <span class="built_in">rm</span> -f mynginx   <span class="comment"># 强制删除正在运行中的容器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#停止容器</span></span><br><span class="line">docker stop 容器<span class="built_in">id</span>/名字</span><br><span class="line"><span class="comment">#再次启动</span></span><br><span class="line">docker start 容器<span class="built_in">id</span>/名字</span><br></pre></td></tr></table></figure><h5 id="修改容器内容">3）修改容器内容：</h5><ul><li>法1：进入容器内部，然后修改</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入容器内部的系统，修改容器内容</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 容器<span class="built_in">id</span> /bin/bash</span><br></pre></td></tr></table></figure><ul><li>法2：挂载数据到外部修改：(请注意：挂载在外部的数据是没法提交改变的)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=mynginx </span><br><span class="line">-d  --restart=always </span><br><span class="line">-p  88:80 </span><br><span class="line">-v /data/html:/usr/share/nginx/html:ro  <span class="comment"># 外部数据地址:内部数据地址 :ro代表只读模式，容器内不能修改</span></span><br><span class="line">nginx</span><br></pre></td></tr></table></figure><h5 id="提交改变">4）提交改变：</h5><ul><li>将自己修改好的自定义镜像提交,这样会在本地产生一个新的镜像</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># -a author -m message</span></span><br><span class="line">docker commit -a <span class="string">&quot;fantast&quot;</span> -m <span class="string">&quot;首页变化&quot;</span> 341d81f7504f slksnginx:v1.0</span><br></pre></td></tr></table></figure><ul><li>将镜像文件打包存储，然后传输给另一台主机：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打包镜像至压缩包</span></span><br><span class="line">docker save -o abc.tar fantastnginx:v1.0</span><br><span class="line"><span class="comment"># 远程传输</span></span><br><span class="line">scp abc.tar root@128.12.33.12:/root/</span><br><span class="line"><span class="comment"># 加载docker镜像压缩包</span></span><br><span class="line">docker load abc.tar</span><br></pre></td></tr></table></figure><ul><li>推送至远程仓库docker hub</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把旧镜像的名字，改成仓库要求的新版名字</span></span><br><span class="line">docker tag fantastnginx:v1.0 fantast616/fantastnginx:v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录到docker hub</span></span><br><span class="line">docker login       </span><br><span class="line"></span><br><span class="line">docker <span class="built_in">logout</span>（推送完成镜像后退出）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送</span></span><br><span class="line">docker push fantast616/fantastnginx:v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 别的机器下载</span></span><br><span class="line">docker pull fantast616/fantastnginx:v1.0</span><br></pre></td></tr></table></figure><h5 id="其他命令">5）其他命令：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker 运行日志</span></span><br><span class="line">docker logs 容器名/id</span><br><span class="line"><span class="comment"># docker 进入内部BASH控制台</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 容器<span class="built_in">id</span> /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker 经常修改nginx配置文件</span></span><br><span class="line">docker run -d -p 80:80 \</span><br><span class="line">-v /data/html:/usr/share/nginx/html:ro \</span><br><span class="line">-v /data/conf/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">--name mynginx-02 \</span><br><span class="line">nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#把容器指定位置的东西复制出来 </span></span><br><span class="line">docker <span class="built_in">cp</span> 5eff66eec7e1:/etc/nginx/nginx.conf  /data/conf/nginx.conf  </span><br><span class="line"><span class="comment">#把外面的内容复制到容器里面</span></span><br><span class="line">docker <span class="built_in">cp</span>  /data/conf/nginx.conf  5eff66eec7e1:/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><h4id="编写一个简单的springboot应用并部署">5、编写一个简单的SpringBoot应用并部署：</h4><h5 id="docker部署redis">1）Docker部署Redis</h5><p>首先下载redis镜像，并在外部配置文件，最后启动redis镜像完成映射</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">#redis使用自定义配置文件启动</span><br><span class="line"></span><br><span class="line">docker run -v /data/redis/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-v /data/redis/data:/data \</span><br><span class="line">-d --name myredis \</span><br><span class="line">-p 6379:6379 \</span><br><span class="line">redis:latest  redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure><h5 id="非docker部署步骤">2）非Docker部署步骤：</h5><ul><li>SpringBoot打包为可执行的jar包，并上传至服务器</li><li>服务器运行java -jar</li></ul><h5id="docker部署步骤编写dockerfile">3）Docker部署步骤：编写DockerFile</h5><ul><li>Dockerfile如下：</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-slim  <span class="comment"># 基础镜像环境，比如说运行环境java</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=fantast</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> target/*.jar /app.jar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><ul><li><p>还有一个Jar目录叫做 target</p></li><li><p>将Dockerfile和target上传到服务器的一个目录下，然后执行以下命令构建镜像</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t java-demo:v1.0 .</span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221104142249625.png" /></p><h5 id="分享docker">4）分享docker</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录docker hub</span></span><br><span class="line">docker login</span><br><span class="line"></span><br><span class="line"><span class="comment">#给旧镜像起名</span></span><br><span class="line">docker tag java-demo:v1.0  fantast/java-demo:v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送到docker hub</span></span><br><span class="line">docker push fantast/java-demo:v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 别的机器</span></span><br><span class="line">docker pull fantast/java-demo:v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 别的机器运行</span></span><br><span class="line">docker run -d -p 8080:8080 --name myjava-app java-demo:v1.0</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">云原生快速入门系列笔记，云平台+容器化</summary>
    
    
    
    <category term="⑧ 工程类笔记" scheme="https://blog.fantast.top/categories/%E2%91%A7-%E5%B7%A5%E7%A8%8B%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="云原生入门" scheme="https://blog.fantast.top/categories/%E2%91%A7-%E5%B7%A5%E7%A8%8B%E7%B1%BB%E7%AC%94%E8%AE%B0/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="Cloud Native" scheme="https://blog.fantast.top/tags/Cloud-Native/"/>
    
  </entry>
  
  <entry>
    <title>Mysql数据库调优工具</title>
    <link href="https://blog.fantast.top/2022/10/28/a30af89db2dc/"/>
    <id>https://blog.fantast.top/2022/10/28/a30af89db2dc/</id>
    <published>2022-10-28T08:41:19.000Z</published>
    <updated>2022-10-30T14:16:43.773Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一数据库优化步骤及优化工具">一、数据库优化步骤及优化工具</h3><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221028165505532.png" style="zoom:67%;" /></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221028165600066.png" style="zoom:67%;" /></p><h4 id="统计sql的查询成本">1、统计SQL的查询成本：</h4><p>​ 这个Value代表的是进行了多少个页的查询</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221028170212104.png" /></p><p>​使用场景：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。SQL查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：</p><ul><li>位置决定效率。如果页就在数据库缓冲池中，那么效率是最高的，否则还需要从内存或者磁盘中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。</li><li>批量决定效率。如果我们从磁盘中对单一页进行随机读，那么效率是很低的（差不多10ms），而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。</li><li>考虑数据存放的位置，如果是经常使用的数据就要尽量放到缓冲池中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。</li></ul><h4 id="开启慢查询日志">2、开启慢查询日志：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global slow_query_log=&#x27;ON&#x27;;</span><br></pre></td></tr></table></figure><p>​MySQL的慢查询日志，用来记录在MySQL中响应时间超过阈值的语句，具体指运行时间超过long_query_time值的SQL，会被记录到慢查询日志中，默认值为10s。</p><p>​ 如果不是调优需要的话，一般不会开启该参数。</p><p>​ 设置时间阈值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global long_query_time = 1;</span><br><span class="line">mysql&gt; show global variables like &#x27;%long_query_time%&#x27;;</span><br><span class="line">mysql&gt; set long_query_time=1;</span><br><span class="line">mysql&gt; show variables like &#x27;%long_query_time%&#x27;;</span><br></pre></td></tr></table></figure><p>​ 查看慢查询记录条数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GLOBAL STATUS LIKE &#x27;%Slow_queries%&#x27;;</span><br></pre></td></tr></table></figure><p>​ 慢查询日志分析工具：mysqldumpslow</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#得到返回记录集最多的10个SQL</span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log</span><br><span class="line">#得到访问次数最多的10个SQL</span><br><span class="line">mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log</span><br><span class="line">#得到按照时间排序的前10条里面含有左连接的查询语句</span><br><span class="line">mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/atguigu-slow.log</span><br><span class="line">#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more</span><br></pre></td></tr></table></figure><p>​ 查看SQL执行成本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; set profiling = &#x27;ON&#x27;;</span><br><span class="line">mysql &gt; show profiles;</span><br><span class="line">mysql &gt; show profile;</span><br><span class="line">mysql&gt; show profile cpu,block io for query 2;</span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/image-20221029131535493.png" /></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29 13.17.28.png" style="zoom:67%;" /></p><h4 id="分析查询语句explain">3、分析查询语句EXPLAIN：</h4><p>​<strong>定位了查询慢的SQL之后，我们就可以使用EXPLAIN或DESCRIBE工具做针对性的分析查询语句。</strong></p><ul><li><p>能显示哪些信息？</p><ul><li><p>表的读取顺序，数据读取操作的操作类型、哪些索引可以使用，哪些索引实际被使用、表之间的引用、每张表有多少行被优化器查询。</p></li><li><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29%2013.32.18.png" /></p></li><li><table><colgroup><col style="width: 19%" /><col style="width: 80%" /></colgroup><thead><tr class="header"><th>id</th><th></th></tr></thead><tbody><tr class="odd"><td>select_type</td><td>SELECT关键字对应的那个查询的类型</td></tr><tr class="even"><td>table</td><td>表名</td></tr><tr class="odd"><td>Partitions</td><td>匹配的分区信息</td></tr><tr class="even"><td>type</td><td>针对单表的访问方法</td></tr><tr class="odd"><td>Possible_keys</td><td>可能用到的索引</td></tr><tr class="even"><td>key</td><td>实际上使用的索引</td></tr><tr class="odd"><td>key_len</td><td>实际使用到的索引长度</td></tr><tr class="even"><td>ref</td><td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td></tr><tr class="odd"><td>rows</td><td>预估的需要读取的记录条数</td></tr><tr class="even"><td>filtered</td><td>某个表经过搜索条件过滤后剩余记录条数的百分比</td></tr><tr class="odd"><td>Extra</td><td>一些额外的信息</td></tr></tbody></table></li></ul></li></ul><h5 id="id-和-table关键词">1）id 和 table关键词</h5><ul><li>Case1:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 INNER JOIN s2</span><br><span class="line">ON s1.key1 = s2.key1</span><br><span class="line">WHERE s1.common_field = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><ul><li><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29%2013.57.41.png" /></p><ul><li><p>每一条查询记录，都对应一张单表。比如说上述innerjoin，用到两个单表，所以会显示有两条记录</p></li><li><p>但是在一个大的查询中，一个SELECT关键词对应着一个id</p></li></ul></li><li><p>Case2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure></li><li><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29%2014.03.11.png" /></p><ul><li>有两个SELECT语句，所以对应两个id</li></ul></li><li><p>Case3:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key2 FROM s2 WHERE common_field = &#x27;a&#x27;);</span><br></pre></td></tr></table></figure><ul><li><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29%2014.07.15.png" /></p></li><li><p>虽然有两个SELECT语句，为啥同一个ID呢？因为查询优化器可能对涉及子查询的查询语句进行重写，转换为多表查询的形式。</p></li></ul></li><li><p>Case4:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;</span><br></pre></td></tr></table></figure><ul><li><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29%2014.09.41.png" /></p></li><li><p>UNION操作因为需要中间表进行去重操作，所以涉及到第三个记录。</p></li></ul></li><li><p>Case5:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;</span><br></pre></td></tr></table></figure></li><li><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29%2014.10.39.png" /></p></li><li><p>因为UNION ALL不用去重，所以不会有第三条记录</p></li><li><p><strong>总结相关内容：</strong></p><ul><li>id如果相同，可以认为是一组，从上往下顺序执行</li><li>在所有组中，id值越大，优先级越高，越先执行</li><li>关注点：id号每个号码，表示一趟独立的查询,一个sql的查询趟数越少越好</li></ul></li></ul><h5 id="select_type">2）select_type</h5><p>​SELECT关键字对应的那个查询的类型，确认了小查询在大的查询中扮演了怎样的一个角色。</p><ul><li><p>查询语句中不包含UNION和子查询的都是SIMPLE</p></li><li><p>连接查询都是SIMPLE</p></li><li><p>Case1: 相关子查询 DEPENDENT SUBQUERY</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE s1.key2 =</span><br><span class="line">s2.key2) OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29%2014.18.01.png" /></p></li><li><p>Case2: 查询优化器优化了的情况</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 IN </span><br><span class="line">(</span><br><span class="line">    SELECT key1 FROM s2 WHERE key1 = &#x27;a&#x27; </span><br><span class="line">   UNION </span><br><span class="line">   SELECT key1 FROM s1 WHERE key1 = &#x27;b&#x27;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29%2014.23.09.png" /></p><h5id="type对某张表的查询类型查询方法">3）type：对某张表的查询类型，查询方法</h5><ul><li>所有访问类型，越靠前是我们最希望看到的（效果越好）：system ， const， eq_ref ， ref ， fulltext ， ref_or_null ，index_merge ，unique_subquery ， index_subquery ， range ， index ， ALL</li><li>system</li></ul><p>示例：表结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE s1 (</span><br><span class="line">    id INT AUTO_INCREMENT,</span><br><span class="line">    key1 VARCHAR(100),</span><br><span class="line">    key2 INT,</span><br><span class="line">    key3 VARCHAR(100),</span><br><span class="line">    key_part1 VARCHAR(100),</span><br><span class="line">    key_part2 VARCHAR(100),</span><br><span class="line">    key_part3 VARCHAR(100),</span><br><span class="line">    common_field VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    INDEX idx_key1 (key1),</span><br><span class="line">    UNIQUE INDEX idx_key2 (key2),</span><br><span class="line">    INDEX idx_key3 (key3),</span><br><span class="line">    INDEX idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE=INNODB CHARSET=utf8;</span><br></pre></td></tr></table></figure><ul><li>const：根据主键或唯一二级索引与常数进行匹配</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE id = 10005;</span><br></pre></td></tr></table></figure><ul><li>eq_ref：连接查询时，被驱动表根据主键或唯一二级索引与常数进行匹配</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;</span><br></pre></td></tr></table></figure><p>​从执行计划的结果中可以看出，MySQL打算将s2作为驱动表，s1作为被驱动表，重点关注s1的访问方法是eq_ref，表明在访问s1表的时候可以通过主键的等值匹配来进行访问</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29%2014.29.09.png" /></p><ul><li>ref：普通二级索引与常数进行匹配</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29%2014.33.58.png" /></p><ul><li>ref_or_null 普通二级索引与常数进行匹配，且索引值可能为null</li><li>index_merge MySQL 打算使用索引合并的方式来执行对 s1 表的查询。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27; OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><ul><li>unique_subquery</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key2 IN (SELECT id FROM s2 where s1.key1 = s2.key1) OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><ul><li>index_subquery</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE common_field IN (SELECT key3 FROM s2 where s1.key1 = s2.key1) OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><ul><li>range使用索引获取某些范围区间的记录，那么就可能使用到range访问方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;a&#x27; AND key1 &lt; &#x27;b&#x27;;</span><br></pre></td></tr></table></figure><ul><li>index当我们可以使用素引覆盖（不用回表就可以查到数据），但需要扫描全部的索引记录时，该表的访问方法就是index【因为此处，联合索引的字段最优先的是key_part1,key_part2然后才是key_part3】</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3=&#x27;a&#x27;；</span><br></pre></td></tr></table></figure><p>​ 即如果语句如下，则type就是ref而非index</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT key_part2 FROM s1 WHERE key_part1=&#x27;a&#x27; and key_part3 = &#x27;b&#x27;;</span><br></pre></td></tr></table></figure><ul><li>all</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1;</span><br></pre></td></tr></table></figure><p>​ <strong>SQL</strong> <strong>性能优化的目标：至少要达到</strong><strong>range</strong> <strong>级别，要求是</strong><strong>ref</strong> <strong>级别，最好是</strong><strong>consts</strong>级别。</p><h5 id="possible_keys-和-key">4）possible_keys 和 key</h5><p>​在EXPLAIN语句输出的执行计划中，possible_keys列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些。一般查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。key列表示实际用到的索引有哪些，如果为NULL，则没有使用索引。</p><h5 id="key_len">5）key_len</h5><p>​实际使用到的索引长度（字节数），帮你检查是否充分的利用上了索引，值越大越好，主要针对于联合索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE id = 10005;</span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221029221248821.png" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key2 = 10126;</span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221029221254958.png" /></p><p>4+1 =5, 因为key2字段不是非空的，所以记录NULL需要一个字节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key_part1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221029221407032.png" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key_part1 = &#x27;a&#x27; AND key_part2 = &#x27;b&#x27;;</span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221029221412049.png" /></p><p><strong>key_len</strong>如何计算:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># varchar(10)变长字段且允许NULL = 10 * ( character set：</span><br><span class="line"># utf8=3,gbk=2,latin1=1)+1(NULL)+2(变长字段)</span><br><span class="line"></span><br><span class="line"># varchar(10)变长字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+2(变长字段)</span><br><span class="line"></span><br><span class="line"># char(10)固定字段且允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL)</span><br><span class="line"></span><br><span class="line"># char(10)固定字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)</span><br></pre></td></tr></table></figure><h5 id="ref">6）ref</h5><p>​ 当使用索引列等值查询的时候，与索引列进行等值匹配的对象信息。</p><h5 id="rows">7）rows</h5><p>​ 预估的需要读取的记录条数</p><h5 id="filtered">8）filtered</h5><p>​某个表经过搜索条件过滤后，剩余记录条数的百分比。对于单表查询没有什么大的意义。</p><ul><li>Case1:代表，单表查询时，经过key1 &gt; 'z' 和 common_filed='a'条件筛选后，还剩下的记录是10%</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27; AND common_field = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221030202016814.png" /></p><ul><li>Case2:连表查询时，s1驱动表，s2被驱动表,此时filtered的值决定了被驱动表s2需要执行的次数，即rows*filtered。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key1 WHERE s1.common_field = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221030202138448.png" /></p><h5 id="extra">9） Extra</h5><p>​ 更准确的理解MySQL到底将如何执行给定的查询语句</p><h5 id="小结">10）小结：</h5><ul><li>EXPLAIN不考虑各种Cache</li><li>EXPLAIN不能显示MySQL在执行查询时所作的优化工作</li><li>EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况</li><li>部分统计信息是估算的，并非精确值</li></ul><h4 id="explain语句的输出格式">4、EXPLAIN语句的输出格式</h4><h5 id="传统格式表格形式">1）传统格式，表格形式</h5><p>​ 即上述内容</p><h5 id="json格式会显示成本">2）JSON格式，会显示成本</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN FORMAT=JSON SELECT ....</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query_block&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;select_id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cost_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;4445.50&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;nested_loop&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;table_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s1&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;access_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ALL&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;possible_keys&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;idx_key1&quot;</span></span><br><span class="line">          <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;rows_examined_per_scan&quot;</span><span class="punctuation">:</span> <span class="number">9825</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;rows_produced_per_join&quot;</span><span class="punctuation">:</span> <span class="number">9825</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;filtered&quot;</span><span class="punctuation">:</span> <span class="string">&quot;100.00&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;cost_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;read_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;24.25&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;eval_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;982.50&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;prefix_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1006.75&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;data_read_per_join&quot;</span><span class="punctuation">:</span> <span class="string">&quot;17M&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;used_columns&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;id&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key3&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key_part1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key_part2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key_part3&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;common_field&quot;</span></span><br><span class="line">          <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;attached_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`experiment`.`s1`.`key1` is not null)&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;table_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s2&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;access_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eq_ref&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;possible_keys&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;idx_key2&quot;</span></span><br><span class="line">          <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;idx_key2&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;used_key_parts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;key2&quot;</span></span><br><span class="line">          <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;key_length&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;ref&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;experiment.s1.key1&quot;</span></span><br><span class="line">          <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;rows_examined_per_scan&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;rows_produced_per_join&quot;</span><span class="punctuation">:</span> <span class="number">9825</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;filtered&quot;</span><span class="punctuation">:</span> <span class="string">&quot;100.00&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;index_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(cast(`experiment`.`s1`.`key1` as double) = cast(`experiment`.`s2`.`key2` as double))&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;cost_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;read_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2456.25&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;eval_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;982.50&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;prefix_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;4445.50&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;data_read_per_join&quot;</span><span class="punctuation">:</span> <span class="string">&quot;17M&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;used_columns&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;id&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key3&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key_part1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key_part2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key_part3&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;common_field&quot;</span></span><br><span class="line">          <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>由于 s2 表是被驱动表，所以可能被读取多次，这里的 read_cost 和eval_cost 是访问多次 s2 表后累</p><p>加起来的值，大家主要关注里边儿的 prefix_cost的值代表的是整个连接查询预计的成本，也就是单</p><p>次查询 s1 表和多次查询 s2 表后的成本的和.</p></li><li><p>read_cost</p><ul><li>IO 成本</li><li>检测 rows × (1 - filter) 条记录的 CPU 成本</li></ul></li><li><p>eval_cost</p><ul><li>检测rows × filter 条记录的成本</li></ul></li><li><p>prefix_cost</p><ul><li>单独查询s1表的成本</li></ul></li><li><p>data_read_per_join</p><ul><li>在此次查询中需要读取的数据量</li></ul></li></ul><h5 id="tree形式">3）TREE形式</h5><h5 id="可视化形式">4）可视化形式</h5><h4id="分析优化器执行计划trace工具">5、分析优化器执行计划：trace工具</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET optimizer_trace=&quot;enabled=on&quot;,end_markers_in_json=on;</span><br><span class="line">SET optimizer_trace_max_mem_size=1000000;</span><br></pre></td></tr></table></figure><p>开启以后可以分析常见的许多SQL语句,通过如下语句进行查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.optimizer_trace\G</span><br></pre></td></tr></table></figure><h4 id="mysql监控分析视图-sys-schema">6、MySQL监控分析视图-sysschema</h4><p>​关于MySQL的性能监控和问题诊断，我们一般都从performance_schema中去获取想要的数据，在MySQL5.7.7版本中新增sysschema，它将prformance_schema和information_schema中的数据以更容易理解的方式总结归纳为”视图”，其目的就是为了降低查询performance_schema的复杂度，让DBA能够快速的定位问题。</p><p>​下面看看这些库中都有哪些监控表和视图，掌握了这些，在我们开发和运维的过程中就起到了事半功倍的效果。</p><ul><li>索引相关</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#1. 查询冗余索引</span><br><span class="line">select * from sys.schema_redundant_indexes;</span><br><span class="line">#2. 查询未使用过的索引</span><br><span class="line">select * from sys.schema_unused_indexes;</span><br><span class="line">#3. 查询索引的使用情况</span><br><span class="line">select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted</span><br><span class="line">from sys.schema_index_statistics where table_schema=&#x27;dbname&#x27; ;</span><br></pre></td></tr></table></figure><ul><li>表相关</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 1. 查询表的访问量</span><br><span class="line">select table_schema,table_name,sum(io_read_requests+io_write_requests) as io from</span><br><span class="line">sys.schema_table_statistics group by table_schema,table_name order by io desc;</span><br><span class="line"># 2. 查询占用bufferpool较多的表</span><br><span class="line">select object_schema,object_name,allocated,data</span><br><span class="line">from sys.innodb_buffer_stats_by_table order by allocated limit 10;</span><br><span class="line"># 3. 查看表的全表扫描情况</span><br><span class="line">select * from sys.statements_with_full_table_scans where db=&#x27;dbname&#x27;;</span><br></pre></td></tr></table></figure><ul><li>语句相关</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#1. 监控SQL执行的频率</span><br><span class="line">select db,exec_count,query from sys.statement_analysis</span><br><span class="line">order by exec_count desc;</span><br><span class="line">#2. 监控使用了排序的SQL</span><br><span class="line">select db,exec_count,first_seen,last_seen,query</span><br><span class="line">from sys.statements_with_sorting limit 1;</span><br><span class="line">#3. 监控使用了临时表或者磁盘临时表的SQL</span><br><span class="line">select db,exec_count,tmp_tables,tmp_disk_tables,query</span><br><span class="line">from sys.statement_analysis where tmp_tables&gt;0 or tmp_disk_tables &gt;0</span><br><span class="line">order by (tmp_tables+tmp_disk_tables) desc;</span><br></pre></td></tr></table></figure><ul><li>IO相关</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#1. 查看消耗磁盘IO的文件</span><br><span class="line">select file,avg_read,avg_write,avg_read+avg_write as avg_io</span><br><span class="line">from sys.io_global_by_file_by_bytes order by avg_read limit 10;</span><br></pre></td></tr></table></figure><ul><li>Innodb相关</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#1. 行锁阻塞情况</span><br><span class="line">select * from sys.innodb_lock_waits;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Chap12——Mysql 数据库效率调优工具，包含EXPLAIN，trace，sys schema</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://blog.fantast.top/2022/10/27/5b0755a55834/"/>
    <id>https://blog.fantast.top/2022/10/27/5b0755a55834/</id>
    <published>2022-10-27T13:51:19.000Z</published>
    <updated>2022-10-28T08:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一索引的创建与删除">一、索引的创建与删除</h3><ul><li>分类之<strong>全文索引</strong>：搜索引擎使用的一种关键技术。它能够利用【分词技术】等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。<strong>全文索引非常适合大型数据集，对于小的数据集，它的用处比较小。</strong><ul><li>使用参数FULLTEXT可以设置索引为全文索引。</li><li>在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。查询数据量较大的字符串类型的字段时，使用全文索引可以提高查询速度。例如，表student的字段information是TEXT类型，该字段包含了很多文字信息。在字段information上建立全文索引后，可以提高查询字段information的速度。</li></ul></li></ul><h4 id="创建删除索引">1、创建删除索引：</h4><h5 id="创建表时新增">1）创建表时新增</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name [col_name data_type]</span><br><span class="line">[UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC | DESC]</span><br></pre></td></tr></table></figure><ul><li><p>UNIQUE 、FULLTEXT 和SPATIAL为可选参数，分别表示唯一索引、全文索引和空间索引；</p></li><li><p>INDEX 与KEY 为同义词，两者的作用相同，用来指定创建索引；</p></li><li><p>index_name指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名；</p></li><li><p>col_name为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；</p></li><li><p>length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；</p></li><li><p>ASC 或DESC 指定升序或者降序的索引值存</p></li><li><p>多列索引：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INDEX multi_idx(id,name,age)</span><br></pre></td></tr></table></figure><ul><li>全文索引：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `papers` (</span><br><span class="line">`id` int(10) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">`title` varchar(200) DEFAULT NULL,</span><br><span class="line">`content` text,</span><br><span class="line">PRIMARY KEY (`id`),</span><br><span class="line">FULLTEXT KEY `title` (`title`,`content`)</span><br><span class="line">) ENGINE=MyISAM DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>全文检索如何查询？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM papers WHERE content LIKE ‘%查询字符串%’; # 普通查询</span><br><span class="line">SELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’); # 全文检索，非常快</span><br></pre></td></tr></table></figure><h5 id="创建表后新增">2）创建表后新增</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name</span><br><span class="line">ON table_name (col_name[length],...) [ASC | DESC]</span><br></pre></td></tr></table></figure><h5 id="删除索引">3）删除索引：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX index_name ON table_name;</span><br></pre></td></tr></table></figure><h3 id="二mysql8.0索引新特性">二、Mysql8.0索引新特性：</h3><h4 id="降序索引">1、降序索引：</h4><p>​ 即DESC关键字被支持，其在某种场景下意义重大，如下：</p><p>先创建索引如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE ts1(a int,b int,index idx_a_b(a ASC,b desc));</span><br></pre></td></tr></table></figure><p>​ 在执行如下语句时，执行计划中扫描数为799，而且提示使用了Usingfilesort，这是MySQL中一种速度比较慢的外部排序，能避免是最好的。多数情况下，管理员可以通过优化索引来尽量避免出现Usingfilesort，从而提高数据库执行速度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM ts1 ORDER BY a,b DESC LIMIT 5;</span><br></pre></td></tr></table></figure><p>​ 但是在执行如下语句时，就会快很多且不会使用Using filesort：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM ts1 ORDER BY a ASC,b DESC LIMIT 5;</span><br></pre></td></tr></table></figure><h4 id="隐藏索引">2、隐藏索引：</h4><p>​只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引（即使使用forceindex（强制使用索引），优化器也不会使用该索引），确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。</p><p>​ 这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除。</p><p>​同时，如果你想验证某个索引删除之后的查询性能影响，就可以暂时先隐藏该索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX indexname</span><br><span class="line">ON tablename(propname[(length)]) INVISIBLE;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引</span><br><span class="line">ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引</span><br></pre></td></tr></table></figure><h3 id="三索引的设计原则">三、索引的设计原则</h3><h4 id="哪些情况适合创建索引">1、哪些情况适合创建索引？</h4><h5id="字段的数值有唯一性的限制但是没有加唯一性约束的字段">1）字段的数值有唯一性的限制，但是没有加唯一性约束的字段</h5><h5 id="频繁作为where查询条件的字段">2）频繁作为WHERE查询条件的字段</h5><h5 id="经常group-by和order-by的列">3）经常GROUP BY和ORDER BY的列</h5><p>​需要对分组或者排序的字段进行索引。如果待排序的列有多个，那么可以在这些列上建立联合索引。既有GROUPBY 又有 ORDER BY，可以考虑建立联合索引，但联合索引要先写GROUP BY 再写ORDER BY。</p><h5 id="updatedelete-的-where-条件列">4）UPDATE、DELETE 的 WHERE条件列</h5><p>​如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</p><h5 id="distinct-操作的字段需要创建索引">5）DISTINCT操作的字段需要创建索引</h5><p>​有时候我们需要对某个字段进行去重，使用DISTINCT，那么对这个字段创建索引，也会提升查询效率。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT(student_id) FROM `student_info`;</span><br></pre></td></tr></table></figure><h5id="多表join连接操作时创建索引的注意事项">6）多表JOIN连接操作时，创建索引的注意事项:</h5><ul><li>连接的表数量不要超过3张</li><li>对WHERE条件创建索引</li><li><strong>对用于连接的字段创建索引</strong>，并且该字段在多张表中的类型必须一致。</li></ul><h5 id="使用列的类型小的创建索引">7）使用列的类型小的创建索引</h5><ul><li><p>类型大小指该类型表示的数据范围的大小。</p></li><li><p>如果要对某个列建立索引，尽量让这个列使用较小的数据类型。原因：</p><ul><li>数据类型越小，在查询时进行的比较操作越快</li><li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘I/0带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li></ul></li></ul><h5id="创建字符串列的索引时注意事项">8）创建字符串列的索引时注意事项：</h5><p>​假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的B+树中有这么两个问题：</p><ul><li>B+树索引中的记录需要把该列的完整字符串存储起来，更费时。而且字符串越长，在索引中占用的存储空间越大。</li><li>如果B+树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间。</li></ul><p>​<strong>通过截取字段的前面一部分内容建立索引，这个就叫前缀索引。</strong></p><p>​这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后<strong>根据前缀相同的记录的主键值回表查询完整的字符串值。</strong>既节约空间，又减少了字符串的比较时间，还大体能解决排序的问题。</p><ul><li><p><strong>关键问题</strong>：截取多少比较合适？</p></li><li><p>先看一下字段在全部数据中的选择度</p><ul><li>```mysql select count(distinct address) / count(<em>) from shop;count(distinct left(列名, 索引长度))/count(</em>) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```mysql</span><br><span class="line">  select count(distinct left(address,10)) / count(*) as sub10, -- 截取前10个字符的选择度</span><br><span class="line">  count(distinct left(address,15)) / count(*) as sub11, -- 截取前15个字符的选择度</span><br><span class="line">  count(distinct left(address,20)) / count(*) as sub12, -- 截取前20个字符的选择度</span><br><span class="line">  count(distinct left(address,25)) / count(*) as sub13 -- 截取前25个字符的选择度</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="区分度高的列适合作为索引">9）区分度高的列适合作为索引：</h5><p>​列的基数指的是某一列中不重复数据的个数，比方说某个列包含值2，5，8，2，5，8，2，5，8，虽然有9条记录，但该列的基数却是3。</p><p>​ 可以使用公式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct a)/count(*) from t1 </span><br></pre></td></tr></table></figure><p>​ 计算区分度，越接近1越好，一般超过33%就算是比较高效的索引了。</p><h5id="使用最频繁的列放到联合索引的左侧">10）使用最频繁的列放到联合索引的左侧</h5><h5id="在多个字段都要创建索引时联合索引优于单值索引">11）在多个字段都要创建索引时，联合索引优于单值索引</h5><h4 id="索引数目的限制">2、索引数目的限制：</h4><ul><li><p>单张表不超过6个索引</p></li><li><p>索引占用磁盘空间、会影响insert，update的效率。同时，因为优化器在执行查询前，如果索引太多，会导致其生成执行计划的时间降低。</p></li></ul><h4 id="哪些情况不适合创建索引">3、哪些情况不适合创建索引？</h4><h5id="在where中使用不到的字段不要设置索引">1）在where中使用不到的字段，不要设置索引</h5><h5id="数据量小的表最好不要使用索引">2）数据量小的表最好不要使用索引</h5><h5id="有大量重复数据的列上不要建立索引10">3）有大量重复数据的列上不要建立索引（10%）</h5><p>​ 要在 100 万行数据中查找其中的 50万行（比如性别为男的数据），一旦创建了索引，你需要先访问 50万次索引，然后再访问 50万次数据表，这样加起来的开销比不使用索引可能还要大.</p><h5id="避免对经常更新的表创建过多的索引">4）避免对经常更新的表创建过多的索引</h5><h5 id="不建议用无序的值作为索引">5）不建议用无序的值作为索引</h5><p>​例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。</p>]]></content>
    
    
    <summary type="html">Chap11——Mysql 索引及调优原则</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>事务</title>
    <link href="https://blog.fantast.top/2022/10/17/a0984953b2e8/"/>
    <id>https://blog.fantast.top/2022/10/17/a0984953b2e8/</id>
    <published>2022-10-17T07:09:19.000Z</published>
    <updated>2022-10-17T07:27:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一">一、</h3>]]></content>
    
    
    <summary type="html">Chap8——Mysql 事务</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Mysql日志与备份</title>
    <link href="https://blog.fantast.top/2022/10/17/f545bfc8e29a/"/>
    <id>https://blog.fantast.top/2022/10/17/f545bfc8e29a/</id>
    <published>2022-10-17T07:09:19.000Z</published>
    <updated>2022-10-17T07:27:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一">一、</h3>]]></content>
    
    
    <summary type="html">Chap11——Mysql 日志与备份</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Mysql逻辑架构和存储引擎</title>
    <link href="https://blog.fantast.top/2022/10/17/6d0d3039dfe2/"/>
    <id>https://blog.fantast.top/2022/10/17/6d0d3039dfe2/</id>
    <published>2022-10-17T07:09:19.000Z</published>
    <updated>2022-10-18T09:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一逻辑架构">一、逻辑架构：</h3><p>​ 使用经典的C/S架构，服务端程序使用的是mysqld服务，服务端大致分为三个步骤：</p><ul><li>连接管理（连接池）</li><li>解析和优化（SQL接口、解析器、优化器）</li><li>存储引擎（存储引擎和文件系统、日志文件）</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017154005406.png" /></p><h4 id="connectors">1、Connectors:</h4><p>​MySQL是一个网络i程序，本质上就是在TCP连接上，通过MySql协议跟Mysql服务器进行数据的交互</p><h4 id="连接管理">2、连接管理：</h4><p>​用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，<strong>都将依赖于此时读到的权限。</strong></p><p>​<strong>TCP连接池</strong>：用于限制连接数，可以采用长连接模式来复用TCP连接，解决上述问题</p><p>​<strong>线程池</strong>：TCP连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017161445894.png" style="zoom:50%;" /></p><h4 id="服务层">3、服务层：</h4><ul><li><p>SQL接口：</p><ul><li>接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT ...FROM就是调用SQL Interface</li></ul></li><li><p>Parser解析器：</p><ul><li>在解析器中对 SQL语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。</li><li><strong>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建语法树，并根据数据字典丰富查询语法树，会验证该客户端是否具有执行该查询的权限</strong></li></ul></li><li><p>Optimizer优化器：</p><ul><li><p>SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL语句的执行路径，生成一个执行计划。这个执行计划表明应该使用哪些索引进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。</p></li><li><p>它使用“ 选取-投影-连接”策略进行查询</p></li><li><pre><code>  SELECT id,name FROM student WHERE gender = &#39;女&#39;;</code></pre></li><li><p>这个SELECT查询先根据WHERE语句进行选取，而不是将表全部查询出来以后再进行gender过滤。这个SELECT查询先根据id和name进行属性投影，而不是将属性全部取出以后再进行过滤，将这两个查询条件连接起来生成最终查询结果。</p></li></ul></li><li><p>Caches &amp; Buffers： 查询缓存组件</p><ul><li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等。这个查询缓存可以在不同客户端之间共享</li></ul></li></ul><h4 id="引擎层">4、引擎层</h4><p>​ 插件式存储引擎层（ StorageEngines），真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作</p><h4 id="存储层">5、存储层：</h4><p>​所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在文件系统上，以文件的方式存在的，并完成与存储引擎的交互</p><h3 id="二sql执行流程">二、SQL执行流程：</h3><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017163209630.png" /></p><h4 id="查询缓存">1、查询缓存：</h4><p>​ 因为查询缓存往往效率不高，所以在 MySQL8.0之后就抛弃了这个功能。三大场景原因如下：</p><ul><li>在MySQL中的查询缓存，不是缓存查询计划，而是查询对应的结果。这就意味着查询匹配的鲁棒性大大降低，<strong>只有相同的查询操作才会命中查询缓存。</strong>两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。因此MySQL 的查询缓存命中率不高。</li><li>如果<strong>查询请求中包含某些系统函数、用户自定义变量和函数</strong>、一些系统表，如mysql 、 information_schema、 performance_schema数据库中的表，那这个请求就不会被缓存。</li><li>此外，既然是缓存，那就有它缓存失效的时候。<strong>MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，</strong>如对该表使用了INSERT、 UPDATE 、DELETE 、TRUNCATE TABLE 、ALTER TABLE 、DROP TABLE 或 DROPDATABASE语句，那<strong>使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！</strong>对于更新压力大的数据库来说，查询缓存的命中率会非常低。</li></ul><h4 id="解析器">2、解析器：</h4><ul><li><p>词法分析</p><ul><li>MySQL需要识别出SQL语句里面的字符串分别是什么，代表什么。是代表关键字还是表名</li></ul></li><li><p>语法分析</p><ul><li>根据词法分析的结果，语法分析器（比如：Bison）会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</li></ul></li><li><p>如果SQL语句正确，会生成一个语法树：</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017165049678.png" /></p></li></ul><h4 id="优化器">3、优化器：</h4><p>​ 在优化器中会确定 SQL语句的执行路径，优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序，还有表达式简化、子查询转为连接、外连接转为内连接等。</p><p>​在查询优化器中，可以分为<strong>逻辑查询优化阶段</strong>和<strong>物理查询优化阶段</strong>。</p><ul><li>逻辑查询优化就是通过改变SQL语句的内容来使得SQL查询更高效，同时为物理查询优化提供更多的候选执行计划。通常采用的方式是对SQL语句进行等价变换，对查询进行重写，而查询重写的数学基础就是关系代数。<strong>对条件表达式进行等价谓词重写、条件简化，对视图进行重写，对子查询进行优化，对连接语义进行了外连接消除、嵌套连接消除等</strong></li><li>物理查询优化是基于关系代数进行的查询重写，而关系代数的每一步都对应着物理计算，这些物理计算往往存在多种算法，因此需要计算各种物理路径的代价，从中选择代价最小的作为执行计划。在这个阶段里，对于单表和多表连接的操作，需要高效地使用索引，提升查询效率。</li></ul><h4 id="执行器">4、执行器：</h4><p>​在执行之前需要判断该用户是否具备权限。如果没有，就会返回权限错误。如果具备权限，就执行SQL查询并返回结果。</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017165434638.png" /></p><h4 id="语法顺序">5、语法顺序：</h4><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017170108824.png" /></p><h3 id="三数据库缓冲池">三、数据库缓冲池：</h3><p>​InnoDB存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘I/0需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS会申请占用内存来作为数据缓冲池，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的BufferPoo1之后才可以访问。</p><p>​ <strong>目的</strong>：减少与磁盘直接进行I/O的时间</p><h4 id="缓冲池">1、缓冲池：</h4><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017171714267.png" /></p><p>​缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟。所以InnoDB存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中，<strong>也就是说即使我们只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中。</strong>将整个页加载到内存中后就可以进行读写访问了，<strong>在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其缓存起来，这样将来有请求再次访问该页面时，就可以省去磁盘IO的开销了。</strong></p><p><strong>缓存原则：</strong></p><p>​ 优先对使用频次高的数据进行加载</p><p><strong>缓冲池的预读特性：</strong></p><p>​缓冲池的作用就是提升I/0效率，而我们进行读取数据的时候存在一个“局部性原理”，也就是说我们使用了一些数据，大概率还会使用它周围的一些数据，因此采用“预读”的机制提前加载，可以减少未来可能的磁盘I/O操作。</p><h4 id="缓冲池如何读取数据">2、缓冲池如何读取数据：</h4><p>​缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017172013707.png" /></p><p>​ 如果我们执行 SQL语句的时候更新了缓存池中的数据，那么这些数据会马上同步到磁盘上吗？</p><p>​实际上，当我们对数据库中的记录进行修改的时候，<strong>首先会修改缓冲池中页里面的记录信息，然后数据库会以一定的频率刷新到磁盘上。</strong></p><p>​注意并不是每次发生更新操作，都会立刻进行磁盘回写。缓冲池会采用一种叫做checkpoint的机制将数据回写到磁盘上，这样做的好处就是提升了数据库的整体性能。比如，当缓冲池不够用时，需要释放掉一些不常用的页，此时就可以强行采用checkpoint的方式，<strong>将不常用的脏页回写到磁盘上，然后再从缓冲池中将这些页释放掉。这里脏页（dirtypage）指的是缓冲池中被修改过的页，与磁盘上的数据页不一致。</strong></p><h4 id="多个buffer-pool实例">3、多个Buffer Pool实例：</h4><p>​ BufferPool本质是InnoDB向操作系统申请的一块连续的内存空间，在多线程环境下，访问BufferPool中的数据都需要加锁处理。<strong>在BufferPool特别大而且多线程并发访问特别高的情况下，单一的BufferPool可能会影响请求的处理速度。</strong>所以在BufferPool特别大的时候，我们可以把它们拆分成若干个小的BufferPool，<strong>每个BufferPool都称为一个实例，它们都是独立的，独立的去申请内存空间，独立的管理各种链表。所以在多线程并发访问时并不会相互影响，从而提高并发处理能力。</strong></p><h4 id="一些数据一致性问题">4、一些数据一致性问题</h4><figure><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017172737298.png"alt="image-20221017172737298" /><figcaption aria-hidden="true">image-20221017172737298</figcaption></figure><p>​ 假设我们修改BufferPool中的数据成功，但是还没来得及将数据刷入磁盘MySQL就挂了怎么办？按照上图的逻辑，此时更新之后的数据只存在于BufferPool中，如果此时MySQL宕机了，这部分数据将会永久地丢失；怎么办呢？</p><p>​ 使用Redo Log和Undo Log来解决</p><h3 id="四存储引擎">四、存储引擎：</h3><h4id="innodb引擎具备外键支持功能的事务存储引擎">1、InnoDB引擎：具备外键支持功能的事务存储引擎</h4><ul><li>默认事务型引擎，设计用于处理大量的短期事务，确保事务的完整提交和回滚</li><li>其为处理巨大数据量的最大性能设计</li><li>InnoDB写的处理效率会差一些，其会占用更多的磁盘空间来保存数据和索引</li><li>MyISAM只缓存索引，不缓存真实数据。InnoDB不仅缓存索引，还缓存真实数据，对内存要求较高，内存大小对性能有决定性的影响。</li></ul><h4id="myisam引擎主要的非事务处理存储引擎">2、MyISAM引擎：主要的非事务处理存储引擎</h4><ul><li>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM不支持事务、行级锁、外键，有一个毫无疑问的缺陷就是崩溃后无法安全恢复。</li><li>优势是访问的速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应用</li><li>应用场景：只读应用或者以读为主的业务</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221018172423185.png" /></p><h4 id="archive引擎用于数据归档">3、Archive引擎：用于数据归档</h4><h4id="csv引擎可以快速便捷和外界进行数据交换">4、CSV引擎：可以快速便捷和外界进行数据交换</h4><h4 id="memory引擎置于内存的表">5、Memory引擎：置于内存的表</h4><p>​ Memory采用的逻辑介质是内存，响应速度很快，但是当mysqld守护进程崩溃的时候数据会丢失。如下应用场景：</p><ol type="1"><li>目标数据比较小，而且非常频繁的进行访问，在内存中存放数据，如果太大的数据会造成内存溢出。</li><li>如果数据是临时的，而且必须立即可用得到，那么就可以放在内存中。</li><li>存储在Memory表中的数据如果突然间丢失的话也没有太大的关系。</li></ol>]]></content>
    
    
    <summary type="html">Chap8——Mysql 逻辑架构和存储引擎相关内容</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://blog.fantast.top/2022/10/17/bb6cac39113d/"/>
    <id>https://blog.fantast.top/2022/10/17/bb6cac39113d/</id>
    <published>2022-10-17T07:09:19.000Z</published>
    <updated>2022-10-27T13:50:45.259Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一为什么使用索引优缺点">一、为什么使用索引&amp;优缺点：</h3><p>​避免全表扫描，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据。</p><p>​如上图所示，数据库没有索引的情况下，数据分布在硬盘不同的位置上面，<strong>读取数据时，摆臂需要前后摆动查找数据，这样操作非常消耗时间。</strong></p><p>​索引是一种数据结构，每个节点缓存的是一个Key-Value结构，Key是列的值，Value是该Key所在行对应的指针（文件位置）。</p><h4 id="优点">优点：</h4><ul><li>降低数据库的IO成本，提高数据检索的效率</li><li>加速表和表之间的连接。对于有依赖关系的子表和父表联合查询时，提高速度</li><li>显著减少查询中分组和排序的时间，降低CPU消耗</li></ul><h4 id="缺点">缺点：</h4><ul><li>创建和维护需要耗费时间</li><li>索引需要占据磁盘空间。</li><li>索引提高查询速度的同时，会降低更新表的速度。</li></ul><h3 id="二没有索引时的查找">二、没有索引时的查找：</h3><h4 id="case1-在单页中的查找">Case1: 在单页中的查找</h4><p>​ 如果数据较少，则所有记录都可以被存放到一个页里面</p><ul><li>以主键为搜索条件：可以以O（logN)复杂度查询到</li><li>以其他键为搜索条件：只能遍历.从最小记录开始以此遍历单链表中的每条记录。</li></ul><h4 id="case2在多页中的查找">Case2：在多页中的查找</h4><p>​ 如果记录非常多，需要很多数据页来存储这些记录，主要步骤分为：</p><ul><li>定位到记录所在的页</li><li>从所在的页内查找相应的记录</li></ul><p>​在没有索引的情况下，由于不能快速定位到记录所在的页，只能从第一个页沿着双向链表一直往下找。在每个页中进行匹配。因为要遍历所有的数据页(以及加载)，所以非常耗时.</p><h3 id="三索引的设计">三、索引的设计:</h3><p>首先，简化假设某一条记录在磁盘上的记录形式如下：</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221021092747727.png" /></p><p>那</p><p>1么，将一些记录放到页中的示意图就是如下所示：一个数据页的默认大小为16KB，其中会存有一定数量的记录。</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221021105655165.png" /></p><p>​我们现在的问题就是：想要快速的定位到需要查找的记录在哪些数据页中。我们可以采用B+树的形式进行架构，如下图所示：最底层的数据页存放的是普通的记录，record_type=0，页与页直接以双向链表的形式链接。再上层的数据页中存储的是普通记录的目录项记录，它们的record_type=1，再往上走就是层级更高的目录项，至此构成一颗B+树。需要值得注意的是，相邻的页之间页编号不一定连续，是通过指针指向链接的。</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221021105859291.png" /></p><p>​我们可以利用B+树定位到某条记录在哪个数据页的形式，可以大大节省内存和硬盘的IO次数，定位到具体的数据页以后，在每个页面内也有页目录，可以通过二分法来实现快速的定位记录。</p><h3 id="四常见索引的概念">四、常见索引的概念:</h3><h4 id="聚簇索引">1、聚簇索引：</h4><p>​是一种数据存储方式，所有的用户记录都存储在了叶子节点，即<strong>数据即索引</strong>，<strong>索引即数据</strong>。</p><h5 id="特点">特点：</h5><ul><li>使用记录本身的 主键值的大小 进行记录和页的排序<ul><li>页内的记录——按照主键的大小顺序排成单向链表。</li><li>各个存放用户记录的页——根据主键大小顺序排成一个双向链表</li><li>存放目录项记录的页——分为不同的层次，同一层次中的页之间按逐渐大小顺序排成双向链表</li></ul></li><li>B+树的叶子节点存储的是完整的用户记录</li><li>这种索引不需要我们在mysql中显式创建，InnoDB会自动创建聚簇索引。</li></ul><h5 id="优点-1">优点：</h5><ul><li>访问速度更快，对于主键的排序查找和范围查找非常快</li><li>查询显示一定范围数据的时候，由于数据都紧密相连，数据库不用从多个数据块中提取数据，节省了大量的io操作。</li></ul><h5 id="缺点-1">缺点：</h5><ul><li>插入速度严重依赖于插入顺序</li><li>更新主键代价很高，所以一般定义主键不可更新</li><li>二级索引访问需要两次查找</li></ul><h5 id="限制">限制：</h5><ul><li>仅有InnoDB数据引擎支持，MyISAM不支持聚簇索引</li><li>每个Mysql的表只能有一个聚簇索引，一般情况下是表的主键</li></ul><h4id="二级索引辅助索引非聚簇索引">2、二级索引（辅助索引、非聚簇索引）</h4><p>​如果想以非主键进行查找怎么办呢？多建几颗B+树即可。使用该列的大小作为数据页、页中记录的排序规则。对于这些B+树中，其叶子节点中并不存储完整的用户记录，而是仅存储<strong>该列+ 主键的值</strong></p><h5 id="特点-1">特点：</h5><ul><li>使用记录本身的 该列（建B+树索引的列）值的大小 进行记录和页的排序<ul><li>页内的记录——按照该列的大小顺序排成单向链表。</li><li>各个存放用户记录的页——根据该列大小顺序排成一个双向链表</li><li>存放目录项记录的页——分为不同的层次，同一层次中的页之间按逐渐大小顺序排成双向链表</li></ul></li><li>B+树的叶子节点存储的是 <strong>该列的值 + 主键的值</strong></li><li>这种索引需要我们在mysql中显式创建。</li><li><strong>在以该列为条件搜索的时候，需要进行回表操作</strong>，就是说先查找到记录的主键的值，再利用主键的值去聚簇索引中查找整条记录的值。</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221021212458365.png" /></p><h4 id="联合索引">3、联合索引：</h4><p>​同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照c2和c3列 的大小进行排序，这个包含两层含义：</p><ul><li><p>先把各个记录和页按照c2列进行排序。</p></li><li><p>在记录的c2列相同的情况下，采用c3列进行排序</p></li><li><p>以c2和c3列的大小为排序规则建立的B+树称为 联合索引，<strong>本质上也是一个二级索引。</strong>它的意思与分别为c2和c3列分别建立索引的表述是不同的，主要表现为：</p><ul><li>建立 联合索引 只会建立如上图一样的1棵B+树。</li></ul></li></ul><h4 id="innodb的b树索引的注意事项">4、InnoDB的B+树索引的注意事项：</h4><ul><li><strong>根页面位置不变</strong>，实际上B+树的形成过程如下：<ul><li>每当为某个表创建一个B+树索引的时候，<strong>都会为这个索引创建一个根节点页面。</strong></li><li>最开始表中没有数据的时候，每个B+树索引对应的根节点中既没有用户记录，也没有目录项记录。</li></ul></li><li>非叶节点中目录项记录的唯一性：即如果建立的非聚簇索引的那一列值不唯一怎么办？容易导致非叶节点的目录项不唯一。<ul><li>为了让新插入记录能找到自己在哪个页里，<strong>我们需要保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的。</strong>所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：<ul><li>索引列的值</li><li>主键值</li><li>页号</li></ul></li></ul></li></ul><figure><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221021223514710.png"alt="蓝色即为主键值，橙色为建立索引列的值" /><figcaptionaria-hidden="true">蓝色即为主键值，橙色为建立索引列的值</figcaption></figure><ul><li>一个页面最少存储2条记录（其实就是B+树本身的限制）</li></ul><h4 id="myisam中的索引方案">5、MyISAM中的索引方案：</h4><p>​在MyISAM中，其使用的B+树索引的，叶子结点存储的是数据记录的地址，而不是数据本身。</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/image-20221022120251019.png" /></p><h4 id="innodb和myisam引擎的区别">6、InnoDB和MyISAM引擎的区别</h4><p><strong>MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。</strong></p><ul><li><p>①在InnoDB存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在MyISAM中却需要进行一次回表操作，意味着MyISAM中建立的索引相当于全部都是二级索引。</p></li><li><p>②InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。</p></li><li><p>③InnoDB的非聚簇索引data域存储相应记录主键的值，而MyISAM索引记录的是地址。</p></li><li><p>④MyISAM的回表操作是十分快速的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</p></li><li><p>⑤ InnoDB要求表必须有主键（MyISAM可以没有）。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。</p></li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-22%2012.06.40.png" /></p><h4 id="索引的数据结构选取">7、索引的数据结构选取</h4><p>​为了减少索引在内存中的占用，其都是存储在磁盘上的。当我们使用索引查询的时候，不可能把索引全都一次性加载到内存中，所以要尽可能的设计索引的数据结构，使得<strong>磁盘IO次数较少</strong></p><ul><li>Hash索引从速度上来讲比树型索引要快很多，那么为什么索引还是设计成树的样子呢？<ul><li>因为Hash索引仅能支持 等于、不等于 操作，无法支持范围查询</li><li>数据的存储没有顺序，如果需要ORDER BY的情况下，还要重新排序</li><li>如果重复值多，Hash冲突多的话，效率也会下降</li><li>不能支持联合索引</li><li>InnoDB不支持Hash索引</li></ul></li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/image-20221022121840709.png" /></p><ul><li>InnoDB本身不支持Hash索引，但提供自适应Hash索引：<ul><li>如果某个数据经常被访问，且满足一定条件，该数据页的地址就会放入Hash表中。下次查询的时候，直接通过自适应Hash就可以访问到这个数据页。</li></ul></li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/image-20221022122100058.png" style="zoom: 33%;" /></p><h4 id="b树和b树的选取">8、B树和B+树的选取：</h4><ul><li><p>B树：多路平衡查找树：</p><ul><li>（叶子结点和非叶子结点都会存储数据，搜索有可能终止于非叶子结点）</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/image-20221022122415040.png" /></p></li><li><p>B+树：</p><p>B+树更适合文件索引，两者区别如下：</p><ul><li>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 = 关键字数，而 B树中，孩子数量 = 关键字数+1。</li><li>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）。</li><li>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而B 树中， 非叶子节点既保存索引，也保存数据记录。</li><li>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接</li></ul></li><li><p>B+树相比于B树的区别和好处？</p><ul><li>查找效率更稳定（数据都在叶子节点），且更高（更矮胖）</li><li>范围查找中，效率也更高。因为数据都在叶子节点中，可以通过指针链接查找。</li></ul></li></ul><h4 id="r树">9、R树</h4><p>​其仅支持geometry数据类型。比如查找20km以内所有的餐厅，岂能解决高维空间的搜索问题。其实质上就是一颗用来存储高维数据的平衡树。</p>]]></content>
    
    
    <summary type="html">Chap9——Mysql 索引及调优原则</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB数据存储结构分析</title>
    <link href="https://blog.fantast.top/2022/10/17/e8cf764280fd/"/>
    <id>https://blog.fantast.top/2022/10/17/e8cf764280fd/</id>
    <published>2022-10-17T07:09:19.000Z</published>
    <updated>2022-10-24T01:43:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一数据库的存储结构页">一、数据库的存储结构：页</h3><h4id="磁盘与内存交互的基本单位页">1、磁盘与内存交互的基本单位——页：</h4><ul><li><p>InnoDB将数据划分为若干个页，页的大小默认为16KB。</p></li><li><p><strong>将页作为磁盘和内存之间交互的基本单位。</strong>即，在数据库中，不论读多少行，都是将这些行所在的页进行加载。即I/O操作的最小单位就是页。</p></li><li><p>连续的页之间，不在物理结构上相连接，期间通过双向链表连接。每个数据页中的记录会按照主键的值从小到大的顺序组成一个单向链表，<strong>每个数据也都会为存储在它里面的记录生成一个页目录，</strong>这样可以在页目录中是用二分法定位到对应的槽，再遍历槽对应分组中的记录找到指定记录就行。</p></li><li><p>页的上层结构：</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221023094039939.png" /></p><ul><li>区：一个区会分配64个连续的页</li><li>段：段是数据库中的分配单位。段中不要求区和区之间连续。比如说创建一张表时，会创建一个表段，创建一个索引时，会创建一个索引段。</li><li>表空间：逻辑容器，可以有1个或多个段。表空间从管理上可以划分为：系统表空间、用户表空间等。</li></ul></li></ul><h4 id="页的内部结构">2、页的内部结构：</h4><h5 id="数据页的存储空间被划分为7个部分">1)数据页的存储空间被划分为7个部分：</h5><ul><li><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221023094541084.png" /></li><li><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221023094558222.png" /></li></ul><h5 id="file-header-和-file-trailer-文件头部和文件尾部">2) File Header和 File Trailer 文件头部和文件尾部：</h5><ul><li>File Header 描述各种页的通用信息——页的编号，上一页下一页等<ul><li>FIL_PAGE_OFFSET 页的单独页号</li><li>FIL_PAGE_TYPE 页的类型，比如索引页、日志页等等</li><li>FIL_PAGE_PREV（4字节）和FIL_PAGE_NEXT（4字节）本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，保证这些页之间不需要是物理上的连续，而是逻辑上的连续。</li><li>FIL_PAGE_SPACE_OR_CHKSUM（4字节）当前页面的校验和，<strong>文件头部和尾部都有这个校验和</strong><ul><li>作用 :InnoDB存储引擎以页为单位把数据加载到内存中处理，<strong>如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候断电了，造成了该页传输的不完整。</strong>为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），<strong>这时可以通过文件尾的校验和（checksum值）与文件头的校验和做比对，如果两个值不相等则证明页的传输有问题，需要重新进行传输，</strong>否则认为页的传输已经完成。</li><li>具体操作方法：每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为FileHeader在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在FileHeader中的校验和就代表着已经修改过的页，而在FileTrailer中的校验和代表着原先的页，二者不同则意味着同步中间出了错。</li></ul></li><li>FIL_PAGE_LSN 页面被最后修改时对应的日志序列位置（Log SequenceNumber）</li></ul></li><li>文件尾部：共8字节<ul><li>前4个字节代表页的校验和：这个部分是和File Header中的校验和相对应的。后4个字节代表页面被最后修改时对应的日志序列位置（LSN）：这个部分也是为了校验页的完整性的，如果首部和尾部的LSN值校验不成功的话，就说明同步过程出现了问题</li></ul></li></ul><h5 id="free-space-user-records-infimum-supremum">3) Free Space &amp;User Records &amp; Infimum Supremum</h5><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-23%2016.31.02.png" /></p><ul><li><p>每插入一条记录，从Free Space部分申请一个记录大小的空间分给UserRecords空间</p></li><li><p>我们自己存储的记录会按照指定的行格式存储到UserRecords部分</p></li><li><p>记录按照指定的行格式一条一条摆在UserRecords部分，相互之间形成单链表。用户记录里的一条条数据如何记录和形成呢？详见InnoDB行格式中的记录头信息。</p></li><li><p>Infimum Supremum 最小最大记录：</p><ul><li><p>对于一条完整的记录来说，比较记录的大小就是比较主键的大小。</p></li><li><p>InnoDB规定的最小记录与最大记录这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-23%2016.40.36.png" /></p></li><li><p>这两条记录不是我们自己定义的记录，所以它们并不存放在页的UserRecords部分，他们被单独放在一个称为Infimum +Supremum的部分，如图所示：</p></li></ul></li></ul><h5 id="page-directory-page-header-页目录和页头">4) Page Directory &amp;Page Header 页目录和页头</h5><ul><li><p>1、为什么需要页目录？</p><ul><li>在页中，记录是以单向链表的形式进行存储的。查找性能差，因此在页结构中专门设计了页目录这个模块，专门给记录做一个目录，通过二分查找法的方式进行检索，提升效率。</li><li>具体做法：将所有的记录分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录。<ul><li>第 1 组，也就是最小记录所在的分组只有 1 个记录；最后一组，就是最大记录所在的分组，会有 1-8 条记录； 其余的组记录数量在4-8 条之间。</li><li>在每个组中<strong>最后一条记录的头信息中会存储该组一共有多少条记录</strong>，作为n_owned 字段。</li><li>页目录用来存储<strong>每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，</strong>每组的地址偏移量也被称之为槽（slot），每个槽相当于指针指向了不同组的最后一个记录。</li><li><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-23%2016.50.25.png" /></li></ul></li></ul></li><li><p>2、页目录结构下如何快速查找记录？</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-23%2016.53.45.png" /></p></li></ul><p>Page Header 页头</p><ul><li><p>为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫PageHeader的部分，这个部分占用固定的56个字节，专门存储各种状态信息。</p></li><li><p>PAGE_DIRECTION 记录插入方向</p></li><li><p>PAGE_N_DIRECTION</p><ul><li>假设连续几次插入新记录的方向都是一致的，InnoDB会把沿着同一个方向插入记录的条数记下来，这个条数就用PAGE_N_DIRECTION这个状态表示。当然，如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计。</li></ul></li></ul><h4id="从数据页的角度看b树如何查询">3、从数据页的角度看B+树如何查询：</h4><h5 id="如何查询">1）如何查询？</h5><p>​先从B+树的根开始，逐层检索。然后将数据页加载到内存中，页目录中的槽使用二分查找的方式先找到一个粗略的记录分组，然后再在分组中通过链表遍历的方式查找记录。</p><h5id="普通索引和唯一索引在查询中的区别">2）普通索引和唯一索引在查询中的区别？</h5><p>​唯一索引找到了关键字就可以停止检索。而普通索引找到关键字以后，还需要在内存中多看下X条记录。</p><h4 id="innodb行格式compact行格式">4、InnoDB行格式：COMPACT行格式</h4><p>一条记录的数据可以分为记录的额外信息和真实数据</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-23%2016.34.37.png" /></p><h5 id="变长字段长度列表">1）变长字段长度列表</h5><p>​变长字段中存储多少字节的数据不是固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。</p><p>​在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表。注意：这里面存储的变长长度和字段顺序是反过来的。比如两个varchar字段在表结构的顺序是a(10)，b(15)。那么在变长字段长度列表中存储的长度顺序就是15，10，是反过来的。</p><h5 id="null值列表">2）NULL值列表</h5><p>​Compact行格式会把可以为NULL的列统一管理起来，存在一个标记为NULL值列表中。如果表中没有允许存储NULL 的列，则 NULL值列表也不存在了。</p><ul><li>为什么定义NULL值列表？<ul><li>之所以要存储NULL是因为数据都是需要对齐的，如果没有标注出来NULL值的位置，就有可能在查询数据的时候出现混乱。如果使用一个特定的符号放到相应的数据位表示空置的话，虽然能达到效果，但是这样很浪费空间，所以直接就在行数据得头部开辟出一块空间专门用来记录该行数据哪些是非空数据，哪些是空数据，</li></ul></li><li>格式如下：<ul><li>二进制位的值为1时，代表该列的值为NULL。</li><li>二进制位的值为0时，代表该列的值不为NULL。</li></ul></li><li>例如：字段 a、b、c，其中a是主键，在某一行中存储的数依次是a=1、b=null、c=2。那么Compact行格式中的NULL值列表中存储：01。第一个0表示c不为null，第二个1表示b是null。这里之所以没有a是因为数据库会自动跳过主键，因为主键肯定是非NULL且唯一的，在NULL值列表的数据中就会自动跳过主键。</li></ul><h5 id="记录头信息总共就5个字节">3）记录头信息（总共就5个字节）</h5><ul><li><p>delete_mask</p><ul><li>这个属性标记着当前记录是否被删除，占用1个二进制位。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后其他的记录在磁盘上需要重新排列，导致性能消耗。所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的垃圾链表。<br /></li></ul></li><li><p>min_rec_mask</p><ul><li>B+树的每层非叶子节点中的最小记录都会添加该标记，min_rec_mask值为1。</li></ul></li><li><p>record_type</p><ul><li>这个属性表示当前记录的类型，一共有4种类型的记录：<ul><li>0：表示普通记录<br /></li><li>1：表示B+树非叶节点记录</li><li>2：表示最小记录<br /></li><li>3：表示最大记录</li></ul></li></ul></li><li><p>heap_no</p><ul><li>这个属性表示当前记录在本页中的位置。比如说2，3，4，5等</li><li><strong>MySQL会自动给每个页里加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为伪记录或者虚拟记录。</strong>这两个伪记录一个代表最小记录，一个代表最大记录。最小记录和最大记录的heap_no值分别是0和1，也就是说它们的位置最靠前。<br /></li></ul></li><li><p>n_owned</p><ul><li><strong>页目录</strong>中每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为n_owned 字段。详情见page directory。</li></ul></li><li><p>next_record</p><ul><li>它表示从当前记录的真实数据到下一条记录的真实数据的<strong>地址偏移量。</strong></li><li>比如：第一条记录的next_record值为32，意味着从第一条记录的真实数据的地址处向后找32个字节便是下一条记录的真实数据。注意，下一条记录指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。</li><li>规定Infimum记录（也就是最小记录）的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是Supremum记录（也就是最大记录）。</li></ul></li><li><p><strong>不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的。</strong></p></li><li><p>主键值为2的记录被删掉了以后，存储空间不会回收，如果我们再次把这条记录插入到表中，会发生什么事呢？——直接复用了原来被删除记录的存储空间。</p></li><li><p><strong>说明：当数据页中存在多条被删除掉的记录时，这些记录的next_record属性将会把这些被删除掉的记录组成一个垃圾链表，以备之后重用这部分存储空间。</strong></p></li></ul><h5 id="记录的真实数据">4）记录的真实数据</h5><p>​ 除了我们自己定义的列数据以外，还会有三个隐藏列。</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221023222958606.png" /></p><p>​实际上这几个列的真正名称其实是：DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR</p><ul><li>一个表没有手动定义主键，则会选取一个Unique键作为主键，如果连Unique键都没有定义的话，则会为表默认添加一个名为row_id的隐藏列作为主键。所以row_id是在没有自定义主键以及Unique键的情况下才会存在的。</li><li>事务ID和回滚指针涉及到事务相关的内容，具体见事务</li></ul><h4 id="dynamic和compressed行格式">5、Dynamic和Compressed行格式</h4><h5 id="什么是行溢出">1）什么是行溢出？</h5><p>​ InnoDB存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。很多DBA喜欢MySQL数据库提供的VARCHAR(M)类型，认为可以存放65535字节。这是真的吗？如果我们使用ascii字符集的话，一个字符就代表一个字节，我们看看VARCHAR(65535)是否可用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE varchar_size_demo( c VARCHAR(65535) ) CHARSET=ascii ROW_FORMAT=Compact;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have to change some columns to TEXT or BLOBs </span><br></pre></td></tr></table></figure><p>​报错信息表达的意思是：MySQL对一条记录占用的最大存储空间是有限制的，除BLOB或者TEXT类型的列之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节。这个65535个字节除了列本身的数据之外，还包括一些其他的数据，</p><p>​<strong>以Compact行格式为例，比如说我们为了存储一个VARCHAR(M)类型的列，除了真实数据占有空间以外，还需要记录的额外信息。如果该VARCHAR类型的列没有NOTNULL属性，那最多只能存储65532个字节的数据，因为变长字段的长度占用2个字节，NULL值标识需要占用1个字节。</strong></p><ul><li><p>通过上面的案例，我们可以知道一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65533个字节，<strong>这样就可能出现一个页存放不了一条记录，这种现象称为行溢出。</strong></p></li><li><p>在Compact和Reduntant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中进行分页存储，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。这称为页的扩展，：</p></li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221023224141758.png" /></p><h5 id="dynamic和compressed如何处理行溢出">2)Dynamic和Compressed如何处理行溢出？</h5><p>​ 在MySQL8.0中，默认行格式就是Dynamic。Dynamic、Compressed行格式和Compact行格式挺像，只不过在处理行溢出数据时有分歧：</p><ul><li><p>Compressed和Dynamic两种记录格式对于存放在BLOB中的数据采用了完全的行溢出的方式。</p></li><li><p>如图，在数据页中只存放20个字节的指针（溢出页的地址），实际的数据都存放在OffPage（溢出页）中。Compact和Redundant两种格式会在记录的真实数据处存储一部分数据（存放768个前缀字节）。<strong>Compressed行记录格式的另一个功能就是，存储在其中的行数据会以zlib的算法进行压缩，因此对于BLOB、TEXT、VARCHAR这类大长度类型的数据能够进行非常有效的存储。</strong></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221023224238085.png" /></p></li></ul><h4 id="区段与碎片区与表空间结构">5、区、段与碎片区与表空间结构：</h4><h5 id="为什么要有区">1）为什么要有区？</h5><p>​如果以页为单位来分配存储空间的话，双向链表相邻的两个页之间的物理位置可能离得比较远。当进行范围查询时，我们一般只需要定位到最左侧和最右侧的记录，然后沿着双向链表一直扫描即可。那么如果相邻的两个页之间的物理位置可能离得比较远的话，其实是在做<strong>随机IO</strong>，对于磁盘而言读写速度是很慢的。</p><p>​所以，引入区的概念，使得1个区中含物理位置上连续的64个页，这样就会把上述过程变成<strong>顺序IO</strong>，减少了磁盘寻道和半圈旋转时间。</p><p>​在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，<strong>而是按照区为单位分配，</strong>甚至在表中的数据特别多的时候，可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费（数据不足以填充满整个区），<strong>但是从性能角度看，可以消除很多的随机I/0</strong>，功大于过！</p><h5 id="为什么要有段">2）为什么要有段？</h5><p>​对于范围查询，其实是对B+树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。</p><p>​所以InnoDB对B+树的叶子节点和非叶子节点进行了区别对待，<strong>也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。</strong></p><p>​存放叶子节点的区的集合就算是一个段（segment），存放非叶子节点的区的集合也算是一个段。<strong>也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。</strong></p><p>​<strong>段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。</strong></p><h5 id="为什么要有碎片区">3）为什么要有碎片区？</h5><p>​默认情况下，一个使用InnoDB存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用1M（64*16Kb=1024Kb）存储空间，所以默认情况下一个只存了几条记录的小表也需要2M的存储空间么？以后每次添加一个索引都要多申请2M的存储空间么？这对于存储记录比较少的表简直是天大的浪费。</p><p>​这个问题的症结在于到现在为止我们介绍的区都是非常纯粹的，<strong>也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。</strong></p><p>​为了考虑以完整的区为单位分配给某个段对于数据量较小的表太浪费存储空间的这种情况，InnoDB提出了一个<strong>碎片（fragment）区的概念</strong>。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是<strong>碎片区中的页可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。</strong></p><p>​ 碎片区直属于表空间，并不属于任何一个段。</p><h5 id="为某个段分配存储空间的策略">4）为某个段分配存储空间的策略：</h5><ul><li>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。</li><li>当某个段已经占用了32个碎片区页面之后，就会申请以完整的区为单位来分配存储间。</li></ul><p>​所以现在段不能仅定义为是某些区的集合，更精确的应该是某些零散的页面以及一些完整的区的集合。</p><h5 id="区的分类">5）区的分类</h5><ul><li><p>碎片区</p><ul><li><p>空闲的区</p></li><li><p>有剩余空间的碎片区</p></li><li><p>没有剩余空间的碎片区</p></li></ul></li><li><p>附属于某个段的区</p></li></ul><h5 id="表空间">6）表空间：</h5><p>​表空间可以看做是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。表空间是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。</p><ul><li>独立表空间：<ul><li>每张表都有一个独立的表空间，即数据和索引信息都会保存在自己的表空间中。空间可以回收</li></ul></li><li>系统表空间：<ul><li>整个MySQL进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面，这部分是独立表空间中没有的。</li><li>InnoDB数据字典：（内部系统表）<ul><li>每当我们向一个表中插入一条记录的时候，MySOL校验过程如下<ul><li>先要校验一下插入语句对应的表存不存在，插入的列和表中的列是否符合，</li><li>如果语法没有问题的话，还需要知道该表的聚簇索引和所有二级索引对应的根页面是哪个表空间的哪个页面，然后把记录插入对应索引的B+树中。</li><li>所以说，MySQL除了保存着我们插入的用户数据之外，还需要保存许多额外的信息（元数据）</li></ul></li><li>注意：用户是不能直接访问InnoDB的这些内部系统表，除非你直接去解析系统表空间对应文件系统上的文件。</li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">Chap10——Mysql InnoDB数据存储结构分析</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>数据库索引优化和查询优化</title>
    <link href="https://blog.fantast.top/2022/10/17/10b6c2c40683/"/>
    <id>https://blog.fantast.top/2022/10/17/10b6c2c40683/</id>
    <published>2022-10-17T07:09:19.000Z</published>
    <updated>2022-10-31T07:24:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>SQL查询优化的技术有很多，大方向上可以分为：</p><ul><li>物理查询优化（索引、表连接方式）</li><li>逻辑查询优化（换一种效率更高的执行方法）</li></ul><p>具体可以从以下四个方面进行数据库调优：</p><ul><li>索引失效、没有充分利用到索引——索引建立</li><li>关联查询太多JOIN（设计缺陷或不得已的需求）—- SQL优化</li><li>服务器调优及各个参数设置（缓冲、线程数等）——调整my.cnf</li><li>数据过多——分库分表I</li></ul><h3 id="一索引优化与查询优化">一、索引优化与查询优化</h3><h4 id="索引失效案例情况">1、索引失效案例情况：</h4><p>​从理论上而言，使用或者不使用索引都是由<strong>优化器</strong>来决定，其是基于cost开销（CostBaseOptimizer），它不是基于规则（Rule-Basedoptimizer），也不是基于语义。怎么样开销小就怎么来。另外，SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。</p><h5 id="最佳左前缀匹配法则">1）最佳左前缀匹配法则</h5><p>​MySQL可以为多个字段创建索引，一个索引可以包括16个字段。<strong>对于多列索引，过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段！索引后面的字段都无法被使用。</strong>如果查询条件中没有使用这些字段中第1个字段时，多列（或联合）索引不会被使用。</p><p>​ 索引文件具有 B-Tree的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p><h5 id="主键插入顺序">2）主键插入顺序</h5><p>​ 如果插入的主键忽大忽小，就容易导致某个数据页满了以后，数据还会往其中插入，这个时候就需要把当前页面分裂成两个页面，把本页中的一些记录移动到新创建的这个页中。<strong>页面分裂和记录移位意味着什么？意味着：性能损耗！</strong>所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的主键值依次递增，这样就不会发生这样的性能损耗了。</p><p>​ <strong>建议：让主键具有AUTO_INCREMENT，让存储引擎自己为表生成主键，而不是我们手动插入。</strong></p><h5id="计算函数类型转换自动或手动导致索引失效">3）计算、函数、类型转换(自动或手动)导致索引失效</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name LIKE &#x27;abc%&#x27;;</span><br><span class="line"># 未使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) = &#x27;abc&#x27;;</span><br></pre></td></tr></table></figure><ul><li>从运行结果上，上述两个SQL语句没有差别。但是从运行效率上而言，下面这条语句因为使用了函数，所以并不会使用到name上的索引进行查询，也就是查询类型会是ALL，效率非常低。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 未使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=123;</span><br><span class="line"># 使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=&#x27;123&#x27;;</span><br></pre></td></tr></table></figure><ul><li>上述，是由于name=123发生类型转换，最终导致索引失效。</li></ul><h5 id="范围条件右边的列索引失效">4）范围条件右边的列索引失效</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_age_name_classid on student(age,classid,name)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 会使用上述联合索引，但是没有用到Name这个字段上建立的索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student</span><br><span class="line">WHERE student.age=30 AND student.classId&gt;20 AND student.name = &#x27;abc&#x27; ;</span><br></pre></td></tr></table></figure><p>​想要起作用，得写成如下格式：建联合索引时，把确定查询的放到前面，范围查询的放到后面.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_age_name_classid on student(age,name,classid)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.name =</span><br><span class="line">&#x27;abc&#x27; AND student.classId&gt;20 ;</span><br></pre></td></tr></table></figure><p>​结论：应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。应将查询条件放置where语句最后。（即创建的联合索引中，务必把范围涉及到的字段写在最后）</p><h5 id="不等于导致索引失效">5）不等于导致索引失效</h5><h5 id="is-null可以使用索引is-not-null无法使用索引">6）isnull可以使用索引，is not null无法使用索引</h5><h5 id="like以通配符开头索引失效">7）like以通配符%开头索引失效</h5><p>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p><h5 id="or-前后存在非索引的列索引失效">8）OR前后存在非索引的列，索引失效</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 未使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 10 OR classid = 100;</span><br><span class="line"># 使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 10 OR name = &#x27;Abel&#x27;;</span><br></pre></td></tr></table></figure><h5id="数据库和表的字符集统一使用utf8mb4">9）数据库和表的字符集统一使用utf8mb4</h5><p>​统一使用utf8mb4兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的字符集进行比较前需要进行转换会造成索引失效。</p><h5 id="总结建议">10）总结建议：</h5><ul><li>单列索引，尽量选择针对当前query过滤性更好的索引</li><li>在选择组合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li><li>在选择组合索引的时候，尽量选择能够包含当前query中的where子句中更多字段的索引。</li><li>在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面。</li></ul><h4 id="关联查询的优化情况">2、关联查询的优化情况：</h4><h5 id="left-join-左外连接左边驱动表右边被驱动表">1）Left Join左外连接（左边驱动表，右边被驱动表）</h5><p>​ LeftJoin的条件（即On上的内容）用于确定如何从右表搜索行，而左边的表一定都有，所以右边是我们的关键点,一定需要建立索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;</span><br><span class="line"></span><br><span class="line"># 在被驱动表book上添加索引，可以避免对book表的全表扫描。</span><br><span class="line">ALTER TABLE book ADD INDEX Y (card);</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;</span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221031110652164.png" /></p><h5 id="inner-join-内连接">2）INNER JOIN 内连接：</h5><p>​ 在INNER JOIN中，驱动表是由MySQL自动选择的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 由于驱动表是查询优化器决定的，所以如果book上建了索引，type没建，那么book会被选为被驱动表，反之type会被选为被驱动表。如果两列都建了索引，那么还是由查询优化器自动根据Cost选择。（一般都是选择小表作为驱动表，即小表驱动大表）</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM type INNER JOIN book ON type.card=book.card;</span><br></pre></td></tr></table></figure><h5 id="join语句的原理">3）JOIN语句的原理</h5><ul><li>驱动表和非驱动表：<ul><li>内连接：优化器自动决定</li><li>外连接：优化器也会帮助决定驱动表</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM t1 STRAIGHT_JOIN t2 ON (t1.a=t2.a);</span><br></pre></td></tr></table></figure><ul><li>Simple Nested-Loop Join 简单嵌套<ul><li>假设A表有A条记录，B表有B条记录，A作为驱动表，B被驱动表</li><li>最终查询开销：外表扫描1次，内表扫描A次，读取记录数：A + B *A，JOIN比较次数 B * A</li><li>所以使用小表驱动大表</li></ul></li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221031112529836.png" /></p><ul><li><p>Index Nested0Loop Join 索引嵌套循环连接</p><p>为了减少内层表数据的匹配次数，所以被驱动表上需要有索引。</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221031112116837.png" /></p><ul><li><p>假设A表有A条记录，B表有B条记录，A作为驱动表，B被驱动表</p></li><li><p>在这条语句里，被驱动表t2的字段a上有索引，join过程用上了这个索引，因此这个语句的执行流程是这样的：</p><ul><li>从表t1中读入一行数据 R；</li><li>从数据行R中，取出a字段到表t2里去查找；</li><li>取出表t2中满足条件的行，跟R组成一行，作为结果集的一部分；</li><li>重复执行步骤1到3，直到表t1的末尾循环结束。</li></ul><p>在这个流程里：</p><ul><li>对驱动表t1做了全表扫描，这个过程需要扫描100行；</li><li>而对于每一行R，根据a字段去表t2查找，走的是树搜索过程。由于我们构造的数据都是一一对应的，因此每次的搜索过程都只扫描一行，也是总共扫描100行；</li><li>所以，整个执行流程，总扫描行数是200</li></ul></li><li></li></ul></li><li><p>Block Nested Loop Join (针对Simple的优化方法)</p><p>​如果存在索引，那么会使用index的方式进行join，如果join的列没有索引，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把被驱动表的记录在加载到内存匹配，这样周而复始，大大增加了I0的次数。</p><p>​ 为了减少被驱动表的IO次数，就出现了Block Nested-LoopJoin的方式。<strong>不再是逐条获取驱动表的数据，而是一块一块的获取，引入了joinbuffer缓冲区，将驱动表join相关的部分数据列（大小受joinbuffer的限制）缓存到joinbuffer中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和joinbuffer中的所有驱动表记录进行匹配（内存中操作），将简单嵌套循环中的多次比较合并成一次</strong>，降低了被驱动表的访问频率。</p></li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221031115027527.png" /></p><ul><li>最终查询开销：<ul><li>外表扫描1次</li><li>内表扫描A * used_column_size / join_buffer_size + 1次</li><li>读取记录数：A + B * (A * used_column_size / join_buffer_size)</li><li>JOIN比较次数 B * A</li></ul></li></ul><h5 id="join语句结论">4）JOIN语句结论：</h5><ul><li>使用join语句，性能比强行拆成多个单表执行SQL语句的性能要好（能够直接多表关联的尽量直接关联，不用子查询）</li><li>如果使用join语句的话，需要让小表做驱动表。(在决定哪个表做驱动表的时候，<strong>应该是两个表按照各自的条件过滤，过滤完成之后，计算参与join的各个字段的总数据量，数据量小的那个表，</strong>就是“小表”，应该作为驱动表。</li><li>为被驱动表匹配的条件增加索引</li><li>增大Join BufferSize的大小（单次缓存的数据越多，内层包的扫表次数越少）</li><li>减少驱动表不必要的字段查询，字段越少，join buffer缓存的数据越多</li></ul><h5 id="hash-join">5）Hash Join</h5><p>​ HashJoin是做大数据集连接时的常用方式，优化器使用两个表中较小（相对较小）的表利用JoinKey在内存中建立散列表，然后扫描较大的表并探测散列表，找出与Hash表匹配的行。</p><p>​<strong>这种方式适用于较小的表完全可以放于内存中的情况，这样总成本就是访问两个表的成本之和。</strong></p><p>​在表很大的情况下并不能完全放入内存，这时优化器会将它分割成若干不同的分区，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高I/O的性能。</p><p>​它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。HashJoin只能应用于等值连接，这是由Hash的特点决定的。</p><h4 id="子查询优化">3、子查询优化</h4><p>​ 子查询能够实现较复杂的语句，但是其执行效率较低，原因如下：</p><ul><li>执行子查询时，MySQL需要为内层查询语句的查询结果建立一个临时表，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表。这样会消耗过多的CPU和IO资源，产生大量的慢查询。</li><li>子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。</li><li>对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</li></ul><p>​故而，对于能够拆解的子查询，尽可能用多个步骤的关联查询来代替子查询。</p><h4 id="排序优化">4、排序优化</h4><p>​ 在MySQL中，支持两种排序方式，分别是FileSort和Index排序。</p><ul><li>Index排序：索引可以保证数据的有序性，效率高。</li><li>FileSort：一般在内存中进行排序，占用CPU较多。如果结果较大则会产生临时文件IO到磁盘进行排序，效率低。</li></ul><p>​ 优化建议：</p><ul><li>SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引：目的是在 WHERE子句中避免全表扫描，在 ORDER BY 子句避免使用FileSort排序。<strong>当然，某些情况下全表扫描，或者 FileSort排序不一定比索引慢。</strong>但总的来说，我们还是要避免，以提高查询效率。</li><li>尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY是相同的列就使用单索引列；<strong>如果不同就使用联合索引</strong>。</li><li>无法使用 Index 时，需要对 FileSort 方式进行调优</li></ul><p>可以应用索引进行排序的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">INDEX a_b_c(a,b,c)</span><br><span class="line"></span><br><span class="line"># 如果WHERE使用索引的最左前缀定义为常量，则order by 能使用索引</span><br><span class="line">- WHERE a = const ORDER BY b,c</span><br><span class="line">- WHERE a = const AND b = const ORDER BY c</span><br><span class="line">- WHERE a = const ORDER BY b,c</span><br><span class="line">- WHERE a = const AND b &gt; const ORDER BY b,c</span><br></pre></td></tr></table></figure><p>不可以应用索引进行排序的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- ORDER BY a ASC,b DESC,c DESC /* 排序不一致 */</span><br><span class="line">- WHERE g = const ORDER BY b,c /*丢失a索引*/</span><br><span class="line">- WHERE a = const ORDER BY c /*丢失b索引*/</span><br><span class="line">- WHERE a = const ORDER BY a,d /*d不是索引的一部分*/</span><br><span class="line">- WHERE a in (...) ORDER BY b,c /*对于排序来说，多个相等条件也是范围查询*/</span><br></pre></td></tr></table></figure><p>​需要注意：有些可以应用索引进行排序的情况，查询优化器不一定会去使用。这会取决于具体的查询字段、数据量等等。</p><ul><li>当【范围条件】和【group by 或者 orderby】的字段出现二选一时，优先观察条件字段的过滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。反之，亦然。</li></ul><h5 id="filesort算法">1）FileSort算法：</h5><ul><li>双路排序<ul><li>是两次扫描磁盘，最终得到数据。</li><li>第一次仅读取行指针和order by列，对他们进行排序。</li><li>第二次扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出，从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段</li></ul></li><li>单路排序（更消耗buffer）<ul><li>直接从磁盘读取查询需要的所有列，按照orderby列在buffer对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空间，因为它把每一行都保存在内存中了。</li><li>如果buffer容量不够，反而可能会导致大量的IO操作。<ul><li>尝试提高 sort_buffer_size</li><li>尝试提高 max_length_for_sort_data</li><li>Order by 时select * 是一个大忌。最好只Query需要的字段</li></ul></li></ul></li></ul><h4 id="group-by-优化">5、GROUP BY 优化：</h4><ul><li>group by 使用索引的原则几乎跟order by一致 ，group by即使没有过滤条件用到索引，也可以直接使用索引。</li><li>group by 先排序再分组，遵照索引建的最佳左前缀法则</li><li>当无法使用索引列，增大max_length_for_sort_data 和sort_buffer_size参数的设置</li><li>where效率高于having，能写在where限定的条件就不要写在having中。减少使用orderby，和业务沟通能不排序就不排序，或将排序放到程序端去做。</li><li>Order by、groupby、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li><li>包含了order by、groupby、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</li></ul><h4 id="优化分页查询">6、优化分页查询：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM student LIMIT 200000,10;</span><br></pre></td></tr></table></figure><ul><li>优化1：在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM student t,(SELECT id FROM student ORDER BY id LIMIT 2000000,10) a</span><br><span class="line">WHERE t.id = a.id;</span><br></pre></td></tr></table></figure><ul><li>优化2：该方案适用于主键自增的表，可以把Limit查询转换成某个位置的查询。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM student WHERE id &gt; 2000000 LIMIT 10;</span><br></pre></td></tr></table></figure><h4 id="覆盖索引">7、覆盖索引：</h4><p>​ 一个索引包含了满足查询结果的数据就叫做覆盖索引。简单说就是，索引列+主键 包含 SELECT 到 FROM 之间查询的列。</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 不使用索引，因为如果要使用还需要回表，成本更高</span><br><span class="line">EXPLAIN SELECT * FROM student WHERE NAME LIKE &#x27;%abc&#x27;</span><br><span class="line"></span><br><span class="line"># 使用索引，因为索引中有id,age,NAME，所以不需要回表</span><br><span class="line">EXPLAIN SELECT id,age,NAME FROM student WHERE NAME LIKE &#x27;%abc&#x27;</span><br></pre></td></tr></table></figure><ul><li>好处：<ul><li>避免Innodb表进行索引的二次查询（回表）</li><li>可以把随机IO变成顺序IO加快查询效率，因为覆盖索引是按照键值的顺序存储的，对于IO密集型的范围查找来说，对比随机从磁盘读取每一行的数据IO要少的多。</li></ul></li><li>弊端：<ul><li>索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑。</li></ul></li></ul><h4 id="索引条件下推">8、索引条件下推：</h4><p>​ Index Condition Pushdown(ICP)是MySQL5.6中新特性，是一种在存储引擎层使用索引过滤数据的一种优化方式。ICP可以减少存储引擎访问基表的次数以及MySQL服务器访问存储引擎的次数。</p><ul><li>示例： 表上有联合索引(key1,key2)<ul><li>不使用ICP的查询过程：先使用联合索引(key1,key2)过滤key1&gt;'z'条件，然后回表，回表后的数据加载到数据页中，再去找满足第二第三个条件的数据</li><li>使用ICP的查询过程：先使用联合索引(key1,key2)过滤key1&gt;'z'条件，然后不急着回表。因为联合索引中有key2这个字段，所以可以先进行索引条件下推，也就是先筛选key2这个条件，然后由于key3不在索引内，所以只能先去回表，再筛选第三个数据了。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 where key1 &gt; &#x27;z&#x27; AND key2 LIKE &#x27;%s&#x27; AND key3 LIKE &#x27;%ss&#x27;</span><br></pre></td></tr></table></figure><h5 id="icp的开启和关闭">1）ICP的开启和关闭：</h5><p>默认情况下启用索引下推，可以通过设置系统变量optimizer_switch =index_contidition_pushdown = on来开启。</p><h5 id="使用条件">2）使用条件：</h5><ul><li>只能用于二级索引(secondary index)</li><li>explain显示的执行计划中type值（join 类型）为range 、 ref 、 eq_ref或者ref_or_null 。</li><li>并非全部where条件都可以用ICP筛选，如果where条件的字段不在索引列中，还是要读取整表的记录到server端做where过滤。</li><li>ICP可以用于MyISAM和InnnoDB存储引擎</li><li>MySQL 5.6版本的不支持分区表的ICP功能，5.7版本的开始支持。</li><li>当SQL使用覆盖索引时，不支持ICP优化方法。</li></ul><h4 id="其他查询优化策略">9、其他查询优化策略：</h4><h5 id="exists-和-in">1）EXISTS 和 IN</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM A WHERE CC IN(SELECT CC FROM B) </span><br><span class="line"></span><br><span class="line">SELECT * FROM A WHERE EXISTS(SELECT CC FROM B WHERE B.cc=A.cc)</span><br></pre></td></tr></table></figure><p>当A小于B时，用EXISTS，因为A是驱动表，执行顺序是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in A:</span><br><span class="line">for j in B:</span><br><span class="line">if j.cc == i.cc then</span><br></pre></td></tr></table></figure><p>当B小于A时，用IN，因为实现逻辑正好与上相反。</p><h5 id="count-和-count具体字段">2）COUNT(*) 和 COUNT(具体字段)</h5><ul><li>COUNT(*) 和 COUNT(1) 两者执行效率类似。</li><li>如果是MyISAM存储引擎，统计表的行数为O(1)复杂度，因为有元数据存储，一致性由表级锁维护。</li><li>如果是InnoDB，其支持事务行锁等机制，无法维护元数据，所以需要扫描全表，是O(n)复杂度，进行循环+计数方式统计。</li><li>InnoDB中，如果采用COUNT(具体字段)，尽可能使用二级索引，因为主键采用的是聚簇索引，包含的信息较多。对于COUNT(*)和 COUNT(1)而言，只是统计行数，系统回自动采用占用空间更小的二级索引来统计。</li></ul><h5 id="关于select">3）关于SELECT *</h5><ul><li>不建议使用，耗费资源和时间</li><li>无法使用覆盖索引</li></ul><h5 id="limit1">4）LIMIT1</h5><ul><li>针对的是会扫描全表的SQL语句，如果你可以确定结果集只有一条，那么加上LIMIT1的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。</li></ul><h5 id="多使用commit">5）多使用COMMIT</h5><ul><li>只要有可能，在程序中尽量多使用COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT所释放的资源而减少。</li><li>COMMIT 所释放的资源：<ul><li>回滚段上用于恢复数据的信息</li><li>被程序语句获得的锁</li><li>redo / undo log buffer 中的空间</li><li>管理上述 3 种资源中的内部花费</li></ul></li></ul><h3 id="二主键应当如何设计">二、主键应当如何设计？</h3><p>​自增ID做主键，简单易懂，几乎所有数据库都支持自增类型，只是实现上各自有所不同而已。自增ID除了简单，其他都是缺点。</p><ol type="1"><li>可靠性不高 存在自增ID回溯的问题，这个问题直到最新版本的MySQL8.0才修复。</li><li>安全性不高对外暴露的接口可以非常容易猜测对应的信息。比如：/User/1/这样的接口。</li><li>性能差 自增ID的性能较差，需要在数据库服务器端生成。</li><li>交互多 业务还需要额外执行一次类似last_insert_id()的函数才能知道刚才插入的自增值，这需要多一次的网络交互。在海量并发的系统中，多1条SQL，就多一次性能上的开销。</li><li>局部唯一性最重要的一点，自增ID是局部唯一，只在当前数据库实例中唯一，而不是全局唯一，在任意服务器间都是唯一的。对于目前分布式系统来说，这简直就是噩梦</li></ol><h4 id="使用业务字段做主键">1、使用业务字段做主键？</h4><p>​ 不可取！建议尽量不要用跟业务有关的字段做主键。</p><h4 id="推荐的主键设计">2、推荐的主键设计：</h4><ul><li>非核心业务：对应表的主键自增ID，如告警、日志、监控等信息。</li><li>核心业务：主键设计至少应该是全局唯一且是单调递增。全局唯一保证在各系统之间都是唯一的，单调递增是希望插入时不影响数据库性能</li></ul><p><strong>UUID</strong>：</p><p>​ UUID = 时间+UUID版本（16字节）- 时钟序列（4字节） -MAC地址（12字节）</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221031152235559.png" /></p><p>​在UUID中时间部分占用60位，存储的类似TIMESTAMP的时间戳，但表示的是从1582-10-1500：00：00.00到现在的100ns的计数。可以看到UUID存储的时间精度比TIMESTAMPE更高</p><ul><li>为什么UUID是随机无序的呢？<ul><li>因为UUID的设计中，<strong>将时间低位放在最前面，而这部分的数据是一直在变化的，并且是无序。</strong></li></ul></li></ul><p><strong>改造UUID，使其适配主键的要求</strong>：</p><p>​若将时间高低位互换，则时间就是单调递增的了，也就变得单调递增了。MySQL8.0可以更换时间低位和时间高位的存储方式，这样UUID就是有序的UUID了。</p><p>​另外在真实的业务系统中，主键还可以加入业务和系统属性，如用户的尾号，机房的信息等。</p>]]></content>
    
    
    <summary type="html">Chap8——Mysql 数据库调优方法和思维，包含索引优化和查询优化</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>电子信息工程中数学模型与方法——单元2 系统辨识</title>
    <link href="https://blog.fantast.top/2022/10/12/f71a1b069441/"/>
    <id>https://blog.fantast.top/2022/10/12/f71a1b069441/</id>
    <published>2022-10-12T00:14:20.782Z</published>
    <updated>2022-09-28T01:09:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一模型智能">一、模型智能</h2><h3 id="什么是智能">1、什么是智能？</h3><p>​ 智能有三个层次（某IBM科学家）：感知智能，执行智能，认知智能</p><ul><li>感知智能：感知环境状态</li><li>执行智能：采取行动</li><li>认知智能：建模、分析与决策，认知智能是最高级智能</li></ul><p>认知智能是动物和人建立/改进环境模型（规律的表述），使用模型处理信息并做出预测和决策的能力</p><ul><li><p>理想人工智能:人工智能是研究模拟和扩展动物和人的智能的理论和方法，包含感知智能、执行智能和认知智能。</p></li><li><p>当前人工智能：现在的所谓人工智能大都是开发基于图像和声音的感知技术。所以当前的人工智能还在感知智能的层次</p></li></ul><p>下图为自动控制流程：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220923163300371.png" style="zoom:67%;" /></p><ul><li><strong>一个系统的最优控制器一定是该系统的数学模型!</strong></li></ul><h3 id="基于智能建模的智能建造技术">2、基于智能建模的智能建造技术：</h3><ul><li><p>流程工业包括石化、化工、发电、钢铁、水泥、造纸、采矿等，是国民经济的基础</p></li><li><p>催生一个巨大的流程工业智能制造市场，在流程工业实现全面自动化生产，即智能制造，可以节能1%-10%，提高收益0.1% - 2%，减少污染物生成5% - 50%</p></li></ul><p>计划调度、诊断监控、实时优化、模型预测控制、常规PID控制、设备仪表及DCS系统</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220923163633152.png" /></p><p><strong>过程模型的建立/维护，是实现每一层自动/闭环的关键</strong></p><p><strong>模型智能：</strong>模型智能是一个计算机算法（软件），对于一类给定过程，可以对其自动建模、自动维护模型、并自动使用模型进行预测、控制、优化及诊断</p><h4 id="系统辨识的渐进法">1）系统辨识的渐进法：</h4><ul><li>多变量、闭环、自动系统辨识（建模）技术<ul><li>• 自动最优激励信号设计，多变量、闭环、自动测试</li><li>• 自动确定模型阶次</li><li>• 自动模型参数估计（计算）</li><li>• 自动模型检验，给出每个模型A, B, C, D评级</li></ul></li></ul><h4 id="pid闭环参数整定">2）PID闭环参数整定</h4><p>​PID控制器以其结构简单、稳定性好、调整方便而成为应用最广泛的一类工业控制器。</p><ul><li>问题核心：PID控制器参数整定困难</li><li>参数整定方法：</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220923164457568.png" style="zoom:67%;" /></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220923164619424.png" /></p><h4 id="模型预测控制">3）模型预测控制：</h4><p>​模型预测控制：是指利用对象的历史信息和模型信息，通过在未来时段上优化过程输出来计算最佳输入序列的一类算法。</p><p>​ <strong>关键环节：</strong>预测模型、滚动优化、反馈校正</p><p>​ 减少波动以后就可以卡边操作</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220923164911006.png" style="zoom:67%;" /></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220923165006259.png" /></p><h4 id="总结">3、总结：</h4><ul><li>动态模型是智能制造的关键，模型才是智能</li><li>团队经过多年研发，流程工业系统的智能建模、控制及优化技术已成熟，包括:(1) 基础控制层; (2) 先进控制层; (3) 实时优化层</li><li>可在各流程工业普及应用，节能减排、提高收益</li></ul><h2id="二系统辨识动态数据建模的理论和方法">二、系统辨识——动态数据建模的理论和方法：</h2><h3id="系统辨识介绍系统辨识的关键步骤">1、系统辨识介绍（系统辨识的关键步骤）</h3><ul><li><p>系统 System：系统是以有序形式排列的对象的集合，用于某种目的</p></li><li><p>过程 Process:过程是用于在流程工业中制造均质材料或能源产品的加工厂。加工工业包括：石油、化工、电力、造纸、玻璃、采矿、金属、水泥、药品、食品</p></li><li><p>模型 Model:模型是一个系统（过程）基本方面的表示，表示该系统的知识</p></li><li><p>数学模型 Mathematical Models:用微分方程和代数方程描述系统变量之间的关系。工程领域的主要部分涉及使用数学模型进行设计、模拟、预测和控制/优化。</p></li><li><p>系统辨识：系统或过程识别是使用测试数据对系统（过程）进行数学建模的领域。从技术上讲，Zadeh（1962）将系统识别定义为：在输入和输出的基础上，确定特定类别系统（模型）内的系统模型。</p></li><li><p><strong>系统辨识的过程</strong></p></li></ul><figure><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220923173506705.png"alt="image-20220923173506705" /><figcaption aria-hidden="true">image-20220923173506705</figcaption></figure><p><strong>系统辨识的关键步骤</strong>：</p><p>1）识别测试，辨识实验的设计 Identification tests/experiments：生成信息，输入输出数据</p><p>2）模型结构选择 Model order/structure selection：线性或非线性，什么结构（MIMO），什么顺序？</p><p>3）参数估计Parameter estimation ：使用一些优化技术确定模型参数。</p><p>4） 模型验证Model validation:：检查获得的模型是否足够好，是否能够使用（目的），如果不够，给出补救方法。</p><h3 id="动态系统和信号的模型">2、动态系统和信号的模型：</h3><h4id="单输入单输出连续时间模型siso-continuous-time-models">1）单输入单输出连续时间模型：SISOContinuous-Time Models</h4><p>​ 最常用的是<strong>微分方程</strong>和<strong>传递函数</strong>：</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927194052145.png" /></p><p>​ <imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927194102312.png" /></p><p>还可以用<strong>脉冲响应模型</strong>进行描述：<strong>引入延迟算子</strong></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927194118895.png" /></p><h4 id="单输入单输出离散时间模型">2）单输入单输出离散时间模型：</h4><p>一个使用保持电路的计算机控制系统采样过程</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927194329943.png" /></p><ul><li><p>Zero-Order Hold 即零阶保持器，只有一个设置<ahref="https://so.csdn.net/so/search?q=采样&amp;spm=1001.2101.3001.7020">采样</a>时间的参数，表示的是以采样时间间隔进行数据的采集；</p></li><li><p>Unit Delay即单位延迟模块，有两个输入参数，类似于<ahref="https://so.csdn.net/so/search?q=寄存器&amp;spm=1001.2101.3001.7020">寄存器</a>，第一个是设置初始值，第二个是采样时间。</p></li><li><p>Zero-Order Hold模块是以当前时间点以后的值为准，而UnitDelay是以当前时间之前的值为准。</p></li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927221208577.png" style="zoom:67%;" /></p><ul><li>在<strong>离散时间模型中</strong>引入延迟算子就能得到相应的离散传递函数：</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927221358771.png" style="zoom:50%;" /></p><ul><li><p>对一个n阶的差分方程使用0阶保持器：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927221507779.png" style="zoom:67%;" /></p></li></ul><h4 id="信号的几种模型描述方式">3）信号的几种模型描述方式</h4><h5 id="频域框架有限序列的信号的周期图">-频域框架：有限序列的信号的周期图：</h5><ul><li>通过傅里叶变化：可以得到信号的周期图</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927221626122.png" style="zoom:50%;" /></p><ul><li><p><strong>信号的周期图：periodogram</strong> ——反映了信号在各个频域点上能量贡献的大小</p></li><li><p>Parsevals恒等式： 左侧是时间域，右侧是频域</p></li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927221815400.png" /></p><p>​ 信号在时间域内拥有的总能量等于其在频域内各个频率的能量的总和</p><h5 id="概率框架信号功率谱-signal-spectra">- 概率框架：信号功率谱 signalspectra</h5><ul><li><p>随机过程：一组信号，在每个时刻都是一个随机变量。</p></li><li><p>平稳随机过程：这个随机过程，其均值属性不随时间变化</p></li><li><p>自相关函数和功率谱</p></li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927222142483.png" style="zoom:50%;" /></p><ul><li>给定两个平稳随机过程v(t)s(t)：互相关函数，和互功率谱（是互相关函数的傅里叶变换）：</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927222301599.png" style="zoom: 50%;" /></p><ul><li>如果给定一个随机过程的实现v(t),可以用时间算子代替数学期望可以估计自相关函数，从而估计功率谱</li></ul><p>但这样一个过程是有一个假设的，这个假设就是 Ergodicprocess（个态遍历）也就是：当N趋于正无穷，时间平均值趋于整体平均</p><h5 id="白噪声信号white-noise-process">- 白噪声信号White noiseprocess:</h5><p>​ 零均值和方差 R 的独立同分布随机变量序列。</p><p>​<strong>特点</strong>：白噪声没有记忆，t时间的信号值和t时间前的值完全无关，也就是可以导出下图中说的重要规则：</p><p><strong>每个平稳随机过程 {v(t)}都可以通过稳定的最小相位滤波器对白噪声滤波来生成</strong></p><p>​ <imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927222909082.png" /></p><h3 id="有扰动情况下的线性过程描述">3、有扰动情况下的线性过程描述：</h3><p>​假设v(t)是稳定随即过程，利用上述的结论，我们可以使用下述这个形式来表示有扰动情况下的线性过程的描述。之后关键就是在这个模型下进行利用实验数据估计G(q)和H(q)</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927223152305.png" style="zoom:50%;" /></p><h2 id="三系统辨识辨识实验设计">三、系统辨识——辨识实验设计</h2><h3 id="辨识实验identification-test的必要性">1、辨识实验IdentificationTest的必要性</h3><ul><li>辨识实验（控制）的目的是激发和收集（控制）相关信息。</li><li>测试期间使用测试信号/激励。</li><li>辨识实验是一种成本，但不要干扰正常生产。</li><li>良好的辨识实验是成功识别/控制的关键。</li><li>没有良好的辨识实验就是数据输入垃圾输出。</li></ul><p><strong>辨识实验是有代价的</strong>：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927223723009.png" style="zoom:50%;" /></p><h3 id="preliminary-tests-预测试">2、Preliminary Tests 预测试</h3><p>目的是为了获得先验知识</p><h4 id="收集历史数据collect-historic-data-p3">1）收集历史数据Collecthistoric data P3</h4><p><strong>一般来说，历史数据对于模型来说不够丰富，或者换句话说，信噪比太低（例如90％的噪声，10％的信号）</strong></p><ul><li>获得过程的第一印象。</li><li>过程的输出 (CV) 代表未测量的干扰。</li><li>MV 的动作代表操作员的控制。</li><li>简单又便宜。 数据库可用于大多数流程。</li><li>与操作者交谈并向他们学习。</li></ul><h4 id="阶跃实验short-step-test-p4">2）阶跃实验Short step test P4</h4><ul><li>将每个操作变量上下操作一些次数</li><li>检查主要时间常数、增益和延迟</li><li>检查并调整 MV PID 回路。</li><li>控制工程师可以通过观察过程阶跃响应直观地了解过程动态。</li><li>低成本测试。</li></ul><h4id="阶梯实验了解对象的非线性程度">3）阶梯实验：了解对象的非线性程度</h4><ul><li>将阶梯信号应用于某些 MV。</li><li>目的是检查非线性。</li><li>高成本测试，通常不允许</li></ul><h3 id="系统辨识中常见的实验信号">3、系统辨识中常见的实验信号</h3><p>实验信号有两个方面的因素需要考虑：信号波形和频谱的要求 wave form andfrequency content</p><ul><li>信号波形（时域）要求： -<ul><li>在正常操作中不会引起干扰（比较脉冲和阶跃）。</li><li>不激发过程非线性（比较脉冲和步骤）。</li><li>操作员友好（比较脉冲和阶跃）。</li></ul></li><li>信号频率成分（功率谱）设计：<ul><li>测试信号的功率谱会影响控制性能。</li><li>用于控制目的的最佳频谱设计。</li></ul></li></ul><h4 id="prbs-二进制伪随机信号">1）PRBS 二进制伪随机信号：</h4><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927224849434.png" /></p><ul><li><p>Clock是时钟脉冲</p></li><li><p>State是移位寄存器</p></li><li><p>移位寄存器产生的序列，最大的周期为 M 即 2^n-1 称为M序列</p></li><li><p>统计特性：（均值、自相关函数、频谱图）</p></li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927225042867.png" /></p><p>​该实验信号模型可以很好的模拟一个白噪声信号，但是这种信号切换频率太快，对工业的装置影响太大。同时其对于中低频信号不友好，比较偏重于高频。而系统辨识需要中低频信号</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927225345044.png" style="zoom:67%;" /></p><p>​ 所以需要调整我们的PRBS来产生低通特性的PRBS信号：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927225321648.png" style="zoom:67%;" /></p><h4 id="gbngeneralized-binary-noise-广义二值化信号">2）GBN(generalizedbinary noise) 广义二值化信号</h4><p>​ 信号翻转的概率，按照如下图：Generation rule进行信号的生成：</p><p>​ psw为切换概率</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927225457178.png" /></p><p>​<strong>通过降低切换概率，增加切换时间来获得低通的信号，来进行辨识信号实验。</strong></p><h4 id="pbrs和gbn对比">3）PBRS和GBN对比：</h4><ul><li>相比于PRBS来说，PRBS在一些特殊的2pi的点等于0，不接近实际，而GBN不会。同时，PRBS有最长周期，而GBN没有，可以随意选择</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927225706274.png" /></p><h4id="持续激励的测试信号persistent-excitation-of-a-test-signal">4）持续激励的测试信号：Persistentexcitation of a test signal</h4><ul><li>N阶的持续激励信号：需要满足以下条件：</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927225916291.png" style="zoom:50%;" /></p><ul><li>N阶持续激励的频域解释：n阶持续激励的频域解释是信号的频谱在区间（-pi,pi）内至少n个频率中不为零</li><li>PRBS和GBN信号的区别：</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927230015132.png" /></p><h3 id="模型辨识的测试最终测试">4、模型辨识的测试，最终测试</h3><h4 id="mpc控制的测试设计">1） MPC控制的测试设计</h4><ul><li>测试时间：<ul><li>小系统或低噪音：（6~10）*（稳定时间 settling time）</li><li>大型系统或高噪音：(12 ~ 20) *(稳定时间 settling time)</li></ul></li><li>信号类型：GBN -</li><li>信号步长：根据预先测试和与操作员的讨论确定。从小开始，可以在测试过程中进行调整-</li><li>信号平均切换时间（功率谱）：</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927230237868.png" style="zoom:50%;" /></p><ul><li><p>GBN信号可以同时做若干个实验，不同实验互不相关。</p></li><li><p>每个测试的MV个数，以及测试信号的相关性：</p><ul><li>每次测试的 MV 数量：开环测试最多 10 个 MV； 在闭环测试中所有MV。</li><li>测试信号之间的相关性：通常独立；对于条件不佳的过程（例如高纯度蒸馏塔），某些 MV之间的强相关性可能会有所帮助。</li></ul></li></ul><h4 id="闭环实验测试">2）闭环实验测试：</h4><ul><li>大多数工业应用使用开环测试。</li><li>20年前，业界不相信的过程是 可使用闭环数据识别。</li><li>可以在设定点或 MV 处应用测试信号</li><li><strong>闭环测试对过程操作的干扰较小</strong></li><li>闭环测试易于进行。</li><li>来自闭环测试数据的模型更适合控制。</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927230553891.png" /></p><h2id="四系统辨识最小二乘的系统辨识方法">四、系统辨识——最小二乘的系统辨识方法</h2><h3 id="最小二乘的原则p20页-由高斯提出">1、最小二乘的原则：P20页由高斯提出</h3><h3id="基于最小二乘估计线性过程的模型arx模型">2、基于最小二乘，估计线性过程的模型——ARX模型</h3><p>用n阶差分方程描述：</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927230958268.png" /></p><p>引入误差项：</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927231012557.png" /></p><p>首先进行等式重组：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927231103308.png" style="zoom: 50%;" /></p><p>在系统辨识实验测试后，我们可以得到数据集，并且使用数据来填充等式：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927231138550.png" style="zoom:50%;" /></p><p>最后，通过最小化如下的目标函数来估计模型参数：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927231216488.png" style="zoom:50%;" /></p><p>如下为解：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927231234423.png" style="zoom:50%;" /></p><h3 id="工业实例">3、工业实例：</h3><figure><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927231336491.png"alt="image-20220927231336491" /><figcaption aria-hidden="true">image-20220927231336491</figcaption></figure><h3 id="最小二乘估计的属性">4、最小二乘估计的属性：</h3><p><strong>估计器的理想（良好）属性：</strong></p><ul><li>无偏估计 Unbiased estimator</li><li>一致的估计器 Consistent estimator</li><li>有效或最小方差估计器 Efficient or minimum variance estimator:</li></ul><p><strong>原始的最小二乘估计器是无偏的</strong></p><p><strong>ARX模型是有偏的，因为A2不保持</strong></p><h2 id="五最小二乘模型的扩展">五、最小二乘模型的扩展：</h2><h3 id="输出误差方法-output-error-method">1、输出误差方法 Output-errormethod</h3><p>​ 其存在一个大的数值问题：输出误差在 A(q) 参数中是非线性的。不存在解析（封闭形式）解决方案，也无法保证全局最小值。</p><h4 id="关于一致性的证明">1）关于一致性的证明：</h4><ul><li>真实过程由 (5.1.4) 给出，其中 v(t) 是零均值的平稳随机过程。</li><li>模型阶数 n 正确。</li><li>输入持续兴奋，阶数高于 2n。</li><li><strong>测试是开环的。</strong></li><li>最小化收敛到所有 N 的全局最小值。</li><li>A(q) 和 B(q) 没有公因数。</li></ul><h3 id="预测误差方法-prediction-error-methods">2、预测误差方法Prediction error methods</h3><p>该方法实现：1）闭环测试的一致性（无偏性） 2)开环和闭环的效率（最小方差）。</p><p>ARMAX 模型：</p><ul><li>一些控制设计方法的良好模型结构。、</li><li>数值优化是必要的，不能保证全局最小值</li></ul><p>BOX-Jenkins模型：</p><h4 id="预测误差方法的属性">预测误差方法的属性：</h4><ul><li>假设：（1）过程稳定； (2)模型结构正确； (3) 测试信号持续激励； (4)最小化收敛到其全局最小值</li></ul><h3 id="阶次选择-order-selection">3、阶次选择 Order Selection</h3><ul><li>目的：找到模型阶次，以便模型对其使用最准确（在控制中）。<ul><li>粗阶选择方法：检查协方差矩阵的秩，绘制 Hankel 矩阵的奇异值。对于嘈杂的数据不准确。</li><li>准确的方法：首先估计具有递增阶数的模型，然后使用错误准则选择最佳阶数。</li></ul></li><li>主要议题：什么策略？什么数据集？<ul><li>在识别文献中，预测误差准则常用于模型阶数选择。 -</li><li>交叉验证的缺点是成本高。 使用估计数据进行模型阶数选择更经济。</li><li>使用估计数据的错误标准是使用验证数据的错误标准的有偏估计。</li></ul></li></ul><p><strong>输出误差小并不能保证仿真误差小</strong></p><ul><li><p>仍然需要证明 FOE 是对验证数据的 OE 标准的无偏估计。</p></li><li><p>我们可以将这种使用不同标准进行模型估计和订单选择的交叉标准方法称为方法。</p></li></ul><h3 id="模型验证-model-validation">4、模型验证 Model Validation</h3><p>检查获得的模型是否足以使用（控制），如果没有，提供补救措施（做什么</p><p>将模型属性与过程知识进行比较。 粗略估计过程增益，主要时间常数。</p><p>使用模型阶跃响应图。 检查不同方法的一致性。 估计 FIR、ARX、ARMAX 和Box-Jenkins 模型并比较它们的阶跃响应和频率响应</p><h4 id="残差分析">1) 残差分析：</h4><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220928090759861.png" style="zoom:50%;" /></p><ul><li>一个批评意见：控制的识别没有解决。 （这类模型是否适用于控制）<ul><li>前三种方法或多或少是定性测试。</li><li>残差分析是检查模型是否与测试数据充分吻合。</li><li>没有一种方法可以判断模型是否适合控制。</li><li>如果一个模型通过了残差分析，它只告诉给定数据获得了好的模型。但是数据是否足够好（用于控制）？</li></ul></li></ul>]]></content>
    
    
    <summary type="html">本篇笔记为电子信息工程中数学模型与方法——单元2 系统辨识的相关知识整理，用于学在浙大考试。</summary>
    
    
    
    <category term="⓾ 课程笔记" scheme="https://blog.fantast.top/categories/%E2%93%BE-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="电子信息工程数学模型与方法" scheme="https://blog.fantast.top/categories/%E2%93%BE-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    
    
    <category term="course" scheme="https://blog.fantast.top/tags/course/"/>
    
  </entry>
  
  <entry>
    <title>电子信息工程中数学模型与方法——单元3 电磁系统</title>
    <link href="https://blog.fantast.top/2022/09/30/2742f0d23b8a/"/>
    <id>https://blog.fantast.top/2022/09/30/2742f0d23b8a/</id>
    <published>2022-09-30T04:13:19.000Z</published>
    <updated>2022-10-02T07:29:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一概述和基本理论">一、概述和基本理论</h2><h3 id="麦克斯韦方程组">1、麦克斯韦方程组：</h3><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221002113642895.png" /></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221002113659170.png" /></p><h3 id="平面电磁波">2、平面电磁波：</h3><ul><li><p>波 : 扰动、能量、或物理信息在空间上传播的一种物理现象；</p></li><li><p>电磁波 : 传播电磁能量的波；</p></li><li><p>平面电磁波 :波前（等相位面）是平行面且与传播方向垂直的固定频率电磁波；</p></li><li><p>亥姆亥兹方程（Helmholtz’s equation）</p></li></ul><p><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150037334.png" /></p><ul><li>电场强度表达式：</li></ul><p><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150210202.png" /></p><p><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150222274.png" /></p><ul><li><p>磁场强度表达式：</p><figure><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150256704.png"alt="image-20221002150256704" /><figcaption aria-hidden="true">image-20221002150256704</figcaption></figure></li></ul><h3 id="特征阻抗">3、特征阻抗：</h3><p>电场强度和磁场强度的幅值比值定义为某种材料的特征阻抗</p><p><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150355839.png" /></p><h3 id="电磁辐射天线辐射">4、电磁辐射—天线辐射</h3><p>​ 分为近场和远场，近场又分为两个</p><p><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150510352.png" /></p><p>​ 在比较远的地方可以等价于一个平面波的形式</p><p><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150516797.png" /></p><h3 id="电磁辐射赫兹偶极子">5、电磁辐射—赫兹偶极子：</h3><h3 id="电磁辐射半波长偶极子">6、电磁辐射—半波长偶极子</h3><h3 id="电磁辐射天线应用-p24-26">7、电磁辐射—天线应用 P24-26</h3><figure><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150915273.png"alt="image-20221002150915273" /><figcaption aria-hidden="true">image-20221002150915273</figcaption></figure><ul><li>移动手机 P26-27</li><li>笔记本电脑 P28-29</li><li>无线可穿戴设备 P30-31</li><li>无线电识别天线 P32-33<ul><li>无线电识别：一种用来在一定距离无线识别的电子贴片技术。</li></ul></li><li>工作范围：P３４　　近场和远场</li><li>工作模式：被动（Passive Tag 主动（ Active Tag 半被动（ Semi passiveTag)<ul><li>被动：<ul><li>没有电源，使用从读卡器上的能量来充能并且传输数据到读卡器</li><li>更小，更廉价</li><li>往往只有很短的读取距离</li></ul></li><li>主动：<ul><li>有电源，tag先传输，然后是reader</li><li>更长的读取距离，100m或以上</li><li>昂贵，使用时间较有限</li></ul></li></ul></li></ul><h3 id="电磁感应无线传能">8、电磁感应—无线传能</h3><h3 id="电磁感应全息成像">9、电磁感应—全息成像</h3><h3 id="电磁辐射穿透性-p39">10、电磁辐射—穿透性 P39</h3><h2 id="二电磁散射系统建模和可视化">二、电磁散射系统建模和可视化</h2><h3 id="电磁散射基本理论-狄拉克格林函数">1、电磁散射基本理论狄拉克格林函数</h3><h3 id="瑞利散射">2、瑞利散射</h3><p>​ 半径比光或其他电磁辐射的波长小很多（ （&lt;0.1 𝜆）的 微小颗粒（例如单个原子或分子）对入射光束的散射。</p><p>​瑞利散射在光通过<strong>透明的固体和液体时都会发生，但以气体最为显著。</strong></p><figure><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002152515412.png"alt="image-20221002152515412" /><figcaption aria-hidden="true">image-20221002152515412</figcaption></figure><ul><li>总的辐射能量与波数的四次方成正相关，与波长的四次方成反相关。频率越高，瑞利散射越强</li><li>公式见P7</li></ul><h3 id="米氏散射">3、米氏散射：</h3><p>​ <strong>当 微粒半径的大小接近于或大于入射光线的波长 λ的时候</strong>，大部分的入射光线会沿着前进的方向进行散射，这种现象被称为米氏散射。​<strong>散射场几乎与波长无关；前向波比较大 ;物体大小越大，前向波越大</strong></p><p>​这种大微粒包括灰尘，水滴，来自污染物的颗粒物质，如烟雾等。即s是形成所谓的丁达尔效应</p><p><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002152726428.png" /></p><ul><li>为什么天空是蓝色、红色（傍晚）、白色（云）？</li></ul><p>​ 瑞利散射：波长的四次方成反相关，即频率越高，瑞利散射越强</p><p><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002152752906.png" /></p><h3 id="应用微波近场扫描显微成像">4、应用：微波近场扫描显微成像：</h3><p><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002152904823.png" /></p>]]></content>
    
    
    <summary type="html">本篇笔记为电子信息工程中数学模型与方法——单元3 电磁散射、逆问题系统建模及可视化的相关知识整理，用于学在浙大考试。</summary>
    
    
    
    <category term="⓾ 课程笔记" scheme="https://blog.fantast.top/categories/%E2%93%BE-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="电子信息工程数学模型与方法" scheme="https://blog.fantast.top/categories/%E2%93%BE-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    
    
    <category term="course" scheme="https://blog.fantast.top/tags/course/"/>
    
  </entry>
  
  <entry>
    <title>电子信息工程中数学模型与方法——单元1 工业智能</title>
    <link href="https://blog.fantast.top/2022/09/19/e947a7cc4335/"/>
    <id>https://blog.fantast.top/2022/09/19/e947a7cc4335/</id>
    <published>2022-09-19T02:40:19.000Z</published>
    <updated>2022-09-19T08:09:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2id="一以模型为核心的工业智能工信融合与工业智能">一、以模型为核心的工业智能——工信融合与工业智能</h2><h3 id="工业文明发展和工信融合-p9">1、工业文明发展和工信融合 P9</h3><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220919140907698.png" alt="image-20220919140907698" style="zoom:33%;" /></p><ul><li>我国工业面临的形式和发展目标 P13</li><li>什么是两者领域的深度融合？ P14</li></ul><h3 id="智能人类智能和工业智能">2、智能：人类智能和工业智能</h3><ul><li>人类心智的八个范畴 P19</li><li>什么是智能？什么是智慧？智能的进化属性？理解工程科学的智能 P20</li><li>工业智能的八个范畴 P24</li><li>人擅长做的：感知、决策和执行</li></ul><h3 id="控制视角和控制前沿">3、控制视角和控制前沿</h3><ul><li>工业系统信息物理深度融合面临的主要挑战 P28<ul><li>综合认知难、融合表达难、协同调控难、安全防护难</li></ul></li><li>实时、精准的综合信息感知 P29</li><li>工业大数据的综合表达与认知 P30</li><li>人-机-物协同的智能控制与优化 P31</li><li>三元空间的一体化安全防护 P32</li><li>智能工厂的内涵 P41</li><li>无人驾驶和无人工厂 共性和区别 P42</li><li>工厂智能化的技术分级：范围、能力、效益 L0-L5 P43</li></ul><h3 id="流程工业的智能化之路">4、流程工业的智能化之路</h3><ul><li>工业运行方式的变迁 P46 47<ul><li>流程工业是形成人类物质文明的基础工业</li><li>流程工业的行业特点、新需求等</li><li>人工控制——少量仪表——中控系统——现代化大型控制室</li></ul></li><li>设计型技术和运行型技术：P48<ul><li>设计型技术：产品和工艺设计-&gt;高附加值产品、新工艺</li><li>运行型技术：生产和制造-&gt;高效、高适应性生产。不增加太多投资的情况下取得显著的经济效益，投资小见效快是最集中体现流程企业操作运行“智能”的技术关键</li><li>流程工业生产运行的新需求：高效、柔性。</li></ul></li><li>什么是智能？工厂的指挥、智慧工厂的工作流 P52</li><li>无人化工厂的技术核心：P53<ul><li>人工智能：算力、数据、算法</li><li>工业智能：建模、控制、优化</li><li>大工业：工艺、流程、设备</li></ul></li><li>无人化工厂的新目标：P54</li></ul><h2id="二以模型为核心的工业智能过程系统建模与分析运行">二、以模型为核心的工业智能——过程系统建模与分析运行：</h2><h3 id="引言">1、引言</h3><ul><li>机理模型（白箱）：P59</li><li>数据模型（黑箱）：P59</li></ul><h3 id="过程系统简介">2、过程系统简介</h3><ul><li>过程系统的结构</li><li>流程工业的典型生产过程：（反应 + 分离 很重要）<ul><li>化工过程是由一个个加工过程组成的，可以分为两类：化学反应过程，物理加工过程。</li><li>化学反应过程对应的设备为反应器，物理加工过程对应的设备为单元操作。</li><li>所有单元操作都属于动量、热量、质量的传递速率控制过程</li><li>单元操作的种类：P68</li><li>过程系统工程：以数学模型、计算机辅助为基础的效能分析、设计放大、操作调整</li></ul></li><li>田纳西过程：P69<ul><li>操作变量：用于调节生产运行状态的手段。通常是阀门开度或者电机转速。</li><li>测量变量（生产装置的眼睛）：现场仪表或实验室分析手段所能测量的流量、温度、压力、液位、组分等变量。通过测量变量可以了解生产过程的工作状</li><li>运行约束：运行约束一般包括设备操作范围的约束，产品约束，安全约束等。</li><li>优化目标：常见的优化目标包括提高产品收率、降低生产能耗等。</li></ul></li></ul><h3 id="模型描述和求解">3、模型描述和求解</h3><ul><li><p>装置与流股： P77</p><ul><li>全流程的机理模型是由单个装置的机理模型+连接关系组合而成的</li><li>装置与装置之间的连接称为流股Stream（包括物质流股和能量流股）</li><li>物质流股S由流量、组分、温度、压力来描述。能量流股H由热量和温度来描述。</li></ul></li><li><p>连接关系与全流程模型 P78</p></li><li><p>仿真问题与反问题：</p><ul><li><p>仿真问题：可用于回溯分析，what-if分析（就是如果输入调整，输出会如何改变）</p></li><li><p>仿真问题反问题：</p><ul><li><p>要求输出流股(产品)的状态为Y，相应的输入流股(进料)条件是怎样的？(操作问题)</p></li><li><p>设备参数应该如何选择？(设计问题)</p></li><li><p>获得了输入流股、输出流股等数据，如何反推设备参数？(参数估计问题)</p></li></ul></li></ul></li><li><p>序贯求解</p><ul><li>当进料条件为X时，产品的状态是怎样的？</li><li>当流程中存在回路Recycle时，需要先断开某个流股（割裂流股），才能够序贯求解。回路的存在使得求解过程更加复杂</li><li><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220919154605965.png" /></li><li>优化问题：怎样的进料条件，使得A产品产量最高/生产能耗最低/有害物质产出最少？</li></ul></li><li><p>物质流 &amp; 能量流 &amp; 信息流：P83</p></li><li><p>单个装置的建模：装置的方程 P84</p></li><li><p>全流程机理模型的层次化特征：</p><ul><li>上述两类方程及流程单元的连接构成层次化特征，多层次的模型造成了机理模型的复杂性。</li><li><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220919155241488.png" /></li></ul></li><li><p>完整模型的序贯求解：P91</p><ul><li>上述多层次结构中的每个层次的模型通常都没有closedform的解。也就是说序贯求解的思路需要在每个层次上，需要迭代求解那个层次的方程组。因此，完整模型序贯求解的工作流呈现出一种“洋葱结构”。</li></ul></li><li><p>机理模型联立求解：</p><ul><li>对于复杂耦合流程的优化问题，采用序贯法求解时迭代过程嵌套层数多，内外层信息传递复杂、收敛难度大。采用联立方程法求解可以避免这一问题</li><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220919155604175.png" style="zoom:50%;" /></li></ul></li></ul><h3 id="不同类型的命题">4、不同类型的命题</h3><ul><li>仿真或WHAT-IF分析 P95</li><li>灵敏度分析：灵敏度分析一般是各种优化问题求解的前置步骤</li><li>设计优化、操作优化：包括设备操作范围的约束、产品约束、安全约束</li><li>参数估计：参数估计需要使用实际装置的测量数据𝑦0。实际的测量数据存在噪声、静差等，需要先进行校正和滤波，然后再用于参数估计</li><li>稳态与动态：稳态是指各生产变量基本保持不变的平稳的运行状态动态是指两个稳态之间的过渡过程</li><li>动态优化问题：动态优化的结果不再是一个数值，而是一个时间序列𝑢(𝑡)</li></ul><h3 id="数学建模的步骤">5、数学建模的步骤</h3><ul><li>模型建立：工艺分析和简化装置数学模型的建立 P103<ul><li>（建模假设、模型变量建立、机理方程的建立）</li></ul></li><li>命题求解：数学模型的变换和化简，模型的编程实现，数学规划命题的求解P103</li><li>结果分析：求解结果是否正确，是否符合预期目标 P103</li></ul><p>​ 代数建模语言(Algebraic modeling language,AML)：用于大规模数学计算(一般是数学规划)中的数学元素进行描述，并提供求解器接口的一类高级脚本语言。</p><p>​ 非线性方程组求解和优化：迭代法数值计算</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220919160136072.png" style="zoom:50%;" /></p><p>​初值（初始迭代点）对非线性规划问题的求解影响很大，考虑以下的优化命题：</p><h3 id="模型降阶和融合">6、模型降阶和融合：</h3><p>​ 高保真度模型，低保真度模型</p><ul><li><p>模型复杂度和性能的关系：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220919160736180.png" style="zoom:67%;" /></p></li><li><p>模型简化思路 P119</p></li><li><p>代理模型的建立 P121</p></li><li><p>机理数据融合模型 —— 灰箱模型 P122</p><ul><li>不同的融合思路 —— P123</li></ul></li></ul>]]></content>
    
    
    <summary type="html">本篇笔记为电子信息工程中数学模型与方法——单元1 工业智能的相关知识整理，用于学在浙大考试。</summary>
    
    
    
    <category term="⓾ 课程笔记" scheme="https://blog.fantast.top/categories/%E2%93%BE-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="电子信息工程数学模型与方法" scheme="https://blog.fantast.top/categories/%E2%93%BE-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    
    
    <category term="course" scheme="https://blog.fantast.top/tags/course/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 字符集底层原理，用户与权限管理</title>
    <link href="https://blog.fantast.top/2022/09/13/50a88c64ec31/"/>
    <id>https://blog.fantast.top/2022/09/13/50a88c64ec31/</id>
    <published>2022-09-13T07:09:19.000Z</published>
    <updated>2022-10-17T07:23:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一字符集与底层原理">一、字符集与底层原理</h3><p>mysql5.7默认server字符集为 latin，不支持中文</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%character%&#x27;;</span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220913152542290.png" /></p><ul><li>当创建数据库时不显示地指定字符集，则继承mysql服务器的默认字符集</li><li>当创建数据表时不显示地指定字符集，则继承所在数据库的默认字符集</li></ul><h4 id="已有库表的字符集修改">已有库表的字符集修改：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table emp1 convert to character set &#x27;utf8&#x27;</span><br></pre></td></tr></table></figure><h4 id="各级别的字符集">各级别的字符集：</h4><ul><li>服务器级别 character_set_server</li><li>数据库级别 character_set_database</li><li>表级别</li><li>列级别</li></ul><h4 id="字符集和比较规则">字符集和比较规则</h4><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220913221630290.png" /></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220913221612265.png" /></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220913221723119.png" /></p><h4id="请求到响应过程中字符集的变化">请求到响应过程中字符集的变化：</h4><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220914222210985.png" /></p><p><strong>这个过程中涉及到三个变量：</strong></p><p>character_set_client 和 character_set_connection 和character_set_results</p><p><strong>一般来说客户端：类unix操作系统使用utf8编码，windows使用gbk编码</strong></p><p><strong>开发中通常把上述三个系统变量设置成和客户端使用的字符集一致的情况，这样就减少了很多无谓的字符集转换</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET NAMES utf8mb4</span><br></pre></td></tr></table></figure><h3 id="二sql大小写规范">二、SQL大小写规范</h3><ul><li>MySQL在windows下是大小写不敏感的</li><li>MySQL在Linux下数据库名、表名、列名、别名大小写规则是这样的：<ul><li>1、数据库名、表名、表的别名、变量名是严格区分大小写的；</li><li>2、关键字、函数名称在SQL中不区分大小写；</li><li>3、列名（或字段名）与列的别名（或字段别名）在所有的情况下均是忽略大小写的；</li></ul></li></ul><h3 id="三sql编写建议">三、SQL编写建议：</h3><ul><li>关键字和函数名称<strong>全部大写</strong></li><li>数据库名、表名、表别名、字段名、字段别名等<strong>全部小写</strong></li><li>SQL语句必须以分号结尾</li></ul><h3 id="四sql_mode的合理设置">四、SQL_MODE的合理设置：</h3><p>​ 其会影响支持的SQL语法以及它执行的数据验证检查。</p><h4 id="宽松模式-严格模式">1、宽松模式 &amp; 严格模式</h4><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-06%2009.25.12.png" /></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-06%2009.25.57.png" /></p><p><strong>虽然MYSQL等数据库总想把关于数据库的所有操作都自己包揽下来，包括数据的校验等等，但是其实有些校验最好在开发层完成</strong></p><h3 id="五数据库在文件系统中的表示">五、数据库在文件系统中的表示：</h3><h4 id="innodb存储引擎模式">1、Innodb存储引擎模式</h4><h5 id="表结构">1） 表结构：</h5><p>​ 为了保存表结构， InnoDB在数据目录下对应的数据库子目录下创建了一个专门<strong>用于描述表结构的文件</strong>，文件名是这样，该文件以二进制格式存储</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表名.frm</span><br></pre></td></tr></table></figure><h5 id="表中数据和索引">2）表中数据和索引：</h5><ul><li>系统表空间：<ul><li>默认情况下，InnoDB会在数据目录下创建一个名为ibdata1 、大小为12M的文件，这个文件就是对应的系统表空间在文件系统上的表示。注意这个文件是自扩展文件，当不够用的时候它会自己增加文件大小。</li></ul></li><li>独立表空间：<ul><li>在mysql5.6以后，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是<strong>为每一个表建立一个独立表空间</strong>，也就是说我们创建了多少个表，就有多少个独立表空间。使用独立表空间来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同，只不过添加了一个.ibd的扩展名而已，所以完整的文件名称长这样：</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表名.ibd</span><br></pre></td></tr></table></figure><h4 id="myisam存储引擎模式">2、MyISAM存储引擎模式：</h4><h5 id="表结构与innodb一致">1）表结构：与Innodb一致</h5><h5 id="表中数据和索引-1">2）表中数据和索引：</h5><p>​在MyISAM中的索引全部都是二级索引，该<strong>存储引擎的数据和索引是分开存放的</strong>。假如test表使用MyISAM存储引擎的话，那么在它所在数据库对应的atguigu目录下会为test 表创建这三个文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test.frm 存储表结构</span><br><span class="line">test.MYD 存储数据 (MYData)</span><br><span class="line">test.MYI 存储索引 (MYIndex)</span><br></pre></td></tr></table></figure><h3 id="六用户和权限管理">六、用户和权限管理：</h3><h4 id="创建修改与删除用户">1、创建、修改与删除用户</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#x27;kangshifu&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE mysql.user SET USER=&#x27;li4&#x27; WHERE USER=&#x27;wang5&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP USER &#x27;kangshifu&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure><h4 id="密码相关策略内容">2、密码相关策略内容</h4><ul><li>使用root用户登录Mysql后，可以这样修改自己的密码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET PASSWORD=&#x27;new_password&#x27;;</span><br></pre></td></tr></table></figure><ul><li>修改其他用户密码：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET PASSWORD FOR &#x27;username&#x27;@&#x27;hostname&#x27;=&#x27;new_password&#x27;;</span><br></pre></td></tr></table></figure><ul><li>密码过期策略：</li></ul><p>​在MySQL中，数据库管理员可以手动设置账号密码过期，也可以建立一个自动密码过期策略。过期策略可以是全局的，也可以为每个账号设置单独的过期策</p><ul><li>密码重用策略：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET PERSIST password_history = 6; #设置不能选择最近使用过的6个密码</span><br><span class="line">SET PERSIST password_reuse_interval = 365; #设置不能选择最近一年内的密码</span><br></pre></td></tr></table></figure><h4 id="权限列表种类">3、权限列表种类：</h4><ul><li>Mysql的权限种类：<ul><li>CREATE和DROP 创建删除数据库和表</li><li>SELECT、INSERT、UPDATE和DELETE 在数据库现有表上操作</li><li>SELECT 检索权限</li><li>INDEX 允许创建或删除索引</li><li>ALTER 更改表结构和重命名</li><li>GRANT 允许授权给其他用户</li></ul></li><li>授予权限的原则：<ul><li>只授予满足需要的最小权限</li><li>创建用户时限制登陆主机IP</li></ul></li><li>授予权限方式有两种<ul><li>把角色赋予给用户授权</li><li>直接给用户授权</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT 权限1,权限2,…权限n ON 数据库名称.表名称 TO 用户名@用户地址 [IDENTIFIED BY ‘密码口令’];</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GRANTS FOR &#x27;user&#x27;@&#x27;主机地址&#x27;;</span><br></pre></td></tr></table></figure><ul><li>收回权限</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE 权限1,权限2,…权限n ON 数据库名称.表名称 FROM 用户名@用户地址;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#收回全库全表的所有权限</span><br><span class="line">REVOKE ALL PRIVILEGES ON *.* FROM joe@&#x27;%&#x27;;</span><br><span class="line">#收回mysql库下的所有表的插删改查权限</span><br><span class="line">REVOKE SELECT,INSERT,UPDATE,DELETE ON mysql.* FROM joe@localhost;</span><br></pre></td></tr></table></figure><h4 id="权限表">4、权限表</h4><h5 id="user表">1）User表</h5><p>​记录用户账号和权限信息，分为用户列、权限列、安全列、资源控制列（限制用户使用的资源，比如每小时允许执行的查询操作次数等）</p><h5 id="db表">2）db表</h5><p>​DB表中存储了用户对某个数据库的操作权限,决定用户能从哪个数据库中存取</p><h5id="tables_priv表和columns_priv表">3）tables_priv表和columns_priv表</h5><p>​tables_priv表用来对表设置操作权限，columns_priv表用来对表的某一列设置权限</p><h5 id="procs_priv表">4）procs_priv表：</h5><p>​ procs_priv表可以对存储过程和存储函数设置操作权限</p><h4 id="访问控制">5、访问控制：</h4><ul><li>连接核实阶段</li></ul><p>​服务器<strong>只有在user表记录的Host和User字段匹配客户端主机名和用户名，并且提供正确的密码时才接受连接</strong>。如果连接核实没有通过，服务器就完全拒绝访问；否则，服务器接受连接，然后进入请求核实阶段等待用户请求。</p><ul><li>请求核实阶段</li></ul><p>​对此连接上进来的每个请求，服务器检查该请求要执行什么操作、是否有足够的权限来执行它，这正是需要授权表中的权限列发挥作用的地方。这些权限可以来自user、db、table_priv和column_priv表。</p><p>​确认权限时，MySQL<strong>首先检查user表</strong>，如果指定的权限没有在user表中被授予，那么MySQL就会<strong>继续检查db表</strong>，db表是下一安全层级，其中的权限限定于数据库层级，在该层级的SELECT权限允许用户查看指定数据库的所有表中的数据；如果在该层级没有找到限定的权限，则MySQL<strong>继续检查tables_priv表以及columns_priv表</strong>，如果所有权限表都检查完毕，但还是没有找到允许的权限操作，MySQL将返回错误信息，用户请求的操作不能执行，操作失败。</p><h4 id="角色管理">6、角色管理</h4><ul><li><p>创建角色、给角色赋予权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE ROLE &#x27;role_name&#x27;[@&#x27;host_name&#x27;] [,&#x27;role_name&#x27;[@&#x27;host_name&#x27;]]...</span><br><span class="line"># 创建角色之后，默认这个角色是没有任何权限的，我们需要给角色授权。给角色授权的语法结构是</span><br><span class="line">GRANT privileges ON table_name TO &#x27;role_name&#x27;[@&#x27;host_name&#x27;];</span><br><span class="line"># 上述语句中privileges代表权限的名称，多个权限以逗号隔开</span><br><span class="line"># 查看角色权限：</span><br><span class="line">SHOW GRANTS FOR &#x27;manager&#x27;;</span><br><span class="line"># 只要你创建了一个角色，系统就会自动给你一个“ USAGE ”权限，意思是连接登录数据库的权限。</span><br></pre></td></tr></table></figure></li><li><p>回收角色权限、删除角色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 角色授权后，可以对角色的权限进行维护，对权限进行添加或撤销。添加权限使用GRANT语句，与角色授权相同。撤销角色或角色权限使用REVOKE语句。撤销角色</span><br><span class="line">REVOKE privileges ON tablename FROM &#x27;rolename&#x27;;</span><br><span class="line"># 删除角色</span><br><span class="line">DROP ROLE role [,role2]...</span><br></pre></td></tr></table></figure></li><li><p>给用户赋予角色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 角色创建并授权后，要赋给用户并处于激活状态才能发挥作用</span><br><span class="line">GRANT role [,role2,...] TO user [,user2,...];</span><br></pre></td></tr></table></figure></li><li><p>激活角色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET DEFAULT ROLE ALL TO user@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>撤销角色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE role FROM user</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">Chap7——Mysql 架构相关，包含字符集底层原理，用户与权限管理</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 视图，存储过程与函数</title>
    <link href="https://blog.fantast.top/2022/09/12/108274e25ef3/"/>
    <id>https://blog.fantast.top/2022/09/12/108274e25ef3/</id>
    <published>2022-09-12T10:09:19.000Z</published>
    <updated>2022-09-12T12:30:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一视图">一、视图</h3><p>​<strong>视图一方面可以帮我们使用表的一部分而不是所有的表，另一方面也可以针对不同的用户制定不同的查询视图。比如，针对一个公司的销售人员，我们只想给他看部分数据，而某些特殊的数据，比如采购的价格，则不会提供给他。再比如，人员薪酬是个敏感的字段，那么只给某个级别以上的人员开放，其他人的查询视图中则不提供这个字段。</strong></p><ul><li><p>视图是一种虚拟表，本身是不具有数据的，占用很少的内存空间</p></li><li><p>视图建立在已有表的基础上, 视图赖以建立的这些表称为基表</p></li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220912195718829.png" /></p><ul><li><p>视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化，反之亦然。</p></li><li><p>视图，是向用户提供基表数据的另一种表现形式。<strong>通常情况下，小型项目的数据库可以不使用视图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，它可以帮助我们把经常查询的结果集放到虚拟表中，提升使用效率。理解和使用起来都非常方便</strong></p></li></ul><h3 id="二创建视图">二、创建视图：</h3><ul><li>创建单表视图</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW empvu80</span><br><span class="line">AS</span><br><span class="line">SELECT employee_id, last_name, salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id = 80;</span><br></pre></td></tr></table></figure><ul><li>创建多表联合视图：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW empview</span><br><span class="line">AS</span><br><span class="line">SELECT employee_id emp_id,last_name NAME,department_name</span><br><span class="line">FROM employees e,departments d</span><br><span class="line">WHERE e.department_id = d.department_id;</span><br></pre></td></tr></table></figure><ul><li>可以利用视图来对数据进行格式化：</li></ul><p>​比如我们想输出员工姓名和对应的部门名，对应格式为emp_name(department_name)，就可以使用视图来完成数据格式化的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW emp_depart</span><br><span class="line">AS</span><br><span class="line">SELECT CONCAT(last_name,&#x27;(&#x27;,department_name,&#x27;)&#x27;) AS emp_dept</span><br><span class="line">FROM employees e JOIN departments d</span><br><span class="line">WHERE e.department_id = d.department_id</span><br></pre></td></tr></table></figure><h3 id="三更新视图的数据">三、更新视图的数据</h3><p>​支持使用INSERT、UPDATE和DELETE语句对视图中的数据进行插入、更新和删除操作</p><h4 id="关于一些不可更新的视图">关于一些不可更新的视图</h4><p>​要使视图可更新，视图中的行和底层基本表中的行之间必须存在一对一的关系。另外当视图定义出现如下情况时，视图不支持更新操作：</p><ul><li>在定义视图的时候指定了“ALGORITHM =TEMPTABLE”，视图将不支持INSERT和DELETE操作；</li><li>视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT操作；</li><li>在定义视图的SELECT语句中使用了JOIN联合查询，视图将不支持INSERT和DELETE操作；</li><li>在定义视图的SELECT语句后的字段列表中使用了数学表达式或子查询，视图将不支持INSERT，也</li><li>不支持UPDATE使用了数学表达式、子查询的字段值；</li><li>在定义视图的SELECT语句后的字段列表中使用DISTINCT 、聚合函数、GROUPBY 、HAVING 、 UNION 等，视图将不支持INSERT、UPDATE、DELETE；</li><li>在定义视图的SELECT语句中包含了子查询，而子查询中引用了FROM后面的表，视图将不支持INSERT、UPDATE、DELETE；</li><li>视图定义基于一个不可更新视图</li><li>常量视图</li></ul><h3 id="四视图的优缺点与总结">四、视图的优缺点与总结：</h3><ul><li>优点</li></ul><p>1、操作简单，<strong>将经常使用的查询操作定义为视图，开发人员不需要关心视图对应的数据表的结构、表与表之间的关联关系等</strong></p><p>2、减少数据冗余，其存储的是查询语句，本身不存储数据</p><p>3、数据安全，将用户对数据的访问限制在某些数据的结果集上，具有一定的隔离性。</p><p>4、适应多变的需求，分解复杂的查询逻辑。可以先将复杂的逻辑查询分解，创建多个视图，再将这多个视图结合起来，完成复杂的查询逻辑。</p><ul><li>缺点：</li></ul><p>1、如果实际数据表的结构变更了，我们就需要及时对相关的视图进行相应的维护。特别是嵌套的视图（就是在视图的基础上创建视图），维护会变得比较复杂，可读性不好，容易变成系统的潜在隐患。因为创建视图的 SQL查询可能会对字段重命名，也可能包含复杂的逻辑，这些都会增加维护的成本。</p><h3 id="五存储过程与函数">五、存储过程与函数：</h3><ul><li>存储过程就是一组经过预先编译的 SQL 语句的封装。</li><li>执行过程：存储过程预先存储在 MySQL服务器上，需要执行的时候，客户端只需要向服务器端发出调用存储过程的命令，服务器端就可以把预先存储好的这一系列 SQL语句全部执行。</li></ul>]]></content>
    
    
    <summary type="html">Chap5——Mysql 视图，存储过程与函数</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 变量与游标.触发器</title>
    <link href="https://blog.fantast.top/2022/09/12/2c85f3f81b49/"/>
    <id>https://blog.fantast.top/2022/09/12/2c85f3f81b49/</id>
    <published>2022-09-12T10:09:19.000Z</published>
    <updated>2022-09-12T14:23:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一系统变量">一、系统变量：</h3><p>​系统变量由系统定义，不是用户定义，属于服务器层面。启动MySQL服务，生成MySQL服务实例期间，MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特征。这些系统变量的值要么是编译MySQL时参数的默认值，要么是配置文件（例如my.ini等）中的参数值。</p><h4id="全局系统变量-global关键字-会话系统变量-session关键字">1、全局系统变量global关键字 &amp; 会话系统变量 session关键字</h4><p>​每一个MySQL客户机成功连接MySQL服务器后，都会产生与之对应的会话Session。会话期间，MySQL服务实例会在MySQL服务器内存中生成与该会话对应的<strong>会话系统变量</strong>，这些会话系统变量的初始值是全局系统变量值的复制。</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220912221138151.png" /></p><ul><li><p>全局系统变量针对于所有会话（连接）有效，<strong>但不能跨重启</strong></p></li><li><p>会话1对某个全局系统变量值的修改会导致会话2中同一个全局系统变量值的修改</p></li></ul><p>​ <strong>在MySQL中有些系统变量只能是全局的，例如 max_connections用于限制服务器的最大连接数；有些系统变量作用域既可以是全局又可以是会话，例如 character_set_client用于设置客户端的字符集；有些系 统变量的作用域只能是当前会话，例如pseudo_thread_id 用于标记当前会话的 MySQL 连接 ID</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查看所有全局变量</span><br><span class="line">SHOW GLOBAL VARIABLES;</span><br><span class="line">#查看所有会话变量</span><br><span class="line">SHOW SESSION VARIABLES;</span><br><span class="line">或</span><br><span class="line">SHOW VARIABLES;</span><br></pre></td></tr></table></figure><p>​ MySQL 中的系统变量以两个“@” 开头，其中“@<span class="citation"data-cites="global">@global</span>”仅用于标记全局系统变量，“@<spanclass="citation"data-cites="session">@session</span>”仅用于标记会话系统变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#查看指定的系统变量的值</span><br><span class="line">SELECT @@global.变量名;</span><br><span class="line">#查看指定的会话变量的值</span><br><span class="line">SELECT @@session.变量名;</span><br><span class="line">#或者</span><br><span class="line">SELECT @@变量名;</span><br><span class="line"></span><br><span class="line">#为某个全局变量赋值</span><br><span class="line">#方式1</span><br><span class="line">SET @@global.变量名=变量值;</span><br><span class="line">#方式2：</span><br><span class="line">SET GLOBAL 变量名=变量值;</span><br><span class="line">#为某个会话变量赋值</span><br><span class="line">#方式1：</span><br><span class="line">SET @@session.变量名=变量值;</span><br><span class="line">#方式2：</span><br><span class="line">SET SESSION 变量名=变量值;</span><br></pre></td></tr></table></figure><h4 id="会话用户变量与局部变量">2、会话用户变量与局部变量：</h4><ul><li>会话用户变量：作用域和会话变量一样，只对当前连接会话有效。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#方式1：“=”或“:=”</span><br><span class="line">SET @用户变量 = 值;</span><br><span class="line">SET @用户变量 := 值;</span><br><span class="line">#方式2：“:=” 或 INTO关键字</span><br><span class="line">SELECT @用户变量 := 表达式 [FROM 等子句];</span><br><span class="line">SELECT 表达式 INTO @用户变量 [FROM 等子句];</span><br></pre></td></tr></table></figure><ul><li>局部变量：只在 BEGIN 和 END语句块中有效。局部变量只能在存储过程和函数中使用。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">#声明局部变量</span><br><span class="line">DECLARE 变量名1 变量数据类型 [DEFAULT 变量默认值];</span><br><span class="line">DECLARE 变量名2,变量名3,... 变量数据类型 [DEFAULT 变量默认值];</span><br><span class="line">#为局部变量赋值</span><br><span class="line">SET 变量名1 = 值;</span><br><span class="line">SELECT 值 INTO 变量名2 [FROM 子句];</span><br><span class="line">#查看局部变量的值</span><br><span class="line">SELECT 变量1,变量2,变量3;</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h3 id="二游标">二、游标</h3><p>​游标，提供了一种灵活的操作方式，让我们能够对结果集中的每一条记录进行定位，并对指向的记录中的数据进行操作的数据结构。游标让SQL 这种面向集合的语言有了面向过程开发的能力。</p><p>​游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标充当了指针的作用，我们可以通过操作游标来对数据行进行操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE get_count_by_limit_total_salary(IN limit_total_salary DOUBLE,OUT</span><br><span class="line">total_count INT)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE sum_salary DOUBLE DEFAULT 0; #记录累加的总工资</span><br><span class="line">DECLARE cursor_salary DOUBLE DEFAULT 0; #记录某一个工资值</span><br><span class="line">DECLARE emp_count INT DEFAULT 0; #记录循环个数</span><br><span class="line">#定义游标</span><br><span class="line">DECLARE emp_cursor CURSOR FOR SELECT salary FROM employees ORDER BY salary DESC;</span><br><span class="line">#打开游标</span><br><span class="line">OPEN emp_cursor;</span><br><span class="line">REPEAT</span><br><span class="line">#使用游标（从游标中获取数据）</span><br><span class="line">FETCH emp_cursor INTO cursor_salary;</span><br><span class="line">SET sum_salary = sum_salary + cursor_salary;</span><br><span class="line">SET emp_count = emp_count + 1;</span><br><span class="line">UNTIL sum_salary &gt;= limit_total_salary</span><br><span class="line">END REPEAT;</span><br><span class="line">SET total_count = emp_count;</span><br><span class="line">#关闭游标</span><br><span class="line">CLOSE emp_cursor;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h3 id="三触发器">三、触发器</h3><p><strong>应用场景：</strong></p><p>​ 在实际开发中，我们经常会遇到这样的情况：有 2个或者多个相互关联的表，如商品信息和库存信息分别存放在 2个不同的数据表中，我们在添加一条新商品记录的时候，为了保证数据的完整性，必须同时在库存表中添加一条库存记录。​这样一来，我们就必须把这两个关联的操作步骤写到程序里面，而且要用事务包裹起来，确保这两个操作成为一个原子操作，要么全部执行，要么全部不执行。要是遇到特殊情况，可能还需要对数据进行手动维护，这样就很容易忘记其中的一步，导致数据缺失。​这个时候，咱们可以使用触发器。你可以创建一个触发器，让商品信息数据的插入操作自动触发库存数据的插入操作。这样一来，就不用担心因为忘记添加库存数据而导致的数据缺失了。</p><p>​</p><p><strong>概述</strong>：</p><p>​ 触发器是由事件来触发某个操作，这些事件包括INSERT 、UPDATE 、DELETE事件。所谓事件就是指用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生了，就会自动激发触发器执行相应的操作。</p><ul><li>优点：<ul><li>触发器可以确保数据的完整性。</li><li>触发器可以帮助我们记录操作日志。</li><li>可以具体记录什么时间发生了什么。比如，记录修改会员储值金额的触发器，就是一个很好的例子。这对我们还原操作执行时的具体场景，</li><li>触发器还可以用在操作数据前，对数据进行合法性检查。</li></ul></li><li>缺点：<ul><li>着触发器有可能不受应用层的控制。这对系统维护是非常有挑战的。</li><li>相关数据的变更，可能会导致触发器出错。特别是数据表结构的变更，都可能会导致触发器出错，进而影响数据操作的正常运行。这些都会由于触发器本身的隐蔽性，影响到应用中错误原因排查的效率。</li></ul></li></ul><p><strong>注意</strong>：</p><p>​ 如果在子表中定义了外键约束，并且外键指定了ON UPDATE/DELETECASCADE/SETNULL子句，此时修改父表被引用的键值或删除父表被引用的记录行时，也会引起子表的修改和删除操作，此时基于子表的UPDATE和DELETE语句定义的触发器并不会被激活。</p>]]></content>
    
    
    <summary type="html">Chap6——Mysql 变量流程控制与游标.触发器</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 约束</title>
    <link href="https://blog.fantast.top/2022/09/10/ee0ee8e192df/"/>
    <id>https://blog.fantast.top/2022/09/10/ee0ee8e192df/</id>
    <published>2022-09-10T10:09:19.000Z</published>
    <updated>2022-09-12T11:13:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一约束">一、约束</h3><p>​ 约束是表级的强制规定,可以通过如下命令查看表的约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM information_schema.table_constraints</span><br><span class="line">WHERE table name=&#x27;’&#x27;表名称&#x27;；</span><br></pre></td></tr></table></figure><h3 id="二非空约束">二、非空约束</h3><p>​ 单列约束，不能组合非空值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test(</span><br><span class="line">id INT NOT NULL,</span><br><span class="line">    email CHAR</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ALTER TABLE test</span><br><span class="line">MODIFY email CHAR NOT NULL;</span><br><span class="line"></span><br><span class="line">ALTER TABLE test</span><br><span class="line">MODIFY id INT NULL;</span><br></pre></td></tr></table></figure><h3 id="三唯一性约束">三、唯一性约束</h3><p>​ 单列约束，允许出现多个NULL值，可以多个列的组合唯一</p><ul><li>唯一性约束允许列值为空。</li><li>在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。</li><li><strong>MySQL会给唯一约束的列上默认创建一个唯一索引。</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE USER(</span><br><span class="line">    id INT NOT NULL,</span><br><span class="line">    CNAME VARCHAR(25) UNIQUE,  # 列级约束语法</span><br><span class="line">    NAME VARCHAR(25),</span><br><span class="line">    PASSWORD VARCHAR(16),</span><br><span class="line">    # 使用表级约束语法</span><br><span class="line">    CONSTRAINT uk_name_pwd UNIQUE(NAME,PASSWORD) # 用户名和密码组合不能重复</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>复合唯一约束</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table student_course(</span><br><span class="line">    id int,</span><br><span class="line">    sid int,</span><br><span class="line">    cid int,</span><br><span class="line">    score int,</span><br><span class="line">    unique key(sid,cid) #复合唯一</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="四主键约束">四、主键约束</h3><ul><li>主键约束相当于唯一约束+非空约束的组合，主键约束列不允许重复，也不允许出现空值。</li><li>主键约束对应着表中的一列或者多列（复合主键）</li><li>MySQL的主键名总是PRIMARY，就算自己命名了主键约束名也没用。</li><li>当创建主键约束时，系统默认会在所在的列或列组合上建立对应的主键索引</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE emp4(</span><br><span class="line">    id INT PRIMARY KEY AUTO_INCREMENT ,</span><br><span class="line">    NAME VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table student_course(</span><br><span class="line">    sid int,</span><br><span class="line">    cid int,</span><br><span class="line">    score int,</span><br><span class="line">    primary key(sid,cid) #复合主键</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">alter table 表名称 drop primary key;</span><br></pre></td></tr></table></figure><h3 id="五auto_increment">五、AUTO_INCREMENT</h3><ul><li>一个表最多只能有一个自增长列</li><li>当需要产生唯一标识符或顺序值时，可设置自增长</li><li>自增长列约束的列必须是键列（主键列，唯一键列）</li><li>自增约束的列的数据类型必须是整数类型</li><li>如果自增列指定了 0 和null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table 表名称(</span><br><span class="line">    字段名 数据类型 primary key auto_increment,</span><br><span class="line">    字段名 数据类型 unique key not null,</span><br><span class="line">    字段名 数据类型 unique key,</span><br><span class="line">    字段名 数据类型 not null default 默认值,</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意：自增主键的持久化：</strong></p><p>​ 在MySQL 5.7系统中，对于自增主键的分配规则，是由InnoDB数据字典内部一个 计数器 来决定的，而该计数器只在 内存中维护，并不会持久化到磁盘中。当数据库重启时，该 计数器会被初始化。</p><p>​ MySQL 8.0将自增主键的计数器持久化到 重做日志中。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值</p><h3 id="六外键约束">六、外键约束</h3><p><strong>从表的外键列，必须引用/参考主表的主键或唯一约束的列</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">create table dept( #主表</span><br><span class="line">    did int primary key, #部门编号</span><br><span class="line">    dname varchar(50) #部门名称</span><br><span class="line">);</span><br><span class="line">create table emp(#从表</span><br><span class="line">    eid int primary key, #员工编号</span><br><span class="line">    ename varchar(5), #员工姓名</span><br><span class="line">    deptid int, #员工所在的部门</span><br><span class="line">    foreign key (deptid) references dept(did) #在从表中指定外键约束</span><br><span class="line">    #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>约束等级</strong>：</p><ul><li>Cascade方式：在父表上update/delete记录时，同步update/delete掉子表的匹配记录</li><li>Set null方式：在父表上update/delete记录时，将子表上匹配记录的列设为null，但是要注意子表的外键列不能为not null</li><li>No action方式：如果子表中有匹配的记录，则不允许对父表对应候选键进行update/delete操作</li><li>Restrict方式 ：同no action， 都是立即检查外键约束</li><li>Set default方式（在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置成一个默认的值，但Innodb不能识别</li></ul><p><strong>对于外键约束，最好是采用: ON UPDATE CASCADE ON DELETERESTRICT 的方式。</strong></p><p><strong>在 MySQL里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL操作，有可能会不适 合。比如大型网站的中央数据库，可能会因为外键约束的系统开销而变得非常慢 。所以， MySQL 允许你不使用系统自带的外键约束，在 应用层面完成检查数据一致性的逻辑。也就是说，即使你不用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。</strong></p><p><strong>一些提示：【 强制】不得使用外键与级联，一切外键概念必须在应用层解决。说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的student_id 则为外键。如果更新学 生表中的 student_id，同时触发成绩表中的student_id 更新，即为级联更新。外键与级联更新适用于 单 机低并发 ，不适合分布式 、 高并发集群 ；级联更新是强阻塞，存在数据库 更新风暴的风险；外键影响 数据库的 插入速度 。</strong></p><h3 id="七检查约束与默认值约束">七、检查约束与默认值约束</h3><h4 id="check约束">1 CHECK约束</h4><p>​ 检查某个字段的值是否符合xx要求，一般指的是值的范围</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE temp(</span><br><span class="line">    id INT AUTO_INCREMENT,</span><br><span class="line">    NAME VARCHAR(20),</span><br><span class="line">    age INT CHECK(age &gt; 20),</span><br><span class="line">    PRIMARY KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="default-约束">2 DEFAULT 约束</h4><p>给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table 表名称(</span><br><span class="line">    字段名 数据类型 primary key,</span><br><span class="line">    字段名 数据类型 unique key not null,</span><br><span class="line">    字段名 数据类型 unique key,</span><br><span class="line">    字段名 数据类型 not null default 默认值,</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>一些问题</strong>：</p><ul><li>为什么不想要 null 的值<ul><li>1）不好比较。null是一种特殊值，比较时只能用专门的is null 和 is notnull来比较。碰到运算符，通 常返回null。</li><li>2）效率不高。影响提高索引效果。因此，我们往往在建表时 not nulldefault '' 或 default 0</li></ul></li></ul>]]></content>
    
    
    <summary type="html">Chap4——Mysql 约束</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>2022-2023秋冬大计基答疑整理——沈睿班</title>
    <link href="https://blog.fantast.top/2022/09/09/66d597ae86a9/"/>
    <id>https://blog.fantast.top/2022/09/09/66d597ae86a9/</id>
    <published>2022-09-09T02:00:00.000Z</published>
    <updated>2022-11-03T07:05:24.438Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用指南">1、使用指南：</h2><h3id="如何在本文档内搜索相关问题">1）如何在本文档内搜索相关问题？：</h3><ul><li><strong>方法1</strong>：使用博客上方内置的<strong>搜索功能</strong>，点击搜索后，输入相关关键词即可。<strong>需要注意的是，由于本文档是基于整个博客进行更新的，所以该搜索功能是在整个博客内进行搜索，请从中找到本篇文章，即《2022-2023秋冬大计基答疑整理—沈睿班》的搜索结果进入即可</strong>，如果没有本篇文章的搜索结果即代表没有相关内容。如果对其他博文感兴趣也可以随意浏览。</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220908105925826.png" style="zoom:67%;" /></p><ul><li><strong>方法2</strong>：以firefox浏览器为例，在浏览器中打开本网页后，按<strong>CTRL+F</strong>键,会看到浏览器底部会出现如下搜索栏,在左侧"在此页面中查找"处输入你想要搜索的内容即可进行相关内容的搜索。其他不同浏览器的搜索框使用方法可以访问如下链接：https://www.163.com/dy/article/H6K7CURU0552EUN3.html</li></ul><h3id="如果对本文档内容有所疑问如何提出">2）如果对本文档内容有所疑问如何提出？：</h3><p>​如果你发现本文档内有问答有错误或不严谨的地方，你可以通过以下方法提出</p><ul><li><p><strong>方法1</strong>：你可以直接截图发至钉钉群内，<spanclass="citation"data-cites="助教提出你的疑问">@助教提出你的疑问</span>。</p></li><li><p><strong>方法2</strong>：使用博客页面下方内置的评论功能，此功能需要你先注册<ahref="https://github.com">github</a>账号，随后以github账号登录进行评论。评论后助教会进行更正或以同样形式回答。</p></li></ul><h3 id="其他便捷功能">3）其他便捷功能：</h3><ul><li>1、你可以使用左侧的导航栏帮助你快速定位你所在的问题目录</li><li>2、你可以通过点击左侧导航栏下方的"叉叉"图标，来关闭左侧导航栏。</li><li>3、你可以通过点击左侧导航栏下方的"箭头"图标，来快速返回至该文档的最上方。箭头图标旁的百分比代表你目前正在浏览的部分是整份文档的何处位置。</li></ul><h2 id="正文">2、正文：</h2><h3id="问1vmware官网哪里点进去有软件下载">问1：vmware官网哪里点进去有软件下载？</h3><ul><li>https://customerconnect.vmware.com/downloads/#all_products</li></ul><hr /><h3id="问2window10的iso镜像文件哪里可以下载">问2：window10的iso镜像文件哪里可以下载？</h3><ul><li><p>需要校园网内网访问，是学校的官方软件平台</p></li><li><p>http://download.ms.zju.edu.cn/SW_DVD9_Win_Pro_10_21H1_64BIT_ChnSimp_Pro_Ent_EDU_N_MLF_X22-55090.ISO</p></li></ul><hr /><h3id="问3安装vmware时出现如下错误">问3：安装VMWare时出现如下错误：</h3><p>写入文件时 DIFXAPI.dll时出错，请确认您有访问该目录的权限</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220918171424902.png" /></p><ul><li>一般这种情况是因为你电脑上开着一些杀毒软件导致的，比如说360安全卫士，电脑管家这种，可以先关闭杀毒软件后尝试安装。</li></ul><hr /><h3id="问4绑定pta账号时绑定码是多少">问4：绑定PTA账号时，绑定码是多少？</h3><ul><li>不同时间的班不一样，见下：<ul><li>周四1、2节：248374</li><li>周四3、4节：717242</li><li>周四7、8节：834958</li></ul></li></ul><hr /><h3id="问5判断题计算机存储模式规定存储单元以位bit为单位8个二进制位构成1个字节byte">问5：判断题：计算机存储模式规定，存储单元以位（bit）为单位，8个二进制位构成1个字节（Byte）。</h3><ul><li>答案：错误。存储单元以字节为单位，即Byte</li></ul><hr /><h3id="问6判断题高速缓存器cache介于cpu与主存之间用于解决内存与外存的速度匹配问题以提高存储速度">问6：判断题：高速缓存器Cache介于CPU与主存之间，用于解决内存与外存的速度匹配问题，以提高存储速度。</h3><ul><li>答案：错误。不是为了解决内存与外存的速度匹配问题，而是为了解决内存和CPU的速度匹配问题。因为现代CPU频率比较高，内存的发展跟不上CPU访问主存的速度，这样的话把CPU最有可能访问的数据放在cache中，CPU可以在很短的时间内得到数据</li></ul><hr /><h3id="问7如果某一计算机的内存单元总共可存储256个字节的容量则这些内存单元的地址编号可以从1000hh表示16进制到h">问7：如果某一计算机的内存单元总共可存储256个字节的容量，则这些内存单元的地址编号可以从1000H（H表示16进制）到（）H。</h3><ul><li>答案：10FFH。这一类题目涉及到十六进制运算，搞清楚这块的计算就可以应付许多题目。首先你需要学会16进制和10进制的转换。即十进制的256，在16进制中是多少？答案是100H.所以，内存的地址编号应该就是从1000H+ 100H - 1 = 10FFH.</li><li>题外话：在一些其他题目中，注意区分字节和位，字节是Byte，位是bit，简写一个是B，一个是b。1Byte= 8bit</li></ul><hr /><h3id="问8某系统的进程状态如下图所示其中3表示等待某个事件1表示进程被选中问a是_状态2表示____________c表示___________">问8：某系统的进程状态如下图所示，其中3表示等待某个事件，1表示进程被选中，问：a是_<strong><em>状态，2表示</em></strong>____________，c表示___________。</h3><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221019185521467.png" /></p><ul><li>答案：运行，时间片到，等待I/O</li><li>分析：这个是考察进程的状态转移的一道题目，大家可以通过熟悉下图来完成相关的题目。下图是详细版的一个进程状态转移的说明。值得注意的是：</li><li>运行态→阻塞态是一种进程自身做出的<strong>主动行为</strong></li><li>阻塞态→就绪态是不是进程自身能控制的，是一种<strong>被动行为</strong>。</li><li>注意：<strong>不能由阻塞态直接转换为运行态</strong>，<strong>也不能由就绪态直接转换为阻塞态</strong>（因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221019185634225.png" /></p><hr /><h3id="问9在windows中用户使用______管理硬件资源设置">问9：在Windows中，用户使用（______）管理硬件资源设置。</h3><ul><li>答案：控制面板.</li></ul><hr /><h3id="问10以下关于浮点数的描述_____________是正确的">问10：以下关于浮点数的描述，_____________是正确的</h3><p>A. 符号位用来决定阶码是正的还是负的</p><p>B.小数点是以二进制1的形式保存在尾数中的</p><p>C.对于一个32位的浮点数来说,阶码的位数与尾数的位数并不是固定的</p><p>D.若阶码的值=n,则尾数乘以2的n次方就是该浮点数的大小</p><ul><li>答案：D.</li><li>解析：A 符号位决定的是浮点数本身是正还是负，而不是决定阶码的政府。B.明显错误 C.单精度（32位）浮点数。占用4个字节（32位）存储空间，包括符号位1位，阶码8位，尾数23位，都是固定的位数。D.正确的</li></ul><hr /><h3id="问11实现汉字字形表示的方法一般可分为______两大类">问11：实现汉字字形表示的方法，一般可分为______两大类。</h3><ul><li>答案：点阵与曲线（轮廓），曲线（轮廓）实际上就是矢量的表现形式，所以实现汉字字形表示的方法可以分为点阵与矢量或者说 点阵与曲线轮廓 都可以<imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221103145458857.png" /></li></ul><hr /><h3 id="问12">问12：</h3>]]></content>
    
    
    <summary type="html">本文档用于2022-2023秋冬大计基沈睿老师班的答疑整理，该文档会由助教定期根据群里有价值的提问进行汇总整理，随后更新至该文档中。为提高问答效率，请大家在群内提问前访问本网页，可以先在本文档中搜索是否有类似相关问题，如果没有再前往群内进行提问。</summary>
    
    
    
    <category term="⓽ 其他内容" scheme="https://blog.fantast.top/categories/%E2%93%BD-%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql DDL与DCL操作、增删改与数据类型</title>
    <link href="https://blog.fantast.top/2022/09/07/60ff079d7c8c/"/>
    <id>https://blog.fantast.top/2022/09/07/60ff079d7c8c/</id>
    <published>2022-09-07T10:09:19.000Z</published>
    <updated>2022-09-10T14:15:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一一些ddl与dcl操作">一、一些DDL与DCL操作：</h3><h4 id="数据库相关操作">1、数据库相关操作：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE mytest1 CHARACTER SET &#x27;utf8&#x27;;</span><br><span class="line">ALTER DATABASE mytest1 CHARACTER SET &#x27;utf8mb4&#x27;;</span><br><span class="line">DROP DATABASE IF EXISTS mytest1;  //删除数据库</span><br></pre></td></tr></table></figure><h4 id="数据表相关操作">2、数据表相关操作：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS myempl(</span><br><span class="line">id INT,</span><br><span class="line">emp_name VARCHAR(15),</span><br><span class="line">hire_date DATE); # 创建表</span><br><span class="line"></span><br><span class="line">DESC myempl;  # 查看表结构</span><br><span class="line"></span><br><span class="line"># 通过现有表建立新表，会导入现有表数据</span><br><span class="line">CREATE TABLE myemp3</span><br><span class="line">AS </span><br><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line"># 结合子查询，通过现有表执行</span><br><span class="line">CREATE TABLE myemp3</span><br><span class="line">AS </span><br><span class="line">SELECT e.employee_id emp_id,e.last_name lname,d.department name</span><br><span class="line">FROM employees e JOIN departments d</span><br><span class="line">ON e.department id = d. department id;</span><br><span class="line"></span><br><span class="line"># 修改表</span><br><span class="line"># ====== 添加一个字段 ====== </span><br><span class="line">ALTER TABLE myemp1</span><br><span class="line">ADD salary DOUBLE(10,2);  # 默认添加到表中的最后一个字段</span><br><span class="line"></span><br><span class="line">ALTER TABLE myemp1</span><br><span class="line">ADD salary DOUBLE(10,2) FIRST;  # 添加到表中的第一个字段</span><br><span class="line"></span><br><span class="line"># 修改一个字段</span><br><span class="line">ALTER TABLE myemp1</span><br><span class="line">MODIFY salary DOUBLE(10,2) DEFAULT &#x27;aaa&#x27;;  # 添加到表中的第一个字段</span><br><span class="line"></span><br><span class="line"># 重命名一个字段</span><br><span class="line">ALTER TABLE dept80</span><br><span class="line">CHANGE department_name dept_name varchar(15);</span><br><span class="line"></span><br><span class="line"># 删除一个字段</span><br><span class="line">ALTER TABLE myemp1 DROP salary</span><br><span class="line"></span><br><span class="line"># 重命名表</span><br><span class="line">RENAME TABLE myemp1</span><br><span class="line">TO myemp11</span><br><span class="line"></span><br><span class="line"># 删除表</span><br><span class="line">DROP TABLE myemp1 IF EXISTS</span><br><span class="line"></span><br><span class="line"># 清空表</span><br><span class="line">TRUNCATE TABLE myemp1;</span><br><span class="line">#【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 TRIGGER，有可能造成事故，故不建议在开发代码中使用此语句。</span><br></pre></td></tr></table></figure><h3 id="二ddl-和-dml的说明">二、DDL 和 DML的说明</h3><p>​ DDL的操作一旦执行，就不可回滚。</p><p>​DML的操作默认情况，一旦执行，也是不可回滚的。但是，如果在执行DL之前，执行了SETautocommit=FALSE，则执行的DML操作就可以实现回滚。</p><h3 id="三mysql8-ddl的原子化">三、MYSQL8 ——DDL的原子化：</h3><p>​在MySQL8.0版本中，InnoDB表的DDL支持事务完整性，即DDL操作要么成功要么回滚。DDL操作回滚日志写入到datadictionary数据字典表mysql.innodb_ddlIlog（该表是隐藏的表，通过showtables无法看到）中，用于回滚操作。通过设置参数，可将DDL操作日志打印输出到MySQL错误日志中。</p><h3 id="四增删改">四、增删改</h3><h4 id="增">1、增</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO departments(department_id, department_name)</span><br><span class="line">VALUES (80, &#x27;IT&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO emp(emp_id,emp_name)</span><br><span class="line">VALUES (1001,&#x27;shkstart&#x27;),</span><br><span class="line">(1002,&#x27;atguigu&#x27;),</span><br><span class="line">(1003,&#x27;Tom&#x27;);</span><br><span class="line"></span><br><span class="line"># 通过SELECT来增加</span><br><span class="line">INSERT INTO sales_reps(id, name, salary, commission_pct)</span><br><span class="line">SELECT employee_id, last_name, salary, commission_pct</span><br><span class="line">FROM employees</span><br><span class="line">WHERE job_id LIKE &#x27;%REP%&#x27;;</span><br></pre></td></tr></table></figure><h4 id="删">2、删</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM departments</span><br><span class="line">WHERE department_name = &#x27;Finance&#x27;;</span><br></pre></td></tr></table></figure><h4 id="改">3、改</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE employees</span><br><span class="line">SET department_id = 70</span><br><span class="line">WHERE employee_id = 113;</span><br></pre></td></tr></table></figure><h4 id="mysql8-计算列">4、MYSQL8 计算列：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tb1(</span><br><span class="line">    id INT,</span><br><span class="line">    a INT,</span><br><span class="line">    b INT,</span><br><span class="line">    c INT GENERATED ALWAYS AS (a + b) VIRTUAL</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="五数据类型详解">五、数据类型详解：</h3><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220910112143456.png" style="zoom:67%;" /></p><h4 id="整型">1、整型</h4><ul><li><p>TINYINT 1字节一般用于枚举数据，比如系统设定取值范围很小且固定的场景</p></li><li><p>SMALLINT 2字节可以用于较小范围的统计数据，比如统计工厂的固定资产库存数量</p></li><li><p>MEDUIMINT 3字节 用于较大整数的计算，比如车站每日的客流量</p></li><li><p>INT4字节取值范围足够大，一般情况下不用考虑超限问题，用得最多。比如商品编号</p></li><li><p>BIGINT 8字节只有当你处理特别巨大的整数时才会用到。比如双十一的交易量、大型门户网站点击量、证券公司衍生产品持仓等</p></li><li><p>可选属性</p><ul><li>UNSIGNED 无符号属性</li><li>ZEROFILL 零填充</li></ul></li></ul><h4 id="浮点类型">2、浮点类型</h4><ul><li>FLOAT</li><li>DOUBLE</li></ul><p>​如果用到浮点数，要特别注意误差问题，因为浮点数是不准确的，所以我们要避免使用“=”来​判断两个数是否相等。同时，在一些对精确度要求较高的项目中，千万不要使用浮点数，不然会导致结果错误，甚至是造成不可挽回的损失</p><h4 id="定点数类型">3、定点数类型：</h4><ul><li><p>DECIMAL(M,D)</p></li><li><p>表示高精度小数。其中，M被称为精度，D被称为标度。0&lt;=M&lt;=65，0&lt;=D&lt;=30，D&lt;M。例如，定义DECIMAL（5,2）的类型，表示该列取值范围是-999.99~999.99。</p></li><li><p>DECIMAL的存储空间并不是固定的，由精度值M决定，总共占用的存储空间为M+2个字节。也就是说，在一些对精度要求不高的场景下，比起占用同样字节长度的定点数，浮点数表达的数值范围可以更大一些。</p></li><li><p>定点数在MySQL内部是以字符串的形式进行存储，这就决定了<strong>它一定是精准的</strong>。</p></li></ul><h4 id="位类型">4、位类型</h4><ul><li>BIT(M)</li><li>如果没有指定(M)，默认是1位。这个1位，表示只能存1位的二进制值。这里(M)是表示二进制的位数，位数最小值为1，最大值为64。</li></ul><h4 id="日期与时间类型">5、日期与时间类型</h4><ul><li><p>YEAR 类型通常用来表示年</p></li><li><p>DATE 类型通常用来表示年、月、日</p></li><li><p>TIME 类型通常用来表示时、分、秒</p></li><li><p>DATETIME 类型通常用来表示年、月、日、时、分、秒</p></li><li><p>TIMESTAMP 类型通常用来表示带时区的年、月、日、时、分、秒</p></li><li><p>DATETIME占用8个字节</p></li><li><p>TIMESTAMP占用4个字节，TIMESTAMP底层存储的是毫秒值</p></li><li><p>DATETIME 和 TIMESTAMP差别：</p><ul><li>TIMESTAMP存储的时间范围比DATETIME要小很多，只能存储“1970-01-0100:00:01 UTC”到“2038-01-19 03:14:07UTC”之间的时间。存储数据的时候需要对当前时间所在的时区进行转换，查询数据的时候再将时间转换回当前的时区。因此，使用TIMESTAMP存储的同一个时间值，在不同的时区查询时会显示不同的时间</li><li>TIMESTAMP会根据用户的时区不同，显示不同的结果。而DATETIME则只能反映出插入时当地的时区，其他时区的人查看数据必然会有误差的,需要额外做处理</li></ul></li></ul><h4 id="文本字符串类型">6、文本字符串类型</h4><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220910143332516.png" /></p><ul><li>何时使用CHAR？何时使用VARCHAR？<ul><li><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220910143612992.png" /></li><li>情况1：存储很短的信息。比如门牌号码101，201....这样很短的信息应该用char，因为varchar还要占个byte用于存储信息长度，本来打算节约存储的，结果得不偿失。</li><li>情况2：固定长度的。比如使用uuid作为主键，那用char应该更合适。因为他固定长度，varchar动态根据长度的特性就消失了，而且还要占个长度信息。</li><li>情况3：十分频繁改变的列，因为varchar的每次存储都需要有额外的计算，得到长度等工作。如果一个非常频繁改变的话，会又较多的小号用于计算。</li><li>情况4：具体存储引擎的情况：<ul><li>InnoDB存储引擎，建议使用VARCHAR类型。因为对于InnoDB数据表，内部的行存储格式并没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），而且主要影响性能的因素是数据行使用的存储总量，由于char平均占用的空间多于varchar，所以除了简短并且固定长度的，其他考虑varchar。这样节省空间，对磁盘I/O和数据存储总量比较好。</li></ul></li></ul></li><li>关于TEXT字段：<ul><li>TEXT文本类型，可以存比较大的文本段，搜索速度稍慢，因此如果不是特别大的内容，建议使用CHAR，VARCHAR来代替。还有TEXT类型不用加默认值，加了也没用。而且text和blob类型的数据删除后容易导致“空洞”，使得文件碎片比较多，所以频繁使用的表不建议包含TEXT类型字段，建议单独分出去，单独用一个表。</li></ul></li><li>关于ENUM和SET<ul><li>设置字段值时，ENUM类型只允许从成员中选取单个值，不能一次选取多个值。</li><li>SET类型在选取成员时，可以一次选择多个成员，这一点与ENUM类型不同。</li></ul></li></ul><h4 id="二进制字符串">7、二进制字符串</h4><p>BINARY VARBINARY BLOB</p><ul><li>使用TEXT和BLOB时的注意事项：<ul><li>BLOB和TEXT值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值会在数据表中留下很大的"空洞"，以后填入这些"空洞"的记录可能长度不同。为了提高性能，建议定期 使用OPTIMIZE TABLE 功能对这类表进行碎片整理。</li><li>如果需要对大文本字段进行模糊查询，MySQL提供了前缀索引。但是仍然要在不必要的时候避免检索大型的BLOB或TEXT值。例如，SELECT *查询就不是很好的想法，除非你能够确定作为约束条件的WHERE子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的值。</li><li>把BLOB或TEXT列分离到单独的表中。在某些环境中，如果把这些数据列移动到第二张数据表中，可以让你把原数据表中的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会减少主表中的碎片，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行 SELECT* 查询的时候不会通过 网络传输大量的BLOB或TEXT值。</li></ul></li></ul><h4 id="json类型">8、JSON类型：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO test_json (js)</span><br><span class="line">VALUES (&#x27;&#123;&quot;name&quot;:&quot;songhk&quot;, &quot;age&quot;:18, &quot;address&quot;:&#123;&quot;province&quot;:&quot;beijing&quot;,</span><br><span class="line">&quot;city&quot;:&quot;beijing&quot;&#125;&#125;&#x27;);</span><br></pre></td></tr></table></figure><h4 id="空间类型">9、空间类型：</h4><p>​ MySQL空间类型扩展支持地理特征的生成、存储和分析。这里的地理特征表示世界上具有位置的任何东西，可以是一个实体，例如一座山；可以是空间，例如一座办公楼；也可以是一个可定义的位置，例如一个十字路口等等。MySQL中使用Geometry（几何）来表示所有地理特征。Geometry指一个点或点的集合，代表世界上任何具有位置的事物。</p><h4 id="总结">10、总结：</h4><ul><li>任何字段如果为非负数，必须是 UNSIGNED</li><li>【强制】小数类型为 DECIMAL，禁止使用 FLOAT 和DOUBLE。说明：在存储的时候，FLOAT 和 DOUBLE都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过DECIMAL 的范围，建议将数据拆成整数和小数并分开存储。</li><li>【强制】如果存储的字符串长度几乎相等，使用 CHAR定长字符串类型。</li><li>【强制】VARCHAR 是可变长字符串，不预先分配存储空间，长度不要超过5000。如果存储长度大 于此值，定义字段类型为TEXT，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</li></ul>]]></content>
    
    
    <summary type="html">Chap3——Mysql DDL操作、增删改与数据类型</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Mysql各类函数与子查询</title>
    <link href="https://blog.fantast.top/2022/09/05/22f2ef21dade/"/>
    <id>https://blog.fantast.top/2022/09/05/22f2ef21dade/</id>
    <published>2022-09-05T09:03:19.000Z</published>
    <updated>2022-09-07T10:08:31.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一函数">一、函数</h3><h4 id="流程控制函数">1、流程控制函数</h4><ul><li>CASE WHEN THEN</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id,salary, CASE WHEN salary&gt;=15000 THEN &#x27;高薪&#x27;</span><br><span class="line">WHEN salary&gt;=10000 THEN &#x27;潜力股&#x27;</span><br><span class="line">WHEN salary&gt;=8000 THEN &#x27;屌丝&#x27;</span><br><span class="line">ELSE &#x27;草根&#x27; END &quot;描述&quot;</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure><ul><li>IF &amp;&amp; IFNULL</li></ul><h4 id="加密与解密函数">2、加密与解密函数</h4><ul><li><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220905172002244.png" /></li></ul><h4 id="mysql信息函数">3、MYSQL信息函数</h4><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220905172039855.png" /></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220905172112542.png" /></p><h4 id="一些其他单行函数">4、一些其他单行函数：</h4><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220905172140390.png" /></p><h4 id="聚合函数">5、聚合函数：</h4><p>​ <strong>输入一组数据的集合，输出单个值</strong></p><ul><li>常用的聚合函数：AVG SUM MAX MIN</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT AVG(salary),SUM(salary),AVG(salary)*107</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT MAX(salary),MIN(salary)</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure><ul><li>COUNT</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(employee_id),COUNT(salary),COUNT(2* salary)</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure><ul><li><p>COUNT计算指定字段，是不计算该字段为空值的记录数目的</p></li><li><p>所以如果想要计算表中有多少条记录，可以使用COUNT(*)</p></li></ul><p><strong>需求：查询公司中平均奖金率</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 错误的做法，因为有可能commission_pct为null</span><br><span class="line">SELECT AVG(commission_pct)</span><br><span class="line">FROM employees;</span><br><span class="line"># 正确的做法：</span><br><span class="line">SELECT SUM(commission_pct) / COUNT(IFNULL(commission_pct,0))</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure><ul><li>GROUP BY 的使用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT department_id,AVG(salary)</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br></pre></td></tr></table></figure><ul><li>如果要使用多个列进行GROUP BY 分组操作：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT department_id,job_id,AVG(salary)</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id,job_id</span><br></pre></td></tr></table></figure><p><strong>提示结论</strong>：</p><ul><li><p>出现在SELECT中的非聚合函数字段，都必须出现在GROUPBY里面。</p></li><li><p>GROUP BY 声明在FROM后面、WHERE后面，ORDERBY前面、LIMIT前面</p></li><li><p>在GROUP BY中使用 WITH ROLLUP，使用WITHROLLUP关键字之后，在所有查询出的分组记录之后增加一条记录，该记录计算查询出的所有记录的总和，即统计记录数量。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT department_id,AVG(salary) AS avg_sal</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id WITH ROLLUP;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 当使用ROLLUP时，不能同时使用ORDER BY子句进行结果排那，即ROLLUP和ORDER BY是互相排斥的。</span><br><span class="line">SELECT department_id,AVG(salary) AS avg_sal</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">ORDER BY avg_sal ASC;</span><br></pre></td></tr></table></figure><ul><li>Having的使用（用于过滤数据）<ul><li>如果过滤条件中使用了聚合函数，必须使用HAVING来替换WHERE</li><li>如果过滤条件中没有聚合函数，则过滤条件声明在HAVING或WHERE中都可以</li></ul></li></ul><p><strong>查询各个部门中最高工资比10000高的部门信息：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT department_id,MAX(salary)</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING MAX(salary) &gt; 10000</span><br></pre></td></tr></table></figure><h4 id="where-和-having的区别">6、WHERE 和 HAVING的区别：</h4><ul><li>区别1：WHERE可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件；HAVING必须要与GROUPBY配合使用，可以把分组计算的函数和分组字段作为筛选条件。</li><li>区别2：如果需要通过连接从关联表中获取需要的数据，WHERE是先筛选后连接，而HAVING是先连接后筛选。这一点，就决定了在关联查询中，WHERE比HAVING更高效。因为WHERE可以先筛选，用一个筛选后的较小数据集和关联表进行连接，这样占用的资源比较少，执行效率也比较高。HAVING则需要先把结果集准备好，也就是用未被筛选的数据集进行关联，然后对这个大的数据集进行筛选，这样占用的资源就比较多，执行效率也较低。</li></ul><h4 id="sql底层执行原理">7、SQL底层执行原理：</h4><p>Select语句的完整结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># sql92</span><br><span class="line">SELECT ... , ... , ... (存在聚合函数)</span><br><span class="line">FROM ... , ... , ...</span><br><span class="line">WHERE 多表连接条件 AND 不包含聚合函数的过滤条件</span><br><span class="line">GROUP BY ...</span><br><span class="line">HAVING 包含聚合函数的过滤条件</span><br><span class="line">ORDER BY ... (ASC/DESC)</span><br><span class="line">LIMIT ...,...</span><br><span class="line"></span><br><span class="line"># sql92</span><br><span class="line">SELECT ... , ... , ... (存在聚合函数)</span><br><span class="line">FROM ... JOIN ... ON 多表连接条件</span><br><span class="line">JOIN ... ON ...</span><br><span class="line">WHERE 不包含聚合函数的过滤条件</span><br><span class="line">GROUP BY ...</span><br><span class="line">HAVING 包含聚合函数的过滤条件</span><br><span class="line">ORDER BY ... (ASC/DESC)</span><br><span class="line">LIMIT ...,...</span><br></pre></td></tr></table></figure><ul><li>SQL语句如何执行，执行过程？<ul><li>FROM—&gt; ON( 多表连接条件)—&gt; ( LEFT / RIGHT JOIN根据左外右外连接补充数据 ) —&gt; WHERE（筛选数据）</li><li>—&gt; GROUP BY（分组） —&gt; HAVING（分组后筛选） —&gt;SELECT（选择） —&gt; ORDER BY（排序） —&gt;</li><li>LIMIT （限制条数）</li></ul></li></ul><h3 id="二子查询">二、子查询</h3><p>​很多时候查询需要从结果集中获取数据，或者<strong>需要从同一个表中先计算得出一个数据结果，然后与这个数据结果（可能是某个标量，也可能是某个集合）进行比较。</strong></p><p>​ <strong>虽然有的时候子查询可以通过两个连续的SQL查询或自连接实现同样的功能，但是子查询性能更优。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &gt; (</span><br><span class="line"> SELECT salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name = &#x27;Abel&#x27;</span><br><span class="line"> );</span><br></pre></td></tr></table></figure><p>​ <strong>子查询在主查询之前一次执行完成</strong></p><p>​ <strong>将子查询放在比较条件的右侧</strong></p><p>​ <strong>单行操作对应单行子查询，多行操作对应多行子查询</strong></p><h4id="内查询返回的结果条目数单行多行子查询">1、内查询返回的结果条目数（单行、多行子查询）：</h4><ul><li><p>单行子查询（内查询返回单行数据）</p></li><li><p>多行子查询：应当使用多行比较操作符： IN ， ANY ， ALL</p><ul><li><p>返回其它job_id中比job_id为 'IT_PROG'部门任一工资低的员工的员工号</p></li><li><p>```mysql SELECT employee_id,last_name,job_id,salary FROMemployees WHERE job_id &lt;&gt; 'IT_PROG' AND salary &lt; ANY ( SELECTsalary FROM employees WHERE job id = 'IT PROG' );<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2、内查询是否被执行多次（相关子查询、不相关子查询）：</span><br><span class="line"></span><br><span class="line">- 相关子查询</span><br><span class="line"></span><br><span class="line">  - 内查询返回的值与外查询相关</span><br><span class="line"></span><br><span class="line">  - 如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，**因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为关联子查询。**</span><br><span class="line"></span><br><span class="line">    ```mysql</span><br><span class="line">    # 查询工资大于本部门平均工资的员工信息</span><br><span class="line">    # 张三在部门A，李四在部门B，那么张三来查和李四来查，内查询查的是各自部门的平均工资，返回的是不一样的，也就是内查询执行了多次</span><br></pre></td></tr></table></figure></p></li></ul></li></ul><p>​ <strong>执行流程</strong>：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220907113232810.png" style="zoom: 67%;" /></p><p><strong>查询员工中工资大于本部门平均工资的员工的lat_name，salary和其department_id</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT last_name,salry,department_id</span><br><span class="line">FROM employees AS e1</span><br><span class="line">WHERE salry &gt; (</span><br><span class="line">SELECT AVG(salary) as avg_sal</span><br><span class="line">FROM employees as e2</span><br><span class="line">WHERE e2.department_id = e1.department_id</span><br><span class="line">GROUP BY department_id )</span><br></pre></td></tr></table></figure><p><strong>查询员工的id,salary,按照department_name排序</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee id, salary</span><br><span class="line">FROM employees AS e</span><br><span class="line">ORDER BY(</span><br><span class="line">SELECT department_name</span><br><span class="line">FROM departments AS d</span><br><span class="line">WHERE e.department_id = d.department_id </span><br><span class="line">) ASC;</span><br></pre></td></tr></table></figure><ul><li><p>不相关子查询</p><ul><li><p>内查询返回的值与外查询无关</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查询工资大于本公司平均工资的员工信息</span><br><span class="line"># 张三在部门A，李四在部门B，那么张三来查和李四来查，内查询查的都是全公司的平均工资，返回的是一样的，也就是内查询执行了一次</span><br></pre></td></tr></table></figure></li></ul></li><li><p>相关子查询结论：<strong>在SELECT语句中，除了GROUP BY 和LIMIT之外，其他地方都可以声明子查询</strong></p></li></ul><h4id="相关子查询中的exists-和-not-exists关键字">3、相关子查询中的EXISTS 和NOT EXISTS关键字</h4><ul><li><p>如果在子查询中不存在满足条件的行：</p><ul><li><p>条件返回 FALSE</p></li><li><p>继续在子查询中查找</p></li></ul></li><li><p>如果在子查询中存在满足条件的行：</p><ul><li>不在子查询中继续查找</li><li>条件返回 TRUE</li></ul></li></ul><p><strong>查询公司管理者的employee_id，last_name，job_id，department_id信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee id, last name, job id, department id</span><br><span class="line">FROM employees e1</span><br><span class="line">WHERE EXISTS(</span><br><span class="line">SELECT *</span><br><span class="line">FROM employees e2</span><br><span class="line">WHERE e1.employee_id= e2.manager_id</span><br><span class="line"> );</span><br><span class="line"># 将外查询中的第1条记录送入子查询中，执行查找，如果存在则返回TRUE</span><br><span class="line"># 将外查询中的第2条记录送入子查询中，执行查找，如果存在则返回TRUE</span><br><span class="line"># 将外查询中的第...条记录送入子查询中，执行查找，如果存在则返回TRUE   </span><br><span class="line"># 相关子查询的执行过程就是如上所述</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Chap2——Mysql数据库函数与子查询精简复习版</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
</feed>
