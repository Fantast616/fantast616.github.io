<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fantast&#39;s Blog</title>
  
  
  <link href="https://blog.fantast.top/atom.xml" rel="self"/>
  
  <link href="https://blog.fantast.top/"/>
  <updated>2022-11-17T14:12:10.895Z</updated>
  <id>https://blog.fantast.top/</id>
  
  <author>
    <name>Fantast</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Tomcat与Servelet入门</title>
    <link href="https://blog.fantast.top/2022/11/15/50b9c3d3d025/"/>
    <id>https://blog.fantast.top/2022/11/15/50b9c3d3d025/</id>
    <published>2022-11-15T07:55:19.000Z</published>
    <updated>2022-11-17T14:12:10.895Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一tomcat配置与简单部署html">一、Tomcat配置与简单部署Html</h3><h4 id="安装与配置">1、安装与配置：</h4><ul><li><p>官网下载压缩包解压：https://tomcat.apache.org/download-80.cgi</p></li><li><p>配置环境变量JAVA_HOME：为jdk的目录</p></li><li><p>点击tomcat文件夹bin目录内start.bat文件，启动tomcat服务，其默认在8080端口</p></li></ul><h4id="手动部署app的方法一个最简单的demo">2、手动部署app的方法：一个最简单的demo：</h4><ul><li>在webapps里新建一个文件夹叫test</li><li>test文件夹内新建一个文件夹叫WEB-INF，这个文件夹名字是定死的。</li><li>同时在test目录下部署项目资源</li><li>最简单部署完以后，既可以通过localhost:8080/test访问服务</li></ul><h4id="在idea下建立项目并配置tomcat完成可以自动部署的流程">3、在IDEA下建立项目，并配置Tomcat，完成可以自动部署的流程：</h4><ul><li>首先建立一个空的Project</li><li>选择File-&gt;Project Structure-&gt;Modules-&gt; + -&gt;Web增加一个Webapp模块</li><li>然后增加对应的artifacts（Artifact是maven中的一个概念，表示某个module要如何打包。例如warexploded、war、jar、ear等等这种打包形式； 一个module有了 Artifacts就可以部署到应用服务器中了。不带exploded的是打包压缩过的，带exploded的是没有打包压缩过而是分开的。开发建议带exploded）</li><li>随后在右上角运行配置项里新增Tomcat Server，并配置On Updateaction为Redeploy，On frame deactivation为Update classes andresources，这样我们修改了代码以后它会自动更新部署。</li><li>在Deployment中增加之前我们增加的web模块的artifact即可。</li></ul><h3 id="二servlet">二、Servlet</h3><h4 id="做一个最简单的servlet-app">1、做一个最简单的Servlet App</h4><h5 id="工程配置">1）工程配置：</h5><p>​由于想要接受前端页面的请求，我们必须要继承某个类，即HttpServlet类。这个类并不在jdk中，而是在tomcat中有，所以第一步需要将tomcat添加到模块的项目的依赖项中。</p><ul><li><p>File-&gt;Project Structure-&gt;Modules-&gt; 选中当前模块 -&gt;Dependencies -&gt; 新增 -&gt; Library -&gt; Tomcat即可，配置完成后会发现外部依赖项里多了Tomcat8.5</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221115145108886.png" /></p></li></ul><h5 id="写处理请求的类">2）写处理请求的类：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myAddServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">priceStr</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">price</span> <span class="operator">=</span> Integer.parseInt(priceStr);</span><br><span class="line">        System.out.println(<span class="string">&quot;name=&quot;</span> + name);</span><br><span class="line">        System.out.println(<span class="string">&quot;price=&quot;</span> + price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="写项目中的html文件">3）写项目中的HTML文件：</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;add&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">name</span>=<span class="string">&quot;price&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="配置项目目录中的web.xml文件">4）配置项目目录中的web.xml文件</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myAddServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.demo.myAddServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myAddServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/add<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>至此位置，项目的目录结构如下：</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221115145901182.png" /></p><p>请求的全过程如下：</p><ul><li>用户发请求，action=add</li><li>项目中，从web.xml的servlet-mapping中找到url-pattern=/add</li><li>知道/add对应的servlet-name=Addservlet后去servlet中找和servlet-name=Addservlet的servlet-class</li><li>找到对应的servlet-class为-&gt;com.demo.myAddServlet</li><li>由于用户发透的是post请求，因此tomcat会共行Addservlet中的doPost()方法</li></ul><h5id="处理请求的中文字符乱码的问题">5）处理请求的中文字符乱码的问题：</h5><p>​ 在Tomcat8中，Post请求中，doPost函数最开始，添加如下代码即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.setCharacterEncoding(&quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure><h4id="servlet的继承关系及service方法">2、Servlet的继承关系及Service方法：</h4><p>​ 自己写的类需要继承HttpServlet类， 继承关系如下：HttpServlet -&gt;GenericServlet -&gt; Servlet</p><ul><li><p>javax.servlet.Servlet接口:</p><ul><li>void init(config) - 初始化方法</li><li>void service(request,response) - 服务方法</li><li>void destory() - 销毁方法</li></ul></li><li><p>javax.servlet.GenericServlet抽象类：</p><ul><li>void service(request,response) - 仍然是抽象的</li></ul></li><li><p>javax.servlet.http.HttpServlet 抽象子类：</p><ul><li>void service(request,response) - 不是抽象的，内部逻辑如下<ol type="1"><li>String method = req.getMethod(); 获取请求的方式</li><li>各种if判断，根据请求方式不同，决定去调用不同的do方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (method.equals(<span class="string">&quot;GET&quot;</span>)) &#123;</span><br><span class="line"> <span class="built_in">this</span>.doGet(req,resp);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;HEAD&quot;</span>)) &#123;</span><br><span class="line"> <span class="built_in">this</span>.doHead(req, resp);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line"> <span class="built_in">this</span>.doPost(req, resp);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>在HttpServlet这个抽象类中，do方法都差不多,如下：我们可以看到，就是执行报错的一个过程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">protocol</span> <span class="operator">=</span> req.getProtocol();</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_get_not_supported&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (protocol.endsWith(<span class="string">&quot;1.1&quot;</span>)) &#123;</span><br><span class="line">     resp.sendError(<span class="number">405</span>, msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     resp.sendError(<span class="number">400</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>总而言之：当有请求过来时，service方法会自动响应（其实是tomcat容器调用的），然后在HttpServlet的service方法中我们会去分析请求的方式：到底是get、post、head还是delete等等，然后再决定调用的是哪个do开头的方法。在HttpServlet中这些do方法默认都是405的报错实现风格-所以我们子类如果没有实现对应的方法，比如没有实现doGet方法但是前端请求了该url的get，就会默认报405错误</strong></p></li></ul><h4 id="servlet的生命周期">3、Servlet的生命周期：</h4><ul><li><p>对应Servlet中的三个方法：init(),service(),destroy()</p><ul><li>第一次接收请求时，这个Servlet会进行实例化(调用构造方法)、初始化(调用init())、然后服务(调用service())</li><li>从第二次请求开始，每一次都是服务</li><li>当容器关闭时，其中的所有的servlet实例会被销毁，调用销毁方法</li></ul></li><li><p>Servlet实例tomcat只会创建一个，所有的请求都是这个实例去响应。</p></li><li><p>Servlet的初始化时机：默认是第一次接收请求时，实例化，初始化，我们可以通过<load-on-startup>来设置servlet启动的先后顺序,数字越小，启动越靠前，最小值0</p></li><li><p>Servlet在容器中是：单例的、线程不安全的</p><ul><li>单例：所有的请求都是同一个实例去响应</li><li>线程不安全：一个线程需要根据这个实例中的某个成员变量值去做逻辑判断。但是在中间某个时机，另一个线程改变了这个成员变量的值，从而导致第一个线程的执行路径发生了变化</li></ul></li><li><p>故而：尽量不要在servlet中定义成员变量。如果不得不定义成员变量，那么</p><ul><li>①不要去修改成员变量的值</li><li>②不要去根据成员变量的值做一些逻辑判断</li></ul></li></ul><h4 id="session会话跟踪">4、Session会话跟踪：</h4><p>​ 通过会话跟踪技术来解决Http无状态的问题，具体如下所示：</p><ul><li>客户端第一次发请求给服务器，服务器获取session，获取不到，则创建新的，然后响应给客户端</li><li>下次客户端给服务器发请求时，会把sessionID带给服务器，那么服务器就能获取到了，那么服务器就判断这一次请求和上次某次请求是同一个客户端，从而能够区分开客户端</li></ul><p>常见的session相关的API：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">request.getSession() <span class="comment">// 获取当前的会话，没有则创建一个新的会话</span></span><br><span class="line">request.getSession(<span class="literal">true</span>) <span class="comment">// 效果和不带参数相同</span></span><br><span class="line">request.getSession(<span class="literal">false</span>) <span class="comment">// 获取当前会话，没有则返回null，不会创建新的</span></span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">session.getId() <span class="comment">// 获取sessionID</span></span><br><span class="line">session.isNew() <span class="comment">// 判断当前session是否是新的</span></span><br><span class="line">session.getMaxInactiveInterval() <span class="comment">// session的非激活间隔时长，默认1800秒</span></span><br><span class="line">session.setMaxInactiveInterval()</span><br><span class="line">session.invalidate() <span class="comment">// 强制性让会话立即失效</span></span><br></pre></td></tr></table></figure><ul><li>书写一个Session测试用的Servlet：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mySessionServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">        System.out.println(<span class="string">&quot;Session Id:&quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>浏览器第一次请求该接口：</p><ul><li>可以看到响应头—有了一个字段Set-Cookie，即服务器返回的SESSIONID</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221115204052061.png" /></p><ul><li>随后浏览器会自动将这个字段存到Cookie中的JSESSIONID</li><li><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221115203959564.png" /></li></ul></li><li><p>浏览器后续请求该接口时，会自动携带该字段向服务器发起请求，服务器即能识别</p></li></ul><figure><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221115203917388.png"alt="image-20221115203917388" /><figcaption aria-hidden="true">image-20221115203917388</figcaption></figure><h4 id="session的保存作用域">5、Session的保存作用域：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session.setAttribute(k,v);   <span class="comment">//向当前Session保存作用域中添加一组key,value</span></span><br><span class="line">session.getAttribute(k);     <span class="comment">//获取当前Session保存作用中的key的值</span></span><br></pre></td></tr></table></figure><h4id="服务器内部转发和客户端重定向">6、服务器内部转发和客户端重定向</h4><p>1） 服务器内部转发 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(&quot;....&quot;).forward(request,response);</span><br></pre></td></tr></table></figure><ul><li>一次请求响应的过程，对于客户端而言，内部经过了多少次转发，客户端是不知道的</li><li>地址栏没有变化</li></ul><p>2） 客户端重定向：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(&quot;....&quot;);</span><br></pre></td></tr></table></figure><ul><li>两次请求响应的过程。客户端肯定知道请求URL有变化</li><li>地址栏有变化</li></ul><h4 id="简化servlet-url的注册方式">7、简化Servlet Url的注册方式：</h4><p>​从Servlet3.0版本开始，就支持注解方式的注册，如下，这样就不需要在web.xml文件中写配置了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mySessionServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">        System.out.println(session.getAttribute(<span class="string">&quot;uname&quot;</span>));</span><br><span class="line">        session.setAttribute(<span class="string">&quot;uname&quot;</span>,<span class="string">&quot;fantast&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Session Id:&quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4id="如何让html内动态渲染数据thymeleaf视图模板技术此处略说">8、如何让HTML内动态渲染数据？Thymeleaf视图模板技术（此处略说）</h4><p>​实际上就是创建了一个类ViewBaseServlet，继承HttpServlet，其中提供了将数据渲染至对应模板文件的函数，之后所有的Servlet就可以继承他，就可以方便的返回渲染好的HTML文件，而不用重复进行渲染。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewBaseServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> TemplateEngine templateEngine;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"> <span class="comment">//在初始化的时候初始化一些渲染模板用的实例</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processTemplate</span><span class="params">(String templateName, HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//通过该函数，将动态数据渲染至一些对应的模板文件，从而方便直接返回直接渲染好的HTML页面</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="servlet的保存作用域">9、Servlet的保存作用域：</h4><p>​其中有四个级别的保存作用域，page（已经不用了），request（一次请求响应范围），session（一次会话范围），application</p><ul><li>request：单次请求级别<ul><li>如果采用服务器内部转发的形式，是能够获取到request级别的作用域的</li><li>如果采用客户端重定向的形式，则是获取不到request级别的作用域的</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.setAttribute(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;fantast&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>session：会话级别，见上</li><li>application：应用程序级别，只要有一个会话保存了k,v属性，那么所有会话都可以访问到对应k的属性v</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> request.getSetvletContext();</span><br><span class="line">application.setAttribute(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;fantast&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="三servlet优化mvc架构">三、Servlet优化——MVC架构：</h3><h4id="简化功能类似的servlet至一个servlet">1、简化功能类似的servlet至一个servlet</h4><p>​比如说，可以合并所有用户相关的增删改查操作至一个servlet中，重写其的service方法即可</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221115215818336.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">//设置编码</span></span><br><span class="line">    request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">operate</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;operate&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(StringUtil.isEmpty(operate))&#123;</span><br><span class="line">        operate = <span class="string">&quot;index&quot;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(operate)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;index&quot;</span>:</span><br><span class="line">            index(request,response);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;add&quot;</span>:</span><br><span class="line">            add(request,response);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;del&quot;</span>:</span><br><span class="line">            del(request,response);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;edit&quot;</span>:</span><br><span class="line">            edit(request,response);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;update&quot;</span>:</span><br><span class="line">            update(request,response);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;operate值非法!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4id="使用反射机制优化一个servlet内的结构">2、使用反射机制优化一个Servlet内的结构：</h4><p>​ 按照第一步的简化，service方法中会存在很多的switchcase方法，来执行不同的逻辑。一旦方法逻辑多了，就很容易导致代码冗杂。通过java的反射机制改造如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">//设置编码</span></span><br><span class="line">    request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">operate</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;operate&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(StringUtil.isEmpty(operate))&#123;</span><br><span class="line">        operate = <span class="string">&quot;index&quot;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method[] methods = <span class="built_in">this</span>.getClass().getDeclaredMethods();</span><br><span class="line">    <span class="keyword">for</span>(Method m : methods)&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> m.getName();</span><br><span class="line">        <span class="keyword">if</span>(operate,equals(methodName))&#123;</span><br><span class="line">            <span class="comment">//找到和operate同名的方法，通过反射来调用</span></span><br><span class="line">            m.invoke(request,response)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dispatcher-servlet核心控制器优化请求转发">3、DispatcherServlet核心控制器优化请求转发：</h4><p>​ 通过DispatcherServlet核心控制器，来管控所有的请求，根据不同的请求内容处理转发至对应的各个Servlet，比如FruitServlet，UserServlet，OrderServlet等等。此时，由于各个原先的Servlet不需要直接注册url了，所以本质上已经不是Servlet，已经是个普通类了，我们改名叫FruitController，UserController等，故将整个架构图改成如下所示：此时核心的DispatcherServlet类代码和applicationContext.xml文件如下所示：</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221116094213840.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;*.do&quot;)</span>  <span class="comment">//注册所有的*.do的路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; beanMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DispatcherServlet</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//1.创建DocumentBuilderFactory</span></span><br><span class="line">        <span class="type">DocumentBuilderFactory</span> <span class="variable">documentBuilderFactory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">        <span class="comment">//2.创建DocumentBuilder对象</span></span><br><span class="line">        <span class="type">DocumentBuilder</span> <span class="variable">documentBuilder</span> <span class="operator">=</span> documentBuilderFactory.newDocumentBuilder() ;</span><br><span class="line">        <span class="comment">//3.创建Document对象</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> documentBuilder.parse(inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.获取所有的bean节点</span></span><br><span class="line">        <span class="type">NodeList</span> <span class="variable">beanNodeList</span> <span class="operator">=</span> document.getElementsByTagName(<span class="string">&quot;bean&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;beanNodeList.getLength() ; i++)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">beanNode</span> <span class="operator">=</span> beanNodeList.item(i);</span><br><span class="line">            <span class="keyword">if</span>(beanNode.getNodeType() == Node.ELEMENT_NODE)&#123;</span><br><span class="line">                <span class="type">Element</span> <span class="variable">beanElement</span> <span class="operator">=</span> (Element)beanNode ;</span><br><span class="line">                <span class="type">String</span> <span class="variable">beanId</span> <span class="operator">=</span>  beanElement.getAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> beanElement.getAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">                <span class="type">Class</span> <span class="variable">controllerBeanClass</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">beanObj</span> <span class="operator">=</span> controllerBeanClass.newInstance() ;</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setServletContextMethod</span> <span class="operator">=</span> controllerBeanClass.getDeclaredMethod(<span class="string">&quot;setServletContext&quot;</span>,ServletContext.class);</span><br><span class="line">                setServletContextMethod.invoke(beanObj , <span class="built_in">this</span>.getServletContext());</span><br><span class="line"></span><br><span class="line">                beanMap.put(beanId , beanObj) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//设置编码</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 假设url是：  http://localhost:8080/pro15/hello.do</span></span><br><span class="line">        <span class="comment">// 那么servletPath是：    /hello.do</span></span><br><span class="line">        <span class="comment">// 我的思路是：</span></span><br><span class="line">        <span class="comment">// 第1步： /hello.do -&gt;   hello   或者  /fruit.do  -&gt; fruit</span></span><br><span class="line">        <span class="comment">// 第2步： hello -&gt; HelloController 或者 fruit -&gt; FruitController</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">servletPath</span> <span class="operator">=</span> request.getServletPath();</span><br><span class="line">        servletPath = servletPath.substring(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastDotIndex</span> <span class="operator">=</span> servletPath.lastIndexOf(<span class="string">&quot;.do&quot;</span>) ;</span><br><span class="line">        servletPath = servletPath.substring(<span class="number">0</span>,lastDotIndex);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">controllerBeanObj</span> <span class="operator">=</span> beanMap.get(servletPath);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">operate</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;operate&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtil.isEmpty(operate))&#123;</span><br><span class="line">            operate = <span class="string">&quot;index&quot;</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> controllerBeanObj.getClass().getDeclaredMethod(operate,HttpServletRequest.class,HttpServletResponse.class);</span><br><span class="line">            <span class="keyword">if</span>(method!=<span class="literal">null</span>)&#123;</span><br><span class="line">                method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                method.invoke(controllerBeanObj,request,response);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;operate值非法!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这个bean标签的作用是 将来servletpath中涉及的名字对应的是fruit，那么就要FruitController这个类来处理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;fruit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.fruit.controllers.FruitController&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="dispatcher-servlet核心控制器优化视图资源重定向">4、DispatcherServlet核心控制器优化视图资源重定向：</h4><p>​我们发现，在上面的架构中，Controller中不同的函数最后还是要执行视图资源的重定向，我们希望把这个事情统一交给核心控制器来管理，Controller不需要关心任何视图层的内容：</p><p>​首先更改FruitController最后，将资源重定向变成返回一个字符串，交给DispathcerServlet来处理重定向</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FruitController</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.设置编码</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fidStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fid&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">fid</span> <span class="operator">=</span> Integer.parseInt(fidStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">fname</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fname&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">priceStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> Integer.parseInt(priceStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">fcountStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fcount&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">fcount</span> <span class="operator">=</span> Integer.parseInt(fcountStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">remark</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;remark&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.执行更新</span></span><br><span class="line">        fruitDAO.updateFruit(<span class="keyword">new</span> <span class="title class_">Fruit</span>(fid,fname, price ,fcount ,remark ));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.资源跳转</span></span><br><span class="line">        <span class="comment">//super.processTemplate(&quot;index&quot;,request,response);</span></span><br><span class="line">        <span class="comment">//request.getRequestDispatcher(&quot;index.html&quot;).forward(request,response);</span></span><br><span class="line">        <span class="comment">//此处需要重定向，目的是重新给IndexServlet发请求，重新获取furitList，然后覆盖到session中，这样index.html页面上显示的session中的数据才是最新的</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//response.sendRedirect(&quot;fruit.do&quot;);</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;redirect:fruit.do&quot;</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 然后更改DispatchController:在service函数中的调用controller对应方法后，我们还需要根据controller传回的字符串来负责视图资源的处理重定向。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.controller组件中的方法调用</span></span><br><span class="line">method.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">returnObj</span> <span class="operator">=</span> method.invoke(controllerBeanObj,parameterValues);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.视图处理</span></span><br><span class="line"><span class="type">String</span> <span class="variable">methodReturnStr</span> <span class="operator">=</span> (String)returnObj ;</span><br><span class="line"><span class="keyword">if</span>(methodReturnStr.startsWith(<span class="string">&quot;redirect:&quot;</span>))&#123;        <span class="comment">//比如：  redirect:fruit.do</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">redirectStr</span> <span class="operator">=</span> methodReturnStr.substring(<span class="string">&quot;redirect:&quot;</span>.length());</span><br><span class="line">    response.sendRedirect(redirectStr);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">super</span>.processTemplate(methodReturnStr,request,response);    <span class="comment">// 比如：  &quot;edit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dispatcher-servlet核心控制器优化参数获取">5、DispatcherServlet核心控制器优化参数获取：</h4><p>​由于我们发现Controller中不同的方法里面，都会从request中获取参数，只不过获取的参数不一样罢了，我们想要把这部分也交付给DispatcherServlet来完成，使得Controller这一层只负责逻辑的控制，业务的处理，不需要关心参数获取、视图转移等等问题。首先简化Controller中的方法，我们发现至此根本不需要给Controller传任何请求相关的内容了，它完全不关心这部分事情</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">update</span><span class="params">(Integer fid , String fname , Integer price , Integer fcount , String remark )</span>&#123;</span><br><span class="line">    <span class="comment">//1.执行更新</span></span><br><span class="line">    fruitDAO.updateFruit(<span class="keyword">new</span> <span class="title class_">Fruit</span>(fid,fname, price ,fcount ,remark ));</span><br><span class="line">    <span class="comment">//2.资源跳转</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:fruit.do&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">add</span><span class="params">(String fname , Integer price , Integer fcount , String remark )</span> &#123;</span><br><span class="line">    <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="number">0</span>,fname , price , fcount , remark ) ;</span><br><span class="line">    fruitDAO.addFruit(fruit);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:fruit.do&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ <strong>随后，我们要在DispathcerServlet中书写负责处理此部分的代码：如何根据不同的函数需要获取的参数来从request拿参数是非常核心的一个点——反射机制：</strong>以下是改造完以后，DispatcherServlet的service方法最终代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">       <span class="comment">//设置编码</span></span><br><span class="line">       request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">       <span class="comment">//假设url是：  http://localhost:8080/pro15/hello.do</span></span><br><span class="line">       <span class="comment">//那么servletPath是：    /hello.do</span></span><br><span class="line">       <span class="comment">// 我的思路是：</span></span><br><span class="line">       <span class="comment">// 第1步： /hello.do -&gt;   hello   或者  /fruit.do  -&gt; fruit</span></span><br><span class="line">       <span class="comment">// 第2步： hello -&gt; HelloController 或者 fruit -&gt; FruitController</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">servletPath</span> <span class="operator">=</span> request.getServletPath();</span><br><span class="line">       servletPath = servletPath.substring(<span class="number">1</span>);</span><br><span class="line">       <span class="type">int</span> <span class="variable">lastDotIndex</span> <span class="operator">=</span> servletPath.lastIndexOf(<span class="string">&quot;.do&quot;</span>) ;</span><br><span class="line">       servletPath = servletPath.substring(<span class="number">0</span>,lastDotIndex);</span><br><span class="line"></span><br><span class="line">       <span class="type">Object</span> <span class="variable">controllerBeanObj</span> <span class="operator">=</span> beanMap.get(servletPath);</span><br><span class="line"></span><br><span class="line">       <span class="type">String</span> <span class="variable">operate</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;operate&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span>(StringUtil.isEmpty(operate))&#123;</span><br><span class="line">           operate = <span class="string">&quot;index&quot;</span> ;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Method[] methods = controllerBeanObj.getClass().getDeclaredMethods();</span><br><span class="line">           <span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">               <span class="keyword">if</span>(operate.equals(method.getName()))&#123;</span><br><span class="line">                   <span class="comment">//1.统一获取请求参数</span></span><br><span class="line">                   <span class="comment">//1-1.获取当前方法的参数，返回参数数组</span></span><br><span class="line">                   Parameter[] parameters = method.getParameters();</span><br><span class="line">                   <span class="comment">//1-2.parameterValues 用来承载参数的值</span></span><br><span class="line">                   Object[] parameterValues = <span class="keyword">new</span> <span class="title class_">Object</span>[parameters.length];</span><br><span class="line">                   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">                       <span class="type">Parameter</span> <span class="variable">parameter</span> <span class="operator">=</span> parameters[i];</span><br><span class="line">                       <span class="type">String</span> <span class="variable">parameterName</span> <span class="operator">=</span> parameter.getName() ;</span><br><span class="line">                       <span class="comment">//如果参数名是request,response,session 那么就不是通过请求中获取参数的方式了</span></span><br><span class="line">                       <span class="keyword">if</span>(<span class="string">&quot;request&quot;</span>.equals(parameterName))&#123;</span><br><span class="line">                           parameterValues[i] = request ;</span><br><span class="line">                       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;response&quot;</span>.equals(parameterName))&#123;</span><br><span class="line">                           parameterValues[i] = response ;</span><br><span class="line">                       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;session&quot;</span>.equals(parameterName))&#123;</span><br><span class="line">                           parameterValues[i] = request.getSession() ;</span><br><span class="line">                       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                           <span class="comment">//从请求中获取参数值</span></span><br><span class="line">                           <span class="type">String</span> <span class="variable">parameterValue</span> <span class="operator">=</span> request.getParameter(parameterName);</span><br><span class="line">                           <span class="type">String</span> <span class="variable">typeName</span> <span class="operator">=</span> parameter.getType().getName();</span><br><span class="line">                           <span class="type">Object</span> <span class="variable">parameterObj</span> <span class="operator">=</span> parameterValue ;</span><br><span class="line">                           <span class="keyword">if</span>(parameterObj!=<span class="literal">null</span>) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (<span class="string">&quot;java.lang.Integer&quot;</span>.equals(typeName)) &#123;</span><br><span class="line">                                   parameterObj = Integer.parseInt(parameterValue);</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                           parameterValues[i] = parameterObj ;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//2.controller组件中的方法调用</span></span><br><span class="line">                   method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                   <span class="type">Object</span> <span class="variable">returnObj</span> <span class="operator">=</span> method.invoke(controllerBeanObj,parameterValues);</span><br><span class="line"></span><br><span class="line">                   <span class="comment">//3.视图处理</span></span><br><span class="line">                   <span class="type">String</span> <span class="variable">methodReturnStr</span> <span class="operator">=</span> (String)returnObj ;</span><br><span class="line">                   <span class="keyword">if</span>(methodReturnStr.startsWith(<span class="string">&quot;redirect:&quot;</span>))&#123;        <span class="comment">//比如：  redirect:fruit.do</span></span><br><span class="line">                       <span class="type">String</span> <span class="variable">redirectStr</span> <span class="operator">=</span> methodReturnStr.substring(<span class="string">&quot;redirect:&quot;</span>.length());</span><br><span class="line">                       response.sendRedirect(redirectStr);</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       <span class="built_in">super</span>.processTemplate(methodReturnStr,request,response);    <span class="comment">// 比如：  &quot;edit&quot;</span></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">           &#125;else&#123;</span></span><br><span class="line"><span class="comment">               throw new RuntimeException(&quot;operate值非法!&quot;);</span></span><br><span class="line"><span class="comment">           &#125;</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="mvc架构搭建完成总结">6、MVC架构搭建完成总结：</h4><p>​至此为止，我们已经自己基于Servlet构建了一个MVC框架的大概，整个的架构演变过程如下：</p><ol type="1"><li>最初的做法是：一个请求对应一个Servlet，这样存在的问题是servlet太多了</li><li>把一些类似的请求都对应一个Servlet, 比如IndexServlet/AddServlet/EditServlet/DelServlet/UpdateServlet -&gt;合并成FruitServlet，通过一个operate的值来决定调用FruitServlet中的哪一个方法，使用的是switch-case</li><li>在上一个版本中，Servlet中充斥着大量的switch-case，如果项目的业务规模扩大，那么会有很多的Servlet，也就意味着会有很多的switch-case，这是一种代码冗余。因此，我们在servlet中使用了反射技术，<strong>规定operate的值和方法名一致</strong>，那么接收到operate的值是什么就表明我们需要调用对应的方法进行响应，如果找不到对应的方法，则抛异常</li><li>在上一个版本中我们使用了反射技术，但是其实还是存在一定的问题：<strong>每一个servlet中都有类似的反射技术的代码。因此继续抽取，设计了中央控制器类：DispatcherServlet</strong>，DispatcherServlet这个类的工作分为两大部分：<ul><li>根据url定位到能够处理这个请求的controller组件：<ul><li>从url中提取servletPath : /fruit.do -&gt; fruit</li><li>根据fruit找到对应的组件:FruitController ，这个对应的依据我们存储在applicationContext.xml中</li><li>&lt;bean id="fruit"class="com.atguigu.fruit.controllers.FruitController/&gt;</li><li>通过DOM技术我们去解析XML文件，在中央控制器中形成一个beanMap容器，用来存放所有的Controller组件</li><li>根据获取到的operate的值定位到我们FruitController中需要调用的方法</li></ul></li><li>调用Controller组件中的方法：<ul><li>获取参数 获取即将要调用的方法的参数签名信息: Parameter[] parameters= method.getParameters(); 通过parameter.getName()获取参数的名称；准备了Object[] parameterValues 这个数组用来存放对应参数的参数值另外，我们需要考虑参数的类型问题，需要做类型转化的工作。通过parameter.getType()获取参数的类型</li><li>执行方法 Object returnObj = method.invoke(controllerBean ,parameterValues);</li><li>视图处理，进行重定向 String returnStr = (String)returnObj;if(returnStr.startWith("redirect:")){ .... }</li></ul></li></ul></li></ol><h3 id="四servlet-进阶">四、Servlet 进阶：</h3><h4 id="初始化方法init">1、初始化方法Init</h4><p>Servlet中的初始化方法有两个：init() , init(config) <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="built_in">this</span>.config = config ;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们想要在Servlet初始化时做一些准备工作，那么我们可以重写init方法，可以通过如下步骤去获取初始化设置的数据</p><ul><li>获取config对象：ServletConfig config = getServletConfig();</li><li>获取初始化参数值： config.getInitParameter(key);</li></ul><p>这些初始化参数值是可以在web.xml中进行配置的，然后可以在init中获取</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>world<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以通过注解方式配置获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &#123;&quot;/demo01&quot;&#125; ,</span></span><br><span class="line"><span class="meta">initParams = &#123;</span></span><br><span class="line"><span class="meta">        @WebInitParam(name=&quot;hello&quot;,value=&quot;world&quot;),</span></span><br><span class="line"><span class="meta">        @WebInitParam(name=&quot;uname&quot;,value=&quot;jim&quot;)</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure><h4id="servletcontext和context-param">2、ServletContext和&lt;context-param&gt;</h4><ul><li><p>获取ServletContext的方法</p><ul><li><p>在初始化方法中：</p><p>ServletContxt servletContext = getServletContext();</p></li><li><p>在服务方法中也可以通过request对象获取，也可以通过session获取：</p><p>request.getServletContext(); session.getServletContext()</p></li></ul></li><li><p>获取初始化值： servletContext.getInitParameter();</p></li></ul><h4 id="mvc各层说明">3、MVC各层说明</h4><ul><li><p>View 视图层：用于做数据展示以及和用户交互的一个界面</p></li><li><p>Controller控制层：能够接受客户端的请求，具体的业务功能还是需要借助于<strong>模型组件</strong>来完成</p></li><li><p>Model 模型层：模型分为很多种：有比较简单的pojo/vo(valueobject)，有业务模型组件，有数据访问层组件</p><ul><li><p>pojo/vo : 值对象</p></li><li><p>DAO(Data Access Object) ：数据访问对象</p></li><li><p>BO(Business Object) ： 业务对象</p></li></ul></li><li><p>DAO中的方法都是单精度方法或者称之为细粒度方法。什么叫单精度？一个方法只考虑一个操作，比如添加，那就是insert操作、查询那就是select操作...</p></li><li><p>BO中的方法属于业务方法，也实际的业务是比较复杂的，因此业务方法的粒度是比较粗的</p></li></ul><p>​根据上述思想，我们需要加一层Service业务模型组件：Service中的业务模型组件会调用DAO数据访问层组件，由此一来，Controller层不需要关注业务功能，他只要能够接受客户端的请求并借助模型组件来完成请求就可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FruitService</span> &#123;</span><br><span class="line">    <span class="comment">//获取指定页面的库存列表信息</span></span><br><span class="line">    List&lt;Fruit&gt; <span class="title function_">getFruitList</span><span class="params">(String keyword , Integer pageNo)</span>;</span><br><span class="line">    <span class="comment">//添加库存记录信息</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addFruit</span><span class="params">(Fruit fruit)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">FruitService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">FruitDAOImpl</span> <span class="variable">fruitDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitDAOImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Fruit&gt; <span class="title function_">getFruitList</span><span class="params">(String keyword, Integer pageNo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fruitDAO.getFruitList(keyword,pageNo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFruit</span><span class="params">(Fruit fruit)</span> &#123;</span><br><span class="line">        fruitDAO.addFruit(fruit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​ 至此为止，整个访问架构就如下所示：</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221116175837292.png" /></p><h4 id="ioc实现">4、IOC实现：</h4><p>​ IOC(Inversion ofControl)控制反转：使用对象时,由主动new产生对象转换成,从外部提供对象,在这个过程中,对象的创建控制权由程序转移到外部,此思想称为控制反转</p><p>​为了实现高内聚低耦合的目标，使得层与层之间的依赖关系不那么强。也就是说，我们下层的FruitService删除了以后，不会直接的引起FruitController报错。在先前，我们的FruitController是如下写的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">FruitService</span> <span class="variable">fruitService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">update</span><span class="params">(Integer fid , String fname , Integer price , Integer fcount , String remark )</span>&#123;</span><br><span class="line">        fruitService.updateFruit(<span class="keyword">new</span> <span class="title class_">Fruit</span>(fid,fname, price ,fcount ,remark ));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:fruit.do&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​第一步，我们需要将此处的<code>new FruitServiceImpl()</code>改为<code>null</code>，然后将加载类这个事情交给配置文件和另一个专门加载类的对象，如下所示，修改applicationContext.xml</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;fruitDAO&quot;</span> class=<span class="string">&quot;com.atguigu.fruit.dao.impl.FruitDAOImpl&quot;</span>/&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;fruitService&quot;</span> class=<span class="string">&quot;com.atguigu.fruit.service.impl.FruitServiceImpl&quot;</span>&gt;</span><br><span class="line">        &lt;!-- property标签用来表示属性；name表示属性名；ref表示引用其他bean的id值--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;fruitDAO&quot;</span> ref=<span class="string">&quot;fruitDAO&quot;</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;fruit&quot;</span> class=<span class="string">&quot;com.atguigu.fruit.controllers.FruitController&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;fruitService&quot;</span> ref=<span class="string">&quot;fruitService&quot;</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>​然后，我们新建如下接口和类：此类可以通过反射机制，解除层与层之间的耦合，<strong>通过xml配置文件的方式来指定层与层之间的依赖关系，而不是将层与层之间的关系写死在代码内部。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.myssm.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactory</span> &#123;</span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(String id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassPathXmlApplicationContext</span> <span class="keyword">implements</span> <span class="title class_">BeanFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; beanMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">            <span class="comment">//1.创建DocumentBuilderFactory</span></span><br><span class="line">            <span class="type">DocumentBuilderFactory</span> <span class="variable">documentBuilderFactory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">            <span class="comment">//2.创建DocumentBuilder对象</span></span><br><span class="line">            <span class="type">DocumentBuilder</span> <span class="variable">documentBuilder</span> <span class="operator">=</span> documentBuilderFactory.newDocumentBuilder() ;</span><br><span class="line">            <span class="comment">//3.创建Document对象</span></span><br><span class="line">            <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> documentBuilder.parse(inputStream);</span><br><span class="line">            <span class="comment">//4.获取所有的bean节点</span></span><br><span class="line">            <span class="type">NodeList</span> <span class="variable">beanNodeList</span> <span class="operator">=</span> document.getElementsByTagName(<span class="string">&quot;bean&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;beanNodeList.getLength() ; i++)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">beanNode</span> <span class="operator">=</span> beanNodeList.item(i);</span><br><span class="line">                <span class="keyword">if</span>(beanNode.getNodeType() == Node.ELEMENT_NODE)&#123;</span><br><span class="line">                    <span class="type">Element</span> <span class="variable">beanElement</span> <span class="operator">=</span> (Element)beanNode ;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">beanId</span> <span class="operator">=</span>  beanElement.getAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> beanElement.getAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">                    <span class="type">Class</span> <span class="variable">beanClass</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">                    <span class="comment">//创建bean实例</span></span><br><span class="line">                    <span class="type">Object</span> <span class="variable">beanObj</span> <span class="operator">=</span> beanClass.newInstance() ;</span><br><span class="line">                    <span class="comment">//将bean实例对象保存到map容器中</span></span><br><span class="line">                    beanMap.put(beanId , beanObj) ;</span><br><span class="line">                    <span class="comment">//到目前为止，此处需要注意的是，bean和bean之间的依赖关系还没有设置</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//5.组装bean之间的依赖关系</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;beanNodeList.getLength() ; i++)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">beanNode</span> <span class="operator">=</span> beanNodeList.item(i);</span><br><span class="line">                <span class="keyword">if</span>(beanNode.getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">                    <span class="type">Element</span> <span class="variable">beanElement</span> <span class="operator">=</span> (Element) beanNode;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">beanId</span> <span class="operator">=</span> beanElement.getAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                    <span class="type">NodeList</span> <span class="variable">beanChildNodeList</span> <span class="operator">=</span> beanElement.getChildNodes();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; beanChildNodeList.getLength() ; j++) &#123;</span><br><span class="line">                        <span class="type">Node</span> <span class="variable">beanChildNode</span> <span class="operator">=</span> beanChildNodeList.item(j);</span><br><span class="line">                        <span class="keyword">if</span>(beanChildNode.getNodeType()==Node.ELEMENT_NODE &amp;&amp; <span class="string">&quot;property&quot;</span>.equals(beanChildNode.getNodeName()))&#123;</span><br><span class="line">                            <span class="type">Element</span> <span class="variable">propertyElement</span> <span class="operator">=</span> (Element) beanChildNode;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">propertyName</span> <span class="operator">=</span> propertyElement.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                            <span class="type">String</span> <span class="variable">propertyRef</span> <span class="operator">=</span> propertyElement.getAttribute(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">                            <span class="comment">//1) 找到propertyRef对应的实例</span></span><br><span class="line">                            <span class="type">Object</span> <span class="variable">refObj</span> <span class="operator">=</span> beanMap.get(propertyRef);</span><br><span class="line">                            <span class="comment">//2) 将refObj设置到当前bean对应的实例的property属性上去</span></span><br><span class="line">                            <span class="type">Object</span> <span class="variable">beanObj</span> <span class="operator">=</span> beanMap.get(beanId);</span><br><span class="line">                            <span class="type">Class</span> <span class="variable">beanClazz</span> <span class="operator">=</span> beanObj.getClass();</span><br><span class="line">                            <span class="type">Field</span> <span class="variable">propertyField</span> <span class="operator">=</span> beanClazz.getDeclaredField(propertyName);</span><br><span class="line">                            propertyField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                            propertyField.set(beanObj,refObj);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParserConfigurationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SAXException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> beanMap.get(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，有了如下组件以后，在DispatcherController中的init()函数里的加载也可以挪到这里面来进行。修改DispathcerController的init()方法。所有的内容统一从BeanFactory中进行加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BeanFactory beanFactory ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="built_in">super</span>.init();</span><br><span class="line">    beanFactory = <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p><strong>IOC 控制反转：</strong></p><ol type="1"><li><p>之前在Servlet中，我们创建service对象 ， FruitService fruitService= new FruitServiceImpl();</p><ul><li><p>这句话如果出现在servlet中的某个方法内部，那么这个fruitService的作用域（生命周期）应该就是这个方法级别；</p></li><li><p>如果这句话出现在servlet的类中，也就是说fruitService是一个成员变量，那么这个fruitService的作用域（生命周期）应该就是这个servlet实例级别</p></li></ul></li><li><p>之后我们在applicationContext.xml中定义了这个fruitService。然后通过解析XML，产生fruitService实例，存放在beanMap中，这个beanMap在一个BeanFactory中</p><ul><li>因此，我们转移（改变）了之前的service实例、dao实例等等他们的生命周期。<strong>控制权从程序员转移到BeanFactory。这个现象我们称之为控制反转</strong></li></ul></li></ol><p><strong>DI 依赖注入：</strong></p><ol type="1"><li>之前我们在控制层出现代码：FruitService fruitService = newFruitServiceImpl()；那么，控制层和service层存在耦合。</li><li>之后，我们将代码修改成FruitService fruitService = null ;然后，在配置文件中配置:从而打破这种耦合</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;fruit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;FruitController&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;fruitService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;fruitService&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4id="过滤器filter其实就是类似请求和响应拦截器">5、过滤器Filter(其实就是类似请求和响应拦截器)</h4><ol type="1"><li><p>Filter也属于Servlet规范</p></li><li><p>Filter开发步骤：新建类实现Filter接口，然后实现其中的三个方法：init、doFilter、destroy配置Filter，可以用注解@WebFilter，也可以使用xml文件 <filter><filter-mapping></p></li><li><p>Filter在配置时，和servlet一样，也可以配置通配符，例如 <spanclass="citation"data-cites="WebFilter">@WebFilter</span>("*.do")表示拦截所有以.do结尾的请求</p></li><li><p>过滤器链（遵循洋葱模型） 1）执行的顺序依次是： A B C demo03 C2 B2A22）如果采取的是注解的方式进行配置，那么过滤器链的拦截顺序是按照<strong>全类名的先后顺序排序的</strong></p><p>3）如果采取的是xml的方式进行配置，那么按照配置的先后顺序进行排序</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;*.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Filter01</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">        <span class="comment">//响应发出去之前要执行的内容</span></span><br><span class="line">        System.out.println(<span class="string">&quot;A2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事务管理transaction">6、事务管理Transaction</h4><h5 id="为什么需要事务管理">1）为什么需要事务管理？</h5><ul><li>原因很简单：因为我们知道Service往往是由多个DAO模块组件完成的，在之前，我们的数据回滚和提交操作都在DAO内部，这样的话无法定义Service的执行成功或失败。所以我们需要在代码中进行管理：</li><li>大致解决思路：使用一个Filter，执行如下流程，其实就是类似一个请求异常捕获机制，那么难点就在于我们需要使得多次DAO操作使用的数据库连接都是同一个，才能让他们在数据库的同一个事务内。如果以函数思想，那么所有的DAO操作都需要传入数据库Connection对象，然后保持Connetion不关闭才可以，有一点点麻烦</li></ul><p><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221116221959452.png" /></p><ul><li>这个时候需要引入一个概念叫ThreadLocal利用这个技术能够实现如上的需求</li><li>这个类有两个方法，set和get，通过set方法可以将Connection对象放到ThreadLocal中，后续就可以通过get方法可以将Connection对象取出，继续使用。</li></ul><h5id="事务管理的实现opensessioninviewfilter">2）事务管理的实现：OpenSessionInViewFilter</h5><p>首先定义ConnUtil类，统一管理和数据库的连接，也就是说用于取代原来的BaseDAO类：</p><p>这个工具类负责创建conncetion,获取connection，关闭connection</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DRIVER</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/fruitdb?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PWD</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title function_">createConn</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.加载驱动</span></span><br><span class="line">            Class.forName(DRIVER);</span><br><span class="line">            <span class="comment">//2.通过驱动管理器获取连接对象</span></span><br><span class="line">            <span class="keyword">return</span> DriverManager.getConnection(URL, USER, PWD);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConn</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line">        <span class="keyword">if</span>(conn==<span class="literal">null</span>)&#123;</span><br><span class="line">            conn =createConn();</span><br><span class="line">            threadLocal.set(conn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get() ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeConn</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line">        <span class="keyword">if</span>(conn==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!conn.isClosed())&#123;</span><br><span class="line">            conn.close();</span><br><span class="line">            threadLocal.set(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>随后定义事务管理类：负责开启事务、提交事务、回滚事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启事务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">beginTrans</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        ConnUtil.getConn().setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ConnUtil.getConn();</span><br><span class="line">        conn.commit();</span><br><span class="line">        ConnUtil.closeConn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回滚事务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ConnUtil.getConn();</span><br><span class="line">        conn.rollback();</span><br><span class="line">        ConnUtil.closeConn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然就可以定义我们的OpenSessionInViewFilter类了，来做统一的上层的事务管理：逻辑和之前图上分析的一摸一样。所有底层的异常都不要自己处理，都只要往外抛就可以了。或者Catch到了以后加一层信息再往外抛</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;*.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OpenSessionInViewFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            TransactionManager.beginTrans();</span><br><span class="line">            System.out.println(<span class="string">&quot;开启事务....&quot;</span>);</span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">            TransactionManager.commit();</span><br><span class="line">            System.out.println(<span class="string">&quot;提交事务...&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TransactionManager.rollback();</span><br><span class="line">                System.out.println(<span class="string">&quot;回滚事务....&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4id="关于threadlocal的get方法和set方法原理">7、关于ThreadLocal的Get()方法和Set()方法原理：</h4><p>​ ThreadLocal称之为本地线程 。我们可以通过set方法在<strong>当前线程上存储数据、通过get方法在当前线程上</strong>获取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">   <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread(); <span class="comment">//获取当前的线程</span></span><br><span class="line">   <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);    <span class="comment">//每一个线程都维护各自的一个容器（ThreadLocalMap）</span></span><br><span class="line">   <span class="keyword">if</span> (map != <span class="literal">null</span>) map.set(<span class="built_in">this</span>, value);          </span><br><span class="line">   <span class="comment">//这里的key对应的是ThreadLocal，因为我们的组件中需要传输（共享）的对象可能会有多个（不止Connection）</span></span><br><span class="line">   <span class="keyword">else</span> createMap(t, value);   <span class="comment">//默认情况下map是没有初始化的，那么第一次往其中添加数据时，会去初始化</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread(); <span class="comment">//获取当前的线程</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);    <span class="comment">//获取和这个线程相关的ThreadLocalMap（也就是工作纽带的集合）</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">    ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>); <span class="comment">//this指的是ThreadLocal对象，通过它知道哪一个工作纽带</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;     <span class="comment">//entry.value就可以获取到工具箱了</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="listener监听器">7、Listener监听器</h4><ul><li>ServletContextListener -监听ServletContext对象的创建和销毁的过程</li><li>HttpSessionListener - 监听HttpSession对象的创建和销毁的过程</li><li>ServletRequestListener -监听ServletRequest对象的创建和销毁的过程</li><li>ServletContextAttributeListener -监听ServletContext的保存作用域的改动(add,remove,replace)</li><li>HttpSessionAttributeListener -监听HttpSession的保存作用域的改动(add,remove,replace)</li><li>ServletRequestAttributeListener -监听ServletRequest的保存作用域的改动(add,remove,replace)</li><li>HttpSessionBindingListener -监听某个对象在Session域中的创建与移除</li><li>HttpSessionActivationListener -监听某个对象在Session域中的序列化和反序列化</li></ul>]]></content>
    
    
    <summary type="html">Tomcat与Servelet入门</summary>
    
    
    
    <category term="⑧ 工程类笔记" scheme="https://blog.fantast.top/categories/%E2%91%A7-%E5%B7%A5%E7%A8%8B%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JavaWeb" scheme="https://blog.fantast.top/categories/%E2%91%A7-%E5%B7%A5%E7%A8%8B%E7%B1%BB%E7%AC%94%E8%AE%B0/JavaWeb/"/>
    
    
    <category term="Tomcat" scheme="https://blog.fantast.top/tags/Tomcat/"/>
    
    <category term="Servelet" scheme="https://blog.fantast.top/tags/Servelet/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb中一些技术的逻辑关系梳理</title>
    <link href="https://blog.fantast.top/2022/11/12/fd10fe3b2e47/"/>
    <id>https://blog.fantast.top/2022/11/12/fd10fe3b2e47/</id>
    <published>2022-11-12T07:55:19.000Z</published>
    <updated>2022-11-15T03:21:54.361Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一尚硅谷给出的java学习路线">一、尚硅谷给出的JAVA学习路线：</h3><p>JavaSE --&gt; MySQL--&gt; JDBC --&gt; JavaWeb --&gt; Spring5 --&gt;SpringMVC --&gt; MyBatis--&gt; Maven --&gt; Ssm框架整合案例 --&gt;Git/GitHub --&gt; Redis6 --&gt; MySQL高级优化 --&gt; MyBatisPlus --&gt;Spring注解驱动开发 --&gt; ZooKeeper --&gt; Dubbo --&gt;消息中间件ActiveMQ --&gt; RabbitMQ --&gt;RocketMQ--&gt;SpringBoot2--&gt; SpringCloud</p><h4 id="javase">1、JavaSE:</h4><p>​JAVA语言学习基础，关于一些对象、类、继承、接口、异常、集合并发等等。</p><h4 id="mysql">2、MYSQL：</h4><p>​ 最常用的开源数据库，项目开发中必备内容</p><h4 id="jdbc">3、JDBC:</h4><pre><code>JDBC（Java Database Connectivity）是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口（一组API）。</code></pre><p>​JDBC为访问不同的数据库提供了一种统一的途径，为开发者屏蔽了一些细节问题。JDBC的目标是<strong>使java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</strong></p><h4 id="javaweb">4、JavaWeb</h4><h5 id="htmlcssjs">1）html/css/js：</h5><p>​前端web网页三剑客，构成静态网站的最底层的三个语言。属于web资源中的静态资源。</p><h5 id="jquery">2）jQuery：</h5><p>​ jQuery，是辅助JavaScript开发的js类库。它实现了很多浏览器的兼容问题。</p><h5 id="xml">3）XML：</h5><p>​XML是可扩展的标记性语言。可以用于保存数据、做为项目或者模块的配置文件或做为网络传输数据的格式（现在ISON为主）。</p><h5 id="nginx">4）Nginx：</h5><p>​Nginx优点：负载均衡、反向代理、处理静态文件优势。nginx处理静态请求的速度高于apache；</p><p>​Apache优点：相对于Tomcat服务器来说处理静态文件是它的优势，速度快。Apache是静态解析，适合静态HTML、图片等。</p><p>​ Tomcat：<ahref="https://www.zhihu.com/search?q=动态解析容器&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A226688632%7D">动态解析容器</a>，处理动态请求，是编译JSP，Nginx有动态分离机制，静态请求直接就可以通过Nginx处理，动态请求才转发请求到后台交由Tomcat进行处理.</p><p>​ Tomcat是由 Apache 组织提供的一种Web 服务器，提供对jsp 和Servlet的支持。它是一种轻量级的javaWeb容器（服务器），也是当前应用最广的JavaWeb 服务器。</p><h5 id="serveletjava程序抽象接口">5）Servelet—java程序（抽象接口）</h5><p>​ Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自Web 浏览器或其他 HTTP 客户端的请求和 HTTP服务器上的数据库或应用程序之间的中间层。</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221110165842713.png" /></p><h5 id="jsp语言需要依托tomcat">6）JSP—语言，需要依托tomcat</h5><p>​ <strong>JSP 与 PHP、ASP、ASP.NET等语言类似，运行在服务端的语言。</strong></p><p>​ JSP 技术是以 Java 语言作为脚本语言的，JSP 网页为整个服务器端的 Java库单元提供了一个接口来服务于HTTP的应用程序。先前使用Serverlet开发的话，返回的HTML需要以比较复杂的过程进行构建返回，有了JSP以后，就可以以模板的形式进行渲染返回了。</p><h5 id="spring轻量java框架">7）Spring—轻量java框架</h5><p>​ Spring是Java EE编程领域的一个轻量级开源框架，该框架由一个叫RodJohnson的程序员在 2002年最早提出并随后创建，是为了解决企业级编程开发中的复杂性，实现敏捷开发的应用型框架。</p><h5 id="springmvc">8）SpringMVC</h5><h5 id="mybatis">9）MyBatis</h5><h5 id="maven">10）Maven</h5><h5 id="section">11）</h5>]]></content>
    
    
    <summary type="html">笔者认为在学习路径中，一些技术的相关联性以及演变路径十分重要，不能仅了解最新的框架而不了解底层逻辑。故而本篇整理了一些JavaWeb中一些技术的逻辑关系梳理，按照网上的某些Java学习路线，结合现有的理解，对一些框架和技术给出的定位注解</summary>
    
    
    
    <category term="⑧ 工程类笔记" scheme="https://blog.fantast.top/categories/%E2%91%A7-%E5%B7%A5%E7%A8%8B%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JavaWeb" scheme="https://blog.fantast.top/categories/%E2%91%A7-%E5%B7%A5%E7%A8%8B%E7%B1%BB%E7%AC%94%E8%AE%B0/JavaWeb/"/>
    
    
    <category term="Cloud Native" scheme="https://blog.fantast.top/tags/Cloud-Native/"/>
    
  </entry>
  
  <entry>
    <title>事务、事务日志与锁</title>
    <link href="https://blog.fantast.top/2022/11/10/02d829a87e69/"/>
    <id>https://blog.fantast.top/2022/11/10/02d829a87e69/</id>
    <published>2022-11-10T09:09:19.000Z</published>
    <updated>2022-11-10T07:50:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一事务概述">一、事务概述</h3><h4 id="acid特性">1、ACID特性：</h4><ul><li><p>Atomicity：原子性</p></li><li><p>Consistency：一致性，一致性是指事务执行前后，<strong>数据从一个合法性状态变换到另外一个合法性状态。</strong>这种状态是语义上的而不是语法上的，跟具体的业务有关。</p></li><li><p>Isolation:隔离性，一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰.</p></li><li><p>Durability：持久性，指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。<strong>持久性是通过事务日志来保证的。日志包括了重做日志和回滚日志。</strong>当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。</p></li></ul><h4 id="事务的状态">2、事务的状态：</h4><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221110143622797.png" style="zoom: 33%;" /></p><h4 id="显式事务和隐式事务">3、显式事务和隐式事务：</h4><h5 id="显式事务">1）显式事务：</h5><ol type="1"><li><p>START TRANSACTION [READ ONLY/READ WRITE/WITH CONSISTENTSNAPSHOT]</p><p>显式开启一个事务,READ ONLY标识当前事务是一个只读事务，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。READ WRITE：标识当前事务是一个读写事务，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。</p></li><li><p>DML语句</p></li><li><p>COMMIT / ROLLBACK / ROLLBACK TO [SAVEPOINT]</p></li></ol><h5 id="隐式事务">2）隐式事务：</h5><ul><li><p>Mysql中有系统变量：autocommit，当该变量为True时，每个DML语句执行后都会默认提交。【除了显式开启事务内的DML】</p></li><li><p>当上述变量为False时，其在何时会隐式的提交数据呢？</p><ul><li><p>DDL 数据定义语言执行的时候</p></li><li><p>隐式使用或修改mysql数据库中的表</p></li><li><p>当我们在一个事务还没提交或者回滚时就又使用START TRANSACTION或者BEGIN 语句开启了另一个事务时，会隐式的提交上一个事务。</p></li><li><p>使用LOCK TABLES 、UNLOCK TABLES等关于锁定的语句也会隐式的提交前边语句所属的事务。</p></li><li><p>加载数据LOAD DATA，以及关于MYSQL复制的一些操作</p></li></ul></li></ul><h4 id="事务类型">4、事务类型：</h4><p>​ MYSQL中的事务类型参数：completion_type</p><ul><li>completion_type=0，默认情况，执行COMMIT时提交事务，执行下一个事务的时候还需要使用START_TRANSACTION或BEGIN来开启</li><li>completion_type=1，提交事务后相当于执行了COMMIT ANDCHAIN，相当于提交事务后又自动开启了一个相同隔离级别的事务。</li><li>completion_type=2，提交事务后会自动与服务器断开连接。</li></ul><h4 id="事务的隔离级别">5、事务的隔离级别：</h4><p>​事务有隔离性的特性，理论上在某个事务对某个数据进行访问时，其他事务应该进行排队，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样对性能影响太大，我们既想保持事务的隔离性，又想让服务器在处理访问同一数据的多个事务时性能尽量高些，如何权衡？</p><h5id="访问相同数据的事务不串行可能导致的问题">1）访问相同数据的事务不串行可能导致的问题：</h5><ul><li>脏写：事务Session A 修改了另一个<strong>未提交事务Session B修改过的数据</strong>，那就意味着发生了脏写</li><li>脏读：Session A 读取了已经被 Session B更新但还没有被提交的字段，之后若 Session B 回滚，Session A读取的内容就是临时且无效的。</li><li>不可重复读：Session A 读取了一个字段，然后 Session B 更新了该字段。之后Session A 再次读取同一个字段，值就不同了。那就意味着发生了不可重复读。</li><li>幻读：Session A 从一个表中读取了一个字段, 然后 Session B在该表中插入了一些新的行。 之后, 如果 Session A 再次读取同一个表,就会多出几行。（幻读，并不是说两次读取获取的结果集不同，幻读侧重的方面是某一次的select操作得到的结果所表征的数据状态无法支撑后续的业务操作。更为具体一些：select某记录是否存在，不存在，准备插入此记录，但执行insert态无法支撑后续的业务操作。更为具体一些：select某记录是否存在，不存在，准备插入此记录，但执行insert时发现此记录已存在，无法插入，此时就发生了幻读。）</li></ul><h5 id="四种隔离级别">2）四种隔离级别：</h5><p>​对于上述四种问题，其严重性实际上排序如下：脏写&gt;脏读&gt;不可重复读&gt;幻读，<strong>我们愿意舍弃一部分隔离性来换取一部分性能在这里就体现在：设立一些隔离级别，隔离级别越低，并发问题发生的就越多。SQL标准中设立了4个隔离级别：</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221110151010412.png" style="zoom: 33%;" /></p><ul><li>READ UNCOMMITTED：读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。</li><li>READ COMMITTED：读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。</li><li>REPEATABLE READ：可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。这是MySQL的默认隔离级别。</li><li>SERIALIZABLE：可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读</li></ul><p>不同的隔离级别有不同的现象，并有不同的锁和并发机制，隔离级别越高，数据库的并发性能就越差，4种事务隔离级别与并发性能的关系如下：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221110151047171.png" style="zoom: 33%;" /></p><p>​ MySQL的<strong>默认隔离级别为REPEATABLE READ</strong></p><h3 id="二事务日志">二、事务日志：</h3><p>​事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？</p><ul><li><p>事务的隔离性由锁机制实现。</p></li><li><p>事务的原子性、一致性和持久性由事务的 redo 日志和undo日志来保证。</p><ul><li><p>REDO LOG称为重做日志，提供再写入操作，恢复提交事务修改的页操作，<strong>用来保证事务的持久性</strong>。</p></li><li><p>UNDO LOG称为回滚日志，回滚行记录到某个特定版本，<strong>用来保证事务的原子性、一致性</strong>。</p></li><li><p>REDO LOG是存储引擎层Innodb进行记录的，记录的是物理级别的一些操作，比如页号偏移量写入了啥数据，主要为了保证数据的可靠性。</p></li><li><p>UNDO LOG是存储引擎层Innodb进行记录的，记录的是逻辑操作日志，比如对某一行数据进行INSERT语句操作，那么UNDOLOG就记录一条与之相反的DELETE操作，主要用于事务回滚和MVCC。</p></li></ul></li></ul><h4 id="redo日志">1、REDO日志：</h4><p>​InnoDB存储引擎是以页为单位来管理存储空间的。在真正访问页面之前，需要把在磁盘上的页缓存到内存中的BufferPool之后才可以访问。所有的变更都必须先更新缓冲池中的数据，<strong>然后缓冲池中的脏页会以一定的频率被刷入磁盘（checkPoint机制），通过缓冲池来优化CPU和磁盘之间的鸿沟，这样就可以保证整体的性能不会下降太快。</strong></p><h5 id="why需要redo日志">1）Why需要REDO日志？</h5><ul><li>缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然而由于checkpoint并不是每次变更的时候就触发的，而是master线程隔一段时间去处理的。<strong>所以最坏的情况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。</strong></li><li>事务包含持久性的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失，所以我们需要一个解决方案来解决。</li></ul><h5 id="如何解决上述问题">2）如何解决上述问题？</h5><ul><li>解决方案1：可以在事务提交完成之前，将该事务所修改的所有页面都刷到磁盘上，但是这种做法有问题：<ul><li>修改量与刷新磁盘工作量严重不成比例。只修改1个字节，但是要刷1个页16KB的数据到磁盘上</li><li>随机的IO刷盘是比较慢的</li></ul></li><li>解决方案2：REDO日志：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。<strong>所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把修改了哪些东西记录一下就好。</strong>比如，某个事务将系统表空间中第10号页面中偏移量为100处的那个字节的值 1 改成2。我们只需要记录一下：将第0号表空间的10号页面的偏移量为100处的值更新为2。同时：InnoDB引擎的事务采用了WAL技术（Write-AheadLogging），这种技术的思想就是<strong>先写日志再写磁盘，只有日志写入成功，才算事务提交成功，</strong>这样即使事务提交了但是脏页还没有写入磁盘，还可以靠已经写入磁盘的redolog来进行恢复。当发生宕机且数据未刷到磁盘的时候，可以通过redolog来恢复，保证ACID中的D，这就是redo log的作用。</li></ul><h5 id="redo日志的优缺点">3）REDO日志的优缺点：</h5><ul><li>redo日志降低了刷盘频率，且因为其占用空间小，所以刷盘很快</li><li>redo日志是顺序写入磁盘的，也就是说是顺序IO，比直接写磁盘的随机IO快的多。</li><li>事务执行的过程中，redolog是在不停的记录的，并不是只有提交了才会写。</li></ul><h5 id="redo日志的组成与刷盘策略">4）REDO日志的组成与刷盘策略：</h5><p>​</p><h4 id="undo日志">2、UNDO日志：</h4><h5 id="why需要undo日志">1）Why需要UNDO日志？</h5><p>​ redo log是事务持久性的保证，undolog是事务原子性的保证。在事务中更新数据的前置操作其实是要先写入一个undolog。</p><p>​但有时候事务执行到一半会出现一些情况，我们需要把数据改回原先的样子，这个过程称之为回滚，这样就可以造成一个假象：这个事务看起来什么都没做，所以符合原子性要求。</p><p>​ 所以我们需要执行以下操作：</p><p>​每当我们要对一条记录做改动时（这里的改动可以指INSERT、DELETE、UPDATE），都需要“留一手“—-把回滚时所需的东西记下来。比如：</p><ul><li>你插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。（对于每个INSERT，InnoDB存储引擎会完成一个DELETE）</li><li>你删除了一条记录，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。（对于每个DELETE，InnoDB存储引擎会执行一个INSERT）</li><li>你修改了一条记录，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。（对于每个UPDATE，InnoDB存储引擎会执行一个相反的UPDATE，将修改前的行放回去）</li><li>MySQL把这些为了回滚而记录的这些内容称之为撤销日志或者回滚日志（即undolog）。注意，由于查询操作（SELECT）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的undo日志。</li></ul><p>​ <strong>此外，undo log会产生redo log，也就是undolog的产生会伴随着redo log的产生，这是因为undolog也需要持久性的保护。</strong></p><h5 id="undo-日志的作用">2）UNDO 日志的作用：</h5><ul><li><p>回滚数据：<strong>undo是逻辑日志，因此只是将数据库逻辑地恢复到原来的样子。</strong>所有修改都被逻辑地取消了，<strong>但是数据结构和页本身在回滚之后可能大不相同。</strong>因为在多用户并发系统中，可能会有数千个并发事务，其主要的任务就是协调对数据记录的并发访问。因此不能在物理上将一个页回滚到事务开始的时候，会影响别的事务。</p></li><li><p>MVCC多版本并发控制：在InnoDB字储引擎中MVCC的实现是通过undo来完成。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。</p></li></ul><h5 id="undo-日志的存储结构">3）UNDO 日志的存储结构：</h5><h3 id="三锁">三、锁：</h3>]]></content>
    
    
    <summary type="html">Chap15——Mysql 事务、事务日志与锁</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>数据库设计范式</title>
    <link href="https://blog.fantast.top/2022/11/10/e7fbd86c0b92/"/>
    <id>https://blog.fantast.top/2022/11/10/e7fbd86c0b92/</id>
    <published>2022-11-10T07:09:19.000Z</published>
    <updated>2022-11-10T06:20:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一范式">一、范式</h3><p>​目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。</p><p>​一般来说，在关系型数据库设计中，最高也就遵循到BCNF，普遍还是3NF。但也不绝对，有时候为了提高某些查询性能，我们还需要破坏范式规则，也就是反规范化。</p><h3 id="二一些概念">二、一些概念：</h3><ul><li>超键：能唯一标识元组的属性集叫做超键</li><li>候选键：如果超键不包含多余的属性，则这个超键就是候选键</li><li>主键：我们自己选定，也就是从候选键中选择一个。</li><li>主属性、非主属性：包含在任一候选键中的属性称为主属性。</li></ul><h3 id="三1nf-第一范式">三、1NF 第一范式</h3><p>​需要符合每个字段的值必须具有原子性，即每个字段的值不可再次拆分。<strong>值得注意的是：字段本身的原子性是主观的</strong></p><h3 id="四2nf-第二范式">四、2NF 第二范式</h3><p>​第二范式要求，在满足第一范式的基础上，还要满足数据表里的每一条数据记录，都是可唯一标识的。</p><p>​<strong>所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分。</strong></p><ul><li>完全依赖关系：如果已知属性A、属性B可以决定得到属性C，那么（A，B）—》C就是完全依赖关系</li></ul><p>​ <strong>1NF 告诉我们字段属性需要是原子性的，而 2NF告诉我们一张表就是一个独立的对象，一张表只表达一个意思。</strong></p><h3 id="五3nf-第三范式">五、3NF 第三范式</h3><p>​第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关。</p><p>​也就是说，要求数据表中的<strong>所有非主键字段不能依赖于其他非主键字段。</strong></p><p>​（即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况，即存在“A→B→C”的决定关系）</p><p>​通俗地讲，该规则的意思是所有非主键属性之间不能有依赖关系，必须相互独立。</p><p>​<strong>符合3NF后的数据模型通俗地讲，2NF和3NF通常以这句话概括：“每个非键属性依赖于主键，依赖于整个主键，并且除了主键别无他物”。</strong></p><h3 id="六范式优缺点">六、范式优缺点：</h3><ul><li>优点：避免数据冗余</li><li>缺点：降低查询的效率，需要多表联查，还可能使得一些索引失效。</li></ul><p>​<strong>范式只是提出了设计的标准，实际上设计数据表时，未必一定要符合这些标准。开发中，我们会出现为了性能和读取效率违反范式化的原则，通过增加少量的冗余或重复的数据来提高数据库的读性能，减少关联查询，join表的次数，实现空间换取时间的目的。因此在实际的设计过程中要理论结合实际，灵活运用。</strong></p><h3 id="七反范式">七、反范式</h3><p>​当冗余信息有价值或者能大幅度提高查询效率的时候，我们才会采取反范式的优化。</p><h4 id="适用场景">1、适用场景：</h4><ul><li>增加的冗余字段需要满足两个条件：<ul><li>这个冗余字段不需要经常进行修改</li><li>这个冗余字段查询的时候不可或缺</li></ul></li><li>历史快照、历史数据的需要：<ul><li><strong>在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每次发生的订单收货信息都属于历史快照，需要进行保存，但用户可以随时修改自己的信息，这时保存这些冗余信息是非常有必要的。</strong></li><li><strong>反范式优化也常用在数据仓库的设计中，因为数据仓库通常存储历史数据，对增删改的实时性要求不强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。</strong></li></ul></li><li>数据库和数据仓库的区别：<ul><li>数据库设计的目的在于捕获数据，而数据仓库设计的目的在于分析数据；</li><li>数据库对数据的增删改实时性要求强，需要存储在线的用户数据，而数据仓库存储的一般是历史数据；</li><li>数据库设计需要尽量避免冗余，但为了提高查询效率也允许一定的冗余度，而数据仓库在设计上更偏向采用反范式设计。</li></ul></li></ul><h3 id="八bcnf-巴斯范式">八、BCNF 巴斯范式：</h3><p>​若一个关系达到了第三范式，并且它只有一个候选键，或者它的每个候选键都是单属性，则该关系自然达到BCNF</p><p>​ BCNF 在 3NF的基础上消除了主属性对候选键的部分依赖或者传递依赖关系。</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221110093440365.png" /></p><ul><li>其满足第三范式，但是管理员依赖于仓库名，所以不符合BCNF，应该拆解成如下方式：</li><li>根据 BCNF 的要求，我们需要把仓库管理关系 warehouse_keeper表拆分成下面这样：<ul><li>仓库表：（仓库名，管理员）</li><li>库存表：（仓库名，物品名，数量）</li></ul></li></ul><h3 id="九er模型实体属性和关系">九、ER模型——实体、属性和关系</h3><ul><li>强实体 &amp; 弱实体：不需要依赖其他任何实体的为强实体</li><li>可以独立存在的称为实体，不可再分的称为属性。</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221110095158493.png" /></p><ul><li><p>ER模型细化：加上相关属性内容</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221110095247151.png" /></p></li><li><p>随后我们可以通过ER模型转换至数据表：</p></li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221110095326103.png" /></p><h3 id="十数据库对象编写建议">十、数据库对象编写建议：</h3><h4 id="关于数据库">1、关于数据库：</h4><ul><li>创建数据库时必须显式指定字符集，并且字符集只能是utf8或者utf8mb4</li><li>对于程序连、接数据库账号，遵循权限最小原则。使用数据库账号只能在一个DB下使用，不准跨库。程序使用的账号原则上不准有drop权限。</li></ul><h4 id="关于数据表">2、关于数据表：</h4><ul><li>创建表时必须显式指定字符集为utf8或utf8mb4。</li><li>创建表时必须显式指定表存储引擎类型。如无特殊需求，一律为InnoDB</li><li>字段命名应尽可能使用表达实际含义的英文单词或缩写。如：公司ID，不要使用corporation_id, 而用corp_id 即可</li><li>布尔值类型的字段命名为is_描述</li><li>建表时关于主键： 表必须有主键(1)强制要求主键为id，类型为int或bigint，且为auto_increment建议使用unsigned无符号型。</li><li><strong>表中所有字段尽量都是NOT NULL属性，业务可以根据需要定义DEFAULT值。因为使用NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题。</strong></li></ul><h4 id="关于索引">3、关于索引：</h4><ul><li>主键的名称以 pk_ 开头，唯一键以 uni_ 或 uk_ 开头，普通索引以 idx_开头，一律使用小写格式，以字段的名称或缩写作为后缀</li><li>多单词组成的columnname，取前几个单词首字母，加末单词组成column_name。如:sample表 member_id 上的索引：idx_sample_mid。</li><li>在建立索引时，多考虑建立联合索引，并把区分度最高的字段放在最前面。</li><li>在多表 JOIN 的SQL里，保证被驱动表的连接列上有索引，这样JOIN执行效率最高。</li></ul><h4 id="sql编写">4、SQL编写：</h4><ul><li>程序端SELECT语句必须指定具体字段名称，禁止写成 *。</li><li>程序端insert语句指定具体字段名称，不要写成INSERT INTO t1VALUES(…)。</li><li>线上环境，多表 JOIN 不要超过5个表。</li><li>包含了ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢</li><li>对单表的多次alter操作必须合并为一次，对于超过100W行的大表进行altertable，必须经过DBA审核，并在业务低峰期执行，多个alter需整 合在一起。因为altertable会产生表锁，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。</li><li>批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep。</li><li>事务里包含SQL不超过5个。因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等问题。</li><li>事务里更新语句尽量基于主键或UNIQUE KEY，如UPDATE… WHEREid=XX;否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。</li></ul>]]></content>
    
    
    <summary type="html">Chap14——数据库设计范式</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>数据库索引优化和查询优化</title>
    <link href="https://blog.fantast.top/2022/11/07/cd7b91a8821a/"/>
    <id>https://blog.fantast.top/2022/11/07/cd7b91a8821a/</id>
    <published>2022-11-07T07:09:19.000Z</published>
    <updated>2022-11-10T00:59:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>SQL查询优化的技术有很多，大方向上可以分为：</p><ul><li>物理查询优化（索引、表连接方式）</li><li>逻辑查询优化（换一种效率更高的执行方法）</li></ul><p>具体可以从以下四个方面进行数据库调优：</p><ul><li>索引失效、没有充分利用到索引——索引建立</li><li>关联查询太多JOIN（设计缺陷或不得已的需求）—- SQL优化</li><li>服务器调优及各个参数设置（缓冲、线程数等）——调整my.cnf</li><li>数据过多——分库分表I</li></ul><h3 id="一索引优化与查询优化">一、索引优化与查询优化</h3><h4 id="索引失效案例情况">1、索引失效案例情况：</h4><p>​从理论上而言，使用或者不使用索引都是由<strong>优化器</strong>来决定，其是基于cost开销（CostBaseOptimizer），它不是基于规则（Rule-Basedoptimizer），也不是基于语义。怎么样开销小就怎么来。另外，SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。</p><h5 id="最佳左前缀匹配法则">1）最佳左前缀匹配法则</h5><p>​MySQL可以为多个字段创建索引，一个索引可以包括16个字段。<strong>对于多列索引，过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段！索引后面的字段都无法被使用。</strong>如果查询条件中没有使用这些字段中第1个字段时，多列（或联合）索引不会被使用。</p><p>​ 索引文件具有 B-Tree的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p><h5 id="主键插入顺序">2）主键插入顺序</h5><p>​ 如果插入的主键忽大忽小，就容易导致某个数据页满了以后，数据还会往其中插入，这个时候就需要把当前页面分裂成两个页面，把本页中的一些记录移动到新创建的这个页中。<strong>页面分裂和记录移位意味着什么？意味着：性能损耗！</strong>所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的主键值依次递增，这样就不会发生这样的性能损耗了。</p><p>​ <strong>建议：让主键具有AUTO_INCREMENT，让存储引擎自己为表生成主键，而不是我们手动插入。</strong></p><h5id="计算函数类型转换自动或手动导致索引失效">3）计算、函数、类型转换(自动或手动)导致索引失效</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name LIKE &#x27;abc%&#x27;;</span><br><span class="line"># 未使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) = &#x27;abc&#x27;;</span><br></pre></td></tr></table></figure><ul><li>从运行结果上，上述两个SQL语句没有差别。但是从运行效率上而言，下面这条语句因为使用了函数，所以并不会使用到name上的索引进行查询，也就是查询类型会是ALL，效率非常低。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 未使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=123;</span><br><span class="line"># 使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=&#x27;123&#x27;;</span><br></pre></td></tr></table></figure><ul><li>上述，是由于name=123发生类型转换，最终导致索引失效。</li></ul><h5 id="范围条件右边的列索引失效">4）范围条件右边的列索引失效</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_age_name_classid on student(age,classid,name)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 会使用上述联合索引，但是没有用到Name这个字段上建立的索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student</span><br><span class="line">WHERE student.age=30 AND student.classId&gt;20 AND student.name = &#x27;abc&#x27; ;</span><br></pre></td></tr></table></figure><p>​想要起作用，得写成如下格式：建联合索引时，把确定查询的放到前面，范围查询的放到后面.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_age_name_classid on student(age,name,classid)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.name =</span><br><span class="line">&#x27;abc&#x27; AND student.classId&gt;20 ;</span><br></pre></td></tr></table></figure><p>​结论：应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。应将查询条件放置where语句最后。（即创建的联合索引中，务必把范围涉及到的字段写在最后）</p><h5 id="不等于导致索引失效">5）不等于导致索引失效</h5><h5 id="is-null可以使用索引is-not-null无法使用索引">6）isnull可以使用索引，is not null无法使用索引</h5><h5 id="like以通配符开头索引失效">7）like以通配符%开头索引失效</h5><p>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p><h5 id="or-前后存在非索引的列索引失效">8）OR前后存在非索引的列，索引失效</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 未使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 10 OR classid = 100;</span><br><span class="line"># 使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 10 OR name = &#x27;Abel&#x27;;</span><br></pre></td></tr></table></figure><h5id="数据库和表的字符集统一使用utf8mb4">9）数据库和表的字符集统一使用utf8mb4</h5><p>​统一使用utf8mb4兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的字符集进行比较前需要进行转换会造成索引失效。</p><h5 id="总结建议">10）总结建议：</h5><ul><li>单列索引，尽量选择针对当前query过滤性更好的索引</li><li>在选择组合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li><li>在选择组合索引的时候，尽量选择能够包含当前query中的where子句中更多字段的索引。</li><li>在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面。</li></ul><h4 id="关联查询的优化情况">2、关联查询的优化情况：</h4><h5 id="left-join-左外连接左边驱动表右边被驱动表">1）Left Join左外连接（左边驱动表，右边被驱动表）</h5><p>​ LeftJoin的条件（即On上的内容）用于确定如何从右表搜索行，而左边的表一定都有，所以右边是我们的关键点,一定需要建立索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;</span><br><span class="line"></span><br><span class="line"># 在被驱动表book上添加索引，可以避免对book表的全表扫描。</span><br><span class="line">ALTER TABLE book ADD INDEX Y (card);</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;</span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221031110652164.png" /></p><h5 id="inner-join-内连接">2）INNER JOIN 内连接：</h5><p>​ 在INNER JOIN中，驱动表是由MySQL自动选择的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 由于驱动表是查询优化器决定的，所以如果book上建了索引，type没建，那么book会被选为被驱动表，反之type会被选为被驱动表。如果两列都建了索引，那么还是由查询优化器自动根据Cost选择。（一般都是选择小表作为驱动表，即小表驱动大表）</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM type INNER JOIN book ON type.card=book.card;</span><br></pre></td></tr></table></figure><h5 id="join语句的原理">3）JOIN语句的原理</h5><ul><li>驱动表和非驱动表：<ul><li>内连接：优化器自动决定</li><li>外连接：优化器也会帮助决定驱动表</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM t1 STRAIGHT_JOIN t2 ON (t1.a=t2.a);</span><br></pre></td></tr></table></figure><ul><li>Simple Nested-Loop Join 简单嵌套<ul><li>假设A表有A条记录，B表有B条记录，A作为驱动表，B被驱动表</li><li>最终查询开销：外表扫描1次，内表扫描A次，读取记录数：A + B *A，JOIN比较次数 B * A</li><li>所以使用小表驱动大表</li></ul></li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221031112529836.png" /></p><ul><li><p>Index Nested0Loop Join 索引嵌套循环连接</p><p>为了减少内层表数据的匹配次数，所以被驱动表上需要有索引。</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221031112116837.png" /></p><ul><li><p>假设A表有A条记录，B表有B条记录，A作为驱动表，B被驱动表</p></li><li><p>在这条语句里，被驱动表t2的字段a上有索引，join过程用上了这个索引，因此这个语句的执行流程是这样的：</p><ul><li>从表t1中读入一行数据 R；</li><li>从数据行R中，取出a字段到表t2里去查找；</li><li>取出表t2中满足条件的行，跟R组成一行，作为结果集的一部分；</li><li>重复执行步骤1到3，直到表t1的末尾循环结束。</li></ul><p>在这个流程里：</p><ul><li>对驱动表t1做了全表扫描，这个过程需要扫描100行；</li><li>而对于每一行R，根据a字段去表t2查找，走的是树搜索过程。由于我们构造的数据都是一一对应的，因此每次的搜索过程都只扫描一行，也是总共扫描100行；</li><li>所以，整个执行流程，总扫描行数是200</li></ul></li><li></li></ul></li><li><p>Block Nested Loop Join (针对Simple的优化方法)</p><p>​如果存在索引，那么会使用index的方式进行join，如果join的列没有索引，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把被驱动表的记录在加载到内存匹配，这样周而复始，大大增加了I0的次数。</p><p>​ 为了减少被驱动表的IO次数，就出现了Block Nested-LoopJoin的方式。<strong>不再是逐条获取驱动表的数据，而是一块一块的获取，引入了joinbuffer缓冲区，将驱动表join相关的部分数据列（大小受joinbuffer的限制）缓存到joinbuffer中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和joinbuffer中的所有驱动表记录进行匹配（内存中操作），将简单嵌套循环中的多次比较合并成一次</strong>，降低了被驱动表的访问频率。</p></li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221031115027527.png" /></p><ul><li>最终查询开销：<ul><li>外表扫描1次</li><li>内表扫描A * used_column_size / join_buffer_size + 1次</li><li>读取记录数：A + B * (A * used_column_size / join_buffer_size)</li><li>JOIN比较次数 B * A</li></ul></li></ul><h5 id="join语句结论">4）JOIN语句结论：</h5><ul><li>使用join语句，性能比强行拆成多个单表执行SQL语句的性能要好（能够直接多表关联的尽量直接关联，不用子查询）</li><li>如果使用join语句的话，需要让小表做驱动表。(在决定哪个表做驱动表的时候，<strong>应该是两个表按照各自的条件过滤，过滤完成之后，计算参与join的各个字段的总数据量，数据量小的那个表，</strong>就是“小表”，应该作为驱动表。</li><li>为被驱动表匹配的条件增加索引</li><li>增大Join BufferSize的大小（单次缓存的数据越多，内层包的扫表次数越少）</li><li>减少驱动表不必要的字段查询，字段越少，join buffer缓存的数据越多</li></ul><h5 id="hash-join">5）Hash Join</h5><p>​ HashJoin是做大数据集连接时的常用方式，优化器使用两个表中较小（相对较小）的表利用JoinKey在内存中建立散列表，然后扫描较大的表并探测散列表，找出与Hash表匹配的行。</p><p>​<strong>这种方式适用于较小的表完全可以放于内存中的情况，这样总成本就是访问两个表的成本之和。</strong></p><p>​在表很大的情况下并不能完全放入内存，这时优化器会将它分割成若干不同的分区，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高I/O的性能。</p><p>​它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。HashJoin只能应用于等值连接，这是由Hash的特点决定的。</p><h4 id="子查询优化">3、子查询优化</h4><p>​ 子查询能够实现较复杂的语句，但是其执行效率较低，原因如下：</p><ul><li>执行子查询时，MySQL需要为内层查询语句的查询结果建立一个临时表，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表。这样会消耗过多的CPU和IO资源，产生大量的慢查询。</li><li>子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。</li><li>对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</li></ul><p>​故而，对于能够拆解的子查询，尽可能用多个步骤的关联查询来代替子查询。</p><h4 id="排序优化">4、排序优化</h4><p>​ 在MySQL中，支持两种排序方式，分别是FileSort和Index排序。</p><ul><li>Index排序：索引可以保证数据的有序性，效率高。</li><li>FileSort：一般在内存中进行排序，占用CPU较多。如果结果较大则会产生临时文件IO到磁盘进行排序，效率低。</li></ul><p>​ 优化建议：</p><ul><li>SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引：目的是在 WHERE子句中避免全表扫描，在 ORDER BY 子句避免使用FileSort排序。<strong>当然，某些情况下全表扫描，或者 FileSort排序不一定比索引慢。</strong>但总的来说，我们还是要避免，以提高查询效率。</li><li>尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY是相同的列就使用单索引列；<strong>如果不同就使用联合索引</strong>。</li><li>无法使用 Index 时，需要对 FileSort 方式进行调优</li></ul><p>可以应用索引进行排序的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">INDEX a_b_c(a,b,c)</span><br><span class="line"></span><br><span class="line"># 如果WHERE使用索引的最左前缀定义为常量，则order by 能使用索引</span><br><span class="line">- WHERE a = const ORDER BY b,c</span><br><span class="line">- WHERE a = const AND b = const ORDER BY c</span><br><span class="line">- WHERE a = const ORDER BY b,c</span><br><span class="line">- WHERE a = const AND b &gt; const ORDER BY b,c</span><br></pre></td></tr></table></figure><p>不可以应用索引进行排序的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- ORDER BY a ASC,b DESC,c DESC /* 排序不一致 */</span><br><span class="line">- WHERE g = const ORDER BY b,c /*丢失a索引*/</span><br><span class="line">- WHERE a = const ORDER BY c /*丢失b索引*/</span><br><span class="line">- WHERE a = const ORDER BY a,d /*d不是索引的一部分*/</span><br><span class="line">- WHERE a in (...) ORDER BY b,c /*对于排序来说，多个相等条件也是范围查询*/</span><br></pre></td></tr></table></figure><p>​需要注意：有些可以应用索引进行排序的情况，查询优化器不一定会去使用。这会取决于具体的查询字段、数据量等等。</p><ul><li>当【范围条件】和【group by 或者 orderby】的字段出现二选一时，优先观察条件字段的过滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。反之，亦然。</li></ul><h5 id="filesort算法">1）FileSort算法：</h5><ul><li>双路排序<ul><li>是两次扫描磁盘，最终得到数据。</li><li>第一次仅读取行指针和order by列，对他们进行排序。</li><li>第二次扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出，从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段</li></ul></li><li>单路排序（更消耗buffer）<ul><li>直接从磁盘读取查询需要的所有列，按照orderby列在buffer对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空间，因为它把每一行都保存在内存中了。</li><li>如果buffer容量不够，反而可能会导致大量的IO操作。<ul><li>尝试提高 sort_buffer_size</li><li>尝试提高 max_length_for_sort_data</li><li>Order by 时select * 是一个大忌。最好只Query需要的字段</li></ul></li></ul></li></ul><h4 id="group-by-优化">5、GROUP BY 优化：</h4><ul><li>group by 使用索引的原则几乎跟order by一致 ，group by即使没有过滤条件用到索引，也可以直接使用索引。</li><li>group by 先排序再分组，遵照索引建的最佳左前缀法则</li><li>当无法使用索引列，增大max_length_for_sort_data 和sort_buffer_size参数的设置</li><li>where效率高于having，能写在where限定的条件就不要写在having中。减少使用orderby，和业务沟通能不排序就不排序，或将排序放到程序端去做。</li><li>Order by、groupby、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li><li>包含了order by、groupby、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</li></ul><h4 id="优化分页查询">6、优化分页查询：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM student LIMIT 200000,10;</span><br></pre></td></tr></table></figure><ul><li>优化1：在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM student t,(SELECT id FROM student ORDER BY id LIMIT 2000000,10) a</span><br><span class="line">WHERE t.id = a.id;</span><br></pre></td></tr></table></figure><ul><li>优化2：该方案适用于主键自增的表，可以把Limit查询转换成某个位置的查询。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM student WHERE id &gt; 2000000 LIMIT 10;</span><br></pre></td></tr></table></figure><h4 id="覆盖索引">7、覆盖索引：</h4><p>​ 一个索引包含了满足查询结果的数据就叫做覆盖索引。简单说就是，索引列+主键 包含 SELECT 到 FROM 之间查询的列。</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 不使用索引，因为如果要使用还需要回表，成本更高</span><br><span class="line">EXPLAIN SELECT * FROM student WHERE NAME LIKE &#x27;%abc&#x27;</span><br><span class="line"></span><br><span class="line"># 使用索引，因为索引中有id,age,NAME，所以不需要回表</span><br><span class="line">EXPLAIN SELECT id,age,NAME FROM student WHERE NAME LIKE &#x27;%abc&#x27;</span><br></pre></td></tr></table></figure><ul><li>好处：<ul><li>避免Innodb表进行索引的二次查询（回表）</li><li>可以把随机IO变成顺序IO加快查询效率，因为覆盖索引是按照键值的顺序存储的，对于IO密集型的范围查找来说，对比随机从磁盘读取每一行的数据IO要少的多。</li></ul></li><li>弊端：<ul><li>索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑。</li></ul></li></ul><h4 id="索引条件下推">8、索引条件下推：</h4><p>​ Index Condition Pushdown(ICP)是MySQL5.6中新特性，是一种在存储引擎层使用索引过滤数据的一种优化方式。ICP可以减少存储引擎访问基表的次数以及MySQL服务器访问存储引擎的次数。</p><ul><li>示例： 表上有联合索引(key1,key2)<ul><li>不使用ICP的查询过程：先使用联合索引(key1,key2)过滤key1&gt;'z'条件，然后回表，回表后的数据加载到数据页中，再去找满足第二第三个条件的数据</li><li>使用ICP的查询过程：先使用联合索引(key1,key2)过滤key1&gt;'z'条件，然后不急着回表。因为联合索引中有key2这个字段，所以可以先进行索引条件下推，也就是先筛选key2这个条件，然后由于key3不在索引内，所以只能先去回表，再筛选第三个数据了。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 where key1 &gt; &#x27;z&#x27; AND key2 LIKE &#x27;%s&#x27; AND key3 LIKE &#x27;%ss&#x27;</span><br></pre></td></tr></table></figure><h5 id="icp的开启和关闭">1）ICP的开启和关闭：</h5><p>默认情况下启用索引下推，可以通过设置系统变量optimizer_switch =index_contidition_pushdown = on来开启。</p><h5 id="使用条件">2）使用条件：</h5><ul><li>只能用于二级索引(secondary index)</li><li>explain显示的执行计划中type值（join 类型）为range 、 ref 、 eq_ref或者ref_or_null 。</li><li>并非全部where条件都可以用ICP筛选，如果where条件的字段不在索引列中，还是要读取整表的记录到server端做where过滤。</li><li>ICP可以用于MyISAM和InnnoDB存储引擎</li><li>MySQL 5.6版本的不支持分区表的ICP功能，5.7版本的开始支持。</li><li>当SQL使用覆盖索引时，不支持ICP优化方法。</li></ul><h4 id="其他查询优化策略">9、其他查询优化策略：</h4><h5 id="exists-和-in">1）EXISTS 和 IN</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM A WHERE CC IN(SELECT CC FROM B) </span><br><span class="line"></span><br><span class="line">SELECT * FROM A WHERE EXISTS(SELECT CC FROM B WHERE B.cc=A.cc)</span><br></pre></td></tr></table></figure><p>当A小于B时，用EXISTS，因为A是驱动表，执行顺序是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in A:</span><br><span class="line">for j in B:</span><br><span class="line">if j.cc == i.cc then</span><br></pre></td></tr></table></figure><p>当B小于A时，用IN，因为实现逻辑正好与上相反。</p><h5 id="count-和-count具体字段">2）COUNT(*) 和 COUNT(具体字段)</h5><ul><li>COUNT(*) 和 COUNT(1) 两者执行效率类似。</li><li>如果是MyISAM存储引擎，统计表的行数为O(1)复杂度，因为有元数据存储，一致性由表级锁维护。</li><li>如果是InnoDB，其支持事务行锁等机制，无法维护元数据，所以需要扫描全表，是O(n)复杂度，进行循环+计数方式统计。</li><li>InnoDB中，如果采用COUNT(具体字段)，尽可能使用二级索引，因为主键采用的是聚簇索引，包含的信息较多。对于COUNT(*)和 COUNT(1)而言，只是统计行数，系统回自动采用占用空间更小的二级索引来统计。</li></ul><h5 id="关于select">3）关于SELECT *</h5><ul><li>不建议使用，耗费资源和时间</li><li>无法使用覆盖索引</li></ul><h5 id="limit1">4）LIMIT1</h5><ul><li>针对的是会扫描全表的SQL语句，如果你可以确定结果集只有一条，那么加上LIMIT1的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。</li></ul><h5 id="多使用commit">5）多使用COMMIT</h5><ul><li>只要有可能，在程序中尽量多使用COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT所释放的资源而减少。</li><li>COMMIT 所释放的资源：<ul><li>回滚段上用于恢复数据的信息</li><li>被程序语句获得的锁</li><li>redo / undo log buffer 中的空间</li><li>管理上述 3 种资源中的内部花费</li></ul></li></ul><h3 id="二主键应当如何设计">二、主键应当如何设计？</h3><p>​自增ID做主键，简单易懂，几乎所有数据库都支持自增类型，只是实现上各自有所不同而已。自增ID除了简单，其他都是缺点。</p><ol type="1"><li>可靠性不高 存在自增ID回溯的问题，这个问题直到最新版本的MySQL8.0才修复。</li><li>安全性不高对外暴露的接口可以非常容易猜测对应的信息。比如：/User/1/这样的接口。</li><li>性能差 自增ID的性能较差，需要在数据库服务器端生成。</li><li>交互多 业务还需要额外执行一次类似last_insert_id()的函数才能知道刚才插入的自增值，这需要多一次的网络交互。在海量并发的系统中，多1条SQL，就多一次性能上的开销。</li><li>局部唯一性最重要的一点，自增ID是局部唯一，只在当前数据库实例中唯一，而不是全局唯一，在任意服务器间都是唯一的。对于目前分布式系统来说，这简直就是噩梦</li></ol><h4 id="使用业务字段做主键">1、使用业务字段做主键？</h4><p>​ 不可取！建议尽量不要用跟业务有关的字段做主键。</p><h4 id="推荐的主键设计">2、推荐的主键设计：</h4><ul><li>非核心业务：对应表的主键自增ID，如告警、日志、监控等信息。</li><li>核心业务：主键设计至少应该是全局唯一且是单调递增。全局唯一保证在各系统之间都是唯一的，单调递增是希望插入时不影响数据库性能</li></ul><p><strong>UUID</strong>：</p><p>​ UUID = 时间+UUID版本（16字节）- 时钟序列（4字节） -MAC地址（12字节）</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221031152235559.png" /></p><p>​在UUID中时间部分占用60位，存储的类似TIMESTAMP的时间戳，但表示的是从1582-10-1500：00：00.00到现在的100ns的计数。可以看到UUID存储的时间精度比TIMESTAMPE更高</p><ul><li>为什么UUID是随机无序的呢？<ul><li>因为UUID的设计中，<strong>将时间低位放在最前面，而这部分的数据是一直在变化的，并且是无序。</strong></li></ul></li></ul><p><strong>改造UUID，使其适配主键的要求</strong>：</p><p>​若将时间高低位互换，则时间就是单调递增的了，也就变得单调递增了。MySQL8.0可以更换时间低位和时间高位的存储方式，这样UUID就是有序的UUID了。</p><p>​另外在真实的业务系统中，主键还可以加入业务和系统属性，如用户的尾号，机房的信息等。</p>]]></content>
    
    
    <summary type="html">Chap13——Mysql 数据库调优方法和思维，包含索引优化和查询优化</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>云原生快速入门系列Chap2——Kubernetes入门</title>
    <link href="https://blog.fantast.top/2022/11/04/8e7c78160822/"/>
    <id>https://blog.fantast.top/2022/11/04/8e7c78160822/</id>
    <published>2022-11-04T09:43:19.000Z</published>
    <updated>2022-11-07T08:17:19.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="kubernetes基础概念">1、Kubernetes基础概念：</h4><ul><li><p>工程部署的演变：传统部署——虚拟机部署——容器化部署</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221104180722605.png" /></p></li><li><p>当容器化部署时代到来，微服务模块非常多的情境下，可能一台服务器上会有几十个容器，且不同的容器都部署在几十台服务器上，这个时候我们就需要一个<strong>大规模的容器编排管理系统</strong>。Kubernetes为你提供了一个可弹性运行分布式系统的框架。 Kubernetes会满足你的扩展要求、故障转移、部署模式等。</p></li><li><p>Kubernetes的特性如下：</p><ul><li><strong>服务发现和负载均衡</strong>：如果进入容器的流量很大，Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。</li><li><strong>存储编排</strong>：Kubernetes允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。</li><li><strong>自动部署和回滚</strong>：你可以自动化 Kubernetes来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器</li><li><strong>自动完成装箱计算</strong>：Kubernetes 允许你指定每个容器所需CPU 和内存（RAM）。 当容器指定了资源请求时，Kubernetes可以做出更好的决策来管理容器的资源。</li><li><strong>自我修复</strong>：Kubernetes重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。</li><li><strong>密钥与配置管理</strong>：Kubernetes允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。</li></ul></li></ul><h4 id="kubernetes架构">2、Kubernetes架构：</h4><ul><li>K8s基于一个服务器集群进行安装：N个主节点+M个工作节点（N&gt;=1）</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221104181719685.png" /></p><ul><li><strong>Control Plane控制平面【相当于集团中心，Master节点】</strong>：控制平面的组件对集群做出全局决策(比如调度)，以及检测和响应集群事件。控制平面组件可以在集群中的任何节点上运行。<ul><li>apiserver【相当于集团秘书部，一切对外活动都交给她中转】:API 服务器是Kubernetes 控制面的前端。它可通过部署多个实例进行伸缩。你可以运行kube-apiserver 的多个实例，并在这些实例之间平衡流量。</li><li>scheduler【调度者】：责监视新创建的、未指定运行<ahref="https://kubernetes.io/zh/docs/concepts/architecture/nodes/">节点（node）</a>的容器，选择节点让容器在上面运行。调度决策考虑的因素包括单个 Pod 和 Pod集合的资源需求、硬件/软件/策略约束等等。</li><li>etcd【相当于集团资料中心】：etcd是兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes所有集群数据的后台数据库。</li><li>controller-manager(c-m)【集团决策者】：在主节点上运行 <ahref="https://kubernetes.io/zh/docs/concepts/architecture/controller/">控制器</a>的组件。从逻辑上讲，每个<ahref="https://kubernetes.io/zh/docs/concepts/architecture/controller/">控制器</a>都是一个单独的进程，但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。</li><li>cloud-controller-manager(c-c-m)【外联部，可选】：仅运行特定于云平台的控制回路。如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境，所部署的环境中不需要云控制器管理器。</li></ul></li><li><strong>Node组件【相当于分工厂，Worker节点】</strong>：节点组件在每个节点上运行，维护运行的Pod 并提供 Kubernetes 运行环境<ul><li><p>kubelet【厂长，监工】：一个在集群中每个<ahref="https://kubernetes.io/zh/docs/concepts/architecture/nodes/">节点（node）</a>上运行的代理。它保证<ahref="https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/#why-containers">容器（containers）</a>都运行在 <ahref="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pod</a>中。kubelet 接收一组通过各类机制提供给它的 PodSpecs，确保这些 PodSpecs中描述的容器处于运行状态且健康。负责该节点中应用的启停以及销毁，能够探测到不同应用的状态，然后汇报给api-server。</p></li><li><p>kube-proxy【门卫导航，网络访问入口】：是集群中每个节点上运行的网络代理，实现 Kubernetes <ahref="https://kubernetes.io/zh/docs/concepts/services-networking/service/">服务（Service）</a>概念的一部分。可以告知想要访问谁怎么访问，kube-proxy维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod进行网络通信。</p></li></ul></li><li>交互形式：</li></ul><p><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221104230011339.png" /></p><h4 id="集群搭建与部署">3、集群搭建与部署</h4><p>每台服务器需要首先安装</p><ul><li>Docker 容器运行化环境</li><li>kubelet 节点厂长</li><li>kubectl 控制命令行</li><li>kubeadm 控制管理器</li></ul><p>​随后，在某一台主节点处执行<code>kubeadm init</code>，初始化该节点为主节点，随后kubelet会自动下载主节点需要的如scheduler、api-server等等服务的镜像。</p><p>​再随后，在其他节点处执行<code>kubeadm join</code>即可加入主节点创建的k8s集群。</p><h5 id="需要三台服务器">1）需要三台服务器</h5><ul><li>集群中的所有机器的网络彼此均能相互连接(公网和内网都可以)</li><li>节点之中不可以有重复的主机名、MAC 地址或product_uuid。<strong>设置不同hostname</strong></li><li><strong>内网互信</strong></li><li>禁用交换分区。为了保证 kubelet 正常工作，你 <strong>必须</strong>禁用交换分区。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装每台服务器的预安装环境（Docker、kubelet、kebectl、kubeadm）</span></span><br><span class="line"><span class="comment"># 更新镜像源</span></span><br><span class="line">sudo yum install -y yum-utils</span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装docker</span></span><br><span class="line">yum install -y docker-ce-20.10.7 docker-ce-cli-20.10.7  containerd.io-1.4.6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动docker</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker --now</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker的生产环境核心配置cgroup</span></span><br><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line">sudo <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://82m9ar63.mirror.aliyuncs.com&quot;</span>],</span><br><span class="line">  <span class="string">&quot;exec-opts&quot;</span>: [<span class="string">&quot;native.cgroupdriver=systemd&quot;</span>],</span><br><span class="line">  <span class="string">&quot;log-driver&quot;</span>: <span class="string">&quot;json-file&quot;</span>,</span><br><span class="line">  <span class="string">&quot;log-opts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;max-size&quot;</span>: <span class="string">&quot;100m&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;storage-driver&quot;</span>: <span class="string">&quot;overlay2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务器1、2、3分别执行以重命名hostname</span></span><br><span class="line">hostnamectl set-hostname k8s-master</span><br><span class="line">hostnamectl set-hostname k8s-node1</span><br><span class="line">hostnamectl set-hostname k8s-node2</span><br><span class="line"><span class="comment"># 下述命令全部服务器需要执行：k8s官方文档要求</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 SELinux 设置为 permissive 模式（相当于将其禁用）</span></span><br><span class="line">sudo sed -i <span class="string">&#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27;</span> /etc/selinux/config</span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭服务器交换分区</span></span><br><span class="line">sed -ri <span class="string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> /etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="comment">#允许 iptables 检查桥接流量</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/modules-load.d/k8s.conf</span></span><br><span class="line"><span class="string">br_netfilter</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/sysctl.d/k8s.conf</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装kubelet、kubeadm、kubectl</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置下载镜像源</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/yum.repos.d/kubernetes.repo</span></span><br><span class="line"><span class="string">[kubernetes]</span></span><br><span class="line"><span class="string">name=Kubernetes</span></span><br><span class="line"><span class="string">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=0</span></span><br><span class="line"><span class="string">repo_gpgcheck=0</span></span><br><span class="line"><span class="string">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span></span><br><span class="line"><span class="string">   http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span></span><br><span class="line"><span class="string">exclude=kubelet kubeadm kubectl</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用yum安装</span></span><br><span class="line">sudo yum install -y kubelet-1.20.9 kubeadm-1.20.9 kubectl-1.20.9 --disableexcludes=kubernetes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动kubelet</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> --now kubelet</span><br></pre></td></tr></table></figure><p>注意：kubelet 现在每隔几秒就会重启，因为它陷入了一个等待 kubeadm指令的死循环</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用kubeadm引导启动集群</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载各个机器需要的镜像</span></span><br><span class="line">sudo <span class="built_in">tee</span> ./images.sh &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">images=(</span><br><span class="line">kube-apiserver:v1.20.9</span><br><span class="line">kube-proxy:v1.20.9</span><br><span class="line">kube-controller-manager:v1.20.9</span><br><span class="line">kube-scheduler:v1.20.9</span><br><span class="line">coredns:1.7.0</span><br><span class="line">etcd:3.4.13-0</span><br><span class="line">pause:3.2</span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> imageName <span class="keyword">in</span> <span class="variable">$&#123;images[@]&#125;</span> ; <span class="keyword">do</span></span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/<span class="variable">$imageName</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">EOF</span><br><span class="line">   </span><br><span class="line"><span class="built_in">chmod</span> +x ./images.sh &amp;&amp; ./images.sh</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化主节点：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有机器都需要执行如下：</span></span><br><span class="line"><span class="comment"># 即添加master域名映射，需要填写集群的内网的IP</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;172.31.0.4  cluster-endpoint&quot;</span> &gt;&gt; /etc/hosts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行完后，各个机器能够ping cluster-endpoint 能够ping通，说明配置正确了</span></span><br><span class="line"><span class="comment"># 主节点初始化，仅在主节点处理</span></span><br><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=<span class="variable">$&#123;master node ip&#125;</span> \</span><br><span class="line">--control-plane-endpoint=<span class="variable">$&#123;master node domain name&#125;</span> \</span><br><span class="line">--image-repository registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images \</span><br><span class="line">--kubernetes-version v1.20.9 \</span><br><span class="line">--service-cidr=10.96.0.0/16 \</span><br><span class="line">--pod-network-cidr=192.168.0.0/16</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意需要保证service-cidr和pod-netword-cidr不能重叠且和机器不能在一个网段</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上述命令执行成功后，会显示如下页面：</span></span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  sudo <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  sudo <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, <span class="keyword">if</span> you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run <span class="string">&quot;kubectl apply -f [podnetwork].yaml&quot;</span> with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">You can now <span class="built_in">join</span> any number of control-plane nodes by copying certificate authorities</span><br><span class="line">and service account keys on each node and <span class="keyword">then</span> running the following as root:</span><br><span class="line"></span><br><span class="line">  kubeadm <span class="built_in">join</span> cluster-endpoint:6443 --token hums8f.vyx71prsg74ofce7 \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:a394d059dd51d68bb007a532a037d0a477131480ae95f75840c461e85e2c6ae3 \</span><br><span class="line">    --control-plane </span><br><span class="line"></span><br><span class="line">Then you can <span class="built_in">join</span> any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm <span class="built_in">join</span> cluster-endpoint:6443 --token hums8f.vyx71prsg74ofce7 \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:a394d059dd51d68bb007a532a037d0a477131480ae95f75840c461e85e2c6ae3</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据上述的提示信息，还需要在主节点上执行：</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"><span class="comment"># 观察是否正确</span></span><br><span class="line">kubectl get nodes</span><br><span class="line"><span class="comment"># 查看集群部署了哪些应用？</span></span><br><span class="line">kubectl get pods -A</span><br><span class="line"><span class="comment"># 运行中的应用在docker里面叫容器，在k8s里面叫Pod</span></span><br><span class="line">kubectl get pods -A</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在主节点上执行，下载网络组件</span></span><br><span class="line"></span><br><span class="line">curl https://docs.projectcalico.org/manifests/calico.yaml -O</span><br><span class="line"></span><br><span class="line">kubectl apply -f calico.yaml</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Worker节点准备，执行上面提示的信息即可</span></span><br><span class="line"></span><br><span class="line">kubeadm <span class="built_in">join</span> cluster-endpoint:6443 --token hums8f.vyx71prsg74ofce7 \</span><br><span class="line">    --discovery-token-ca-cert-hash</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 可以在Master节点上运行：</span></span><br><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure><h5 id="部署dashboard">2）部署dashboard</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载dashboard配置文件</span></span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.3.1/aio/deploy/recommended.yaml</span><br><span class="line"><span class="comment"># 设置访问端口</span></span><br><span class="line">kubectl edit svc kubernetes-dashboard -n kubernetes-dashboard</span><br><span class="line"><span class="comment"># 把文件中的  type: ClusterIP 改为 type: NodePort</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行以下命令，查看端口映射关系</span></span><br><span class="line">kubectl get svc -A |grep kubernetes-dashboard</span><br><span class="line"><span class="comment">## 访问： https://集群任意IP:端口</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建访问账号，准备一个yaml文件； vi dash.yaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kubectl apply -f dash.yaml   <span class="comment"># 应用配置文件</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取k8s的访问令牌</span></span><br><span class="line">kubectl -n kubernetes-dashboard get secret $(kubectl -n kubernetes-dashboard get sa/admin-user -o jsonpath=<span class="string">&quot;&#123;.secrets[0].name&#125;&quot;</span>) -o go-template=<span class="string">&quot;&#123;&#123;.data.token | base64decode&#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure><h4 id="k8s命名空间容器工作负载">4、K8s——命名空间、容器、工作负载：</h4><h5 id="k8s的资源创建方法">1）K8s的资源创建方法：</h5><ul><li>使用命令行</li><li>使用YAML文件，书写YAML文件并使用<code>kubectl apply -f filename</code></li></ul><h5 id="namespace">2）Namespace：</h5><ul><li>名称空间，用来对集群资源进行隔离划分。默认只隔离资源，不隔离网络</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create ns hello</span><br><span class="line">kubectl delete ns hello</span><br></pre></td></tr></table></figure><p>或者使用YAML文件的形式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello</span></span><br></pre></td></tr></table></figure><h5 id="pod">3）Pod：</h5><ul><li>运行中的一组容器，Pod是kubernetes中应用的最小单位。</li><li>在Container外层包了一层Pod，注意一个Pod里面允许存在多个容器</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221105220913167.png" /></p><ul><li>如下图所示：在一个Pod里，存在File Puller容器和WebServer两个容器，一个用于内容管理下载，一个用于给客户提供访问服务。两个容器合起来完成了一个小的功能，封装在一个Pod里面。</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221105221025280.png" style="zoom:50%;" /></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动一个Pod，指定一个镜像</span></span><br><span class="line">kubectl run mynginx --image=nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看default名称空间的Pod</span></span><br><span class="line">kubectl get pod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看这个pod的内部运行时描述</span></span><br><span class="line">kubectl describe pod Pod名字</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用YAML文件创建Pod</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">myapp</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">tomcat:8.5.68</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tomcat</span></span><br></pre></td></tr></table></figure><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221105221728766.png" style="zoom: 67%;" /></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除某个Pod</span></span><br><span class="line">kubectl delete pod Pod名字</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Pod的运行日志</span></span><br><span class="line">kubectl logs Pod名字</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个Pod - k8s都会分配一个ip</span></span><br><span class="line">kubectl get pod -owide</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Pod的ip+pod里面运行容器的端口</span></span><br><span class="line">curl 192.168.169.136</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集群中的任意一个机器以及任意的应用都能通过Pod分配的ip来访问这个Pod</span></span><br><span class="line"><span class="comment"># 但是目前，集群外的机器是没法访问的</span></span><br></pre></td></tr></table></figure><h5 id="deployment的多副本能力">4）Deployment的多副本能力</h5><p>​ Deployment用于控制Pod，使得Pod拥有多副本、自愈、扩缩容等能力。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个部署，可以创建多个Pod的副本</span></span><br><span class="line">kubectl create deployment my-dep --image=nginx --replicas=3</span><br></pre></td></tr></table></figure><h5 id="deployment的工作负载能力">5）Deployment的工作负载能力：</h5><ul><li>扩缩容：可以通过如下命令扩容或缩容部署副本数量</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale --replicas=5 deployment/my-dep</span><br></pre></td></tr></table></figure><ul><li><p>自愈&amp;故障转移：当Pod出现故障时，会自动重启该Pod。如果当某台服务器停机了，那么其会将该台服务器上运行的Pod在服务器的其他集群上拉取一份，并且运行，即故障转移</p></li><li><p>滚动更新：用于Pod的版本更新，全程无需停机维护，可以持续应对流量进入。对于服务器集群而言，每一台服务器先启动新版本的Pod，正确后杀死老版本的Pod，并把该台服务器上的流量转入新版本Pod中。当执行滚动更新的时候可以执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改my-dep这个deployment的nginx容器的镜像，是更新后的镜像</span></span><br><span class="line">kubectl <span class="built_in">set</span> image deployment/my-dep nginx=nginx:1.16.1 --record</span><br><span class="line"><span class="comment"># 使用此命令查看状态</span></span><br><span class="line">kubectl rollout status deployment/my-dep</span><br></pre></td></tr></table></figure></li><li><p>版本回退能力：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看版本改动的历史记录</span><br><span class="line">kubectl rollout history deployment/my-dep</span><br><span class="line"># 查看某个版本改动的历史详情</span><br><span class="line">kubectl rollout history deployment/my-dep --revision=2</span><br><span class="line"># 回滚(回到上次)</span><br><span class="line">kubectl rollout undo deployment/my-dep</span><br><span class="line"># 回滚(回到指定版本)</span><br><span class="line">kubectl rollout undo deployment/my-dep --to-revision=2</span><br></pre></td></tr></table></figure><h5 id="其他工作负载资源">6）其他工作负载资源：</h5><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221106130136601.png" /></p><h4 id="k8s服务网络service">5、K8s——服务网络Service：</h4><ul><li>Service：用于Pod的服务发现与负载均衡功能，是将一组Pods公开为网络服务的抽象方法</li><li>如此一来，这一组Pods的API地址就是Service暴露的公开地址，且Service能够对不同的Pod的运行状态进行监测，其实就有点像阿里云的负载均衡服务器。</li></ul><h5 id="cluster-ip模式集群内部访问">1）ClusterIP模式（集群内部访问）</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 部署服务，其可以选择一组Pod然后将他们暴露为Service</span></span><br><span class="line">kubectl expose deployment my-dep --port=8000 --target-port=80</span><br><span class="line"><span class="comment"># 使用标签检索Pod</span></span><br><span class="line">kubectl get pod -l app=my-dep</span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221106130948476.png" /></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取service</span></span><br><span class="line">kubectl get service</span><br><span class="line"><span class="comment"># CLUSTER-IP即暴露给外层的服务地址</span></span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221106131131834.png" /></p><ul><li>什么是服务发现机制？<ul><li>如果原先Deployment对应部署的Pod是三份，此时缩容到了两份，即有一个Pod下线了，那么此时Service能够发现有一个Pod下线了，不会像该Pod转发流量。如果后续Pod重新上线，Service又会重新将流量分流给这个重新上线的Pod。</li></ul></li></ul><h5id="nodeport模式集群外也可以访问">2）NodePort模式（集群外也可以访问）：</h5><p>​此时，不仅可以通过内部Ip+端口可以访问，而且还会在每一台机器上随机暴露一个端口，使得外网可以通过访问机器的公网IP+端口也可以访问该服务。暴露的端口范围在30000-32767 之间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 部署服务，其可以选择一组Pod然后将他们暴露为Service</span></span><br><span class="line">kubectl expose deployment my-dep --port=8000 --target-port=80 --<span class="built_in">type</span>=NodePort</span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221106132238850.png" /></p><h4 id="k8s服务网络-ingress">6、K8s——服务网络 Ingress</h4><ul><li>Ingress是Service的统一网关入口</li><li>Service负责Pod的负载均衡，而Ingress负责将流量转发给Service。Ingress起到类似nginx的作用。</li></ul><figure><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-11-06%2021.00.40.png"alt="截屏2022-11-06 21.00.40" /><figcaption aria-hidden="true">截屏2022-11-06 21.00.40</figcaption></figure><h5id="安装ingress通过yaml文件来进行安装">1）安装ingress，通过yaml文件来进行安装</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v0.47.0/deploy/static/provider/baremetal/deploy.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改镜像</span></span><br><span class="line">vi deploy.yaml</span><br><span class="line"><span class="comment"># 将image的值改为如下值：</span></span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/ingress-nginx-controller:v0.46.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查安装的结果</span></span><br><span class="line">kubectl get pod,svc -n ingress-nginx</span><br></pre></td></tr></table></figure><h5 id="使用ingress">2）使用ingress</h5><ul><li>安装ingress以后，会暴露两个端口，分别负责https和http的访问</li><li>应用如下yaml文件，进行测试：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello-server</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">hello-server</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">hello-server</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hello-server</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/hello-server</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9000</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-demo</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-demo</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-demo</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-demo</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-demo</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">hello-server</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello-server</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">hello-server</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">9000</span></span><br></pre></td></tr></table></figure><ul><li>应用上述yaml部署deployment和service后，架构图如下所示：</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-11-06%2021.10.08.png" /></p><ul><li>此时，我们需要将打入ingress层的流量做一个分流：</li><li>配置生效后，访问hello.atguigu.com要将流量打到hello这个service</li><li>访问demo.atguigu.com就要将流量打到nginx-demo这个service</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress  </span><br><span class="line">metadata:</span><br><span class="line">  name: ingress-host-bar</span><br><span class="line">spec:</span><br><span class="line">  ingressClassName: nginx</span><br><span class="line">  rules:</span><br><span class="line">  - host: <span class="string">&quot;hello.atguigu.com&quot;</span></span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - pathType: Prefix</span><br><span class="line">        path: <span class="string">&quot;/&quot;</span></span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: hello-server</span><br><span class="line">            port:</span><br><span class="line">              number: 8000</span><br><span class="line">  - host: <span class="string">&quot;demo.atguigu.com&quot;</span></span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - pathType: Prefix</span><br><span class="line">        path: <span class="string">&quot;/nginx&quot;</span>  <span class="comment"># 把请求会转给下面的服务，下面的服务一定要能处理这个路径，不能处理就是404</span></span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: nginx-demo  <span class="comment">## java，比如使用路径重写，去掉前缀nginx</span></span><br><span class="line">            port:</span><br><span class="line">              number: 8000</span><br></pre></td></tr></table></figure><ul><li>path: "/nginx" 与 path: "/" 会有什么样不同的效果？<ul><li>这里的path其实就是匹配根目录的一个规则。路径前缀是/nginx的话，网关就知道能够处理，不然网关会直接把这个流量拦下来。同时，后面的service服务也需要能够处理这个路径，不然网关将该请求转发给service以后，如果service不能处理的话就会返回404。</li></ul></li></ul><h5 id="ingress路径重写">3）Ingress路径重写：</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span>  </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="comment"># 新增内容，$2的意思就是$前的东西都舍弃，$后的东西就保留</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/rewrite-target:</span> <span class="string">/$2</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-host-bar</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ingressClassName:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">&quot;hello.atguigu.com&quot;</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&quot;/&quot;</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">hello-server</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">8000</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">&quot;demo.atguigu.com&quot;</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&quot;/nginx(/|$)(.*)&quot;</span>  <span class="comment"># 把请求会转给下面的服务，下面的服务一定要能处理这个路径，不能处理就是404</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">nginx-demo</span>  <span class="comment">## java，比如使用路径重写，去掉前缀nginx</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">8000</span></span><br></pre></td></tr></table></figure><p>如此重写路径后，外层再访问/nginx的地址时，当ingress转发给后台的service时，会先将/nginx前缀截掉，访问service的根目录/。</p><h5 id="流量限制">4）流量限制：</h5><p>应用如下配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-limit-rate</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">  <span class="comment"># 新增流量限制，每秒放行1个请求</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/limit-rps:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ingressClassName:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">&quot;haha.atguigu.com&quot;</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Exact</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&quot;/&quot;</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">nginx-demo</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">8000</span></span><br></pre></td></tr></table></figure><h4 id="k8s存储抽象">6、K8s——存储抽象：</h4><p>​因为K8s具备故障转移的能力，所以如果某个Pod想在别的机器上拉起转移部署，但是数据却没有相应的跟过去的话，就会导致重新拉起的服务无效，故而我们要抽相处一层存储区域。</p><h5 id="nfs网络文件系统">1）NFS网络文件系统</h5><p>​首先搭建NFS网络文件系统，它能够同步多台服务器之间的某一块空间，使得某块特定空间内的数据文件一致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有节点</span></span><br><span class="line"><span class="comment"># 所有机器安装</span></span><br><span class="line">yum install -y nfs-utils</span><br><span class="line"><span class="comment"># 主节点：</span></span><br><span class="line"><span class="comment">#nfs主节点</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/nfs/data/ *(insecure,rw,sync,no_root_squash)&quot;</span> &gt; /etc/exports</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /nfs/data</span><br><span class="line">systemctl <span class="built_in">enable</span> rpcbind --now</span><br><span class="line">systemctl <span class="built_in">enable</span> nfs-server --now</span><br><span class="line"><span class="comment">#配置生效</span></span><br><span class="line">exportfs -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从节点：</span></span><br><span class="line">showmount -e 172.31.0.4 <span class="comment"># 主服务器IP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行以下命令挂载 nfs 服务器上的共享目录到本机路径 /root/nfsmount</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /nfs/data</span><br><span class="line"></span><br><span class="line">mount -t nfs 172.31.0.4:/nfs/data  /nfs/data</span><br><span class="line"><span class="comment"># 写入一个测试文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello nfs server&quot;</span> &gt; /nfs/data/test.txt</span><br></pre></td></tr></table></figure><h5id="使用deployment进行nfs的挂载">2）使用Deployment进行NFS的挂载：</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pv-demo</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-pv-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pv-demo</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pv-demo</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span>   <span class="comment"># 将哪个路径进行部署</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">          <span class="attr">nfs:</span></span><br><span class="line">            <span class="attr">server:</span> <span class="number">172.31</span><span class="number">.0</span><span class="number">.4</span>  <span class="comment"># 主节点IP</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/nfs/data/nginx-pv</span>   <span class="comment"># 进行挂载</span></span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-11-06%2021.40.09.png" /></p><h4 id="存储抽象pv和pvc">7、存储抽象——PV和PVC</h4><p><em>PV：持久卷（PersistentVolume），将应用需要持久化的数据保存到指定位置</em></p><p><em>PVC：持久卷申明（<strong>Persistent VolumeClaim</strong>），申明需要使用的持久卷规格</em></p><p>​先前挂载数据的模式，挂载的文件目录不受控制，可能存在一些问题，故而我们提出了PV和PVC这样一个概念。先事先规划好所有的持久卷及地址。如下图所示，容器想要挂载空间时，需要先申请，申请1G的空间，那么就会从现有的空间中挑选出最合适的分配给这个Pod。这样的好处是：如果Pod被移除，则PVC被移除，PVC移除后，其对应的空间也会被移除。</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-11-07%2014.45.32.png" /></p><h5 id="实践pv池静态供应模式">1）实践：PV池——静态供应模式</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nfs主节点</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /nfs/data/01</span><br><span class="line"><span class="built_in">mkdir</span> -p /nfs/data/02</span><br><span class="line"><span class="built_in">mkdir</span> -p /nfs/data/03</span><br></pre></td></tr></table></figure><ul><li>利用如下YAML文件，在PV池中，创建三个PV存储空间</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv01-10m</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">10M</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/nfs/data/01</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">172.31</span><span class="number">.0</span><span class="number">.4</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv02-1gi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/nfs/data/02</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">172.31</span><span class="number">.0</span><span class="number">.4</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv03-3gi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">3Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/nfs/data/03</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">172.31</span><span class="number">.0</span><span class="number">.4</span></span><br></pre></td></tr></table></figure><ul><li>创建PVC，即写一份空间申请书，我需要申请的空间为200M，且访问模式需要支持读写。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">200Mi</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs</span></span><br></pre></td></tr></table></figure><ul><li>创建Pod绑定PVC</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-deploy-pvc</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deploy-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-deploy-pvc</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-deploy-pvc</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">          <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">            <span class="attr">claimName:</span> <span class="string">nginx-pvc</span></span><br></pre></td></tr></table></figure><h5 id="实践pv池动态供应模式">2）实践：PV池——动态供应模式：</h5><p>​就是PV池并不是提前分配好的，而是每收到一个PVC，就分配一个对应大小的PV空间。</p><h4 id="存储抽象configmap">8、存储抽象——ConfigMap</h4><p>作用：抽取应用配置，并且可以自动更新</p><ul><li>以Redis部署为例：</li></ul><h5id="把之前的配置文件创建为配置集">1）把之前的配置文件创建为配置集</h5><figure class="highlight plaintext"><figcaption><span>s</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 创建配置，redis保存到k8s的etcd；</span><br><span class="line">kubectl create cm redis-conf --from-file=redis.conf</span><br></pre></td></tr></table></figure><h5 id="随后就可以根据配置集启动pod">2）随后就可以根据配置集启动Pod</h5><h4 id="存储抽象secret资源">9、存储抽象——Secret资源：</h4><p>​ Secret 对象类型用来保存敏感信息，例如密码、OAuth 令牌和 SSH 密钥。将这些信息放在 secret 中比放在 <ahref="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pod</a>的定义或者 <ahref="https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-image">容器镜像</a>中来说更加安全和灵活。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过一个私有的docker来创建一个secret资源，</span></span><br><span class="line">kubectl create secret docker-registry leifengyang-docker \</span><br><span class="line">--docker-username=leifengyang \</span><br><span class="line">--docker-password=Lfy123456 \</span><br><span class="line">--docker-email=534096094@qq.com</span><br><span class="line"></span><br><span class="line"><span class="comment">## 命令格式</span></span><br><span class="line">kubectl create secret docker-registry regcred \</span><br><span class="line">  --docker-server=&lt;你的镜像仓库服务器&gt; \</span><br><span class="line">  --docker-username=&lt;你的用户名&gt; \</span><br><span class="line">  --docker-password=&lt;你的密码&gt; \</span><br><span class="line">  --docker-email=&lt;你的邮箱地址&gt;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过secret资源来创建docker</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">private-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">private-nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">leifengyang/guignginx:v1.0</span></span><br><span class="line">  <span class="attr">imagePullSecrets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">leifengyang-docker</span></span><br></pre></td></tr></table></figure><h5 id="section"></h5>]]></content>
    
    
    <summary type="html">云原生快速入门系列笔记，Kubernetes入门</summary>
    
    
    
    <category term="⑧ 工程类笔记" scheme="https://blog.fantast.top/categories/%E2%91%A7-%E5%B7%A5%E7%A8%8B%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="云原生入门" scheme="https://blog.fantast.top/categories/%E2%91%A7-%E5%B7%A5%E7%A8%8B%E7%B1%BB%E7%AC%94%E8%AE%B0/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="Cloud Native" scheme="https://blog.fantast.top/tags/Cloud-Native/"/>
    
  </entry>
  
  <entry>
    <title>云原生快速入门系列Chap1——云平台+容器化</title>
    <link href="https://blog.fantast.top/2022/11/03/a1fb45edd54f/"/>
    <id>https://blog.fantast.top/2022/11/03/a1fb45edd54f/</id>
    <published>2022-11-03T09:43:19.000Z</published>
    <updated>2022-11-04T10:06:28.873Z</updated>
    
    <content type="html"><![CDATA[<h4 id="公有云和私有云">1、公有云和私有云：</h4><ul><li><p>公有云：</p><ul><li>公有云资源（例如服务器和存储空间）由第三方云服务提供商拥有和运营，这些资源通过Internet 提供</li><li><strong>成本更低</strong>：无需购买硬件或软件，仅对使用的服务付费。</li><li><strong>无需维护</strong>：维护由服务提供商提供。</li><li><strong>近乎无限制的缩放性</strong>：提供按需资源，可满足业务需求。</li><li><strong>高可靠性</strong>：具备众多服务器，确保免受故障影响。</li><li>可用性： N个9 全年的故障时间： 365<em>24</em>3600*(1-99.9999%)</li></ul></li><li><p>私有云：</p><ul><li><p>私有云由专供一个企业或组织使用的云计算资源构成。在私有云中，<strong>服务和基础结构始终在私有网络上进行维护，硬件和软件专供组织使用。</strong>私有云的使用对象通常为政府机构、金融机构以及其他具备业务关键性运营且希望对环境拥有更大控制权的中型到大型组织。</p></li><li><p><strong>灵活性更强</strong>：组织可自定义云环境以满足特定业务需求。</p></li><li><p><strong>控制力更强</strong>：资源不与其他组织共享，因此能获得更高的控制力以及<strong>更高的隐私级别。</strong></p></li><li><p><strong>可伸缩性更强</strong>：与本地基础结构相比，私有云通常具有更强的可伸缩性。</p></li></ul></li><li><p>没有一种云计算类型适用于所有人。多种不同的云计算模型、类型和服务已得到发展，可以满足组织快速变化的技术需求。</p></li></ul><h4 id="私有网络vpc">2、私有网络VPC</h4><p>​ 集群内服务器之间互相访问，一般都是用私有IP进行访问，速度更快.</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221031170245325.png" /></p><p>​在实际的服务器集群中,可以自己先新建一个专有网络(其实就是可以在内部创建局域网,然后再通过交换机创建子网等),划分相应的网段.比如说192.168.o.0/16.</p><p>​ 不同VPC之间的主机不能直接通信,VPC提供了一个隔离域.</p><h4 id="docker容器化概念">3、Docker容器化概念</h4><ul><li>统一标准，应用构建、分享和运行。</li><li>资源隔离：cpu内存资源隔离与限制，访问设备隔离与限制，网络隔离与限制等</li><li>虚拟化技术：<ul><li>在Docker容器化技术还没有出现的时候，人们使用的是虚拟化技术。基于虚拟机的部署方式，基础镜像非常大，创建使用稍微复杂，启动速度较慢，移植与分享不方便，虽然其隔离性非常的好。</li><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221101161243475.png" style="zoom:67%;" /></li></ul></li><li>基于虚拟化的Docker容器化技术：<ul><li>基础镜像MB级别，创建简单，启动速度快，移植与分享方便</li><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221101161359831.png" style="zoom:67%;" /></li><li>架构如图所示：Registry镜像仓库，Containers容器，Images镜像</li><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221101161524606.png" style="zoom:67%;" /></li></ul></li></ul><h4 id="docker容器化常用命令">4、Docker容器化常用命令</h4><h5 id="镜像相关">1）镜像相关</h5><p>​ Docker Hub常用的镜像网站</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx  <span class="comment">#下载最新版</span></span><br><span class="line">docker pull nginx:1.20.1 <span class="comment">#下载指定版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 下载来的镜像都在本地</span></span><br><span class="line">docker images  <span class="comment">#查看所有镜像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除镜像</span></span><br><span class="line">docker rmi 镜像名:版本号 / 镜像<span class="built_in">id</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="容器启动停止相关">2）容器启动停止相关：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># -d：后台运行</span></span><br><span class="line"><span class="comment"># --restart=always   该容器开机自启，应用开机自启</span></span><br><span class="line"><span class="comment"># -p 外部端口:内部端口  端口映射 </span></span><br><span class="line">docker run --name=mynginx -d --restart=always -p 88:80 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看正在运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="comment"># 查看所有容器</span></span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除停止的容器</span></span><br><span class="line">docker <span class="built_in">rm</span>  容器<span class="built_in">id</span>/名字</span><br><span class="line">docker <span class="built_in">rm</span> -f mynginx   <span class="comment"># 强制删除正在运行中的容器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#停止容器</span></span><br><span class="line">docker stop 容器<span class="built_in">id</span>/名字</span><br><span class="line"><span class="comment">#再次启动</span></span><br><span class="line">docker start 容器<span class="built_in">id</span>/名字</span><br></pre></td></tr></table></figure><h5 id="修改容器内容">3）修改容器内容：</h5><ul><li>法1：进入容器内部，然后修改</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入容器内部的系统，修改容器内容</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 容器<span class="built_in">id</span> /bin/bash</span><br></pre></td></tr></table></figure><ul><li>法2：挂载数据到外部修改：(请注意：挂载在外部的数据是没法提交改变的)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=mynginx </span><br><span class="line">-d  --restart=always </span><br><span class="line">-p  88:80 </span><br><span class="line">-v /data/html:/usr/share/nginx/html:ro  <span class="comment"># 外部数据地址:内部数据地址 :ro代表只读模式，容器内不能修改</span></span><br><span class="line">nginx</span><br></pre></td></tr></table></figure><h5 id="提交改变">4）提交改变：</h5><ul><li>将自己修改好的自定义镜像提交,这样会在本地产生一个新的镜像</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># -a author -m message</span></span><br><span class="line">docker commit -a <span class="string">&quot;fantast&quot;</span> -m <span class="string">&quot;首页变化&quot;</span> 341d81f7504f slksnginx:v1.0</span><br></pre></td></tr></table></figure><ul><li>将镜像文件打包存储，然后传输给另一台主机：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打包镜像至压缩包</span></span><br><span class="line">docker save -o abc.tar fantastnginx:v1.0</span><br><span class="line"><span class="comment"># 远程传输</span></span><br><span class="line">scp abc.tar root@128.12.33.12:/root/</span><br><span class="line"><span class="comment"># 加载docker镜像压缩包</span></span><br><span class="line">docker load abc.tar</span><br></pre></td></tr></table></figure><ul><li>推送至远程仓库docker hub</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把旧镜像的名字，改成仓库要求的新版名字</span></span><br><span class="line">docker tag fantastnginx:v1.0 fantast616/fantastnginx:v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录到docker hub</span></span><br><span class="line">docker login       </span><br><span class="line"></span><br><span class="line">docker <span class="built_in">logout</span>（推送完成镜像后退出）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送</span></span><br><span class="line">docker push fantast616/fantastnginx:v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 别的机器下载</span></span><br><span class="line">docker pull fantast616/fantastnginx:v1.0</span><br></pre></td></tr></table></figure><h5 id="其他命令">5）其他命令：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker 运行日志</span></span><br><span class="line">docker logs 容器名/id</span><br><span class="line"><span class="comment"># docker 进入内部BASH控制台</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 容器<span class="built_in">id</span> /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker 经常修改nginx配置文件</span></span><br><span class="line">docker run -d -p 80:80 \</span><br><span class="line">-v /data/html:/usr/share/nginx/html:ro \</span><br><span class="line">-v /data/conf/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">--name mynginx-02 \</span><br><span class="line">nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#把容器指定位置的东西复制出来 </span></span><br><span class="line">docker <span class="built_in">cp</span> 5eff66eec7e1:/etc/nginx/nginx.conf  /data/conf/nginx.conf  </span><br><span class="line"><span class="comment">#把外面的内容复制到容器里面</span></span><br><span class="line">docker <span class="built_in">cp</span>  /data/conf/nginx.conf  5eff66eec7e1:/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><h4id="编写一个简单的springboot应用并部署">5、编写一个简单的SpringBoot应用并部署：</h4><h5 id="docker部署redis">1）Docker部署Redis</h5><p>首先下载redis镜像，并在外部配置文件，最后启动redis镜像完成映射</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">#redis使用自定义配置文件启动</span><br><span class="line"></span><br><span class="line">docker run -v /data/redis/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-v /data/redis/data:/data \</span><br><span class="line">-d --name myredis \</span><br><span class="line">-p 6379:6379 \</span><br><span class="line">redis:latest  redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure><h5 id="非docker部署步骤">2）非Docker部署步骤：</h5><ul><li>SpringBoot打包为可执行的jar包，并上传至服务器</li><li>服务器运行java -jar</li></ul><h5id="docker部署步骤编写dockerfile">3）Docker部署步骤：编写DockerFile</h5><ul><li>Dockerfile如下：</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-slim  <span class="comment"># 基础镜像环境，比如说运行环境java</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=fantast</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> target/*.jar /app.jar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><ul><li><p>还有一个Jar目录叫做 target</p></li><li><p>将Dockerfile和target上传到服务器的一个目录下，然后执行以下命令构建镜像</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t java-demo:v1.0 .</span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221104142249625.png" /></p><h5 id="分享docker">4）分享docker</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录docker hub</span></span><br><span class="line">docker login</span><br><span class="line"></span><br><span class="line"><span class="comment">#给旧镜像起名</span></span><br><span class="line">docker tag java-demo:v1.0  fantast/java-demo:v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送到docker hub</span></span><br><span class="line">docker push fantast/java-demo:v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 别的机器</span></span><br><span class="line">docker pull fantast/java-demo:v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 别的机器运行</span></span><br><span class="line">docker run -d -p 8080:8080 --name myjava-app java-demo:v1.0</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">云原生快速入门系列笔记，云平台+容器化</summary>
    
    
    
    <category term="⑧ 工程类笔记" scheme="https://blog.fantast.top/categories/%E2%91%A7-%E5%B7%A5%E7%A8%8B%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="云原生入门" scheme="https://blog.fantast.top/categories/%E2%91%A7-%E5%B7%A5%E7%A8%8B%E7%B1%BB%E7%AC%94%E8%AE%B0/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="Cloud Native" scheme="https://blog.fantast.top/tags/Cloud-Native/"/>
    
  </entry>
  
  <entry>
    <title>Mysql数据库调优工具</title>
    <link href="https://blog.fantast.top/2022/10/28/a30af89db2dc/"/>
    <id>https://blog.fantast.top/2022/10/28/a30af89db2dc/</id>
    <published>2022-10-28T08:41:19.000Z</published>
    <updated>2022-10-30T14:16:43.773Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一数据库优化步骤及优化工具">一、数据库优化步骤及优化工具</h3><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221028165505532.png" style="zoom:67%;" /></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221028165600066.png" style="zoom:67%;" /></p><h4 id="统计sql的查询成本">1、统计SQL的查询成本：</h4><p>​ 这个Value代表的是进行了多少个页的查询</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221028170212104.png" /></p><p>​使用场景：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。SQL查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：</p><ul><li>位置决定效率。如果页就在数据库缓冲池中，那么效率是最高的，否则还需要从内存或者磁盘中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。</li><li>批量决定效率。如果我们从磁盘中对单一页进行随机读，那么效率是很低的（差不多10ms），而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。</li><li>考虑数据存放的位置，如果是经常使用的数据就要尽量放到缓冲池中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。</li></ul><h4 id="开启慢查询日志">2、开启慢查询日志：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global slow_query_log=&#x27;ON&#x27;;</span><br></pre></td></tr></table></figure><p>​MySQL的慢查询日志，用来记录在MySQL中响应时间超过阈值的语句，具体指运行时间超过long_query_time值的SQL，会被记录到慢查询日志中，默认值为10s。</p><p>​ 如果不是调优需要的话，一般不会开启该参数。</p><p>​ 设置时间阈值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global long_query_time = 1;</span><br><span class="line">mysql&gt; show global variables like &#x27;%long_query_time%&#x27;;</span><br><span class="line">mysql&gt; set long_query_time=1;</span><br><span class="line">mysql&gt; show variables like &#x27;%long_query_time%&#x27;;</span><br></pre></td></tr></table></figure><p>​ 查看慢查询记录条数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GLOBAL STATUS LIKE &#x27;%Slow_queries%&#x27;;</span><br></pre></td></tr></table></figure><p>​ 慢查询日志分析工具：mysqldumpslow</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#得到返回记录集最多的10个SQL</span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log</span><br><span class="line">#得到访问次数最多的10个SQL</span><br><span class="line">mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log</span><br><span class="line">#得到按照时间排序的前10条里面含有左连接的查询语句</span><br><span class="line">mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/atguigu-slow.log</span><br><span class="line">#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more</span><br></pre></td></tr></table></figure><p>​ 查看SQL执行成本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; set profiling = &#x27;ON&#x27;;</span><br><span class="line">mysql &gt; show profiles;</span><br><span class="line">mysql &gt; show profile;</span><br><span class="line">mysql&gt; show profile cpu,block io for query 2;</span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/image-20221029131535493.png" /></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29 13.17.28.png" style="zoom:67%;" /></p><h4 id="分析查询语句explain">3、分析查询语句EXPLAIN：</h4><p>​<strong>定位了查询慢的SQL之后，我们就可以使用EXPLAIN或DESCRIBE工具做针对性的分析查询语句。</strong></p><ul><li><p>能显示哪些信息？</p><ul><li><p>表的读取顺序，数据读取操作的操作类型、哪些索引可以使用，哪些索引实际被使用、表之间的引用、每张表有多少行被优化器查询。</p></li><li><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29%2013.32.18.png" /></p></li><li><table><colgroup><col style="width: 19%" /><col style="width: 80%" /></colgroup><thead><tr class="header"><th>id</th><th></th></tr></thead><tbody><tr class="odd"><td>select_type</td><td>SELECT关键字对应的那个查询的类型</td></tr><tr class="even"><td>table</td><td>表名</td></tr><tr class="odd"><td>Partitions</td><td>匹配的分区信息</td></tr><tr class="even"><td>type</td><td>针对单表的访问方法</td></tr><tr class="odd"><td>Possible_keys</td><td>可能用到的索引</td></tr><tr class="even"><td>key</td><td>实际上使用的索引</td></tr><tr class="odd"><td>key_len</td><td>实际使用到的索引长度</td></tr><tr class="even"><td>ref</td><td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td></tr><tr class="odd"><td>rows</td><td>预估的需要读取的记录条数</td></tr><tr class="even"><td>filtered</td><td>某个表经过搜索条件过滤后剩余记录条数的百分比</td></tr><tr class="odd"><td>Extra</td><td>一些额外的信息</td></tr></tbody></table></li></ul></li></ul><h5 id="id-和-table关键词">1）id 和 table关键词</h5><ul><li>Case1:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 INNER JOIN s2</span><br><span class="line">ON s1.key1 = s2.key1</span><br><span class="line">WHERE s1.common_field = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><ul><li><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29%2013.57.41.png" /></p><ul><li><p>每一条查询记录，都对应一张单表。比如说上述innerjoin，用到两个单表，所以会显示有两条记录</p></li><li><p>但是在一个大的查询中，一个SELECT关键词对应着一个id</p></li></ul></li><li><p>Case2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure></li><li><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29%2014.03.11.png" /></p><ul><li>有两个SELECT语句，所以对应两个id</li></ul></li><li><p>Case3:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key2 FROM s2 WHERE common_field = &#x27;a&#x27;);</span><br></pre></td></tr></table></figure><ul><li><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29%2014.07.15.png" /></p></li><li><p>虽然有两个SELECT语句，为啥同一个ID呢？因为查询优化器可能对涉及子查询的查询语句进行重写，转换为多表查询的形式。</p></li></ul></li><li><p>Case4:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;</span><br></pre></td></tr></table></figure><ul><li><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29%2014.09.41.png" /></p></li><li><p>UNION操作因为需要中间表进行去重操作，所以涉及到第三个记录。</p></li></ul></li><li><p>Case5:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;</span><br></pre></td></tr></table></figure></li><li><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29%2014.10.39.png" /></p></li><li><p>因为UNION ALL不用去重，所以不会有第三条记录</p></li><li><p><strong>总结相关内容：</strong></p><ul><li>id如果相同，可以认为是一组，从上往下顺序执行</li><li>在所有组中，id值越大，优先级越高，越先执行</li><li>关注点：id号每个号码，表示一趟独立的查询,一个sql的查询趟数越少越好</li></ul></li></ul><h5 id="select_type">2）select_type</h5><p>​SELECT关键字对应的那个查询的类型，确认了小查询在大的查询中扮演了怎样的一个角色。</p><ul><li><p>查询语句中不包含UNION和子查询的都是SIMPLE</p></li><li><p>连接查询都是SIMPLE</p></li><li><p>Case1: 相关子查询 DEPENDENT SUBQUERY</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE s1.key2 =</span><br><span class="line">s2.key2) OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29%2014.18.01.png" /></p></li><li><p>Case2: 查询优化器优化了的情况</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 IN </span><br><span class="line">(</span><br><span class="line">    SELECT key1 FROM s2 WHERE key1 = &#x27;a&#x27; </span><br><span class="line">   UNION </span><br><span class="line">   SELECT key1 FROM s1 WHERE key1 = &#x27;b&#x27;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29%2014.23.09.png" /></p><h5id="type对某张表的查询类型查询方法">3）type：对某张表的查询类型，查询方法</h5><ul><li>所有访问类型，越靠前是我们最希望看到的（效果越好）：system ， const， eq_ref ， ref ， fulltext ， ref_or_null ，index_merge ，unique_subquery ， index_subquery ， range ， index ， ALL</li><li>system</li></ul><p>示例：表结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE s1 (</span><br><span class="line">    id INT AUTO_INCREMENT,</span><br><span class="line">    key1 VARCHAR(100),</span><br><span class="line">    key2 INT,</span><br><span class="line">    key3 VARCHAR(100),</span><br><span class="line">    key_part1 VARCHAR(100),</span><br><span class="line">    key_part2 VARCHAR(100),</span><br><span class="line">    key_part3 VARCHAR(100),</span><br><span class="line">    common_field VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    INDEX idx_key1 (key1),</span><br><span class="line">    UNIQUE INDEX idx_key2 (key2),</span><br><span class="line">    INDEX idx_key3 (key3),</span><br><span class="line">    INDEX idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE=INNODB CHARSET=utf8;</span><br></pre></td></tr></table></figure><ul><li>const：根据主键或唯一二级索引与常数进行匹配</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE id = 10005;</span><br></pre></td></tr></table></figure><ul><li>eq_ref：连接查询时，被驱动表根据主键或唯一二级索引与常数进行匹配</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;</span><br></pre></td></tr></table></figure><p>​从执行计划的结果中可以看出，MySQL打算将s2作为驱动表，s1作为被驱动表，重点关注s1的访问方法是eq_ref，表明在访问s1表的时候可以通过主键的等值匹配来进行访问</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29%2014.29.09.png" /></p><ul><li>ref：普通二级索引与常数进行匹配</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-29%2014.33.58.png" /></p><ul><li>ref_or_null 普通二级索引与常数进行匹配，且索引值可能为null</li><li>index_merge MySQL 打算使用索引合并的方式来执行对 s1 表的查询。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27; OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><ul><li>unique_subquery</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key2 IN (SELECT id FROM s2 where s1.key1 = s2.key1) OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><ul><li>index_subquery</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE common_field IN (SELECT key3 FROM s2 where s1.key1 = s2.key1) OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><ul><li>range使用索引获取某些范围区间的记录，那么就可能使用到range访问方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;a&#x27; AND key1 &lt; &#x27;b&#x27;;</span><br></pre></td></tr></table></figure><ul><li>index当我们可以使用素引覆盖（不用回表就可以查到数据），但需要扫描全部的索引记录时，该表的访问方法就是index【因为此处，联合索引的字段最优先的是key_part1,key_part2然后才是key_part3】</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3=&#x27;a&#x27;；</span><br></pre></td></tr></table></figure><p>​ 即如果语句如下，则type就是ref而非index</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT key_part2 FROM s1 WHERE key_part1=&#x27;a&#x27; and key_part3 = &#x27;b&#x27;;</span><br></pre></td></tr></table></figure><ul><li>all</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1;</span><br></pre></td></tr></table></figure><p>​ <strong>SQL</strong> <strong>性能优化的目标：至少要达到</strong><strong>range</strong> <strong>级别，要求是</strong><strong>ref</strong> <strong>级别，最好是</strong><strong>consts</strong>级别。</p><h5 id="possible_keys-和-key">4）possible_keys 和 key</h5><p>​在EXPLAIN语句输出的执行计划中，possible_keys列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些。一般查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。key列表示实际用到的索引有哪些，如果为NULL，则没有使用索引。</p><h5 id="key_len">5）key_len</h5><p>​实际使用到的索引长度（字节数），帮你检查是否充分的利用上了索引，值越大越好，主要针对于联合索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE id = 10005;</span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221029221248821.png" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key2 = 10126;</span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221029221254958.png" /></p><p>4+1 =5, 因为key2字段不是非空的，所以记录NULL需要一个字节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key_part1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221029221407032.png" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key_part1 = &#x27;a&#x27; AND key_part2 = &#x27;b&#x27;;</span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221029221412049.png" /></p><p><strong>key_len</strong>如何计算:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># varchar(10)变长字段且允许NULL = 10 * ( character set：</span><br><span class="line"># utf8=3,gbk=2,latin1=1)+1(NULL)+2(变长字段)</span><br><span class="line"></span><br><span class="line"># varchar(10)变长字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+2(变长字段)</span><br><span class="line"></span><br><span class="line"># char(10)固定字段且允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL)</span><br><span class="line"></span><br><span class="line"># char(10)固定字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)</span><br></pre></td></tr></table></figure><h5 id="ref">6）ref</h5><p>​ 当使用索引列等值查询的时候，与索引列进行等值匹配的对象信息。</p><h5 id="rows">7）rows</h5><p>​ 预估的需要读取的记录条数</p><h5 id="filtered">8）filtered</h5><p>​某个表经过搜索条件过滤后，剩余记录条数的百分比。对于单表查询没有什么大的意义。</p><ul><li>Case1:代表，单表查询时，经过key1 &gt; 'z' 和 common_filed='a'条件筛选后，还剩下的记录是10%</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27; AND common_field = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221030202016814.png" /></p><ul><li>Case2:连表查询时，s1驱动表，s2被驱动表,此时filtered的值决定了被驱动表s2需要执行的次数，即rows*filtered。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key1 WHERE s1.common_field = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221030202138448.png" /></p><h5 id="extra">9） Extra</h5><p>​ 更准确的理解MySQL到底将如何执行给定的查询语句</p><h5 id="小结">10）小结：</h5><ul><li>EXPLAIN不考虑各种Cache</li><li>EXPLAIN不能显示MySQL在执行查询时所作的优化工作</li><li>EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况</li><li>部分统计信息是估算的，并非精确值</li></ul><h4 id="explain语句的输出格式">4、EXPLAIN语句的输出格式</h4><h5 id="传统格式表格形式">1）传统格式，表格形式</h5><p>​ 即上述内容</p><h5 id="json格式会显示成本">2）JSON格式，会显示成本</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN FORMAT=JSON SELECT ....</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query_block&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;select_id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cost_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;4445.50&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;nested_loop&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;table_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s1&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;access_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ALL&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;possible_keys&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;idx_key1&quot;</span></span><br><span class="line">          <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;rows_examined_per_scan&quot;</span><span class="punctuation">:</span> <span class="number">9825</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;rows_produced_per_join&quot;</span><span class="punctuation">:</span> <span class="number">9825</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;filtered&quot;</span><span class="punctuation">:</span> <span class="string">&quot;100.00&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;cost_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;read_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;24.25&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;eval_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;982.50&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;prefix_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1006.75&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;data_read_per_join&quot;</span><span class="punctuation">:</span> <span class="string">&quot;17M&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;used_columns&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;id&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key3&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key_part1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key_part2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key_part3&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;common_field&quot;</span></span><br><span class="line">          <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;attached_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`experiment`.`s1`.`key1` is not null)&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;table_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s2&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;access_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eq_ref&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;possible_keys&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;idx_key2&quot;</span></span><br><span class="line">          <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;idx_key2&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;used_key_parts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;key2&quot;</span></span><br><span class="line">          <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;key_length&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;ref&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;experiment.s1.key1&quot;</span></span><br><span class="line">          <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;rows_examined_per_scan&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;rows_produced_per_join&quot;</span><span class="punctuation">:</span> <span class="number">9825</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;filtered&quot;</span><span class="punctuation">:</span> <span class="string">&quot;100.00&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;index_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(cast(`experiment`.`s1`.`key1` as double) = cast(`experiment`.`s2`.`key2` as double))&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;cost_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;read_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2456.25&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;eval_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;982.50&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;prefix_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;4445.50&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;data_read_per_join&quot;</span><span class="punctuation">:</span> <span class="string">&quot;17M&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;used_columns&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;id&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key3&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key_part1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key_part2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;key_part3&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;common_field&quot;</span></span><br><span class="line">          <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>由于 s2 表是被驱动表，所以可能被读取多次，这里的 read_cost 和eval_cost 是访问多次 s2 表后累</p><p>加起来的值，大家主要关注里边儿的 prefix_cost的值代表的是整个连接查询预计的成本，也就是单</p><p>次查询 s1 表和多次查询 s2 表后的成本的和.</p></li><li><p>read_cost</p><ul><li>IO 成本</li><li>检测 rows × (1 - filter) 条记录的 CPU 成本</li></ul></li><li><p>eval_cost</p><ul><li>检测rows × filter 条记录的成本</li></ul></li><li><p>prefix_cost</p><ul><li>单独查询s1表的成本</li></ul></li><li><p>data_read_per_join</p><ul><li>在此次查询中需要读取的数据量</li></ul></li></ul><h5 id="tree形式">3）TREE形式</h5><h5 id="可视化形式">4）可视化形式</h5><h4id="分析优化器执行计划trace工具">5、分析优化器执行计划：trace工具</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET optimizer_trace=&quot;enabled=on&quot;,end_markers_in_json=on;</span><br><span class="line">SET optimizer_trace_max_mem_size=1000000;</span><br></pre></td></tr></table></figure><p>开启以后可以分析常见的许多SQL语句,通过如下语句进行查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.optimizer_trace\G</span><br></pre></td></tr></table></figure><h4 id="mysql监控分析视图-sys-schema">6、MySQL监控分析视图-sysschema</h4><p>​关于MySQL的性能监控和问题诊断，我们一般都从performance_schema中去获取想要的数据，在MySQL5.7.7版本中新增sysschema，它将prformance_schema和information_schema中的数据以更容易理解的方式总结归纳为”视图”，其目的就是为了降低查询performance_schema的复杂度，让DBA能够快速的定位问题。</p><p>​下面看看这些库中都有哪些监控表和视图，掌握了这些，在我们开发和运维的过程中就起到了事半功倍的效果。</p><ul><li>索引相关</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#1. 查询冗余索引</span><br><span class="line">select * from sys.schema_redundant_indexes;</span><br><span class="line">#2. 查询未使用过的索引</span><br><span class="line">select * from sys.schema_unused_indexes;</span><br><span class="line">#3. 查询索引的使用情况</span><br><span class="line">select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted</span><br><span class="line">from sys.schema_index_statistics where table_schema=&#x27;dbname&#x27; ;</span><br></pre></td></tr></table></figure><ul><li>表相关</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 1. 查询表的访问量</span><br><span class="line">select table_schema,table_name,sum(io_read_requests+io_write_requests) as io from</span><br><span class="line">sys.schema_table_statistics group by table_schema,table_name order by io desc;</span><br><span class="line"># 2. 查询占用bufferpool较多的表</span><br><span class="line">select object_schema,object_name,allocated,data</span><br><span class="line">from sys.innodb_buffer_stats_by_table order by allocated limit 10;</span><br><span class="line"># 3. 查看表的全表扫描情况</span><br><span class="line">select * from sys.statements_with_full_table_scans where db=&#x27;dbname&#x27;;</span><br></pre></td></tr></table></figure><ul><li>语句相关</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#1. 监控SQL执行的频率</span><br><span class="line">select db,exec_count,query from sys.statement_analysis</span><br><span class="line">order by exec_count desc;</span><br><span class="line">#2. 监控使用了排序的SQL</span><br><span class="line">select db,exec_count,first_seen,last_seen,query</span><br><span class="line">from sys.statements_with_sorting limit 1;</span><br><span class="line">#3. 监控使用了临时表或者磁盘临时表的SQL</span><br><span class="line">select db,exec_count,tmp_tables,tmp_disk_tables,query</span><br><span class="line">from sys.statement_analysis where tmp_tables&gt;0 or tmp_disk_tables &gt;0</span><br><span class="line">order by (tmp_tables+tmp_disk_tables) desc;</span><br></pre></td></tr></table></figure><ul><li>IO相关</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#1. 查看消耗磁盘IO的文件</span><br><span class="line">select file,avg_read,avg_write,avg_read+avg_write as avg_io</span><br><span class="line">from sys.io_global_by_file_by_bytes order by avg_read limit 10;</span><br></pre></td></tr></table></figure><ul><li>Innodb相关</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#1. 行锁阻塞情况</span><br><span class="line">select * from sys.innodb_lock_waits;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Chap12——Mysql 数据库效率调优工具，包含EXPLAIN，trace，sys schema</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://blog.fantast.top/2022/10/27/5b0755a55834/"/>
    <id>https://blog.fantast.top/2022/10/27/5b0755a55834/</id>
    <published>2022-10-27T13:51:19.000Z</published>
    <updated>2022-11-10T00:59:31.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一索引的创建与删除">一、索引的创建与删除</h3><ul><li>分类之<strong>全文索引</strong>：搜索引擎使用的一种关键技术。它能够利用【分词技术】等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。<strong>全文索引非常适合大型数据集，对于小的数据集，它的用处比较小。</strong><ul><li>使用参数FULLTEXT可以设置索引为全文索引。</li><li>在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。查询数据量较大的字符串类型的字段时，使用全文索引可以提高查询速度。例如，表student的字段information是TEXT类型，该字段包含了很多文字信息。在字段information上建立全文索引后，可以提高查询字段information的速度。</li></ul></li></ul><h4 id="创建删除索引">1、创建删除索引：</h4><h5 id="创建表时新增">1）创建表时新增</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name [col_name data_type]</span><br><span class="line">[UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC | DESC]</span><br></pre></td></tr></table></figure><ul><li><p>UNIQUE 、FULLTEXT 和SPATIAL为可选参数，分别表示唯一索引、全文索引和空间索引；</p></li><li><p>INDEX 与KEY 为同义词，两者的作用相同，用来指定创建索引；</p></li><li><p>index_name指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名；</p></li><li><p>col_name为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；</p></li><li><p>length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；</p></li><li><p>ASC 或DESC 指定升序或者降序的索引值存</p></li><li><p>多列索引：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INDEX multi_idx(id,name,age)</span><br></pre></td></tr></table></figure><ul><li>全文索引：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `papers` (</span><br><span class="line">`id` int(10) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">`title` varchar(200) DEFAULT NULL,</span><br><span class="line">`content` text,</span><br><span class="line">PRIMARY KEY (`id`),</span><br><span class="line">FULLTEXT KEY `title` (`title`,`content`)</span><br><span class="line">) ENGINE=MyISAM DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>全文检索如何查询？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM papers WHERE content LIKE ‘%查询字符串%’; # 普通查询</span><br><span class="line">SELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’); # 全文检索，非常快</span><br></pre></td></tr></table></figure><h5 id="创建表后新增">2）创建表后新增</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name</span><br><span class="line">ON table_name (col_name[length],...) [ASC | DESC]</span><br></pre></td></tr></table></figure><h5 id="删除索引">3）删除索引：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX index_name ON table_name;</span><br></pre></td></tr></table></figure><h3 id="二mysql8.0索引新特性">二、Mysql8.0索引新特性：</h3><h4 id="降序索引">1、降序索引：</h4><p>​ 即DESC关键字被支持，其在某种场景下意义重大，如下：</p><p>先创建索引如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE ts1(a int,b int,index idx_a_b(a ASC,b desc));</span><br></pre></td></tr></table></figure><p>​ 在执行如下语句时，执行计划中扫描数为799，而且提示使用了Usingfilesort，这是MySQL中一种速度比较慢的外部排序，能避免是最好的。多数情况下，管理员可以通过优化索引来尽量避免出现Usingfilesort，从而提高数据库执行速度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM ts1 ORDER BY a,b DESC LIMIT 5;</span><br></pre></td></tr></table></figure><p>​ 但是在执行如下语句时，就会快很多且不会使用Using filesort：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM ts1 ORDER BY a ASC,b DESC LIMIT 5;</span><br></pre></td></tr></table></figure><h4 id="隐藏索引">2、隐藏索引：</h4><p>​只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引（即使使用forceindex（强制使用索引），优化器也不会使用该索引），确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。</p><p>​ 这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除。</p><p>​同时，如果你想验证某个索引删除之后的查询性能影响，就可以暂时先隐藏该索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX indexname</span><br><span class="line">ON tablename(propname[(length)]) INVISIBLE;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引</span><br><span class="line">ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引</span><br></pre></td></tr></table></figure><h3 id="三索引的设计原则">三、索引的设计原则</h3><h4 id="哪些情况适合创建索引">1、哪些情况适合创建索引？</h4><h5id="字段的数值有唯一性的限制但是没有加唯一性约束的字段">1）字段的数值有唯一性的限制，但是没有加唯一性约束的字段</h5><h5 id="频繁作为where查询条件的字段">2）频繁作为WHERE查询条件的字段</h5><h5 id="经常group-by和order-by的列">3）经常GROUP BY和ORDER BY的列</h5><p>​需要对分组或者排序的字段进行索引。如果待排序的列有多个，那么可以在这些列上建立联合索引。既有GROUPBY 又有 ORDER BY，可以考虑建立联合索引，但联合索引要先写GROUP BY 再写ORDER BY。</p><h5 id="updatedelete-的-where-条件列">4）UPDATE、DELETE 的 WHERE条件列</h5><p>​如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</p><h5 id="distinct-操作的字段需要创建索引">5）DISTINCT操作的字段需要创建索引</h5><p>​有时候我们需要对某个字段进行去重，使用DISTINCT，那么对这个字段创建索引，也会提升查询效率。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT(student_id) FROM `student_info`;</span><br></pre></td></tr></table></figure><h5id="多表join连接操作时创建索引的注意事项">6）多表JOIN连接操作时，创建索引的注意事项:</h5><ul><li>连接的表数量不要超过3张</li><li>对WHERE条件创建索引</li><li><strong>对用于连接的字段创建索引</strong>，并且该字段在多张表中的类型必须一致。</li></ul><h5 id="使用列的类型小的创建索引">7）使用列的类型小的创建索引</h5><ul><li><p>类型大小指该类型表示的数据范围的大小。</p></li><li><p>如果要对某个列建立索引，尽量让这个列使用较小的数据类型。原因：</p><ul><li>数据类型越小，在查询时进行的比较操作越快</li><li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘I/0带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li></ul></li></ul><h5id="创建字符串列的索引时注意事项">8）创建字符串列的索引时注意事项：</h5><p>​假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的B+树中有这么两个问题：</p><ul><li>B+树索引中的记录需要把该列的完整字符串存储起来，更费时。而且字符串越长，在索引中占用的存储空间越大。</li><li>如果B+树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间。</li></ul><p>​<strong>通过截取字段的前面一部分内容建立索引，这个就叫前缀索引。</strong></p><p>​这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后<strong>根据前缀相同的记录的主键值回表查询完整的字符串值。</strong>既节约空间，又减少了字符串的比较时间，还大体能解决排序的问题。</p><ul><li><p><strong>关键问题</strong>：截取多少比较合适？</p></li><li><p>先看一下字段在全部数据中的选择度</p><ul><li>```mysql select count(distinct address) / count(<em>) from shop;count(distinct left(列名, 索引长度))/count(</em>) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```mysql</span><br><span class="line">  select count(distinct left(address,10)) / count(*) as sub10, -- 截取前10个字符的选择度</span><br><span class="line">  count(distinct left(address,15)) / count(*) as sub11, -- 截取前15个字符的选择度</span><br><span class="line">  count(distinct left(address,20)) / count(*) as sub12, -- 截取前20个字符的选择度</span><br><span class="line">  count(distinct left(address,25)) / count(*) as sub13 -- 截取前25个字符的选择度</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="区分度高的列适合作为索引">9）区分度高的列适合作为索引：</h5><p>​列的基数指的是某一列中不重复数据的个数，比方说某个列包含值2，5，8，2，5，8，2，5，8，虽然有9条记录，但该列的基数却是3。</p><p>​ 可以使用公式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct a)/count(*) from t1 </span><br></pre></td></tr></table></figure><p>​ 计算区分度，越接近1越好，一般超过33%就算是比较高效的索引了。</p><h5id="使用最频繁的列放到联合索引的左侧">10）使用最频繁的列放到联合索引的左侧</h5><h5id="在多个字段都要创建索引时联合索引优于单值索引">11）在多个字段都要创建索引时，联合索引优于单值索引</h5><h4 id="索引数目的限制">2、索引数目的限制：</h4><ul><li><p>单张表不超过6个索引</p></li><li><p>索引占用磁盘空间、会影响insert，update的效率。同时，因为优化器在执行查询前，如果索引太多，会导致其生成执行计划的时间降低。</p></li></ul><h4 id="哪些情况不适合创建索引">3、哪些情况不适合创建索引？</h4><h5id="在where中使用不到的字段不要设置索引">1）在where中使用不到的字段，不要设置索引</h5><h5id="数据量小的表最好不要使用索引">2）数据量小的表最好不要使用索引</h5><h5id="有大量重复数据的列上不要建立索引10">3）有大量重复数据的列上不要建立索引（10%）</h5><p>​ 要在 100 万行数据中查找其中的 50万行（比如性别为男的数据），一旦创建了索引，你需要先访问 50万次索引，然后再访问 50万次数据表，这样加起来的开销比不使用索引可能还要大.</p><h5id="避免对经常更新的表创建过多的索引">4）避免对经常更新的表创建过多的索引</h5><h5 id="不建议用无序的值作为索引">5）不建议用无序的值作为索引</h5><p>​例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。</p>]]></content>
    
    
    <summary type="html">Chap11——Mysql 索引与创建原则</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB数据存储结构分析</title>
    <link href="https://blog.fantast.top/2022/10/25/df494e08f4d8/"/>
    <id>https://blog.fantast.top/2022/10/25/df494e08f4d8/</id>
    <published>2022-10-25T07:09:19.000Z</published>
    <updated>2022-11-10T00:59:41.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一数据库的存储结构页">一、数据库的存储结构：页</h3><h4id="磁盘与内存交互的基本单位页">1、磁盘与内存交互的基本单位——页：</h4><ul><li><p>InnoDB将数据划分为若干个页，页的大小默认为16KB。</p></li><li><p><strong>将页作为磁盘和内存之间交互的基本单位。</strong>即，在数据库中，不论读多少行，都是将这些行所在的页进行加载。即I/O操作的最小单位就是页。</p></li><li><p>连续的页之间，不在物理结构上相连接，期间通过双向链表连接。每个数据页中的记录会按照主键的值从小到大的顺序组成一个单向链表，<strong>每个数据也都会为存储在它里面的记录生成一个页目录，</strong>这样可以在页目录中是用二分法定位到对应的槽，再遍历槽对应分组中的记录找到指定记录就行。</p></li><li><p>页的上层结构：</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221023094039939.png" /></p><ul><li>区：一个区会分配64个连续的页</li><li>段：段是数据库中的分配单位。段中不要求区和区之间连续。比如说创建一张表时，会创建一个表段，创建一个索引时，会创建一个索引段。</li><li>表空间：逻辑容器，可以有1个或多个段。表空间从管理上可以划分为：系统表空间、用户表空间等。</li></ul></li></ul><h4 id="页的内部结构">2、页的内部结构：</h4><h5 id="数据页的存储空间被划分为7个部分">1)数据页的存储空间被划分为7个部分：</h5><ul><li><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221023094541084.png" /></li><li><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221023094558222.png" /></li></ul><h5 id="file-header-和-file-trailer-文件头部和文件尾部">2) File Header和 File Trailer 文件头部和文件尾部：</h5><ul><li>File Header 描述各种页的通用信息——页的编号，上一页下一页等<ul><li>FIL_PAGE_OFFSET 页的单独页号</li><li>FIL_PAGE_TYPE 页的类型，比如索引页、日志页等等</li><li>FIL_PAGE_PREV（4字节）和FIL_PAGE_NEXT（4字节）本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，保证这些页之间不需要是物理上的连续，而是逻辑上的连续。</li><li>FIL_PAGE_SPACE_OR_CHKSUM（4字节）当前页面的校验和，<strong>文件头部和尾部都有这个校验和</strong><ul><li>作用 :InnoDB存储引擎以页为单位把数据加载到内存中处理，<strong>如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候断电了，造成了该页传输的不完整。</strong>为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），<strong>这时可以通过文件尾的校验和（checksum值）与文件头的校验和做比对，如果两个值不相等则证明页的传输有问题，需要重新进行传输，</strong>否则认为页的传输已经完成。</li><li>具体操作方法：每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为FileHeader在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在FileHeader中的校验和就代表着已经修改过的页，而在FileTrailer中的校验和代表着原先的页，二者不同则意味着同步中间出了错。</li></ul></li><li>FIL_PAGE_LSN 页面被最后修改时对应的日志序列位置（Log SequenceNumber）</li></ul></li><li>文件尾部：共8字节<ul><li>前4个字节代表页的校验和：这个部分是和File Header中的校验和相对应的。后4个字节代表页面被最后修改时对应的日志序列位置（LSN）：这个部分也是为了校验页的完整性的，如果首部和尾部的LSN值校验不成功的话，就说明同步过程出现了问题</li></ul></li></ul><h5 id="free-space-user-records-infimum-supremum">3) Free Space &amp;User Records &amp; Infimum Supremum</h5><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-23%2016.31.02.png" /></p><ul><li><p>每插入一条记录，从Free Space部分申请一个记录大小的空间分给UserRecords空间</p></li><li><p>我们自己存储的记录会按照指定的行格式存储到UserRecords部分</p></li><li><p>记录按照指定的行格式一条一条摆在UserRecords部分，相互之间形成单链表。用户记录里的一条条数据如何记录和形成呢？详见InnoDB行格式中的记录头信息。</p></li><li><p>Infimum Supremum 最小最大记录：</p><ul><li><p>对于一条完整的记录来说，比较记录的大小就是比较主键的大小。</p></li><li><p>InnoDB规定的最小记录与最大记录这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-23%2016.40.36.png" /></p></li><li><p>这两条记录不是我们自己定义的记录，所以它们并不存放在页的UserRecords部分，他们被单独放在一个称为Infimum +Supremum的部分，如图所示：</p></li></ul></li></ul><h5 id="page-directory-page-header-页目录和页头">4) Page Directory &amp;Page Header 页目录和页头</h5><ul><li><p>1、为什么需要页目录？</p><ul><li>在页中，记录是以单向链表的形式进行存储的。查找性能差，因此在页结构中专门设计了页目录这个模块，专门给记录做一个目录，通过二分查找法的方式进行检索，提升效率。</li><li>具体做法：将所有的记录分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录。<ul><li>第 1 组，也就是最小记录所在的分组只有 1 个记录；最后一组，就是最大记录所在的分组，会有 1-8 条记录； 其余的组记录数量在4-8 条之间。</li><li>在每个组中<strong>最后一条记录的头信息中会存储该组一共有多少条记录</strong>，作为n_owned 字段。</li><li>页目录用来存储<strong>每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，</strong>每组的地址偏移量也被称之为槽（slot），每个槽相当于指针指向了不同组的最后一个记录。</li><li><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-23%2016.50.25.png" /></li></ul></li></ul></li><li><p>2、页目录结构下如何快速查找记录？</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-23%2016.53.45.png" /></p></li></ul><p>Page Header 页头</p><ul><li><p>为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫PageHeader的部分，这个部分占用固定的56个字节，专门存储各种状态信息。</p></li><li><p>PAGE_DIRECTION 记录插入方向</p></li><li><p>PAGE_N_DIRECTION</p><ul><li>假设连续几次插入新记录的方向都是一致的，InnoDB会把沿着同一个方向插入记录的条数记下来，这个条数就用PAGE_N_DIRECTION这个状态表示。当然，如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计。</li></ul></li></ul><h4id="从数据页的角度看b树如何查询">3、从数据页的角度看B+树如何查询：</h4><h5 id="如何查询">1）如何查询？</h5><p>​先从B+树的根开始，逐层检索。然后将数据页加载到内存中，页目录中的槽使用二分查找的方式先找到一个粗略的记录分组，然后再在分组中通过链表遍历的方式查找记录。</p><h5id="普通索引和唯一索引在查询中的区别">2）普通索引和唯一索引在查询中的区别？</h5><p>​唯一索引找到了关键字就可以停止检索。而普通索引找到关键字以后，还需要在内存中多看下X条记录。</p><h4 id="innodb行格式compact行格式">4、InnoDB行格式：COMPACT行格式</h4><p>一条记录的数据可以分为记录的额外信息和真实数据</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-23%2016.34.37.png" /></p><h5 id="变长字段长度列表">1）变长字段长度列表</h5><p>​变长字段中存储多少字节的数据不是固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。</p><p>​在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表。注意：这里面存储的变长长度和字段顺序是反过来的。比如两个varchar字段在表结构的顺序是a(10)，b(15)。那么在变长字段长度列表中存储的长度顺序就是15，10，是反过来的。</p><h5 id="null值列表">2）NULL值列表</h5><p>​Compact行格式会把可以为NULL的列统一管理起来，存在一个标记为NULL值列表中。如果表中没有允许存储NULL 的列，则 NULL值列表也不存在了。</p><ul><li>为什么定义NULL值列表？<ul><li>之所以要存储NULL是因为数据都是需要对齐的，如果没有标注出来NULL值的位置，就有可能在查询数据的时候出现混乱。如果使用一个特定的符号放到相应的数据位表示空置的话，虽然能达到效果，但是这样很浪费空间，所以直接就在行数据得头部开辟出一块空间专门用来记录该行数据哪些是非空数据，哪些是空数据，</li></ul></li><li>格式如下：<ul><li>二进制位的值为1时，代表该列的值为NULL。</li><li>二进制位的值为0时，代表该列的值不为NULL。</li></ul></li><li>例如：字段 a、b、c，其中a是主键，在某一行中存储的数依次是a=1、b=null、c=2。那么Compact行格式中的NULL值列表中存储：01。第一个0表示c不为null，第二个1表示b是null。这里之所以没有a是因为数据库会自动跳过主键，因为主键肯定是非NULL且唯一的，在NULL值列表的数据中就会自动跳过主键。</li></ul><h5 id="记录头信息总共就5个字节">3）记录头信息（总共就5个字节）</h5><ul><li><p>delete_mask</p><ul><li>这个属性标记着当前记录是否被删除，占用1个二进制位。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后其他的记录在磁盘上需要重新排列，导致性能消耗。所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的垃圾链表。<br /></li></ul></li><li><p>min_rec_mask</p><ul><li>B+树的每层非叶子节点中的最小记录都会添加该标记，min_rec_mask值为1。</li></ul></li><li><p>record_type</p><ul><li>这个属性表示当前记录的类型，一共有4种类型的记录：<ul><li>0：表示普通记录<br /></li><li>1：表示B+树非叶节点记录</li><li>2：表示最小记录<br /></li><li>3：表示最大记录</li></ul></li></ul></li><li><p>heap_no</p><ul><li>这个属性表示当前记录在本页中的位置。比如说2，3，4，5等</li><li><strong>MySQL会自动给每个页里加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为伪记录或者虚拟记录。</strong>这两个伪记录一个代表最小记录，一个代表最大记录。最小记录和最大记录的heap_no值分别是0和1，也就是说它们的位置最靠前。<br /></li></ul></li><li><p>n_owned</p><ul><li><strong>页目录</strong>中每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为n_owned 字段。详情见page directory。</li></ul></li><li><p>next_record</p><ul><li>它表示从当前记录的真实数据到下一条记录的真实数据的<strong>地址偏移量。</strong></li><li>比如：第一条记录的next_record值为32，意味着从第一条记录的真实数据的地址处向后找32个字节便是下一条记录的真实数据。注意，下一条记录指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。</li><li>规定Infimum记录（也就是最小记录）的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是Supremum记录（也就是最大记录）。</li></ul></li><li><p><strong>不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的。</strong></p></li><li><p>主键值为2的记录被删掉了以后，存储空间不会回收，如果我们再次把这条记录插入到表中，会发生什么事呢？——直接复用了原来被删除记录的存储空间。</p></li><li><p><strong>说明：当数据页中存在多条被删除掉的记录时，这些记录的next_record属性将会把这些被删除掉的记录组成一个垃圾链表，以备之后重用这部分存储空间。</strong></p></li></ul><h5 id="记录的真实数据">4）记录的真实数据</h5><p>​ 除了我们自己定义的列数据以外，还会有三个隐藏列。</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221023222958606.png" /></p><p>​实际上这几个列的真正名称其实是：DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR</p><ul><li>一个表没有手动定义主键，则会选取一个Unique键作为主键，如果连Unique键都没有定义的话，则会为表默认添加一个名为row_id的隐藏列作为主键。所以row_id是在没有自定义主键以及Unique键的情况下才会存在的。</li><li>事务ID和回滚指针涉及到事务相关的内容，具体见事务</li></ul><h4 id="dynamic和compressed行格式">5、Dynamic和Compressed行格式</h4><h5 id="什么是行溢出">1）什么是行溢出？</h5><p>​ InnoDB存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。很多DBA喜欢MySQL数据库提供的VARCHAR(M)类型，认为可以存放65535字节。这是真的吗？如果我们使用ascii字符集的话，一个字符就代表一个字节，我们看看VARCHAR(65535)是否可用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE varchar_size_demo( c VARCHAR(65535) ) CHARSET=ascii ROW_FORMAT=Compact;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have to change some columns to TEXT or BLOBs </span><br></pre></td></tr></table></figure><p>​报错信息表达的意思是：MySQL对一条记录占用的最大存储空间是有限制的，除BLOB或者TEXT类型的列之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节。这个65535个字节除了列本身的数据之外，还包括一些其他的数据，</p><p>​<strong>以Compact行格式为例，比如说我们为了存储一个VARCHAR(M)类型的列，除了真实数据占有空间以外，还需要记录的额外信息。如果该VARCHAR类型的列没有NOTNULL属性，那最多只能存储65532个字节的数据，因为变长字段的长度占用2个字节，NULL值标识需要占用1个字节。</strong></p><ul><li><p>通过上面的案例，我们可以知道一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65533个字节，<strong>这样就可能出现一个页存放不了一条记录，这种现象称为行溢出。</strong></p></li><li><p>在Compact和Reduntant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中进行分页存储，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。这称为页的扩展，：</p></li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221023224141758.png" /></p><h5 id="dynamic和compressed如何处理行溢出">2)Dynamic和Compressed如何处理行溢出？</h5><p>​ 在MySQL8.0中，默认行格式就是Dynamic。Dynamic、Compressed行格式和Compact行格式挺像，只不过在处理行溢出数据时有分歧：</p><ul><li><p>Compressed和Dynamic两种记录格式对于存放在BLOB中的数据采用了完全的行溢出的方式。</p></li><li><p>如图，在数据页中只存放20个字节的指针（溢出页的地址），实际的数据都存放在OffPage（溢出页）中。Compact和Redundant两种格式会在记录的真实数据处存储一部分数据（存放768个前缀字节）。<strong>Compressed行记录格式的另一个功能就是，存储在其中的行数据会以zlib的算法进行压缩，因此对于BLOB、TEXT、VARCHAR这类大长度类型的数据能够进行非常有效的存储。</strong></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221023224238085.png" /></p></li></ul><h4 id="区段与碎片区与表空间结构">5、区、段与碎片区与表空间结构：</h4><h5 id="为什么要有区">1）为什么要有区？</h5><p>​如果以页为单位来分配存储空间的话，双向链表相邻的两个页之间的物理位置可能离得比较远。当进行范围查询时，我们一般只需要定位到最左侧和最右侧的记录，然后沿着双向链表一直扫描即可。那么如果相邻的两个页之间的物理位置可能离得比较远的话，其实是在做<strong>随机IO</strong>，对于磁盘而言读写速度是很慢的。</p><p>​所以，引入区的概念，使得1个区中含物理位置上连续的64个页，这样就会把上述过程变成<strong>顺序IO</strong>，减少了磁盘寻道和半圈旋转时间。</p><p>​在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，<strong>而是按照区为单位分配，</strong>甚至在表中的数据特别多的时候，可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费（数据不足以填充满整个区），<strong>但是从性能角度看，可以消除很多的随机I/0</strong>，功大于过！</p><h5 id="为什么要有段">2）为什么要有段？</h5><p>​对于范围查询，其实是对B+树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。</p><p>​所以InnoDB对B+树的叶子节点和非叶子节点进行了区别对待，<strong>也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。</strong></p><p>​存放叶子节点的区的集合就算是一个段（segment），存放非叶子节点的区的集合也算是一个段。<strong>也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。</strong></p><p>​<strong>段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。</strong></p><h5 id="为什么要有碎片区">3）为什么要有碎片区？</h5><p>​默认情况下，一个使用InnoDB存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用1M（64*16Kb=1024Kb）存储空间，所以默认情况下一个只存了几条记录的小表也需要2M的存储空间么？以后每次添加一个索引都要多申请2M的存储空间么？这对于存储记录比较少的表简直是天大的浪费。</p><p>​这个问题的症结在于到现在为止我们介绍的区都是非常纯粹的，<strong>也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。</strong></p><p>​为了考虑以完整的区为单位分配给某个段对于数据量较小的表太浪费存储空间的这种情况，InnoDB提出了一个<strong>碎片（fragment）区的概念</strong>。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是<strong>碎片区中的页可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。</strong></p><p>​ 碎片区直属于表空间，并不属于任何一个段。</p><h5 id="为某个段分配存储空间的策略">4）为某个段分配存储空间的策略：</h5><ul><li>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。</li><li>当某个段已经占用了32个碎片区页面之后，就会申请以完整的区为单位来分配存储间。</li></ul><p>​所以现在段不能仅定义为是某些区的集合，更精确的应该是某些零散的页面以及一些完整的区的集合。</p><h5 id="区的分类">5）区的分类</h5><ul><li><p>碎片区</p><ul><li><p>空闲的区</p></li><li><p>有剩余空间的碎片区</p></li><li><p>没有剩余空间的碎片区</p></li></ul></li><li><p>附属于某个段的区</p></li></ul><h5 id="表空间">6）表空间：</h5><p>​表空间可以看做是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。表空间是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。</p><ul><li>独立表空间：<ul><li>每张表都有一个独立的表空间，即数据和索引信息都会保存在自己的表空间中。空间可以回收</li></ul></li><li>系统表空间：<ul><li>整个MySQL进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面，这部分是独立表空间中没有的。</li><li>InnoDB数据字典：（内部系统表）<ul><li>每当我们向一个表中插入一条记录的时候，MySOL校验过程如下<ul><li>先要校验一下插入语句对应的表存不存在，插入的列和表中的列是否符合，</li><li>如果语法没有问题的话，还需要知道该表的聚簇索引和所有二级索引对应的根页面是哪个表空间的哪个页面，然后把记录插入对应索引的B+树中。</li><li>所以说，MySQL除了保存着我们插入的用户数据之外，还需要保存许多额外的信息（元数据）</li></ul></li><li>注意：用户是不能直接访问InnoDB的这些内部系统表，除非你直接去解析系统表空间对应文件系统上的文件。</li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">Chap10——Mysql InnoDB数据存储结构分析</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://blog.fantast.top/2022/10/23/abee3bd85d4a/"/>
    <id>https://blog.fantast.top/2022/10/23/abee3bd85d4a/</id>
    <published>2022-10-23T07:09:19.000Z</published>
    <updated>2022-11-10T00:59:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一为什么使用索引优缺点">一、为什么使用索引&amp;优缺点：</h3><p>​避免全表扫描，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据。</p><p>​如上图所示，数据库没有索引的情况下，数据分布在硬盘不同的位置上面，<strong>读取数据时，摆臂需要前后摆动查找数据，这样操作非常消耗时间。</strong></p><p>​索引是一种数据结构，每个节点缓存的是一个Key-Value结构，Key是列的值，Value是该Key所在行对应的指针（文件位置）。</p><h4 id="优点">优点：</h4><ul><li>降低数据库的IO成本，提高数据检索的效率</li><li>加速表和表之间的连接。对于有依赖关系的子表和父表联合查询时，提高速度</li><li>显著减少查询中分组和排序的时间，降低CPU消耗</li></ul><h4 id="缺点">缺点：</h4><ul><li>创建和维护需要耗费时间</li><li>索引需要占据磁盘空间。</li><li>索引提高查询速度的同时，会降低更新表的速度。</li></ul><h3 id="二没有索引时的查找">二、没有索引时的查找：</h3><h4 id="case1-在单页中的查找">Case1: 在单页中的查找</h4><p>​ 如果数据较少，则所有记录都可以被存放到一个页里面</p><ul><li>以主键为搜索条件：可以以O（logN)复杂度查询到</li><li>以其他键为搜索条件：只能遍历.从最小记录开始以此遍历单链表中的每条记录。</li></ul><h4 id="case2在多页中的查找">Case2：在多页中的查找</h4><p>​ 如果记录非常多，需要很多数据页来存储这些记录，主要步骤分为：</p><ul><li>定位到记录所在的页</li><li>从所在的页内查找相应的记录</li></ul><p>​在没有索引的情况下，由于不能快速定位到记录所在的页，只能从第一个页沿着双向链表一直往下找。在每个页中进行匹配。因为要遍历所有的数据页(以及加载)，所以非常耗时.</p><h3 id="三索引的设计">三、索引的设计:</h3><p>首先，简化假设某一条记录在磁盘上的记录形式如下：</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221021092747727.png" /></p><p>那</p><p>1么，将一些记录放到页中的示意图就是如下所示：一个数据页的默认大小为16KB，其中会存有一定数量的记录。</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221021105655165.png" /></p><p>​我们现在的问题就是：想要快速的定位到需要查找的记录在哪些数据页中。我们可以采用B+树的形式进行架构，如下图所示：最底层的数据页存放的是普通的记录，record_type=0，页与页直接以双向链表的形式链接。再上层的数据页中存储的是普通记录的目录项记录，它们的record_type=1，再往上走就是层级更高的目录项，至此构成一颗B+树。需要值得注意的是，相邻的页之间页编号不一定连续，是通过指针指向链接的。</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221021105859291.png" /></p><p>​我们可以利用B+树定位到某条记录在哪个数据页的形式，可以大大节省内存和硬盘的IO次数，定位到具体的数据页以后，在每个页面内也有页目录，可以通过二分法来实现快速的定位记录。</p><h3 id="四常见索引的概念">四、常见索引的概念:</h3><h4 id="聚簇索引">1、聚簇索引：</h4><p>​是一种数据存储方式，所有的用户记录都存储在了叶子节点，即<strong>数据即索引</strong>，<strong>索引即数据</strong>。</p><h5 id="特点">特点：</h5><ul><li>使用记录本身的 主键值的大小 进行记录和页的排序<ul><li>页内的记录——按照主键的大小顺序排成单向链表。</li><li>各个存放用户记录的页——根据主键大小顺序排成一个双向链表</li><li>存放目录项记录的页——分为不同的层次，同一层次中的页之间按逐渐大小顺序排成双向链表</li></ul></li><li>B+树的叶子节点存储的是完整的用户记录</li><li>这种索引不需要我们在mysql中显式创建，InnoDB会自动创建聚簇索引。</li></ul><h5 id="优点-1">优点：</h5><ul><li>访问速度更快，对于主键的排序查找和范围查找非常快</li><li>查询显示一定范围数据的时候，由于数据都紧密相连，数据库不用从多个数据块中提取数据，节省了大量的io操作。</li></ul><h5 id="缺点-1">缺点：</h5><ul><li>插入速度严重依赖于插入顺序</li><li>更新主键代价很高，所以一般定义主键不可更新</li><li>二级索引访问需要两次查找</li></ul><h5 id="限制">限制：</h5><ul><li>仅有InnoDB数据引擎支持，MyISAM不支持聚簇索引</li><li>每个Mysql的表只能有一个聚簇索引，一般情况下是表的主键</li></ul><h4id="二级索引辅助索引非聚簇索引">2、二级索引（辅助索引、非聚簇索引）</h4><p>​如果想以非主键进行查找怎么办呢？多建几颗B+树即可。使用该列的大小作为数据页、页中记录的排序规则。对于这些B+树中，其叶子节点中并不存储完整的用户记录，而是仅存储<strong>该列+ 主键的值</strong></p><h5 id="特点-1">特点：</h5><ul><li>使用记录本身的 该列（建B+树索引的列）值的大小 进行记录和页的排序<ul><li>页内的记录——按照该列的大小顺序排成单向链表。</li><li>各个存放用户记录的页——根据该列大小顺序排成一个双向链表</li><li>存放目录项记录的页——分为不同的层次，同一层次中的页之间按逐渐大小顺序排成双向链表</li></ul></li><li>B+树的叶子节点存储的是 <strong>该列的值 + 主键的值</strong></li><li>这种索引需要我们在mysql中显式创建。</li><li><strong>在以该列为条件搜索的时候，需要进行回表操作</strong>，就是说先查找到记录的主键的值，再利用主键的值去聚簇索引中查找整条记录的值。</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221021212458365.png" /></p><h4 id="联合索引">3、联合索引：</h4><p>​同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照c2和c3列 的大小进行排序，这个包含两层含义：</p><ul><li><p>先把各个记录和页按照c2列进行排序。</p></li><li><p>在记录的c2列相同的情况下，采用c3列进行排序</p></li><li><p>以c2和c3列的大小为排序规则建立的B+树称为 联合索引，<strong>本质上也是一个二级索引。</strong>它的意思与分别为c2和c3列分别建立索引的表述是不同的，主要表现为：</p><ul><li>建立 联合索引 只会建立如上图一样的1棵B+树。</li></ul></li></ul><h4 id="innodb的b树索引的注意事项">4、InnoDB的B+树索引的注意事项：</h4><ul><li><strong>根页面位置不变</strong>，实际上B+树的形成过程如下：<ul><li>每当为某个表创建一个B+树索引的时候，<strong>都会为这个索引创建一个根节点页面。</strong></li><li>最开始表中没有数据的时候，每个B+树索引对应的根节点中既没有用户记录，也没有目录项记录。</li></ul></li><li>非叶节点中目录项记录的唯一性：即如果建立的非聚簇索引的那一列值不唯一怎么办？容易导致非叶节点的目录项不唯一。<ul><li>为了让新插入记录能找到自己在哪个页里，<strong>我们需要保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的。</strong>所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：<ul><li>索引列的值</li><li>主键值</li><li>页号</li></ul></li></ul></li></ul><figure><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221021223514710.png"alt="蓝色即为主键值，橙色为建立索引列的值" /><figcaptionaria-hidden="true">蓝色即为主键值，橙色为建立索引列的值</figcaption></figure><ul><li>一个页面最少存储2条记录（其实就是B+树本身的限制）</li></ul><h4 id="myisam中的索引方案">5、MyISAM中的索引方案：</h4><p>​在MyISAM中，其使用的B+树索引的，叶子结点存储的是数据记录的地址，而不是数据本身。</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/image-20221022120251019.png" /></p><h4 id="innodb和myisam引擎的区别">6、InnoDB和MyISAM引擎的区别</h4><p><strong>MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。</strong></p><ul><li><p>①在InnoDB存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在MyISAM中却需要进行一次回表操作，意味着MyISAM中建立的索引相当于全部都是二级索引。</p></li><li><p>②InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。</p></li><li><p>③InnoDB的非聚簇索引data域存储相应记录主键的值，而MyISAM索引记录的是地址。</p></li><li><p>④MyISAM的回表操作是十分快速的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</p></li><li><p>⑤ InnoDB要求表必须有主键（MyISAM可以没有）。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。</p></li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-22%2012.06.40.png" /></p><h4 id="索引的数据结构选取">7、索引的数据结构选取</h4><p>​为了减少索引在内存中的占用，其都是存储在磁盘上的。当我们使用索引查询的时候，不可能把索引全都一次性加载到内存中，所以要尽可能的设计索引的数据结构，使得<strong>磁盘IO次数较少</strong></p><ul><li>Hash索引从速度上来讲比树型索引要快很多，那么为什么索引还是设计成树的样子呢？<ul><li>因为Hash索引仅能支持 等于、不等于 操作，无法支持范围查询</li><li>数据的存储没有顺序，如果需要ORDER BY的情况下，还要重新排序</li><li>如果重复值多，Hash冲突多的话，效率也会下降</li><li>不能支持联合索引</li><li>InnoDB不支持Hash索引</li></ul></li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/image-20221022121840709.png" /></p><ul><li>InnoDB本身不支持Hash索引，但提供自适应Hash索引：<ul><li>如果某个数据经常被访问，且满足一定条件，该数据页的地址就会放入Hash表中。下次查询的时候，直接通过自适应Hash就可以访问到这个数据页。</li></ul></li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/image-20221022122100058.png" style="zoom: 33%;" /></p><h4 id="b树和b树的选取">8、B树和B+树的选取：</h4><ul><li><p>B树：多路平衡查找树：</p><ul><li>（叶子结点和非叶子结点都会存储数据，搜索有可能终止于非叶子结点）</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/image-20221022122415040.png" /></p></li><li><p>B+树：</p><p>B+树更适合文件索引，两者区别如下：</p><ul><li>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 = 关键字数，而 B树中，孩子数量 = 关键字数+1。</li><li>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）。</li><li>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而B 树中， 非叶子节点既保存索引，也保存数据记录。</li><li>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接</li></ul></li><li><p>B+树相比于B树的区别和好处？</p><ul><li>查找效率更稳定（数据都在叶子节点），且更高（更矮胖）</li><li>范围查找中，效率也更高。因为数据都在叶子节点中，可以通过指针链接查找。</li></ul></li></ul><h4 id="r树">9、R树</h4><p>​其仅支持geometry数据类型。比如查找20km以内所有的餐厅，岂能解决高维空间的搜索问题。其实质上就是一颗用来存储高维数据的平衡树。</p>]]></content>
    
    
    <summary type="html">Chap9——Mysql 索引优缺点与底层原理</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Mysql逻辑架构和存储引擎</title>
    <link href="https://blog.fantast.top/2022/10/23/9dff215cdc98/"/>
    <id>https://blog.fantast.top/2022/10/23/9dff215cdc98/</id>
    <published>2022-10-23T07:09:19.000Z</published>
    <updated>2022-11-10T01:00:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一逻辑架构">一、逻辑架构：</h3><p>​ 使用经典的C/S架构，服务端程序使用的是mysqld服务，服务端大致分为三个步骤：</p><ul><li>连接管理（连接池）</li><li>解析和优化（SQL接口、解析器、优化器）</li><li>存储引擎（存储引擎和文件系统、日志文件）</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017154005406.png" /></p><h4 id="connectors">1、Connectors:</h4><p>​MySQL是一个网络i程序，本质上就是在TCP连接上，通过MySql协议跟Mysql服务器进行数据的交互</p><h4 id="连接管理">2、连接管理：</h4><p>​用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，<strong>都将依赖于此时读到的权限。</strong></p><p>​<strong>TCP连接池</strong>：用于限制连接数，可以采用长连接模式来复用TCP连接，解决上述问题</p><p>​<strong>线程池</strong>：TCP连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017161445894.png" style="zoom:50%;" /></p><h4 id="服务层">3、服务层：</h4><ul><li><p>SQL接口：</p><ul><li>接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT ...FROM就是调用SQL Interface</li></ul></li><li><p>Parser解析器：</p><ul><li>在解析器中对 SQL语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。</li><li><strong>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建语法树，并根据数据字典丰富查询语法树，会验证该客户端是否具有执行该查询的权限</strong></li></ul></li><li><p>Optimizer优化器：</p><ul><li><p>SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL语句的执行路径，生成一个执行计划。这个执行计划表明应该使用哪些索引进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。</p></li><li><p>它使用“ 选取-投影-连接”策略进行查询</p></li><li><pre><code>  SELECT id,name FROM student WHERE gender = &#39;女&#39;;</code></pre></li><li><p>这个SELECT查询先根据WHERE语句进行选取，而不是将表全部查询出来以后再进行gender过滤。这个SELECT查询先根据id和name进行属性投影，而不是将属性全部取出以后再进行过滤，将这两个查询条件连接起来生成最终查询结果。</p></li></ul></li><li><p>Caches &amp; Buffers： 查询缓存组件</p><ul><li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等。这个查询缓存可以在不同客户端之间共享</li></ul></li></ul><h4 id="引擎层">4、引擎层</h4><p>​ 插件式存储引擎层（ StorageEngines），真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作</p><h4 id="存储层">5、存储层：</h4><p>​所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在文件系统上，以文件的方式存在的，并完成与存储引擎的交互</p><h3 id="二sql执行流程">二、SQL执行流程：</h3><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017163209630.png" /></p><h4 id="查询缓存">1、查询缓存：</h4><p>​ 因为查询缓存往往效率不高，所以在 MySQL8.0之后就抛弃了这个功能。三大场景原因如下：</p><ul><li>在MySQL中的查询缓存，不是缓存查询计划，而是查询对应的结果。这就意味着查询匹配的鲁棒性大大降低，<strong>只有相同的查询操作才会命中查询缓存。</strong>两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。因此MySQL 的查询缓存命中率不高。</li><li>如果<strong>查询请求中包含某些系统函数、用户自定义变量和函数</strong>、一些系统表，如mysql 、 information_schema、 performance_schema数据库中的表，那这个请求就不会被缓存。</li><li>此外，既然是缓存，那就有它缓存失效的时候。<strong>MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，</strong>如对该表使用了INSERT、 UPDATE 、DELETE 、TRUNCATE TABLE 、ALTER TABLE 、DROP TABLE 或 DROPDATABASE语句，那<strong>使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！</strong>对于更新压力大的数据库来说，查询缓存的命中率会非常低。</li></ul><h4 id="解析器">2、解析器：</h4><ul><li><p>词法分析</p><ul><li>MySQL需要识别出SQL语句里面的字符串分别是什么，代表什么。是代表关键字还是表名</li></ul></li><li><p>语法分析</p><ul><li>根据词法分析的结果，语法分析器（比如：Bison）会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</li></ul></li><li><p>如果SQL语句正确，会生成一个语法树：</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017165049678.png" /></p></li></ul><h4 id="优化器">3、优化器：</h4><p>​ 在优化器中会确定 SQL语句的执行路径，优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序，还有表达式简化、子查询转为连接、外连接转为内连接等。</p><p>​在查询优化器中，可以分为<strong>逻辑查询优化阶段</strong>和<strong>物理查询优化阶段</strong>。</p><ul><li>逻辑查询优化就是通过改变SQL语句的内容来使得SQL查询更高效，同时为物理查询优化提供更多的候选执行计划。通常采用的方式是对SQL语句进行等价变换，对查询进行重写，而查询重写的数学基础就是关系代数。<strong>对条件表达式进行等价谓词重写、条件简化，对视图进行重写，对子查询进行优化，对连接语义进行了外连接消除、嵌套连接消除等</strong></li><li>物理查询优化是基于关系代数进行的查询重写，而关系代数的每一步都对应着物理计算，这些物理计算往往存在多种算法，因此需要计算各种物理路径的代价，从中选择代价最小的作为执行计划。在这个阶段里，对于单表和多表连接的操作，需要高效地使用索引，提升查询效率。</li></ul><h4 id="执行器">4、执行器：</h4><p>​在执行之前需要判断该用户是否具备权限。如果没有，就会返回权限错误。如果具备权限，就执行SQL查询并返回结果。</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017165434638.png" /></p><h4 id="语法顺序">5、语法顺序：</h4><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017170108824.png" /></p><h3 id="三数据库缓冲池">三、数据库缓冲池：</h3><p>​InnoDB存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘I/0需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS会申请占用内存来作为数据缓冲池，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的BufferPoo1之后才可以访问。</p><p>​ <strong>目的</strong>：减少与磁盘直接进行I/O的时间</p><h4 id="缓冲池">1、缓冲池：</h4><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017171714267.png" /></p><p>​缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟。所以InnoDB存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中，<strong>也就是说即使我们只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中。</strong>将整个页加载到内存中后就可以进行读写访问了，<strong>在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其缓存起来，这样将来有请求再次访问该页面时，就可以省去磁盘IO的开销了。</strong></p><p><strong>缓存原则：</strong></p><p>​ 优先对使用频次高的数据进行加载</p><p><strong>缓冲池的预读特性：</strong></p><p>​缓冲池的作用就是提升I/0效率，而我们进行读取数据的时候存在一个“局部性原理”，也就是说我们使用了一些数据，大概率还会使用它周围的一些数据，因此采用“预读”的机制提前加载，可以减少未来可能的磁盘I/O操作。</p><h4 id="缓冲池如何读取数据">2、缓冲池如何读取数据：</h4><p>​缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017172013707.png" /></p><p>​ 如果我们执行 SQL语句的时候更新了缓存池中的数据，那么这些数据会马上同步到磁盘上吗？</p><p>​实际上，当我们对数据库中的记录进行修改的时候，<strong>首先会修改缓冲池中页里面的记录信息，然后数据库会以一定的频率刷新到磁盘上。</strong></p><p>​注意并不是每次发生更新操作，都会立刻进行磁盘回写。缓冲池会采用一种叫做checkpoint的机制将数据回写到磁盘上，这样做的好处就是提升了数据库的整体性能。比如，当缓冲池不够用时，需要释放掉一些不常用的页，此时就可以强行采用checkpoint的方式，<strong>将不常用的脏页回写到磁盘上，然后再从缓冲池中将这些页释放掉。这里脏页（dirtypage）指的是缓冲池中被修改过的页，与磁盘上的数据页不一致。</strong></p><h4 id="多个buffer-pool实例">3、多个Buffer Pool实例：</h4><p>​ BufferPool本质是InnoDB向操作系统申请的一块连续的内存空间，在多线程环境下，访问BufferPool中的数据都需要加锁处理。<strong>在BufferPool特别大而且多线程并发访问特别高的情况下，单一的BufferPool可能会影响请求的处理速度。</strong>所以在BufferPool特别大的时候，我们可以把它们拆分成若干个小的BufferPool，<strong>每个BufferPool都称为一个实例，它们都是独立的，独立的去申请内存空间，独立的管理各种链表。所以在多线程并发访问时并不会相互影响，从而提高并发处理能力。</strong></p><h4 id="一些数据一致性问题">4、一些数据一致性问题</h4><figure><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221017172737298.png"alt="image-20221017172737298" /><figcaption aria-hidden="true">image-20221017172737298</figcaption></figure><p>​ 假设我们修改BufferPool中的数据成功，但是还没来得及将数据刷入磁盘MySQL就挂了怎么办？按照上图的逻辑，此时更新之后的数据只存在于BufferPool中，如果此时MySQL宕机了，这部分数据将会永久地丢失；怎么办呢？</p><p>​ 使用Redo Log和Undo Log来解决</p><h3 id="四存储引擎">四、存储引擎：</h3><h4id="innodb引擎具备外键支持功能的事务存储引擎">1、InnoDB引擎：具备外键支持功能的事务存储引擎</h4><ul><li>默认事务型引擎，设计用于处理大量的短期事务，确保事务的完整提交和回滚</li><li>其为处理巨大数据量的最大性能设计</li><li>InnoDB写的处理效率会差一些，其会占用更多的磁盘空间来保存数据和索引</li><li>MyISAM只缓存索引，不缓存真实数据。InnoDB不仅缓存索引，还缓存真实数据，对内存要求较高，内存大小对性能有决定性的影响。</li></ul><h4id="myisam引擎主要的非事务处理存储引擎">2、MyISAM引擎：主要的非事务处理存储引擎</h4><ul><li>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM不支持事务、行级锁、外键，有一个毫无疑问的缺陷就是崩溃后无法安全恢复。</li><li>优势是访问的速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应用</li><li>应用场景：只读应用或者以读为主的业务</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20221018172423185.png" /></p><h4 id="archive引擎用于数据归档">3、Archive引擎：用于数据归档</h4><h4id="csv引擎可以快速便捷和外界进行数据交换">4、CSV引擎：可以快速便捷和外界进行数据交换</h4><h4 id="memory引擎置于内存的表">5、Memory引擎：置于内存的表</h4><p>​ Memory采用的逻辑介质是内存，响应速度很快，但是当mysqld守护进程崩溃的时候数据会丢失。如下应用场景：</p><ol type="1"><li>目标数据比较小，而且非常频繁的进行访问，在内存中存放数据，如果太大的数据会造成内存溢出。</li><li>如果数据是临时的，而且必须立即可用得到，那么就可以放在内存中。</li><li>存储在Memory表中的数据如果突然间丢失的话也没有太大的关系。</li></ol>]]></content>
    
    
    <summary type="html">Chap8——Mysql 逻辑架构和存储引擎相关内容</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Mysql日志与备份</title>
    <link href="https://blog.fantast.top/2022/10/17/a810e83d8611/"/>
    <id>https://blog.fantast.top/2022/10/17/a810e83d8611/</id>
    <published>2022-10-17T07:09:19.000Z</published>
    <updated>2022-10-17T07:27:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一">一、</h3>]]></content>
    
    
    <summary type="html">Chap11——Mysql 日志与备份</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>电子信息工程中数学模型与方法——单元2 系统辨识</title>
    <link href="https://blog.fantast.top/2022/10/12/f71a1b069441/"/>
    <id>https://blog.fantast.top/2022/10/12/f71a1b069441/</id>
    <published>2022-10-12T00:14:20.782Z</published>
    <updated>2022-09-28T01:09:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一模型智能">一、模型智能</h2><h3 id="什么是智能">1、什么是智能？</h3><p>​ 智能有三个层次（某IBM科学家）：感知智能，执行智能，认知智能</p><ul><li>感知智能：感知环境状态</li><li>执行智能：采取行动</li><li>认知智能：建模、分析与决策，认知智能是最高级智能</li></ul><p>认知智能是动物和人建立/改进环境模型（规律的表述），使用模型处理信息并做出预测和决策的能力</p><ul><li><p>理想人工智能:人工智能是研究模拟和扩展动物和人的智能的理论和方法，包含感知智能、执行智能和认知智能。</p></li><li><p>当前人工智能：现在的所谓人工智能大都是开发基于图像和声音的感知技术。所以当前的人工智能还在感知智能的层次</p></li></ul><p>下图为自动控制流程：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220923163300371.png" style="zoom:67%;" /></p><ul><li><strong>一个系统的最优控制器一定是该系统的数学模型!</strong></li></ul><h3 id="基于智能建模的智能建造技术">2、基于智能建模的智能建造技术：</h3><ul><li><p>流程工业包括石化、化工、发电、钢铁、水泥、造纸、采矿等，是国民经济的基础</p></li><li><p>催生一个巨大的流程工业智能制造市场，在流程工业实现全面自动化生产，即智能制造，可以节能1%-10%，提高收益0.1% - 2%，减少污染物生成5% - 50%</p></li></ul><p>计划调度、诊断监控、实时优化、模型预测控制、常规PID控制、设备仪表及DCS系统</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220923163633152.png" /></p><p><strong>过程模型的建立/维护，是实现每一层自动/闭环的关键</strong></p><p><strong>模型智能：</strong>模型智能是一个计算机算法（软件），对于一类给定过程，可以对其自动建模、自动维护模型、并自动使用模型进行预测、控制、优化及诊断</p><h4 id="系统辨识的渐进法">1）系统辨识的渐进法：</h4><ul><li>多变量、闭环、自动系统辨识（建模）技术<ul><li>• 自动最优激励信号设计，多变量、闭环、自动测试</li><li>• 自动确定模型阶次</li><li>• 自动模型参数估计（计算）</li><li>• 自动模型检验，给出每个模型A, B, C, D评级</li></ul></li></ul><h4 id="pid闭环参数整定">2）PID闭环参数整定</h4><p>​PID控制器以其结构简单、稳定性好、调整方便而成为应用最广泛的一类工业控制器。</p><ul><li>问题核心：PID控制器参数整定困难</li><li>参数整定方法：</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220923164457568.png" style="zoom:67%;" /></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220923164619424.png" /></p><h4 id="模型预测控制">3）模型预测控制：</h4><p>​模型预测控制：是指利用对象的历史信息和模型信息，通过在未来时段上优化过程输出来计算最佳输入序列的一类算法。</p><p>​ <strong>关键环节：</strong>预测模型、滚动优化、反馈校正</p><p>​ 减少波动以后就可以卡边操作</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220923164911006.png" style="zoom:67%;" /></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220923165006259.png" /></p><h4 id="总结">3、总结：</h4><ul><li>动态模型是智能制造的关键，模型才是智能</li><li>团队经过多年研发，流程工业系统的智能建模、控制及优化技术已成熟，包括:(1) 基础控制层; (2) 先进控制层; (3) 实时优化层</li><li>可在各流程工业普及应用，节能减排、提高收益</li></ul><h2id="二系统辨识动态数据建模的理论和方法">二、系统辨识——动态数据建模的理论和方法：</h2><h3id="系统辨识介绍系统辨识的关键步骤">1、系统辨识介绍（系统辨识的关键步骤）</h3><ul><li><p>系统 System：系统是以有序形式排列的对象的集合，用于某种目的</p></li><li><p>过程 Process:过程是用于在流程工业中制造均质材料或能源产品的加工厂。加工工业包括：石油、化工、电力、造纸、玻璃、采矿、金属、水泥、药品、食品</p></li><li><p>模型 Model:模型是一个系统（过程）基本方面的表示，表示该系统的知识</p></li><li><p>数学模型 Mathematical Models:用微分方程和代数方程描述系统变量之间的关系。工程领域的主要部分涉及使用数学模型进行设计、模拟、预测和控制/优化。</p></li><li><p>系统辨识：系统或过程识别是使用测试数据对系统（过程）进行数学建模的领域。从技术上讲，Zadeh（1962）将系统识别定义为：在输入和输出的基础上，确定特定类别系统（模型）内的系统模型。</p></li><li><p><strong>系统辨识的过程</strong></p></li></ul><figure><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220923173506705.png"alt="image-20220923173506705" /><figcaption aria-hidden="true">image-20220923173506705</figcaption></figure><p><strong>系统辨识的关键步骤</strong>：</p><p>1）识别测试，辨识实验的设计 Identification tests/experiments：生成信息，输入输出数据</p><p>2）模型结构选择 Model order/structure selection：线性或非线性，什么结构（MIMO），什么顺序？</p><p>3）参数估计Parameter estimation ：使用一些优化技术确定模型参数。</p><p>4） 模型验证Model validation:：检查获得的模型是否足够好，是否能够使用（目的），如果不够，给出补救方法。</p><h3 id="动态系统和信号的模型">2、动态系统和信号的模型：</h3><h4id="单输入单输出连续时间模型siso-continuous-time-models">1）单输入单输出连续时间模型：SISOContinuous-Time Models</h4><p>​ 最常用的是<strong>微分方程</strong>和<strong>传递函数</strong>：</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927194052145.png" /></p><p>​ <imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927194102312.png" /></p><p>还可以用<strong>脉冲响应模型</strong>进行描述：<strong>引入延迟算子</strong></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927194118895.png" /></p><h4 id="单输入单输出离散时间模型">2）单输入单输出离散时间模型：</h4><p>一个使用保持电路的计算机控制系统采样过程</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927194329943.png" /></p><ul><li><p>Zero-Order Hold 即零阶保持器，只有一个设置<ahref="https://so.csdn.net/so/search?q=采样&amp;spm=1001.2101.3001.7020">采样</a>时间的参数，表示的是以采样时间间隔进行数据的采集；</p></li><li><p>Unit Delay即单位延迟模块，有两个输入参数，类似于<ahref="https://so.csdn.net/so/search?q=寄存器&amp;spm=1001.2101.3001.7020">寄存器</a>，第一个是设置初始值，第二个是采样时间。</p></li><li><p>Zero-Order Hold模块是以当前时间点以后的值为准，而UnitDelay是以当前时间之前的值为准。</p></li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927221208577.png" style="zoom:67%;" /></p><ul><li>在<strong>离散时间模型中</strong>引入延迟算子就能得到相应的离散传递函数：</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927221358771.png" style="zoom:50%;" /></p><ul><li><p>对一个n阶的差分方程使用0阶保持器：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927221507779.png" style="zoom:67%;" /></p></li></ul><h4 id="信号的几种模型描述方式">3）信号的几种模型描述方式</h4><h5 id="频域框架有限序列的信号的周期图">-频域框架：有限序列的信号的周期图：</h5><ul><li>通过傅里叶变化：可以得到信号的周期图</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927221626122.png" style="zoom:50%;" /></p><ul><li><p><strong>信号的周期图：periodogram</strong> ——反映了信号在各个频域点上能量贡献的大小</p></li><li><p>Parsevals恒等式： 左侧是时间域，右侧是频域</p></li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927221815400.png" /></p><p>​ 信号在时间域内拥有的总能量等于其在频域内各个频率的能量的总和</p><h5 id="概率框架信号功率谱-signal-spectra">- 概率框架：信号功率谱 signalspectra</h5><ul><li><p>随机过程：一组信号，在每个时刻都是一个随机变量。</p></li><li><p>平稳随机过程：这个随机过程，其均值属性不随时间变化</p></li><li><p>自相关函数和功率谱</p></li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927222142483.png" style="zoom:50%;" /></p><ul><li>给定两个平稳随机过程v(t)s(t)：互相关函数，和互功率谱（是互相关函数的傅里叶变换）：</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927222301599.png" style="zoom: 50%;" /></p><ul><li>如果给定一个随机过程的实现v(t),可以用时间算子代替数学期望可以估计自相关函数，从而估计功率谱</li></ul><p>但这样一个过程是有一个假设的，这个假设就是 Ergodicprocess（个态遍历）也就是：当N趋于正无穷，时间平均值趋于整体平均</p><h5 id="白噪声信号white-noise-process">- 白噪声信号White noiseprocess:</h5><p>​ 零均值和方差 R 的独立同分布随机变量序列。</p><p>​<strong>特点</strong>：白噪声没有记忆，t时间的信号值和t时间前的值完全无关，也就是可以导出下图中说的重要规则：</p><p><strong>每个平稳随机过程 {v(t)}都可以通过稳定的最小相位滤波器对白噪声滤波来生成</strong></p><p>​ <imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927222909082.png" /></p><h3 id="有扰动情况下的线性过程描述">3、有扰动情况下的线性过程描述：</h3><p>​假设v(t)是稳定随即过程，利用上述的结论，我们可以使用下述这个形式来表示有扰动情况下的线性过程的描述。之后关键就是在这个模型下进行利用实验数据估计G(q)和H(q)</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927223152305.png" style="zoom:50%;" /></p><h2 id="三系统辨识辨识实验设计">三、系统辨识——辨识实验设计</h2><h3 id="辨识实验identification-test的必要性">1、辨识实验IdentificationTest的必要性</h3><ul><li>辨识实验（控制）的目的是激发和收集（控制）相关信息。</li><li>测试期间使用测试信号/激励。</li><li>辨识实验是一种成本，但不要干扰正常生产。</li><li>良好的辨识实验是成功识别/控制的关键。</li><li>没有良好的辨识实验就是数据输入垃圾输出。</li></ul><p><strong>辨识实验是有代价的</strong>：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927223723009.png" style="zoom:50%;" /></p><h3 id="preliminary-tests-预测试">2、Preliminary Tests 预测试</h3><p>目的是为了获得先验知识</p><h4 id="收集历史数据collect-historic-data-p3">1）收集历史数据Collecthistoric data P3</h4><p><strong>一般来说，历史数据对于模型来说不够丰富，或者换句话说，信噪比太低（例如90％的噪声，10％的信号）</strong></p><ul><li>获得过程的第一印象。</li><li>过程的输出 (CV) 代表未测量的干扰。</li><li>MV 的动作代表操作员的控制。</li><li>简单又便宜。 数据库可用于大多数流程。</li><li>与操作者交谈并向他们学习。</li></ul><h4 id="阶跃实验short-step-test-p4">2）阶跃实验Short step test P4</h4><ul><li>将每个操作变量上下操作一些次数</li><li>检查主要时间常数、增益和延迟</li><li>检查并调整 MV PID 回路。</li><li>控制工程师可以通过观察过程阶跃响应直观地了解过程动态。</li><li>低成本测试。</li></ul><h4id="阶梯实验了解对象的非线性程度">3）阶梯实验：了解对象的非线性程度</h4><ul><li>将阶梯信号应用于某些 MV。</li><li>目的是检查非线性。</li><li>高成本测试，通常不允许</li></ul><h3 id="系统辨识中常见的实验信号">3、系统辨识中常见的实验信号</h3><p>实验信号有两个方面的因素需要考虑：信号波形和频谱的要求 wave form andfrequency content</p><ul><li>信号波形（时域）要求： -<ul><li>在正常操作中不会引起干扰（比较脉冲和阶跃）。</li><li>不激发过程非线性（比较脉冲和步骤）。</li><li>操作员友好（比较脉冲和阶跃）。</li></ul></li><li>信号频率成分（功率谱）设计：<ul><li>测试信号的功率谱会影响控制性能。</li><li>用于控制目的的最佳频谱设计。</li></ul></li></ul><h4 id="prbs-二进制伪随机信号">1）PRBS 二进制伪随机信号：</h4><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927224849434.png" /></p><ul><li><p>Clock是时钟脉冲</p></li><li><p>State是移位寄存器</p></li><li><p>移位寄存器产生的序列，最大的周期为 M 即 2^n-1 称为M序列</p></li><li><p>统计特性：（均值、自相关函数、频谱图）</p></li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927225042867.png" /></p><p>​该实验信号模型可以很好的模拟一个白噪声信号，但是这种信号切换频率太快，对工业的装置影响太大。同时其对于中低频信号不友好，比较偏重于高频。而系统辨识需要中低频信号</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927225345044.png" style="zoom:67%;" /></p><p>​ 所以需要调整我们的PRBS来产生低通特性的PRBS信号：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927225321648.png" style="zoom:67%;" /></p><h4 id="gbngeneralized-binary-noise-广义二值化信号">2）GBN(generalizedbinary noise) 广义二值化信号</h4><p>​ 信号翻转的概率，按照如下图：Generation rule进行信号的生成：</p><p>​ psw为切换概率</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927225457178.png" /></p><p>​<strong>通过降低切换概率，增加切换时间来获得低通的信号，来进行辨识信号实验。</strong></p><h4 id="pbrs和gbn对比">3）PBRS和GBN对比：</h4><ul><li>相比于PRBS来说，PRBS在一些特殊的2pi的点等于0，不接近实际，而GBN不会。同时，PRBS有最长周期，而GBN没有，可以随意选择</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927225706274.png" /></p><h4id="持续激励的测试信号persistent-excitation-of-a-test-signal">4）持续激励的测试信号：Persistentexcitation of a test signal</h4><ul><li>N阶的持续激励信号：需要满足以下条件：</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927225916291.png" style="zoom:50%;" /></p><ul><li>N阶持续激励的频域解释：n阶持续激励的频域解释是信号的频谱在区间（-pi,pi）内至少n个频率中不为零</li><li>PRBS和GBN信号的区别：</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927230015132.png" /></p><h3 id="模型辨识的测试最终测试">4、模型辨识的测试，最终测试</h3><h4 id="mpc控制的测试设计">1） MPC控制的测试设计</h4><ul><li>测试时间：<ul><li>小系统或低噪音：（6~10）*（稳定时间 settling time）</li><li>大型系统或高噪音：(12 ~ 20) *(稳定时间 settling time)</li></ul></li><li>信号类型：GBN -</li><li>信号步长：根据预先测试和与操作员的讨论确定。从小开始，可以在测试过程中进行调整-</li><li>信号平均切换时间（功率谱）：</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927230237868.png" style="zoom:50%;" /></p><ul><li><p>GBN信号可以同时做若干个实验，不同实验互不相关。</p></li><li><p>每个测试的MV个数，以及测试信号的相关性：</p><ul><li>每次测试的 MV 数量：开环测试最多 10 个 MV； 在闭环测试中所有MV。</li><li>测试信号之间的相关性：通常独立；对于条件不佳的过程（例如高纯度蒸馏塔），某些 MV之间的强相关性可能会有所帮助。</li></ul></li></ul><h4 id="闭环实验测试">2）闭环实验测试：</h4><ul><li>大多数工业应用使用开环测试。</li><li>20年前，业界不相信的过程是 可使用闭环数据识别。</li><li>可以在设定点或 MV 处应用测试信号</li><li><strong>闭环测试对过程操作的干扰较小</strong></li><li>闭环测试易于进行。</li><li>来自闭环测试数据的模型更适合控制。</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927230553891.png" /></p><h2id="四系统辨识最小二乘的系统辨识方法">四、系统辨识——最小二乘的系统辨识方法</h2><h3 id="最小二乘的原则p20页-由高斯提出">1、最小二乘的原则：P20页由高斯提出</h3><h3id="基于最小二乘估计线性过程的模型arx模型">2、基于最小二乘，估计线性过程的模型——ARX模型</h3><p>用n阶差分方程描述：</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927230958268.png" /></p><p>引入误差项：</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927231012557.png" /></p><p>首先进行等式重组：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927231103308.png" style="zoom: 50%;" /></p><p>在系统辨识实验测试后，我们可以得到数据集，并且使用数据来填充等式：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927231138550.png" style="zoom:50%;" /></p><p>最后，通过最小化如下的目标函数来估计模型参数：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927231216488.png" style="zoom:50%;" /></p><p>如下为解：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927231234423.png" style="zoom:50%;" /></p><h3 id="工业实例">3、工业实例：</h3><figure><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220927231336491.png"alt="image-20220927231336491" /><figcaption aria-hidden="true">image-20220927231336491</figcaption></figure><h3 id="最小二乘估计的属性">4、最小二乘估计的属性：</h3><p><strong>估计器的理想（良好）属性：</strong></p><ul><li>无偏估计 Unbiased estimator</li><li>一致的估计器 Consistent estimator</li><li>有效或最小方差估计器 Efficient or minimum variance estimator:</li></ul><p><strong>原始的最小二乘估计器是无偏的</strong></p><p><strong>ARX模型是有偏的，因为A2不保持</strong></p><h2 id="五最小二乘模型的扩展">五、最小二乘模型的扩展：</h2><h3 id="输出误差方法-output-error-method">1、输出误差方法 Output-errormethod</h3><p>​ 其存在一个大的数值问题：输出误差在 A(q) 参数中是非线性的。不存在解析（封闭形式）解决方案，也无法保证全局最小值。</p><h4 id="关于一致性的证明">1）关于一致性的证明：</h4><ul><li>真实过程由 (5.1.4) 给出，其中 v(t) 是零均值的平稳随机过程。</li><li>模型阶数 n 正确。</li><li>输入持续兴奋，阶数高于 2n。</li><li><strong>测试是开环的。</strong></li><li>最小化收敛到所有 N 的全局最小值。</li><li>A(q) 和 B(q) 没有公因数。</li></ul><h3 id="预测误差方法-prediction-error-methods">2、预测误差方法Prediction error methods</h3><p>该方法实现：1）闭环测试的一致性（无偏性） 2)开环和闭环的效率（最小方差）。</p><p>ARMAX 模型：</p><ul><li>一些控制设计方法的良好模型结构。、</li><li>数值优化是必要的，不能保证全局最小值</li></ul><p>BOX-Jenkins模型：</p><h4 id="预测误差方法的属性">预测误差方法的属性：</h4><ul><li>假设：（1）过程稳定； (2)模型结构正确； (3) 测试信号持续激励； (4)最小化收敛到其全局最小值</li></ul><h3 id="阶次选择-order-selection">3、阶次选择 Order Selection</h3><ul><li>目的：找到模型阶次，以便模型对其使用最准确（在控制中）。<ul><li>粗阶选择方法：检查协方差矩阵的秩，绘制 Hankel 矩阵的奇异值。对于嘈杂的数据不准确。</li><li>准确的方法：首先估计具有递增阶数的模型，然后使用错误准则选择最佳阶数。</li></ul></li><li>主要议题：什么策略？什么数据集？<ul><li>在识别文献中，预测误差准则常用于模型阶数选择。 -</li><li>交叉验证的缺点是成本高。 使用估计数据进行模型阶数选择更经济。</li><li>使用估计数据的错误标准是使用验证数据的错误标准的有偏估计。</li></ul></li></ul><p><strong>输出误差小并不能保证仿真误差小</strong></p><ul><li><p>仍然需要证明 FOE 是对验证数据的 OE 标准的无偏估计。</p></li><li><p>我们可以将这种使用不同标准进行模型估计和订单选择的交叉标准方法称为方法。</p></li></ul><h3 id="模型验证-model-validation">4、模型验证 Model Validation</h3><p>检查获得的模型是否足以使用（控制），如果没有，提供补救措施（做什么</p><p>将模型属性与过程知识进行比较。 粗略估计过程增益，主要时间常数。</p><p>使用模型阶跃响应图。 检查不同方法的一致性。 估计 FIR、ARX、ARMAX 和Box-Jenkins 模型并比较它们的阶跃响应和频率响应</p><h4 id="残差分析">1) 残差分析：</h4><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220928090759861.png" style="zoom:50%;" /></p><ul><li>一个批评意见：控制的识别没有解决。 （这类模型是否适用于控制）<ul><li>前三种方法或多或少是定性测试。</li><li>残差分析是检查模型是否与测试数据充分吻合。</li><li>没有一种方法可以判断模型是否适合控制。</li><li>如果一个模型通过了残差分析，它只告诉给定数据获得了好的模型。但是数据是否足够好（用于控制）？</li></ul></li></ul>]]></content>
    
    
    <summary type="html">本篇笔记为电子信息工程中数学模型与方法——单元2 系统辨识的相关知识整理，用于学在浙大考试。</summary>
    
    
    
    <category term="⓾ 课程笔记" scheme="https://blog.fantast.top/categories/%E2%93%BE-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="电子信息工程数学模型与方法" scheme="https://blog.fantast.top/categories/%E2%93%BE-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    
    
    <category term="course" scheme="https://blog.fantast.top/tags/course/"/>
    
  </entry>
  
  <entry>
    <title>电子信息工程中数学模型与方法——单元3 电磁系统</title>
    <link href="https://blog.fantast.top/2022/09/30/2742f0d23b8a/"/>
    <id>https://blog.fantast.top/2022/09/30/2742f0d23b8a/</id>
    <published>2022-09-30T04:13:19.000Z</published>
    <updated>2022-10-02T07:29:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一概述和基本理论">一、概述和基本理论</h2><h3 id="麦克斯韦方程组">1、麦克斯韦方程组：</h3><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221002113642895.png" /></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20221002113659170.png" /></p><h3 id="平面电磁波">2、平面电磁波：</h3><ul><li><p>波 : 扰动、能量、或物理信息在空间上传播的一种物理现象；</p></li><li><p>电磁波 : 传播电磁能量的波；</p></li><li><p>平面电磁波 :波前（等相位面）是平行面且与传播方向垂直的固定频率电磁波；</p></li><li><p>亥姆亥兹方程（Helmholtz’s equation）</p></li></ul><p><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150037334.png" /></p><ul><li>电场强度表达式：</li></ul><p><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150210202.png" /></p><p><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150222274.png" /></p><ul><li><p>磁场强度表达式：</p><figure><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150256704.png"alt="image-20221002150256704" /><figcaption aria-hidden="true">image-20221002150256704</figcaption></figure></li></ul><h3 id="特征阻抗">3、特征阻抗：</h3><p>电场强度和磁场强度的幅值比值定义为某种材料的特征阻抗</p><p><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150355839.png" /></p><h3 id="电磁辐射天线辐射">4、电磁辐射—天线辐射</h3><p>​ 分为近场和远场，近场又分为两个</p><p><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150510352.png" /></p><p>​ 在比较远的地方可以等价于一个平面波的形式</p><p><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150516797.png" /></p><h3 id="电磁辐射赫兹偶极子">5、电磁辐射—赫兹偶极子：</h3><h3 id="电磁辐射半波长偶极子">6、电磁辐射—半波长偶极子</h3><h3 id="电磁辐射天线应用-p24-26">7、电磁辐射—天线应用 P24-26</h3><figure><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002150915273.png"alt="image-20221002150915273" /><figcaption aria-hidden="true">image-20221002150915273</figcaption></figure><ul><li>移动手机 P26-27</li><li>笔记本电脑 P28-29</li><li>无线可穿戴设备 P30-31</li><li>无线电识别天线 P32-33<ul><li>无线电识别：一种用来在一定距离无线识别的电子贴片技术。</li></ul></li><li>工作范围：P３４　　近场和远场</li><li>工作模式：被动（Passive Tag 主动（ Active Tag 半被动（ Semi passiveTag)<ul><li>被动：<ul><li>没有电源，使用从读卡器上的能量来充能并且传输数据到读卡器</li><li>更小，更廉价</li><li>往往只有很短的读取距离</li></ul></li><li>主动：<ul><li>有电源，tag先传输，然后是reader</li><li>更长的读取距离，100m或以上</li><li>昂贵，使用时间较有限</li></ul></li></ul></li></ul><h3 id="电磁感应无线传能">8、电磁感应—无线传能</h3><h3 id="电磁感应全息成像">9、电磁感应—全息成像</h3><h3 id="电磁辐射穿透性-p39">10、电磁辐射—穿透性 P39</h3><h2 id="二电磁散射系统建模和可视化">二、电磁散射系统建模和可视化</h2><h3 id="电磁散射基本理论-狄拉克格林函数">1、电磁散射基本理论狄拉克格林函数</h3><h3 id="瑞利散射">2、瑞利散射</h3><p>​ 半径比光或其他电磁辐射的波长小很多（ （&lt;0.1 𝜆）的 微小颗粒（例如单个原子或分子）对入射光束的散射。</p><p>​瑞利散射在光通过<strong>透明的固体和液体时都会发生，但以气体最为显著。</strong></p><figure><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002152515412.png"alt="image-20221002152515412" /><figcaption aria-hidden="true">image-20221002152515412</figcaption></figure><ul><li>总的辐射能量与波数的四次方成正相关，与波长的四次方成反相关。频率越高，瑞利散射越强</li><li>公式见P7</li></ul><h3 id="米氏散射">3、米氏散射：</h3><p>​ <strong>当 微粒半径的大小接近于或大于入射光线的波长 λ的时候</strong>，大部分的入射光线会沿着前进的方向进行散射，这种现象被称为米氏散射。​<strong>散射场几乎与波长无关；前向波比较大 ;物体大小越大，前向波越大</strong></p><p>​这种大微粒包括灰尘，水滴，来自污染物的颗粒物质，如烟雾等。即s是形成所谓的丁达尔效应</p><p><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002152726428.png" /></p><ul><li>为什么天空是蓝色、红色（傍晚）、白色（云）？</li></ul><p>​ 瑞利散射：波长的四次方成反相关，即频率越高，瑞利散射越强</p><p><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002152752906.png" /></p><h3 id="应用微波近场扫描显微成像">4、应用：微波近场扫描显微成像：</h3><p><imgsrc="C:\Users\Fantast\AppData\Roaming\Typora\typora-user-images\image-20221002152904823.png" /></p>]]></content>
    
    
    <summary type="html">本篇笔记为电子信息工程中数学模型与方法——单元3 电磁散射、逆问题系统建模及可视化的相关知识整理，用于学在浙大考试。</summary>
    
    
    
    <category term="⓾ 课程笔记" scheme="https://blog.fantast.top/categories/%E2%93%BE-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="电子信息工程数学模型与方法" scheme="https://blog.fantast.top/categories/%E2%93%BE-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    
    
    <category term="course" scheme="https://blog.fantast.top/tags/course/"/>
    
  </entry>
  
  <entry>
    <title>电子信息工程中数学模型与方法——单元1 工业智能</title>
    <link href="https://blog.fantast.top/2022/09/19/e947a7cc4335/"/>
    <id>https://blog.fantast.top/2022/09/19/e947a7cc4335/</id>
    <published>2022-09-19T02:40:19.000Z</published>
    <updated>2022-09-19T08:09:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2id="一以模型为核心的工业智能工信融合与工业智能">一、以模型为核心的工业智能——工信融合与工业智能</h2><h3 id="工业文明发展和工信融合-p9">1、工业文明发展和工信融合 P9</h3><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220919140907698.png" alt="image-20220919140907698" style="zoom:33%;" /></p><ul><li>我国工业面临的形式和发展目标 P13</li><li>什么是两者领域的深度融合？ P14</li></ul><h3 id="智能人类智能和工业智能">2、智能：人类智能和工业智能</h3><ul><li>人类心智的八个范畴 P19</li><li>什么是智能？什么是智慧？智能的进化属性？理解工程科学的智能 P20</li><li>工业智能的八个范畴 P24</li><li>人擅长做的：感知、决策和执行</li></ul><h3 id="控制视角和控制前沿">3、控制视角和控制前沿</h3><ul><li>工业系统信息物理深度融合面临的主要挑战 P28<ul><li>综合认知难、融合表达难、协同调控难、安全防护难</li></ul></li><li>实时、精准的综合信息感知 P29</li><li>工业大数据的综合表达与认知 P30</li><li>人-机-物协同的智能控制与优化 P31</li><li>三元空间的一体化安全防护 P32</li><li>智能工厂的内涵 P41</li><li>无人驾驶和无人工厂 共性和区别 P42</li><li>工厂智能化的技术分级：范围、能力、效益 L0-L5 P43</li></ul><h3 id="流程工业的智能化之路">4、流程工业的智能化之路</h3><ul><li>工业运行方式的变迁 P46 47<ul><li>流程工业是形成人类物质文明的基础工业</li><li>流程工业的行业特点、新需求等</li><li>人工控制——少量仪表——中控系统——现代化大型控制室</li></ul></li><li>设计型技术和运行型技术：P48<ul><li>设计型技术：产品和工艺设计-&gt;高附加值产品、新工艺</li><li>运行型技术：生产和制造-&gt;高效、高适应性生产。不增加太多投资的情况下取得显著的经济效益，投资小见效快是最集中体现流程企业操作运行“智能”的技术关键</li><li>流程工业生产运行的新需求：高效、柔性。</li></ul></li><li>什么是智能？工厂的指挥、智慧工厂的工作流 P52</li><li>无人化工厂的技术核心：P53<ul><li>人工智能：算力、数据、算法</li><li>工业智能：建模、控制、优化</li><li>大工业：工艺、流程、设备</li></ul></li><li>无人化工厂的新目标：P54</li></ul><h2id="二以模型为核心的工业智能过程系统建模与分析运行">二、以模型为核心的工业智能——过程系统建模与分析运行：</h2><h3 id="引言">1、引言</h3><ul><li>机理模型（白箱）：P59</li><li>数据模型（黑箱）：P59</li></ul><h3 id="过程系统简介">2、过程系统简介</h3><ul><li>过程系统的结构</li><li>流程工业的典型生产过程：（反应 + 分离 很重要）<ul><li>化工过程是由一个个加工过程组成的，可以分为两类：化学反应过程，物理加工过程。</li><li>化学反应过程对应的设备为反应器，物理加工过程对应的设备为单元操作。</li><li>所有单元操作都属于动量、热量、质量的传递速率控制过程</li><li>单元操作的种类：P68</li><li>过程系统工程：以数学模型、计算机辅助为基础的效能分析、设计放大、操作调整</li></ul></li><li>田纳西过程：P69<ul><li>操作变量：用于调节生产运行状态的手段。通常是阀门开度或者电机转速。</li><li>测量变量（生产装置的眼睛）：现场仪表或实验室分析手段所能测量的流量、温度、压力、液位、组分等变量。通过测量变量可以了解生产过程的工作状</li><li>运行约束：运行约束一般包括设备操作范围的约束，产品约束，安全约束等。</li><li>优化目标：常见的优化目标包括提高产品收率、降低生产能耗等。</li></ul></li></ul><h3 id="模型描述和求解">3、模型描述和求解</h3><ul><li><p>装置与流股： P77</p><ul><li>全流程的机理模型是由单个装置的机理模型+连接关系组合而成的</li><li>装置与装置之间的连接称为流股Stream（包括物质流股和能量流股）</li><li>物质流股S由流量、组分、温度、压力来描述。能量流股H由热量和温度来描述。</li></ul></li><li><p>连接关系与全流程模型 P78</p></li><li><p>仿真问题与反问题：</p><ul><li><p>仿真问题：可用于回溯分析，what-if分析（就是如果输入调整，输出会如何改变）</p></li><li><p>仿真问题反问题：</p><ul><li><p>要求输出流股(产品)的状态为Y，相应的输入流股(进料)条件是怎样的？(操作问题)</p></li><li><p>设备参数应该如何选择？(设计问题)</p></li><li><p>获得了输入流股、输出流股等数据，如何反推设备参数？(参数估计问题)</p></li></ul></li></ul></li><li><p>序贯求解</p><ul><li>当进料条件为X时，产品的状态是怎样的？</li><li>当流程中存在回路Recycle时，需要先断开某个流股（割裂流股），才能够序贯求解。回路的存在使得求解过程更加复杂</li><li><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220919154605965.png" /></li><li>优化问题：怎样的进料条件，使得A产品产量最高/生产能耗最低/有害物质产出最少？</li></ul></li><li><p>物质流 &amp; 能量流 &amp; 信息流：P83</p></li><li><p>单个装置的建模：装置的方程 P84</p></li><li><p>全流程机理模型的层次化特征：</p><ul><li>上述两类方程及流程单元的连接构成层次化特征，多层次的模型造成了机理模型的复杂性。</li><li><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220919155241488.png" /></li></ul></li><li><p>完整模型的序贯求解：P91</p><ul><li>上述多层次结构中的每个层次的模型通常都没有closedform的解。也就是说序贯求解的思路需要在每个层次上，需要迭代求解那个层次的方程组。因此，完整模型序贯求解的工作流呈现出一种“洋葱结构”。</li></ul></li><li><p>机理模型联立求解：</p><ul><li>对于复杂耦合流程的优化问题，采用序贯法求解时迭代过程嵌套层数多，内外层信息传递复杂、收敛难度大。采用联立方程法求解可以避免这一问题</li><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220919155604175.png" style="zoom:50%;" /></li></ul></li></ul><h3 id="不同类型的命题">4、不同类型的命题</h3><ul><li>仿真或WHAT-IF分析 P95</li><li>灵敏度分析：灵敏度分析一般是各种优化问题求解的前置步骤</li><li>设计优化、操作优化：包括设备操作范围的约束、产品约束、安全约束</li><li>参数估计：参数估计需要使用实际装置的测量数据𝑦0。实际的测量数据存在噪声、静差等，需要先进行校正和滤波，然后再用于参数估计</li><li>稳态与动态：稳态是指各生产变量基本保持不变的平稳的运行状态动态是指两个稳态之间的过渡过程</li><li>动态优化问题：动态优化的结果不再是一个数值，而是一个时间序列𝑢(𝑡)</li></ul><h3 id="数学建模的步骤">5、数学建模的步骤</h3><ul><li>模型建立：工艺分析和简化装置数学模型的建立 P103<ul><li>（建模假设、模型变量建立、机理方程的建立）</li></ul></li><li>命题求解：数学模型的变换和化简，模型的编程实现，数学规划命题的求解P103</li><li>结果分析：求解结果是否正确，是否符合预期目标 P103</li></ul><p>​ 代数建模语言(Algebraic modeling language,AML)：用于大规模数学计算(一般是数学规划)中的数学元素进行描述，并提供求解器接口的一类高级脚本语言。</p><p>​ 非线性方程组求解和优化：迭代法数值计算</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220919160136072.png" style="zoom:50%;" /></p><p>​初值（初始迭代点）对非线性规划问题的求解影响很大，考虑以下的优化命题：</p><h3 id="模型降阶和融合">6、模型降阶和融合：</h3><p>​ 高保真度模型，低保真度模型</p><ul><li><p>模型复杂度和性能的关系：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220919160736180.png" style="zoom:67%;" /></p></li><li><p>模型简化思路 P119</p></li><li><p>代理模型的建立 P121</p></li><li><p>机理数据融合模型 —— 灰箱模型 P122</p><ul><li>不同的融合思路 —— P123</li></ul></li></ul>]]></content>
    
    
    <summary type="html">本篇笔记为电子信息工程中数学模型与方法——单元1 工业智能的相关知识整理，用于学在浙大考试。</summary>
    
    
    
    <category term="⓾ 课程笔记" scheme="https://blog.fantast.top/categories/%E2%93%BE-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="电子信息工程数学模型与方法" scheme="https://blog.fantast.top/categories/%E2%93%BE-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    
    
    <category term="course" scheme="https://blog.fantast.top/tags/course/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 字符集底层原理，用户与权限管理</title>
    <link href="https://blog.fantast.top/2022/09/13/50a88c64ec31/"/>
    <id>https://blog.fantast.top/2022/09/13/50a88c64ec31/</id>
    <published>2022-09-13T07:09:19.000Z</published>
    <updated>2022-10-17T07:23:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一字符集与底层原理">一、字符集与底层原理</h3><p>mysql5.7默认server字符集为 latin，不支持中文</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%character%&#x27;;</span><br></pre></td></tr></table></figure><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220913152542290.png" /></p><ul><li>当创建数据库时不显示地指定字符集，则继承mysql服务器的默认字符集</li><li>当创建数据表时不显示地指定字符集，则继承所在数据库的默认字符集</li></ul><h4 id="已有库表的字符集修改">已有库表的字符集修改：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table emp1 convert to character set &#x27;utf8&#x27;</span><br></pre></td></tr></table></figure><h4 id="各级别的字符集">各级别的字符集：</h4><ul><li>服务器级别 character_set_server</li><li>数据库级别 character_set_database</li><li>表级别</li><li>列级别</li></ul><h4 id="字符集和比较规则">字符集和比较规则</h4><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220913221630290.png" /></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220913221612265.png" /></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220913221723119.png" /></p><h4id="请求到响应过程中字符集的变化">请求到响应过程中字符集的变化：</h4><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220914222210985.png" /></p><p><strong>这个过程中涉及到三个变量：</strong></p><p>character_set_client 和 character_set_connection 和character_set_results</p><p><strong>一般来说客户端：类unix操作系统使用utf8编码，windows使用gbk编码</strong></p><p><strong>开发中通常把上述三个系统变量设置成和客户端使用的字符集一致的情况，这样就减少了很多无谓的字符集转换</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET NAMES utf8mb4</span><br></pre></td></tr></table></figure><h3 id="二sql大小写规范">二、SQL大小写规范</h3><ul><li>MySQL在windows下是大小写不敏感的</li><li>MySQL在Linux下数据库名、表名、列名、别名大小写规则是这样的：<ul><li>1、数据库名、表名、表的别名、变量名是严格区分大小写的；</li><li>2、关键字、函数名称在SQL中不区分大小写；</li><li>3、列名（或字段名）与列的别名（或字段别名）在所有的情况下均是忽略大小写的；</li></ul></li></ul><h3 id="三sql编写建议">三、SQL编写建议：</h3><ul><li>关键字和函数名称<strong>全部大写</strong></li><li>数据库名、表名、表别名、字段名、字段别名等<strong>全部小写</strong></li><li>SQL语句必须以分号结尾</li></ul><h3 id="四sql_mode的合理设置">四、SQL_MODE的合理设置：</h3><p>​ 其会影响支持的SQL语法以及它执行的数据验证检查。</p><h4 id="宽松模式-严格模式">1、宽松模式 &amp; 严格模式</h4><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-06%2009.25.12.png" /></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-10-06%2009.25.57.png" /></p><p><strong>虽然MYSQL等数据库总想把关于数据库的所有操作都自己包揽下来，包括数据的校验等等，但是其实有些校验最好在开发层完成</strong></p><h3 id="五数据库在文件系统中的表示">五、数据库在文件系统中的表示：</h3><h4 id="innodb存储引擎模式">1、Innodb存储引擎模式</h4><h5 id="表结构">1） 表结构：</h5><p>​ 为了保存表结构， InnoDB在数据目录下对应的数据库子目录下创建了一个专门<strong>用于描述表结构的文件</strong>，文件名是这样，该文件以二进制格式存储</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表名.frm</span><br></pre></td></tr></table></figure><h5 id="表中数据和索引">2）表中数据和索引：</h5><ul><li>系统表空间：<ul><li>默认情况下，InnoDB会在数据目录下创建一个名为ibdata1 、大小为12M的文件，这个文件就是对应的系统表空间在文件系统上的表示。注意这个文件是自扩展文件，当不够用的时候它会自己增加文件大小。</li></ul></li><li>独立表空间：<ul><li>在mysql5.6以后，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是<strong>为每一个表建立一个独立表空间</strong>，也就是说我们创建了多少个表，就有多少个独立表空间。使用独立表空间来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同，只不过添加了一个.ibd的扩展名而已，所以完整的文件名称长这样：</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表名.ibd</span><br></pre></td></tr></table></figure><h4 id="myisam存储引擎模式">2、MyISAM存储引擎模式：</h4><h5 id="表结构与innodb一致">1）表结构：与Innodb一致</h5><h5 id="表中数据和索引-1">2）表中数据和索引：</h5><p>​在MyISAM中的索引全部都是二级索引，该<strong>存储引擎的数据和索引是分开存放的</strong>。假如test表使用MyISAM存储引擎的话，那么在它所在数据库对应的atguigu目录下会为test 表创建这三个文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test.frm 存储表结构</span><br><span class="line">test.MYD 存储数据 (MYData)</span><br><span class="line">test.MYI 存储索引 (MYIndex)</span><br></pre></td></tr></table></figure><h3 id="六用户和权限管理">六、用户和权限管理：</h3><h4 id="创建修改与删除用户">1、创建、修改与删除用户</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#x27;kangshifu&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE mysql.user SET USER=&#x27;li4&#x27; WHERE USER=&#x27;wang5&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP USER &#x27;kangshifu&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure><h4 id="密码相关策略内容">2、密码相关策略内容</h4><ul><li>使用root用户登录Mysql后，可以这样修改自己的密码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET PASSWORD=&#x27;new_password&#x27;;</span><br></pre></td></tr></table></figure><ul><li>修改其他用户密码：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET PASSWORD FOR &#x27;username&#x27;@&#x27;hostname&#x27;=&#x27;new_password&#x27;;</span><br></pre></td></tr></table></figure><ul><li>密码过期策略：</li></ul><p>​在MySQL中，数据库管理员可以手动设置账号密码过期，也可以建立一个自动密码过期策略。过期策略可以是全局的，也可以为每个账号设置单独的过期策</p><ul><li>密码重用策略：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET PERSIST password_history = 6; #设置不能选择最近使用过的6个密码</span><br><span class="line">SET PERSIST password_reuse_interval = 365; #设置不能选择最近一年内的密码</span><br></pre></td></tr></table></figure><h4 id="权限列表种类">3、权限列表种类：</h4><ul><li>Mysql的权限种类：<ul><li>CREATE和DROP 创建删除数据库和表</li><li>SELECT、INSERT、UPDATE和DELETE 在数据库现有表上操作</li><li>SELECT 检索权限</li><li>INDEX 允许创建或删除索引</li><li>ALTER 更改表结构和重命名</li><li>GRANT 允许授权给其他用户</li></ul></li><li>授予权限的原则：<ul><li>只授予满足需要的最小权限</li><li>创建用户时限制登陆主机IP</li></ul></li><li>授予权限方式有两种<ul><li>把角色赋予给用户授权</li><li>直接给用户授权</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT 权限1,权限2,…权限n ON 数据库名称.表名称 TO 用户名@用户地址 [IDENTIFIED BY ‘密码口令’];</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GRANTS FOR &#x27;user&#x27;@&#x27;主机地址&#x27;;</span><br></pre></td></tr></table></figure><ul><li>收回权限</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE 权限1,权限2,…权限n ON 数据库名称.表名称 FROM 用户名@用户地址;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#收回全库全表的所有权限</span><br><span class="line">REVOKE ALL PRIVILEGES ON *.* FROM joe@&#x27;%&#x27;;</span><br><span class="line">#收回mysql库下的所有表的插删改查权限</span><br><span class="line">REVOKE SELECT,INSERT,UPDATE,DELETE ON mysql.* FROM joe@localhost;</span><br></pre></td></tr></table></figure><h4 id="权限表">4、权限表</h4><h5 id="user表">1）User表</h5><p>​记录用户账号和权限信息，分为用户列、权限列、安全列、资源控制列（限制用户使用的资源，比如每小时允许执行的查询操作次数等）</p><h5 id="db表">2）db表</h5><p>​DB表中存储了用户对某个数据库的操作权限,决定用户能从哪个数据库中存取</p><h5id="tables_priv表和columns_priv表">3）tables_priv表和columns_priv表</h5><p>​tables_priv表用来对表设置操作权限，columns_priv表用来对表的某一列设置权限</p><h5 id="procs_priv表">4）procs_priv表：</h5><p>​ procs_priv表可以对存储过程和存储函数设置操作权限</p><h4 id="访问控制">5、访问控制：</h4><ul><li>连接核实阶段</li></ul><p>​服务器<strong>只有在user表记录的Host和User字段匹配客户端主机名和用户名，并且提供正确的密码时才接受连接</strong>。如果连接核实没有通过，服务器就完全拒绝访问；否则，服务器接受连接，然后进入请求核实阶段等待用户请求。</p><ul><li>请求核实阶段</li></ul><p>​对此连接上进来的每个请求，服务器检查该请求要执行什么操作、是否有足够的权限来执行它，这正是需要授权表中的权限列发挥作用的地方。这些权限可以来自user、db、table_priv和column_priv表。</p><p>​确认权限时，MySQL<strong>首先检查user表</strong>，如果指定的权限没有在user表中被授予，那么MySQL就会<strong>继续检查db表</strong>，db表是下一安全层级，其中的权限限定于数据库层级，在该层级的SELECT权限允许用户查看指定数据库的所有表中的数据；如果在该层级没有找到限定的权限，则MySQL<strong>继续检查tables_priv表以及columns_priv表</strong>，如果所有权限表都检查完毕，但还是没有找到允许的权限操作，MySQL将返回错误信息，用户请求的操作不能执行，操作失败。</p><h4 id="角色管理">6、角色管理</h4><ul><li><p>创建角色、给角色赋予权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE ROLE &#x27;role_name&#x27;[@&#x27;host_name&#x27;] [,&#x27;role_name&#x27;[@&#x27;host_name&#x27;]]...</span><br><span class="line"># 创建角色之后，默认这个角色是没有任何权限的，我们需要给角色授权。给角色授权的语法结构是</span><br><span class="line">GRANT privileges ON table_name TO &#x27;role_name&#x27;[@&#x27;host_name&#x27;];</span><br><span class="line"># 上述语句中privileges代表权限的名称，多个权限以逗号隔开</span><br><span class="line"># 查看角色权限：</span><br><span class="line">SHOW GRANTS FOR &#x27;manager&#x27;;</span><br><span class="line"># 只要你创建了一个角色，系统就会自动给你一个“ USAGE ”权限，意思是连接登录数据库的权限。</span><br></pre></td></tr></table></figure></li><li><p>回收角色权限、删除角色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 角色授权后，可以对角色的权限进行维护，对权限进行添加或撤销。添加权限使用GRANT语句，与角色授权相同。撤销角色或角色权限使用REVOKE语句。撤销角色</span><br><span class="line">REVOKE privileges ON tablename FROM &#x27;rolename&#x27;;</span><br><span class="line"># 删除角色</span><br><span class="line">DROP ROLE role [,role2]...</span><br></pre></td></tr></table></figure></li><li><p>给用户赋予角色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 角色创建并授权后，要赋给用户并处于激活状态才能发挥作用</span><br><span class="line">GRANT role [,role2,...] TO user [,user2,...];</span><br></pre></td></tr></table></figure></li><li><p>激活角色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET DEFAULT ROLE ALL TO user@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>撤销角色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE role FROM user</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">Chap7——Mysql 架构相关，包含字符集底层原理，用户与权限管理</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 视图，存储过程与函数</title>
    <link href="https://blog.fantast.top/2022/09/12/108274e25ef3/"/>
    <id>https://blog.fantast.top/2022/09/12/108274e25ef3/</id>
    <published>2022-09-12T10:09:19.000Z</published>
    <updated>2022-09-12T12:30:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一视图">一、视图</h3><p>​<strong>视图一方面可以帮我们使用表的一部分而不是所有的表，另一方面也可以针对不同的用户制定不同的查询视图。比如，针对一个公司的销售人员，我们只想给他看部分数据，而某些特殊的数据，比如采购的价格，则不会提供给他。再比如，人员薪酬是个敏感的字段，那么只给某个级别以上的人员开放，其他人的查询视图中则不提供这个字段。</strong></p><ul><li><p>视图是一种虚拟表，本身是不具有数据的，占用很少的内存空间</p></li><li><p>视图建立在已有表的基础上, 视图赖以建立的这些表称为基表</p></li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220912195718829.png" /></p><ul><li><p>视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化，反之亦然。</p></li><li><p>视图，是向用户提供基表数据的另一种表现形式。<strong>通常情况下，小型项目的数据库可以不使用视图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，它可以帮助我们把经常查询的结果集放到虚拟表中，提升使用效率。理解和使用起来都非常方便</strong></p></li></ul><h3 id="二创建视图">二、创建视图：</h3><ul><li>创建单表视图</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW empvu80</span><br><span class="line">AS</span><br><span class="line">SELECT employee_id, last_name, salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id = 80;</span><br></pre></td></tr></table></figure><ul><li>创建多表联合视图：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW empview</span><br><span class="line">AS</span><br><span class="line">SELECT employee_id emp_id,last_name NAME,department_name</span><br><span class="line">FROM employees e,departments d</span><br><span class="line">WHERE e.department_id = d.department_id;</span><br></pre></td></tr></table></figure><ul><li>可以利用视图来对数据进行格式化：</li></ul><p>​比如我们想输出员工姓名和对应的部门名，对应格式为emp_name(department_name)，就可以使用视图来完成数据格式化的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW emp_depart</span><br><span class="line">AS</span><br><span class="line">SELECT CONCAT(last_name,&#x27;(&#x27;,department_name,&#x27;)&#x27;) AS emp_dept</span><br><span class="line">FROM employees e JOIN departments d</span><br><span class="line">WHERE e.department_id = d.department_id</span><br></pre></td></tr></table></figure><h3 id="三更新视图的数据">三、更新视图的数据</h3><p>​支持使用INSERT、UPDATE和DELETE语句对视图中的数据进行插入、更新和删除操作</p><h4 id="关于一些不可更新的视图">关于一些不可更新的视图</h4><p>​要使视图可更新，视图中的行和底层基本表中的行之间必须存在一对一的关系。另外当视图定义出现如下情况时，视图不支持更新操作：</p><ul><li>在定义视图的时候指定了“ALGORITHM =TEMPTABLE”，视图将不支持INSERT和DELETE操作；</li><li>视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT操作；</li><li>在定义视图的SELECT语句中使用了JOIN联合查询，视图将不支持INSERT和DELETE操作；</li><li>在定义视图的SELECT语句后的字段列表中使用了数学表达式或子查询，视图将不支持INSERT，也</li><li>不支持UPDATE使用了数学表达式、子查询的字段值；</li><li>在定义视图的SELECT语句后的字段列表中使用DISTINCT 、聚合函数、GROUPBY 、HAVING 、 UNION 等，视图将不支持INSERT、UPDATE、DELETE；</li><li>在定义视图的SELECT语句中包含了子查询，而子查询中引用了FROM后面的表，视图将不支持INSERT、UPDATE、DELETE；</li><li>视图定义基于一个不可更新视图</li><li>常量视图</li></ul><h3 id="四视图的优缺点与总结">四、视图的优缺点与总结：</h3><ul><li>优点</li></ul><p>1、操作简单，<strong>将经常使用的查询操作定义为视图，开发人员不需要关心视图对应的数据表的结构、表与表之间的关联关系等</strong></p><p>2、减少数据冗余，其存储的是查询语句，本身不存储数据</p><p>3、数据安全，将用户对数据的访问限制在某些数据的结果集上，具有一定的隔离性。</p><p>4、适应多变的需求，分解复杂的查询逻辑。可以先将复杂的逻辑查询分解，创建多个视图，再将这多个视图结合起来，完成复杂的查询逻辑。</p><ul><li>缺点：</li></ul><p>1、如果实际数据表的结构变更了，我们就需要及时对相关的视图进行相应的维护。特别是嵌套的视图（就是在视图的基础上创建视图），维护会变得比较复杂，可读性不好，容易变成系统的潜在隐患。因为创建视图的 SQL查询可能会对字段重命名，也可能包含复杂的逻辑，这些都会增加维护的成本。</p><h3 id="五存储过程与函数">五、存储过程与函数：</h3><ul><li>存储过程就是一组经过预先编译的 SQL 语句的封装。</li><li>执行过程：存储过程预先存储在 MySQL服务器上，需要执行的时候，客户端只需要向服务器端发出调用存储过程的命令，服务器端就可以把预先存储好的这一系列 SQL语句全部执行。</li></ul>]]></content>
    
    
    <summary type="html">Chap5——Mysql 视图，存储过程与函数</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 变量与游标.触发器</title>
    <link href="https://blog.fantast.top/2022/09/12/2c85f3f81b49/"/>
    <id>https://blog.fantast.top/2022/09/12/2c85f3f81b49/</id>
    <published>2022-09-12T10:09:19.000Z</published>
    <updated>2022-09-12T14:23:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一系统变量">一、系统变量：</h3><p>​系统变量由系统定义，不是用户定义，属于服务器层面。启动MySQL服务，生成MySQL服务实例期间，MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特征。这些系统变量的值要么是编译MySQL时参数的默认值，要么是配置文件（例如my.ini等）中的参数值。</p><h4id="全局系统变量-global关键字-会话系统变量-session关键字">1、全局系统变量global关键字 &amp; 会话系统变量 session关键字</h4><p>​每一个MySQL客户机成功连接MySQL服务器后，都会产生与之对应的会话Session。会话期间，MySQL服务实例会在MySQL服务器内存中生成与该会话对应的<strong>会话系统变量</strong>，这些会话系统变量的初始值是全局系统变量值的复制。</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/image-20220912221138151.png" /></p><ul><li><p>全局系统变量针对于所有会话（连接）有效，<strong>但不能跨重启</strong></p></li><li><p>会话1对某个全局系统变量值的修改会导致会话2中同一个全局系统变量值的修改</p></li></ul><p>​ <strong>在MySQL中有些系统变量只能是全局的，例如 max_connections用于限制服务器的最大连接数；有些系统变量作用域既可以是全局又可以是会话，例如 character_set_client用于设置客户端的字符集；有些系 统变量的作用域只能是当前会话，例如pseudo_thread_id 用于标记当前会话的 MySQL 连接 ID</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查看所有全局变量</span><br><span class="line">SHOW GLOBAL VARIABLES;</span><br><span class="line">#查看所有会话变量</span><br><span class="line">SHOW SESSION VARIABLES;</span><br><span class="line">或</span><br><span class="line">SHOW VARIABLES;</span><br></pre></td></tr></table></figure><p>​ MySQL 中的系统变量以两个“@” 开头，其中“@<span class="citation"data-cites="global">@global</span>”仅用于标记全局系统变量，“@<spanclass="citation"data-cites="session">@session</span>”仅用于标记会话系统变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#查看指定的系统变量的值</span><br><span class="line">SELECT @@global.变量名;</span><br><span class="line">#查看指定的会话变量的值</span><br><span class="line">SELECT @@session.变量名;</span><br><span class="line">#或者</span><br><span class="line">SELECT @@变量名;</span><br><span class="line"></span><br><span class="line">#为某个全局变量赋值</span><br><span class="line">#方式1</span><br><span class="line">SET @@global.变量名=变量值;</span><br><span class="line">#方式2：</span><br><span class="line">SET GLOBAL 变量名=变量值;</span><br><span class="line">#为某个会话变量赋值</span><br><span class="line">#方式1：</span><br><span class="line">SET @@session.变量名=变量值;</span><br><span class="line">#方式2：</span><br><span class="line">SET SESSION 变量名=变量值;</span><br></pre></td></tr></table></figure><h4 id="会话用户变量与局部变量">2、会话用户变量与局部变量：</h4><ul><li>会话用户变量：作用域和会话变量一样，只对当前连接会话有效。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#方式1：“=”或“:=”</span><br><span class="line">SET @用户变量 = 值;</span><br><span class="line">SET @用户变量 := 值;</span><br><span class="line">#方式2：“:=” 或 INTO关键字</span><br><span class="line">SELECT @用户变量 := 表达式 [FROM 等子句];</span><br><span class="line">SELECT 表达式 INTO @用户变量 [FROM 等子句];</span><br></pre></td></tr></table></figure><ul><li>局部变量：只在 BEGIN 和 END语句块中有效。局部变量只能在存储过程和函数中使用。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">#声明局部变量</span><br><span class="line">DECLARE 变量名1 变量数据类型 [DEFAULT 变量默认值];</span><br><span class="line">DECLARE 变量名2,变量名3,... 变量数据类型 [DEFAULT 变量默认值];</span><br><span class="line">#为局部变量赋值</span><br><span class="line">SET 变量名1 = 值;</span><br><span class="line">SELECT 值 INTO 变量名2 [FROM 子句];</span><br><span class="line">#查看局部变量的值</span><br><span class="line">SELECT 变量1,变量2,变量3;</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h3 id="二游标">二、游标</h3><p>​游标，提供了一种灵活的操作方式，让我们能够对结果集中的每一条记录进行定位，并对指向的记录中的数据进行操作的数据结构。游标让SQL 这种面向集合的语言有了面向过程开发的能力。</p><p>​游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标充当了指针的作用，我们可以通过操作游标来对数据行进行操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE get_count_by_limit_total_salary(IN limit_total_salary DOUBLE,OUT</span><br><span class="line">total_count INT)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE sum_salary DOUBLE DEFAULT 0; #记录累加的总工资</span><br><span class="line">DECLARE cursor_salary DOUBLE DEFAULT 0; #记录某一个工资值</span><br><span class="line">DECLARE emp_count INT DEFAULT 0; #记录循环个数</span><br><span class="line">#定义游标</span><br><span class="line">DECLARE emp_cursor CURSOR FOR SELECT salary FROM employees ORDER BY salary DESC;</span><br><span class="line">#打开游标</span><br><span class="line">OPEN emp_cursor;</span><br><span class="line">REPEAT</span><br><span class="line">#使用游标（从游标中获取数据）</span><br><span class="line">FETCH emp_cursor INTO cursor_salary;</span><br><span class="line">SET sum_salary = sum_salary + cursor_salary;</span><br><span class="line">SET emp_count = emp_count + 1;</span><br><span class="line">UNTIL sum_salary &gt;= limit_total_salary</span><br><span class="line">END REPEAT;</span><br><span class="line">SET total_count = emp_count;</span><br><span class="line">#关闭游标</span><br><span class="line">CLOSE emp_cursor;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h3 id="三触发器">三、触发器</h3><p><strong>应用场景：</strong></p><p>​ 在实际开发中，我们经常会遇到这样的情况：有 2个或者多个相互关联的表，如商品信息和库存信息分别存放在 2个不同的数据表中，我们在添加一条新商品记录的时候，为了保证数据的完整性，必须同时在库存表中添加一条库存记录。​这样一来，我们就必须把这两个关联的操作步骤写到程序里面，而且要用事务包裹起来，确保这两个操作成为一个原子操作，要么全部执行，要么全部不执行。要是遇到特殊情况，可能还需要对数据进行手动维护，这样就很容易忘记其中的一步，导致数据缺失。​这个时候，咱们可以使用触发器。你可以创建一个触发器，让商品信息数据的插入操作自动触发库存数据的插入操作。这样一来，就不用担心因为忘记添加库存数据而导致的数据缺失了。</p><p>​</p><p><strong>概述</strong>：</p><p>​ 触发器是由事件来触发某个操作，这些事件包括INSERT 、UPDATE 、DELETE事件。所谓事件就是指用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生了，就会自动激发触发器执行相应的操作。</p><ul><li>优点：<ul><li>触发器可以确保数据的完整性。</li><li>触发器可以帮助我们记录操作日志。</li><li>可以具体记录什么时间发生了什么。比如，记录修改会员储值金额的触发器，就是一个很好的例子。这对我们还原操作执行时的具体场景，</li><li>触发器还可以用在操作数据前，对数据进行合法性检查。</li></ul></li><li>缺点：<ul><li>着触发器有可能不受应用层的控制。这对系统维护是非常有挑战的。</li><li>相关数据的变更，可能会导致触发器出错。特别是数据表结构的变更，都可能会导致触发器出错，进而影响数据操作的正常运行。这些都会由于触发器本身的隐蔽性，影响到应用中错误原因排查的效率。</li></ul></li></ul><p><strong>注意</strong>：</p><p>​ 如果在子表中定义了外键约束，并且外键指定了ON UPDATE/DELETECASCADE/SETNULL子句，此时修改父表被引用的键值或删除父表被引用的记录行时，也会引起子表的修改和删除操作，此时基于子表的UPDATE和DELETE语句定义的触发器并不会被激活。</p>]]></content>
    
    
    <summary type="html">Chap6——Mysql 变量流程控制与游标.触发器</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 约束</title>
    <link href="https://blog.fantast.top/2022/09/10/ee0ee8e192df/"/>
    <id>https://blog.fantast.top/2022/09/10/ee0ee8e192df/</id>
    <published>2022-09-10T10:09:19.000Z</published>
    <updated>2022-09-12T11:13:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一约束">一、约束</h3><p>​ 约束是表级的强制规定,可以通过如下命令查看表的约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM information_schema.table_constraints</span><br><span class="line">WHERE table name=&#x27;’&#x27;表名称&#x27;；</span><br></pre></td></tr></table></figure><h3 id="二非空约束">二、非空约束</h3><p>​ 单列约束，不能组合非空值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test(</span><br><span class="line">id INT NOT NULL,</span><br><span class="line">    email CHAR</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ALTER TABLE test</span><br><span class="line">MODIFY email CHAR NOT NULL;</span><br><span class="line"></span><br><span class="line">ALTER TABLE test</span><br><span class="line">MODIFY id INT NULL;</span><br></pre></td></tr></table></figure><h3 id="三唯一性约束">三、唯一性约束</h3><p>​ 单列约束，允许出现多个NULL值，可以多个列的组合唯一</p><ul><li>唯一性约束允许列值为空。</li><li>在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。</li><li><strong>MySQL会给唯一约束的列上默认创建一个唯一索引。</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE USER(</span><br><span class="line">    id INT NOT NULL,</span><br><span class="line">    CNAME VARCHAR(25) UNIQUE,  # 列级约束语法</span><br><span class="line">    NAME VARCHAR(25),</span><br><span class="line">    PASSWORD VARCHAR(16),</span><br><span class="line">    # 使用表级约束语法</span><br><span class="line">    CONSTRAINT uk_name_pwd UNIQUE(NAME,PASSWORD) # 用户名和密码组合不能重复</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>复合唯一约束</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table student_course(</span><br><span class="line">    id int,</span><br><span class="line">    sid int,</span><br><span class="line">    cid int,</span><br><span class="line">    score int,</span><br><span class="line">    unique key(sid,cid) #复合唯一</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="四主键约束">四、主键约束</h3><ul><li>主键约束相当于唯一约束+非空约束的组合，主键约束列不允许重复，也不允许出现空值。</li><li>主键约束对应着表中的一列或者多列（复合主键）</li><li>MySQL的主键名总是PRIMARY，就算自己命名了主键约束名也没用。</li><li>当创建主键约束时，系统默认会在所在的列或列组合上建立对应的主键索引</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE emp4(</span><br><span class="line">    id INT PRIMARY KEY AUTO_INCREMENT ,</span><br><span class="line">    NAME VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table student_course(</span><br><span class="line">    sid int,</span><br><span class="line">    cid int,</span><br><span class="line">    score int,</span><br><span class="line">    primary key(sid,cid) #复合主键</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">alter table 表名称 drop primary key;</span><br></pre></td></tr></table></figure><h3 id="五auto_increment">五、AUTO_INCREMENT</h3><ul><li>一个表最多只能有一个自增长列</li><li>当需要产生唯一标识符或顺序值时，可设置自增长</li><li>自增长列约束的列必须是键列（主键列，唯一键列）</li><li>自增约束的列的数据类型必须是整数类型</li><li>如果自增列指定了 0 和null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table 表名称(</span><br><span class="line">    字段名 数据类型 primary key auto_increment,</span><br><span class="line">    字段名 数据类型 unique key not null,</span><br><span class="line">    字段名 数据类型 unique key,</span><br><span class="line">    字段名 数据类型 not null default 默认值,</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意：自增主键的持久化：</strong></p><p>​ 在MySQL 5.7系统中，对于自增主键的分配规则，是由InnoDB数据字典内部一个 计数器 来决定的，而该计数器只在 内存中维护，并不会持久化到磁盘中。当数据库重启时，该 计数器会被初始化。</p><p>​ MySQL 8.0将自增主键的计数器持久化到 重做日志中。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值</p><h3 id="六外键约束">六、外键约束</h3><p><strong>从表的外键列，必须引用/参考主表的主键或唯一约束的列</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">create table dept( #主表</span><br><span class="line">    did int primary key, #部门编号</span><br><span class="line">    dname varchar(50) #部门名称</span><br><span class="line">);</span><br><span class="line">create table emp(#从表</span><br><span class="line">    eid int primary key, #员工编号</span><br><span class="line">    ename varchar(5), #员工姓名</span><br><span class="line">    deptid int, #员工所在的部门</span><br><span class="line">    foreign key (deptid) references dept(did) #在从表中指定外键约束</span><br><span class="line">    #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>约束等级</strong>：</p><ul><li>Cascade方式：在父表上update/delete记录时，同步update/delete掉子表的匹配记录</li><li>Set null方式：在父表上update/delete记录时，将子表上匹配记录的列设为null，但是要注意子表的外键列不能为not null</li><li>No action方式：如果子表中有匹配的记录，则不允许对父表对应候选键进行update/delete操作</li><li>Restrict方式 ：同no action， 都是立即检查外键约束</li><li>Set default方式（在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置成一个默认的值，但Innodb不能识别</li></ul><p><strong>对于外键约束，最好是采用: ON UPDATE CASCADE ON DELETERESTRICT 的方式。</strong></p><p><strong>在 MySQL里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL操作，有可能会不适 合。比如大型网站的中央数据库，可能会因为外键约束的系统开销而变得非常慢 。所以， MySQL 允许你不使用系统自带的外键约束，在 应用层面完成检查数据一致性的逻辑。也就是说，即使你不用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。</strong></p><p><strong>一些提示：【 强制】不得使用外键与级联，一切外键概念必须在应用层解决。说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的student_id 则为外键。如果更新学 生表中的 student_id，同时触发成绩表中的student_id 更新，即为级联更新。外键与级联更新适用于 单 机低并发 ，不适合分布式 、 高并发集群 ；级联更新是强阻塞，存在数据库 更新风暴的风险；外键影响 数据库的 插入速度 。</strong></p><h3 id="七检查约束与默认值约束">七、检查约束与默认值约束</h3><h4 id="check约束">1 CHECK约束</h4><p>​ 检查某个字段的值是否符合xx要求，一般指的是值的范围</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE temp(</span><br><span class="line">    id INT AUTO_INCREMENT,</span><br><span class="line">    NAME VARCHAR(20),</span><br><span class="line">    age INT CHECK(age &gt; 20),</span><br><span class="line">    PRIMARY KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="default-约束">2 DEFAULT 约束</h4><p>给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table 表名称(</span><br><span class="line">    字段名 数据类型 primary key,</span><br><span class="line">    字段名 数据类型 unique key not null,</span><br><span class="line">    字段名 数据类型 unique key,</span><br><span class="line">    字段名 数据类型 not null default 默认值,</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>一些问题</strong>：</p><ul><li>为什么不想要 null 的值<ul><li>1）不好比较。null是一种特殊值，比较时只能用专门的is null 和 is notnull来比较。碰到运算符，通 常返回null。</li><li>2）效率不高。影响提高索引效果。因此，我们往往在建表时 not nulldefault '' 或 default 0</li></ul></li></ul>]]></content>
    
    
    <summary type="html">Chap4——Mysql 约束</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库精简笔记" scheme="https://blog.fantast.top/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B2%BE%E7%AE%80%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://blog.fantast.top/tags/Database/"/>
    
  </entry>
  
</feed>
